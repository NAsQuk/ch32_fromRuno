   1              		.cpu cortex-m3
   2              		.arch armv7-m
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.file	"usb_pwr.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.global	bDeviceState
  18              		.section	.bss.bDeviceState,"aw",%nobits
  19              		.align	2
  22              	bDeviceState:
  23 0000 00000000 		.space	4
  24              		.global	fSuspendEnabled
  25              		.section	.data.fSuspendEnabled,"aw"
  28              	fSuspendEnabled:
  29 0000 01       		.byte	1
  30              		.global	ResumeS
  31              		.section	.bss.ResumeS,"aw",%nobits
  32              		.align	2
  35              	ResumeS:
  36 0000 0000     		.space	2
  37              		.section	.text.PowerOn,"ax",%progbits
  38              		.align	1
  39              		.global	PowerOn
  40              		.syntax unified
  41              		.thumb
  42              		.thumb_func
  44              	PowerOn:
  45              	.LFB27:
  46              		.file 1 "usb/usb_pwr.c"
   1:usb/usb_pwr.c **** /******************** (C) COPYRIGHT 2010 STMicroelectronics ********************
   2:usb/usb_pwr.c **** * File Name          : usb_pwr.c
   3:usb/usb_pwr.c **** * Author             : MCD Application Team
   4:usb/usb_pwr.c **** * Version            : V3.2.1
   5:usb/usb_pwr.c **** * Date               : 07/05/2010
   6:usb/usb_pwr.c **** * Description        : Connection/disconnection & power management
   7:usb/usb_pwr.c **** ********************************************************************************
   8:usb/usb_pwr.c **** * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
   9:usb/usb_pwr.c **** * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
  10:usb/usb_pwr.c **** * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
  11:usb/usb_pwr.c **** * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
  12:usb/usb_pwr.c **** * CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
  13:usb/usb_pwr.c **** * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
  14:usb/usb_pwr.c **** *******************************************************************************/
  15:usb/usb_pwr.c **** 
  16:usb/usb_pwr.c **** /* Includes ------------------------------------------------------------------*/
  17:usb/usb_pwr.c **** #include "stm32f10x.h"
  18:usb/usb_pwr.c **** #include "usb_lib.h"
  19:usb/usb_pwr.c **** #include "usb_conf.h"
  20:usb/usb_pwr.c **** #include "usb_pwr.h"
  21:usb/usb_pwr.c **** #include "hw_config.h"
  22:usb/usb_pwr.c **** 
  23:usb/usb_pwr.c **** /* Private typedef -----------------------------------------------------------*/
  24:usb/usb_pwr.c **** /* Private define ------------------------------------------------------------*/
  25:usb/usb_pwr.c **** /* Private macro -------------------------------------------------------------*/
  26:usb/usb_pwr.c **** /* Private variables ---------------------------------------------------------*/
  27:usb/usb_pwr.c **** __IO uint32_t bDeviceState = UNCONNECTED; /* USB device status */
  28:usb/usb_pwr.c **** __IO bool fSuspendEnabled = TRUE;  /* true when suspend is possible */
  29:usb/usb_pwr.c **** 
  30:usb/usb_pwr.c **** struct
  31:usb/usb_pwr.c **** {
  32:usb/usb_pwr.c ****   __IO RESUME_STATE eState;
  33:usb/usb_pwr.c ****   __IO uint8_t bESOFcnt;
  34:usb/usb_pwr.c **** }ResumeS;
  35:usb/usb_pwr.c **** 
  36:usb/usb_pwr.c **** /* Extern variables ----------------------------------------------------------*/
  37:usb/usb_pwr.c **** /* Private function prototypes -----------------------------------------------*/
  38:usb/usb_pwr.c **** /* Extern function prototypes ------------------------------------------------*/
  39:usb/usb_pwr.c **** /* Private functions ---------------------------------------------------------*/
  40:usb/usb_pwr.c **** 
  41:usb/usb_pwr.c **** /*******************************************************************************
  42:usb/usb_pwr.c **** * Function Name  : PowerOn
  43:usb/usb_pwr.c **** * Description    :
  44:usb/usb_pwr.c **** * Input          : None.
  45:usb/usb_pwr.c **** * Output         : None.
  46:usb/usb_pwr.c **** * Return         : USB_SUCCESS.
  47:usb/usb_pwr.c **** *******************************************************************************/
  48:usb/usb_pwr.c **** RESULT PowerOn(void)
  49:usb/usb_pwr.c **** {
  47              		.loc 1 49 1
  48              		.cfi_startproc
  49              		@ args = 0, pretend = 0, frame = 8
  50              		@ frame_needed = 1, uses_anonymous_args = 0
  51 0000 80B5     		push	{r7, lr}
  52              	.LCFI0:
  53              		.cfi_def_cfa_offset 8
  54              		.cfi_offset 7, -8
  55              		.cfi_offset 14, -4
  56 0002 82B0     		sub	sp, sp, #8
  57              	.LCFI1:
  58              		.cfi_def_cfa_offset 16
  59 0004 00AF     		add	r7, sp, #0
  60              	.LCFI2:
  61              		.cfi_def_cfa_register 7
  50:usb/usb_pwr.c **** #ifndef STM32F10X_CL
  51:usb/usb_pwr.c ****   uint16_t wRegVal;
  52:usb/usb_pwr.c **** 
  53:usb/usb_pwr.c ****   /*** cable plugged-in ? ***/
  54:usb/usb_pwr.c ****   USB_Cable_Config(ENABLE);
  62              		.loc 1 54 3
  63 0006 0120     		movs	r0, #1
  64 0008 0E4B     		ldr	r3, .L3
  65 000a 9847     		blx	r3
  66              	.LVL0:
  55:usb/usb_pwr.c **** 
  56:usb/usb_pwr.c ****   /*** CNTR_PWDN = 0 ***/
  57:usb/usb_pwr.c ****   wRegVal = CNTR_FRES;
  67              		.loc 1 57 11
  68 000c 0123     		movs	r3, #1
  69 000e FB80     		strh	r3, [r7, #6]	@ movhi
  58:usb/usb_pwr.c ****   _SetCNTR(wRegVal);
  70              		.loc 1 58 3
  71 0010 0D4A     		ldr	r2, .L3+4
  72 0012 FB88     		ldrh	r3, [r7, #6]
  73 0014 1360     		str	r3, [r2]
  59:usb/usb_pwr.c **** 
  60:usb/usb_pwr.c ****   /*** CNTR_FRES = 0 ***/
  61:usb/usb_pwr.c ****   wInterrupt_Mask = 0;
  74              		.loc 1 61 19
  75 0016 0D4B     		ldr	r3, .L3+8
  76 0018 0022     		movs	r2, #0
  77 001a 1A80     		strh	r2, [r3]	@ movhi
  62:usb/usb_pwr.c ****   _SetCNTR(wInterrupt_Mask);
  78              		.loc 1 62 3
  79 001c 0B4B     		ldr	r3, .L3+8
  80 001e 1A88     		ldrh	r2, [r3]
  81 0020 094B     		ldr	r3, .L3+4
  82 0022 1A60     		str	r2, [r3]
  63:usb/usb_pwr.c ****   /*** Clear pending interrupts ***/
  64:usb/usb_pwr.c ****   _SetISTR(0);
  83              		.loc 1 64 3
  84 0024 0A4B     		ldr	r3, .L3+12
  85 0026 0022     		movs	r2, #0
  86 0028 1A60     		str	r2, [r3]
  65:usb/usb_pwr.c ****   /*** Set interrupt mask ***/
  66:usb/usb_pwr.c ****   wInterrupt_Mask = CNTR_RESETM | CNTR_SUSPM | CNTR_WKUPM;
  87              		.loc 1 66 19
  88 002a 084B     		ldr	r3, .L3+8
  89 002c 4FF4E052 		mov	r2, #7168
  90 0030 1A80     		strh	r2, [r3]	@ movhi
  67:usb/usb_pwr.c ****   _SetCNTR(wInterrupt_Mask);
  91              		.loc 1 67 3
  92 0032 064B     		ldr	r3, .L3+8
  93 0034 1A88     		ldrh	r2, [r3]
  94 0036 044B     		ldr	r3, .L3+4
  95 0038 1A60     		str	r2, [r3]
  68:usb/usb_pwr.c **** #endif /* STM32F10X_CL */
  69:usb/usb_pwr.c **** 
  70:usb/usb_pwr.c ****   return USB_SUCCESS;
  96              		.loc 1 70 10
  97 003a 0023     		movs	r3, #0
  71:usb/usb_pwr.c **** }
  98              		.loc 1 71 1
  99 003c 1846     		mov	r0, r3
 100 003e 0837     		adds	r7, r7, #8
 101              	.LCFI3:
 102              		.cfi_def_cfa_offset 8
 103 0040 BD46     		mov	sp, r7
 104              	.LCFI4:
 105              		.cfi_def_cfa_register 13
 106              		@ sp needed
 107 0042 80BD     		pop	{r7, pc}
 108              	.L4:
 109              		.align	2
 110              	.L3:
 111 0044 00000000 		.word	USB_Cable_Config
 112 0048 405C0040 		.word	1073765440
 113 004c 00000000 		.word	wInterrupt_Mask
 114 0050 445C0040 		.word	1073765444
 115              		.cfi_endproc
 116              	.LFE27:
 118              		.section	.text.PowerOff,"ax",%progbits
 119              		.align	1
 120              		.global	PowerOff
 121              		.syntax unified
 122              		.thumb
 123              		.thumb_func
 125              	PowerOff:
 126              	.LFB28:
  72:usb/usb_pwr.c **** 
  73:usb/usb_pwr.c **** /*******************************************************************************
  74:usb/usb_pwr.c **** * Function Name  : PowerOff
  75:usb/usb_pwr.c **** * Description    : handles switch-off conditions
  76:usb/usb_pwr.c **** * Input          : None.
  77:usb/usb_pwr.c **** * Output         : None.
  78:usb/usb_pwr.c **** * Return         : USB_SUCCESS.
  79:usb/usb_pwr.c **** *******************************************************************************/
  80:usb/usb_pwr.c **** RESULT PowerOff()
  81:usb/usb_pwr.c **** {
 127              		.loc 1 81 1
 128              		.cfi_startproc
 129              		@ args = 0, pretend = 0, frame = 0
 130              		@ frame_needed = 1, uses_anonymous_args = 0
 131 0000 80B5     		push	{r7, lr}
 132              	.LCFI5:
 133              		.cfi_def_cfa_offset 8
 134              		.cfi_offset 7, -8
 135              		.cfi_offset 14, -4
 136 0002 00AF     		add	r7, sp, #0
 137              	.LCFI6:
 138              		.cfi_def_cfa_register 7
  82:usb/usb_pwr.c **** #ifndef STM32F10X_CL
  83:usb/usb_pwr.c ****   /* disable all ints and force USB reset */
  84:usb/usb_pwr.c ****   _SetCNTR(CNTR_FRES);
 139              		.loc 1 84 3
 140 0004 074B     		ldr	r3, .L7
 141 0006 0122     		movs	r2, #1
 142 0008 1A60     		str	r2, [r3]
  85:usb/usb_pwr.c ****   /* clear interrupt status register */
  86:usb/usb_pwr.c ****   _SetISTR(0);
 143              		.loc 1 86 3
 144 000a 074B     		ldr	r3, .L7+4
 145 000c 0022     		movs	r2, #0
 146 000e 1A60     		str	r2, [r3]
  87:usb/usb_pwr.c ****   /* Disable the Pull-Up*/
  88:usb/usb_pwr.c ****   USB_Cable_Config(DISABLE);
 147              		.loc 1 88 3
 148 0010 0020     		movs	r0, #0
 149 0012 064B     		ldr	r3, .L7+8
 150 0014 9847     		blx	r3
 151              	.LVL1:
  89:usb/usb_pwr.c ****   /* switch-off device */
  90:usb/usb_pwr.c ****   _SetCNTR(CNTR_FRES + CNTR_PDWN);
 152              		.loc 1 90 3
 153 0016 034B     		ldr	r3, .L7
 154 0018 0322     		movs	r2, #3
 155 001a 1A60     		str	r2, [r3]
  91:usb/usb_pwr.c **** #endif /* STM32F10X_CL */
  92:usb/usb_pwr.c **** 
  93:usb/usb_pwr.c ****   /* sw variables reset */
  94:usb/usb_pwr.c ****   /* ... */
  95:usb/usb_pwr.c **** 
  96:usb/usb_pwr.c ****   return USB_SUCCESS;
 156              		.loc 1 96 10
 157 001c 0023     		movs	r3, #0
  97:usb/usb_pwr.c **** }
 158              		.loc 1 97 1
 159 001e 1846     		mov	r0, r3
 160 0020 80BD     		pop	{r7, pc}
 161              	.L8:
 162 0022 00BF     		.align	2
 163              	.L7:
 164 0024 405C0040 		.word	1073765440
 165 0028 445C0040 		.word	1073765444
 166 002c 00000000 		.word	USB_Cable_Config
 167              		.cfi_endproc
 168              	.LFE28:
 170              		.section	.text.Suspend,"ax",%progbits
 171              		.align	1
 172              		.global	Suspend
 173              		.syntax unified
 174              		.thumb
 175              		.thumb_func
 177              	Suspend:
 178              	.LFB29:
  98:usb/usb_pwr.c **** 
  99:usb/usb_pwr.c **** /*******************************************************************************
 100:usb/usb_pwr.c **** * Function Name  : Suspend
 101:usb/usb_pwr.c **** * Description    : sets suspend mode operating conditions
 102:usb/usb_pwr.c **** * Input          : None.
 103:usb/usb_pwr.c **** * Output         : None.
 104:usb/usb_pwr.c **** * Return         : USB_SUCCESS.
 105:usb/usb_pwr.c **** *******************************************************************************/
 106:usb/usb_pwr.c **** void Suspend(void)
 107:usb/usb_pwr.c **** {
 179              		.loc 1 107 1
 180              		.cfi_startproc
 181              		@ args = 0, pretend = 0, frame = 8
 182              		@ frame_needed = 1, uses_anonymous_args = 0
 183 0000 80B5     		push	{r7, lr}
 184              	.LCFI7:
 185              		.cfi_def_cfa_offset 8
 186              		.cfi_offset 7, -8
 187              		.cfi_offset 14, -4
 188 0002 82B0     		sub	sp, sp, #8
 189              	.LCFI8:
 190              		.cfi_def_cfa_offset 16
 191 0004 00AF     		add	r7, sp, #0
 192              	.LCFI9:
 193              		.cfi_def_cfa_register 7
 108:usb/usb_pwr.c **** #ifndef STM32F10X_CL
 109:usb/usb_pwr.c ****   uint16_t wCNTR;
 110:usb/usb_pwr.c ****   /* suspend preparation */
 111:usb/usb_pwr.c ****   /* ... */
 112:usb/usb_pwr.c **** 
 113:usb/usb_pwr.c ****   /* macrocell enters suspend mode */
 114:usb/usb_pwr.c ****   wCNTR = _GetCNTR();
 194              		.loc 1 114 11
 195 0006 0D4B     		ldr	r3, .L10
 196 0008 1B68     		ldr	r3, [r3]
 197              		.loc 1 114 9
 198 000a FB80     		strh	r3, [r7, #6]	@ movhi
 115:usb/usb_pwr.c ****   wCNTR |= CNTR_FSUSP;
 199              		.loc 1 115 9
 200 000c FB88     		ldrh	r3, [r7, #6]	@ movhi
 201 000e 43F00803 		orr	r3, r3, #8
 202 0012 FB80     		strh	r3, [r7, #6]	@ movhi
 116:usb/usb_pwr.c ****   _SetCNTR(wCNTR);
 203              		.loc 1 116 3
 204 0014 094A     		ldr	r2, .L10
 205 0016 FB88     		ldrh	r3, [r7, #6]
 206 0018 1360     		str	r3, [r2]
 117:usb/usb_pwr.c **** #endif /* STM32F10X_CL */
 118:usb/usb_pwr.c **** 
 119:usb/usb_pwr.c ****   /* ------------------ ONLY WITH BUS-POWERED DEVICES ---------------------- */
 120:usb/usb_pwr.c ****   /* power reduction */
 121:usb/usb_pwr.c ****   /* ... on connected devices */
 122:usb/usb_pwr.c **** 
 123:usb/usb_pwr.c **** #ifndef STM32F10X_CL
 124:usb/usb_pwr.c ****   /* force low-power mode in the macrocell */
 125:usb/usb_pwr.c ****   wCNTR = _GetCNTR();
 207              		.loc 1 125 11
 208 001a 084B     		ldr	r3, .L10
 209 001c 1B68     		ldr	r3, [r3]
 210              		.loc 1 125 9
 211 001e FB80     		strh	r3, [r7, #6]	@ movhi
 126:usb/usb_pwr.c ****   wCNTR |= CNTR_LPMODE;
 212              		.loc 1 126 9
 213 0020 FB88     		ldrh	r3, [r7, #6]	@ movhi
 214 0022 43F00403 		orr	r3, r3, #4
 215 0026 FB80     		strh	r3, [r7, #6]	@ movhi
 127:usb/usb_pwr.c ****   _SetCNTR(wCNTR);
 216              		.loc 1 127 3
 217 0028 044A     		ldr	r2, .L10
 218 002a FB88     		ldrh	r3, [r7, #6]
 219 002c 1360     		str	r3, [r2]
 128:usb/usb_pwr.c **** #endif /* STM32F10X_CL */
 129:usb/usb_pwr.c **** 
 130:usb/usb_pwr.c ****   /* switch-off the clocks */
 131:usb/usb_pwr.c ****   /* ... */
 132:usb/usb_pwr.c ****   Enter_LowPowerMode();
 220              		.loc 1 132 3
 221 002e 044B     		ldr	r3, .L10+4
 222 0030 9847     		blx	r3
 223              	.LVL2:
 133:usb/usb_pwr.c **** 
 134:usb/usb_pwr.c **** }
 224              		.loc 1 134 1
 225 0032 00BF     		nop
 226 0034 0837     		adds	r7, r7, #8
 227              	.LCFI10:
 228              		.cfi_def_cfa_offset 8
 229 0036 BD46     		mov	sp, r7
 230              	.LCFI11:
 231              		.cfi_def_cfa_register 13
 232              		@ sp needed
 233 0038 80BD     		pop	{r7, pc}
 234              	.L11:
 235 003a 00BF     		.align	2
 236              	.L10:
 237 003c 405C0040 		.word	1073765440
 238 0040 00000000 		.word	Enter_LowPowerMode
 239              		.cfi_endproc
 240              	.LFE29:
 242              		.section	.text.Resume_Init,"ax",%progbits
 243              		.align	1
 244              		.global	Resume_Init
 245              		.syntax unified
 246              		.thumb
 247              		.thumb_func
 249              	Resume_Init:
 250              	.LFB30:
 135:usb/usb_pwr.c **** 
 136:usb/usb_pwr.c **** /*******************************************************************************
 137:usb/usb_pwr.c **** * Function Name  : Resume_Init
 138:usb/usb_pwr.c **** * Description    : Handles wake-up restoring normal operations
 139:usb/usb_pwr.c **** * Input          : None.
 140:usb/usb_pwr.c **** * Output         : None.
 141:usb/usb_pwr.c **** * Return         : USB_SUCCESS.
 142:usb/usb_pwr.c **** *******************************************************************************/
 143:usb/usb_pwr.c **** void Resume_Init(void)
 144:usb/usb_pwr.c **** {
 251              		.loc 1 144 1
 252              		.cfi_startproc
 253              		@ args = 0, pretend = 0, frame = 8
 254              		@ frame_needed = 1, uses_anonymous_args = 0
 255 0000 80B5     		push	{r7, lr}
 256              	.LCFI12:
 257              		.cfi_def_cfa_offset 8
 258              		.cfi_offset 7, -8
 259              		.cfi_offset 14, -4
 260 0002 82B0     		sub	sp, sp, #8
 261              	.LCFI13:
 262              		.cfi_def_cfa_offset 16
 263 0004 00AF     		add	r7, sp, #0
 264              	.LCFI14:
 265              		.cfi_def_cfa_register 7
 145:usb/usb_pwr.c **** #ifndef STM32F10X_CL
 146:usb/usb_pwr.c ****   uint16_t wCNTR;
 147:usb/usb_pwr.c **** #endif /* STM32F10X_CL */
 148:usb/usb_pwr.c **** 
 149:usb/usb_pwr.c ****   /* ------------------ ONLY WITH BUS-POWERED DEVICES ---------------------- */
 150:usb/usb_pwr.c ****   /* restart the clocks */
 151:usb/usb_pwr.c ****   /* ...  */
 152:usb/usb_pwr.c **** 
 153:usb/usb_pwr.c **** #ifndef STM32F10X_CL
 154:usb/usb_pwr.c ****   /* CNTR_LPMODE = 0 */
 155:usb/usb_pwr.c ****   wCNTR = _GetCNTR();
 266              		.loc 1 155 11
 267 0006 0A4B     		ldr	r3, .L13
 268 0008 1B68     		ldr	r3, [r3]
 269              		.loc 1 155 9
 270 000a FB80     		strh	r3, [r7, #6]	@ movhi
 156:usb/usb_pwr.c ****   wCNTR &= (~CNTR_LPMODE);
 271              		.loc 1 156 9
 272 000c FB88     		ldrh	r3, [r7, #6]	@ movhi
 273 000e 23F00403 		bic	r3, r3, #4
 274 0012 FB80     		strh	r3, [r7, #6]	@ movhi
 157:usb/usb_pwr.c ****   _SetCNTR(wCNTR);
 275              		.loc 1 157 3
 276 0014 064A     		ldr	r2, .L13
 277 0016 FB88     		ldrh	r3, [r7, #6]
 278 0018 1360     		str	r3, [r2]
 158:usb/usb_pwr.c **** #endif /* STM32F10X_CL */
 159:usb/usb_pwr.c **** 
 160:usb/usb_pwr.c ****   /* restore full power */
 161:usb/usb_pwr.c ****   /* ... on connected devices */
 162:usb/usb_pwr.c ****   Leave_LowPowerMode();
 279              		.loc 1 162 3
 280 001a 064B     		ldr	r3, .L13+4
 281 001c 9847     		blx	r3
 282              	.LVL3:
 163:usb/usb_pwr.c **** 
 164:usb/usb_pwr.c **** #ifndef STM32F10X_CL
 165:usb/usb_pwr.c ****   /* reset FSUSP bit */
 166:usb/usb_pwr.c ****   _SetCNTR(IMR_MSK);
 283              		.loc 1 166 3
 284 001e 044B     		ldr	r3, .L13
 285 0020 4FF40642 		mov	r2, #34304
 286 0024 1A60     		str	r2, [r3]
 167:usb/usb_pwr.c **** #endif /* STM32F10X_CL */
 168:usb/usb_pwr.c **** 
 169:usb/usb_pwr.c ****   /* reverse suspend preparation */
 170:usb/usb_pwr.c ****   /* ... */
 171:usb/usb_pwr.c **** 
 172:usb/usb_pwr.c **** }
 287              		.loc 1 172 1
 288 0026 00BF     		nop
 289 0028 0837     		adds	r7, r7, #8
 290              	.LCFI15:
 291              		.cfi_def_cfa_offset 8
 292 002a BD46     		mov	sp, r7
 293              	.LCFI16:
 294              		.cfi_def_cfa_register 13
 295              		@ sp needed
 296 002c 80BD     		pop	{r7, pc}
 297              	.L14:
 298 002e 00BF     		.align	2
 299              	.L13:
 300 0030 405C0040 		.word	1073765440
 301 0034 00000000 		.word	Leave_LowPowerMode
 302              		.cfi_endproc
 303              	.LFE30:
 305              		.section	.text.Resume,"ax",%progbits
 306              		.align	1
 307              		.global	Resume
 308              		.syntax unified
 309              		.thumb
 310              		.thumb_func
 312              	Resume:
 313              	.LFB31:
 173:usb/usb_pwr.c **** 
 174:usb/usb_pwr.c **** /*******************************************************************************
 175:usb/usb_pwr.c **** * Function Name  : Resume
 176:usb/usb_pwr.c **** * Description    : This is the state machine handling resume operations and
 177:usb/usb_pwr.c **** *                 timing sequence. The control is based on the Resume structure
 178:usb/usb_pwr.c **** *                 variables and on the ESOF interrupt calling this subroutine
 179:usb/usb_pwr.c **** *                 without changing machine state.
 180:usb/usb_pwr.c **** * Input          : a state machine value (RESUME_STATE)
 181:usb/usb_pwr.c **** *                  RESUME_ESOF doesn't change ResumeS.eState allowing
 182:usb/usb_pwr.c **** *                  decrementing of the ESOF counter in different states.
 183:usb/usb_pwr.c **** * Output         : None.
 184:usb/usb_pwr.c **** * Return         : None.
 185:usb/usb_pwr.c **** *******************************************************************************/
 186:usb/usb_pwr.c **** void Resume(RESUME_STATE eResumeSetVal)
 187:usb/usb_pwr.c **** {
 314              		.loc 1 187 1
 315              		.cfi_startproc
 316              		@ args = 0, pretend = 0, frame = 16
 317              		@ frame_needed = 1, uses_anonymous_args = 0
 318 0000 80B5     		push	{r7, lr}
 319              	.LCFI17:
 320              		.cfi_def_cfa_offset 8
 321              		.cfi_offset 7, -8
 322              		.cfi_offset 14, -4
 323 0002 84B0     		sub	sp, sp, #16
 324              	.LCFI18:
 325              		.cfi_def_cfa_offset 24
 326 0004 00AF     		add	r7, sp, #0
 327              	.LCFI19:
 328              		.cfi_def_cfa_register 7
 329 0006 0346     		mov	r3, r0
 330 0008 FB71     		strb	r3, [r7, #7]
 188:usb/usb_pwr.c **** #ifndef STM32F10X_CL
 189:usb/usb_pwr.c ****   uint16_t wCNTR;
 190:usb/usb_pwr.c **** #endif /* STM32F10X_CL */
 191:usb/usb_pwr.c **** 
 192:usb/usb_pwr.c ****   if (eResumeSetVal != RESUME_ESOF)
 331              		.loc 1 192 6
 332 000a FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 333 000c 072B     		cmp	r3, #7
 334 000e 02D0     		beq	.L16
 193:usb/usb_pwr.c ****     ResumeS.eState = eResumeSetVal;
 335              		.loc 1 193 20
 336 0010 384A     		ldr	r2, .L31
 337 0012 FB79     		ldrb	r3, [r7, #7]
 338 0014 1370     		strb	r3, [r2]
 339              	.L16:
 194:usb/usb_pwr.c **** 
 195:usb/usb_pwr.c ****   switch (ResumeS.eState)
 340              		.loc 1 195 18
 341 0016 374B     		ldr	r3, .L31
 342 0018 1B78     		ldrb	r3, [r3]
 343 001a DBB2     		uxtb	r3, r3
 344              		.loc 1 195 3
 345 001c 052B     		cmp	r3, #5
 346 001e 5DD8     		bhi	.L17
 347 0020 01A2     		adr	r2, .L19
 348 0022 52F823F0 		ldr	pc, [r2, r3, lsl #2]
 349 0026 00BF     		.p2align 2
 350              	.L19:
 351 0028 41000000 		.word	.L24+1
 352 002c 4D000000 		.word	.L23+1
 353 0030 59000000 		.word	.L22+1
 354 0034 67000000 		.word	.L21+1
 355 0038 87000000 		.word	.L20+1
 356 003c A9000000 		.word	.L18+1
 357              		.p2align 1
 358              	.L24:
 196:usb/usb_pwr.c ****   {
 197:usb/usb_pwr.c ****     case RESUME_EXTERNAL:
 198:usb/usb_pwr.c ****       Resume_Init();
 359              		.loc 1 198 7
 360 0040 2D4B     		ldr	r3, .L31+4
 361 0042 9847     		blx	r3
 362              	.LVL4:
 199:usb/usb_pwr.c ****       ResumeS.eState = RESUME_OFF;
 363              		.loc 1 199 22
 364 0044 2B4B     		ldr	r3, .L31
 365 0046 0622     		movs	r2, #6
 366 0048 1A70     		strb	r2, [r3]
 200:usb/usb_pwr.c ****       break;
 367              		.loc 1 200 7
 368 004a 4EE0     		b	.L25
 369              	.L23:
 201:usb/usb_pwr.c ****     case RESUME_INTERNAL:
 202:usb/usb_pwr.c ****       Resume_Init();
 370              		.loc 1 202 7
 371 004c 2A4B     		ldr	r3, .L31+4
 372 004e 9847     		blx	r3
 373              	.LVL5:
 203:usb/usb_pwr.c ****       ResumeS.eState = RESUME_START;
 374              		.loc 1 203 22
 375 0050 284B     		ldr	r3, .L31
 376 0052 0422     		movs	r2, #4
 377 0054 1A70     		strb	r2, [r3]
 204:usb/usb_pwr.c ****       break;
 378              		.loc 1 204 7
 379 0056 48E0     		b	.L25
 380              	.L22:
 205:usb/usb_pwr.c ****     case RESUME_LATER:
 206:usb/usb_pwr.c ****       ResumeS.bESOFcnt = 2;
 381              		.loc 1 206 24
 382 0058 264B     		ldr	r3, .L31
 383 005a 0222     		movs	r2, #2
 384 005c 5A70     		strb	r2, [r3, #1]
 207:usb/usb_pwr.c ****       ResumeS.eState = RESUME_WAIT;
 385              		.loc 1 207 22
 386 005e 254B     		ldr	r3, .L31
 387 0060 0322     		movs	r2, #3
 388 0062 1A70     		strb	r2, [r3]
 208:usb/usb_pwr.c ****       break;
 389              		.loc 1 208 7
 390 0064 41E0     		b	.L25
 391              	.L21:
 209:usb/usb_pwr.c ****     case RESUME_WAIT:
 210:usb/usb_pwr.c ****       ResumeS.bESOFcnt--;
 392              		.loc 1 210 14
 393 0066 234B     		ldr	r3, .L31
 394 0068 5B78     		ldrb	r3, [r3, #1]
 395 006a DBB2     		uxtb	r3, r3
 396              		.loc 1 210 23
 397 006c 013B     		subs	r3, r3, #1
 398 006e DAB2     		uxtb	r2, r3
 399 0070 204B     		ldr	r3, .L31
 400 0072 5A70     		strb	r2, [r3, #1]
 211:usb/usb_pwr.c ****       if (ResumeS.bESOFcnt == 0)
 401              		.loc 1 211 18
 402 0074 1F4B     		ldr	r3, .L31
 403 0076 5B78     		ldrb	r3, [r3, #1]
 404 0078 DBB2     		uxtb	r3, r3
 405              		.loc 1 211 10
 406 007a 002B     		cmp	r3, #0
 407 007c 32D1     		bne	.L28
 212:usb/usb_pwr.c ****         ResumeS.eState = RESUME_START;
 408              		.loc 1 212 24
 409 007e 1D4B     		ldr	r3, .L31
 410 0080 0422     		movs	r2, #4
 411 0082 1A70     		strb	r2, [r3]
 213:usb/usb_pwr.c ****       break;
 412              		.loc 1 213 7
 413 0084 2EE0     		b	.L28
 414              	.L20:
 214:usb/usb_pwr.c ****     case RESUME_START:
 215:usb/usb_pwr.c ****      #ifdef STM32F10X_CL
 216:usb/usb_pwr.c ****       OTGD_FS_SetRemoteWakeup();
 217:usb/usb_pwr.c ****      #else
 218:usb/usb_pwr.c ****       wCNTR = _GetCNTR();
 415              		.loc 1 218 15
 416 0086 1D4B     		ldr	r3, .L31+8
 417 0088 1B68     		ldr	r3, [r3]
 418              		.loc 1 218 13
 419 008a FB81     		strh	r3, [r7, #14]	@ movhi
 219:usb/usb_pwr.c ****       wCNTR |= CNTR_RESUME;
 420              		.loc 1 219 13
 421 008c FB89     		ldrh	r3, [r7, #14]	@ movhi
 422 008e 43F01003 		orr	r3, r3, #16
 423 0092 FB81     		strh	r3, [r7, #14]	@ movhi
 220:usb/usb_pwr.c ****       _SetCNTR(wCNTR);
 424              		.loc 1 220 7
 425 0094 194A     		ldr	r2, .L31+8
 426 0096 FB89     		ldrh	r3, [r7, #14]
 427 0098 1360     		str	r3, [r2]
 221:usb/usb_pwr.c ****      #endif /* STM32F10X_CL */
 222:usb/usb_pwr.c ****       ResumeS.eState = RESUME_ON;
 428              		.loc 1 222 22
 429 009a 164B     		ldr	r3, .L31
 430 009c 0522     		movs	r2, #5
 431 009e 1A70     		strb	r2, [r3]
 223:usb/usb_pwr.c ****       ResumeS.bESOFcnt = 10;
 432              		.loc 1 223 24
 433 00a0 144B     		ldr	r3, .L31
 434 00a2 0A22     		movs	r2, #10
 435 00a4 5A70     		strb	r2, [r3, #1]
 224:usb/usb_pwr.c ****       break;
 436              		.loc 1 224 7
 437 00a6 20E0     		b	.L25
 438              	.L18:
 225:usb/usb_pwr.c ****     case RESUME_ON:
 226:usb/usb_pwr.c ****     #ifndef STM32F10X_CL
 227:usb/usb_pwr.c ****       ResumeS.bESOFcnt--;
 439              		.loc 1 227 14
 440 00a8 124B     		ldr	r3, .L31
 441 00aa 5B78     		ldrb	r3, [r3, #1]
 442 00ac DBB2     		uxtb	r3, r3
 443              		.loc 1 227 23
 444 00ae 013B     		subs	r3, r3, #1
 445 00b0 DAB2     		uxtb	r2, r3
 446 00b2 104B     		ldr	r3, .L31
 447 00b4 5A70     		strb	r2, [r3, #1]
 228:usb/usb_pwr.c ****       if (ResumeS.bESOFcnt == 0)
 448              		.loc 1 228 18
 449 00b6 0F4B     		ldr	r3, .L31
 450 00b8 5B78     		ldrb	r3, [r3, #1]
 451 00ba DBB2     		uxtb	r3, r3
 452              		.loc 1 228 10
 453 00bc 002B     		cmp	r3, #0
 454 00be 13D1     		bne	.L29
 229:usb/usb_pwr.c ****       {
 230:usb/usb_pwr.c ****      #endif /* STM32F10X_CL */
 231:usb/usb_pwr.c ****        #ifdef STM32F10X_CL
 232:usb/usb_pwr.c ****         OTGD_FS_ResetRemoteWakeup();
 233:usb/usb_pwr.c ****        #else
 234:usb/usb_pwr.c ****         wCNTR = _GetCNTR();
 455              		.loc 1 234 17
 456 00c0 0E4B     		ldr	r3, .L31+8
 457 00c2 1B68     		ldr	r3, [r3]
 458              		.loc 1 234 15
 459 00c4 FB81     		strh	r3, [r7, #14]	@ movhi
 235:usb/usb_pwr.c ****         wCNTR &= (~CNTR_RESUME);
 460              		.loc 1 235 15
 461 00c6 FB89     		ldrh	r3, [r7, #14]	@ movhi
 462 00c8 23F01003 		bic	r3, r3, #16
 463 00cc FB81     		strh	r3, [r7, #14]	@ movhi
 236:usb/usb_pwr.c ****         _SetCNTR(wCNTR);
 464              		.loc 1 236 9
 465 00ce 0B4A     		ldr	r2, .L31+8
 466 00d0 FB89     		ldrh	r3, [r7, #14]
 467 00d2 1360     		str	r3, [r2]
 237:usb/usb_pwr.c ****        #endif /* STM32F10X_CL */
 238:usb/usb_pwr.c ****         ResumeS.eState = RESUME_OFF;
 468              		.loc 1 238 24
 469 00d4 074B     		ldr	r3, .L31
 470 00d6 0622     		movs	r2, #6
 471 00d8 1A70     		strb	r2, [r3]
 239:usb/usb_pwr.c ****      #ifndef STM32F10X_CL
 240:usb/usb_pwr.c ****       }
 241:usb/usb_pwr.c ****      #endif /* STM32F10X_CL */
 242:usb/usb_pwr.c ****       break;
 472              		.loc 1 242 7
 473 00da 05E0     		b	.L29
 474              	.L17:
 243:usb/usb_pwr.c ****     case RESUME_OFF:
 244:usb/usb_pwr.c ****     case RESUME_ESOF:
 245:usb/usb_pwr.c ****     default:
 246:usb/usb_pwr.c ****       ResumeS.eState = RESUME_OFF;
 475              		.loc 1 246 22
 476 00dc 054B     		ldr	r3, .L31
 477 00de 0622     		movs	r2, #6
 478 00e0 1A70     		strb	r2, [r3]
 247:usb/usb_pwr.c ****       break;
 479              		.loc 1 247 7
 480 00e2 02E0     		b	.L25
 481              	.L28:
 213:usb/usb_pwr.c ****     case RESUME_START:
 482              		.loc 1 213 7
 483 00e4 00BF     		nop
 484 00e6 00E0     		b	.L30
 485              	.L29:
 242:usb/usb_pwr.c ****     case RESUME_OFF:
 486              		.loc 1 242 7
 487 00e8 00BF     		nop
 488              	.L25:
 489              	.L30:
 248:usb/usb_pwr.c ****   }
 249:usb/usb_pwr.c **** }
 490              		.loc 1 249 1
 491 00ea 00BF     		nop
 492 00ec 1037     		adds	r7, r7, #16
 493              	.LCFI20:
 494              		.cfi_def_cfa_offset 8
 495 00ee BD46     		mov	sp, r7
 496              	.LCFI21:
 497              		.cfi_def_cfa_register 13
 498              		@ sp needed
 499 00f0 80BD     		pop	{r7, pc}
 500              	.L32:
 501 00f2 00BF     		.align	2
 502              	.L31:
 503 00f4 00000000 		.word	ResumeS
 504 00f8 00000000 		.word	Resume_Init
 505 00fc 405C0040 		.word	1073765440
 506              		.cfi_endproc
 507              	.LFE31:
 509              		.text
 510              	.Letext0:
 511              		.file 2 "c:\\program files (x86)\\gnu arm embedded toolchain\\10 2021.10\\arm-none-eabi\\include\\
 512              		.file 3 "c:\\program files (x86)\\gnu arm embedded toolchain\\10 2021.10\\arm-none-eabi\\include\\
 513              		.file 4 "common/lib.stm32/STM32_USB-FS-Device_Driver/inc/usb_core.h"
 514              		.file 5 "usb/usb_pwr.h"
 515              		.file 6 "common/lib.stm32/STM32_USB-FS-Device_Driver/inc/usb_init.h"
 516              		.file 7 "usb/hw_config.h"
 517              		.file 8 "common/lib.stm32/CMSIS/Core/CM3/stm32f10x.h"
DEFINED SYMBOLS
                            *ABS*:00000000 usb_pwr.c
C:\Users\Admin\AppData\Local\Temp\ccvmzhK8.s:22     .bss.bDeviceState:00000000 bDeviceState
C:\Users\Admin\AppData\Local\Temp\ccvmzhK8.s:19     .bss.bDeviceState:00000000 $d
C:\Users\Admin\AppData\Local\Temp\ccvmzhK8.s:28     .data.fSuspendEnabled:00000000 fSuspendEnabled
C:\Users\Admin\AppData\Local\Temp\ccvmzhK8.s:35     .bss.ResumeS:00000000 ResumeS
C:\Users\Admin\AppData\Local\Temp\ccvmzhK8.s:32     .bss.ResumeS:00000000 $d
C:\Users\Admin\AppData\Local\Temp\ccvmzhK8.s:38     .text.PowerOn:00000000 $t
C:\Users\Admin\AppData\Local\Temp\ccvmzhK8.s:44     .text.PowerOn:00000000 PowerOn
C:\Users\Admin\AppData\Local\Temp\ccvmzhK8.s:111    .text.PowerOn:00000044 $d
C:\Users\Admin\AppData\Local\Temp\ccvmzhK8.s:119    .text.PowerOff:00000000 $t
C:\Users\Admin\AppData\Local\Temp\ccvmzhK8.s:125    .text.PowerOff:00000000 PowerOff
C:\Users\Admin\AppData\Local\Temp\ccvmzhK8.s:164    .text.PowerOff:00000024 $d
C:\Users\Admin\AppData\Local\Temp\ccvmzhK8.s:171    .text.Suspend:00000000 $t
C:\Users\Admin\AppData\Local\Temp\ccvmzhK8.s:177    .text.Suspend:00000000 Suspend
C:\Users\Admin\AppData\Local\Temp\ccvmzhK8.s:237    .text.Suspend:0000003c $d
C:\Users\Admin\AppData\Local\Temp\ccvmzhK8.s:243    .text.Resume_Init:00000000 $t
C:\Users\Admin\AppData\Local\Temp\ccvmzhK8.s:249    .text.Resume_Init:00000000 Resume_Init
C:\Users\Admin\AppData\Local\Temp\ccvmzhK8.s:300    .text.Resume_Init:00000030 $d
C:\Users\Admin\AppData\Local\Temp\ccvmzhK8.s:306    .text.Resume:00000000 $t
C:\Users\Admin\AppData\Local\Temp\ccvmzhK8.s:312    .text.Resume:00000000 Resume
C:\Users\Admin\AppData\Local\Temp\ccvmzhK8.s:351    .text.Resume:00000028 $d
C:\Users\Admin\AppData\Local\Temp\ccvmzhK8.s:357    .text.Resume:00000040 $t
C:\Users\Admin\AppData\Local\Temp\ccvmzhK8.s:503    .text.Resume:000000f4 $d

UNDEFINED SYMBOLS
USB_Cable_Config
wInterrupt_Mask
Enter_LowPowerMode
Leave_LowPowerMode
