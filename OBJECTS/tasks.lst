   1              		.cpu cortex-m3
   2              		.arch armv7-m
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.file	"tasks.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.global	pxCurrentTCB
  18              		.section	.bss.pxCurrentTCB,"aw",%nobits
  19              		.align	2
  22              	pxCurrentTCB:
  23 0000 00000000 		.space	4
  24              		.section	.bss.pxReadyTasksLists,"aw",%nobits
  25              		.align	2
  28              	pxReadyTasksLists:
  29 0000 00000000 		.space	200
  29      00000000 
  29      00000000 
  29      00000000 
  29      00000000 
  30              		.section	.bss.xDelayedTaskList1,"aw",%nobits
  31              		.align	2
  34              	xDelayedTaskList1:
  35 0000 00000000 		.space	20
  35      00000000 
  35      00000000 
  35      00000000 
  35      00000000 
  36              		.section	.bss.xDelayedTaskList2,"aw",%nobits
  37              		.align	2
  40              	xDelayedTaskList2:
  41 0000 00000000 		.space	20
  41      00000000 
  41      00000000 
  41      00000000 
  41      00000000 
  42              		.section	.bss.pxDelayedTaskList,"aw",%nobits
  43              		.align	2
  46              	pxDelayedTaskList:
  47 0000 00000000 		.space	4
  48              		.section	.bss.pxOverflowDelayedTaskList,"aw",%nobits
  49              		.align	2
  52              	pxOverflowDelayedTaskList:
  53 0000 00000000 		.space	4
  54              		.section	.bss.xPendingReadyList,"aw",%nobits
  55              		.align	2
  58              	xPendingReadyList:
  59 0000 00000000 		.space	20
  59      00000000 
  59      00000000 
  59      00000000 
  59      00000000 
  60              		.section	.bss.xTasksWaitingTermination,"aw",%nobits
  61              		.align	2
  64              	xTasksWaitingTermination:
  65 0000 00000000 		.space	20
  65      00000000 
  65      00000000 
  65      00000000 
  65      00000000 
  66              		.section	.bss.uxTasksDeleted,"aw",%nobits
  67              		.align	2
  70              	uxTasksDeleted:
  71 0000 00000000 		.space	4
  72              		.section	.bss.xSuspendedTaskList,"aw",%nobits
  73              		.align	2
  76              	xSuspendedTaskList:
  77 0000 00000000 		.space	20
  77      00000000 
  77      00000000 
  77      00000000 
  77      00000000 
  78              		.section	.bss.uxCurrentNumberOfTasks,"aw",%nobits
  79              		.align	2
  82              	uxCurrentNumberOfTasks:
  83 0000 00000000 		.space	4
  84              		.section	.bss.xTickCount,"aw",%nobits
  85              		.align	2
  88              	xTickCount:
  89 0000 00000000 		.space	4
  90              		.section	.bss.uxTopUsedPriority,"aw",%nobits
  91              		.align	2
  94              	uxTopUsedPriority:
  95 0000 00000000 		.space	4
  96              		.section	.bss.uxTopReadyPriority,"aw",%nobits
  97              		.align	2
 100              	uxTopReadyPriority:
 101 0000 00000000 		.space	4
 102              		.section	.bss.xSchedulerRunning,"aw",%nobits
 103              		.align	2
 106              	xSchedulerRunning:
 107 0000 00000000 		.space	4
 108              		.section	.bss.uxSchedulerSuspended,"aw",%nobits
 109              		.align	2
 112              	uxSchedulerSuspended:
 113 0000 00000000 		.space	4
 114              		.section	.bss.uxMissedTicks,"aw",%nobits
 115              		.align	2
 118              	uxMissedTicks:
 119 0000 00000000 		.space	4
 120              		.section	.bss.xMissedYield,"aw",%nobits
 121              		.align	2
 124              	xMissedYield:
 125 0000 00000000 		.space	4
 126              		.section	.bss.xNumOfOverflows,"aw",%nobits
 127              		.align	2
 130              	xNumOfOverflows:
 131 0000 00000000 		.space	4
 132              		.section	.bss.uxTaskNumber,"aw",%nobits
 133              		.align	2
 136              	uxTaskNumber:
 137 0000 00000000 		.space	4
 138              		.section	.text.xTaskGenericCreate,"ax",%progbits
 139              		.align	1
 140              		.global	xTaskGenericCreate
 141              		.syntax unified
 142              		.thumb
 143              		.thumb_func
 145              	xTaskGenericCreate:
 146              	.LFB30:
 147              		.file 1 "common/rtos/tasks.c"
   1:common/rtos/tasks.c **** /*
   2:common/rtos/tasks.c ****     FreeRTOS V6.0.2 - Copyright (C) 2010 Real Time Engineers Ltd.
   3:common/rtos/tasks.c **** 
   4:common/rtos/tasks.c ****     ***************************************************************************
   5:common/rtos/tasks.c ****     *                                                                         *
   6:common/rtos/tasks.c ****     * If you are:                                                             *
   7:common/rtos/tasks.c ****     *                                                                         *
   8:common/rtos/tasks.c ****     *    + New to FreeRTOS,                                                   *
   9:common/rtos/tasks.c ****     *    + Wanting to learn FreeRTOS or multitasking in general quickly       *
  10:common/rtos/tasks.c ****     *    + Looking for basic training,                                        *
  11:common/rtos/tasks.c ****     *    + Wanting to improve your FreeRTOS skills and productivity           *
  12:common/rtos/tasks.c ****     *                                                                         *
  13:common/rtos/tasks.c ****     * then take a look at the FreeRTOS eBook                                  *
  14:common/rtos/tasks.c ****     *                                                                         *
  15:common/rtos/tasks.c ****     *        "Using the FreeRTOS Real Time Kernel - a Practical Guide"        *
  16:common/rtos/tasks.c ****     *                  http://www.FreeRTOS.org/Documentation                  *
  17:common/rtos/tasks.c ****     *                                                                         *
  18:common/rtos/tasks.c ****     * A pdf reference manual is also available.  Both are usually delivered   *
  19:common/rtos/tasks.c ****     * to your inbox within 20 minutes to two hours when purchased between 8am *
  20:common/rtos/tasks.c ****     * and 8pm GMT (although please allow up to 24 hours in case of            *
  21:common/rtos/tasks.c ****     * exceptional circumstances).  Thank you for your support!                *
  22:common/rtos/tasks.c ****     *                                                                         *
  23:common/rtos/tasks.c ****     ***************************************************************************
  24:common/rtos/tasks.c **** 
  25:common/rtos/tasks.c ****     This file is part of the FreeRTOS distribution.
  26:common/rtos/tasks.c **** 
  27:common/rtos/tasks.c ****     FreeRTOS is free software; you can redistribute it and/or modify it under
  28:common/rtos/tasks.c ****     the terms of the GNU General Public License (version 2) as published by the
  29:common/rtos/tasks.c ****     Free Software Foundation AND MODIFIED BY the FreeRTOS exception.
  30:common/rtos/tasks.c ****     ***NOTE*** The exception to the GPL is included to allow you to distribute
  31:common/rtos/tasks.c ****     a combined work that includes FreeRTOS without being obliged to provide the
  32:common/rtos/tasks.c ****     source code for proprietary components outside of the FreeRTOS kernel.
  33:common/rtos/tasks.c ****     FreeRTOS is distributed in the hope that it will be useful, but WITHOUT
  34:common/rtos/tasks.c ****     ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  35:common/rtos/tasks.c ****     FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
  36:common/rtos/tasks.c ****     more details. You should have received a copy of the GNU General Public
  37:common/rtos/tasks.c ****     License and the FreeRTOS license exception along with FreeRTOS; if not it
  38:common/rtos/tasks.c ****     can be viewed here: http://www.freertos.org/a00114.html and also obtained
  39:common/rtos/tasks.c ****     by writing to Richard Barry, contact details for whom are available on the
  40:common/rtos/tasks.c ****     FreeRTOS WEB site.
  41:common/rtos/tasks.c **** 
  42:common/rtos/tasks.c ****     1 tab == 4 spaces!
  43:common/rtos/tasks.c **** 
  44:common/rtos/tasks.c ****     http://www.FreeRTOS.org - Documentation, latest information, license and
  45:common/rtos/tasks.c ****     contact details.
  46:common/rtos/tasks.c **** 
  47:common/rtos/tasks.c ****     http://www.SafeRTOS.com - A version that is certified for use in safety
  48:common/rtos/tasks.c ****     critical systems.
  49:common/rtos/tasks.c **** 
  50:common/rtos/tasks.c ****     http://www.OpenRTOS.com - Commercial support, development, porting,
  51:common/rtos/tasks.c ****     licensing and training services.
  52:common/rtos/tasks.c **** */
  53:common/rtos/tasks.c **** 
  54:common/rtos/tasks.c **** 
  55:common/rtos/tasks.c **** #include <stdio.h>
  56:common/rtos/tasks.c **** #include <stdlib.h>
  57:common/rtos/tasks.c **** #include <string.h>
  58:common/rtos/tasks.c **** 
  59:common/rtos/tasks.c **** /* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
  60:common/rtos/tasks.c **** all the API functions to use the MPU wrappers.  That should only be done when
  61:common/rtos/tasks.c **** task.h is included from an application file. */
  62:common/rtos/tasks.c **** #define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  63:common/rtos/tasks.c **** 
  64:common/rtos/tasks.c **** #include "FreeRTOS.h"
  65:common/rtos/tasks.c **** #include "task.h"
  66:common/rtos/tasks.c **** #include "StackMacros.h"
  67:common/rtos/tasks.c **** 
  68:common/rtos/tasks.c **** #undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
  69:common/rtos/tasks.c **** 
  70:common/rtos/tasks.c **** /*
  71:common/rtos/tasks.c ****  * Macro to define the amount of stack available to the idle task.
  72:common/rtos/tasks.c ****  */
  73:common/rtos/tasks.c **** #define tskIDLE_STACK_SIZE	configMINIMAL_STACK_SIZE
  74:common/rtos/tasks.c **** 
  75:common/rtos/tasks.c **** #define tskIDLE_PRIORITY			( ( unsigned portBASE_TYPE ) 0 )
  76:common/rtos/tasks.c **** 
  77:common/rtos/tasks.c **** /*
  78:common/rtos/tasks.c ****  * Task control block.  A task control block (TCB) is allocated to each task,
  79:common/rtos/tasks.c ****  * and stores the context of the task.
  80:common/rtos/tasks.c ****  */
  81:common/rtos/tasks.c **** typedef struct tskTaskControlBlock
  82:common/rtos/tasks.c **** {
  83:common/rtos/tasks.c **** 	volatile portSTACK_TYPE	*pxTopOfStack;		/*< Points to the location of the last item placed on the 
  84:common/rtos/tasks.c **** 
  85:common/rtos/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
  86:common/rtos/tasks.c **** 		xMPU_SETTINGS xMPUSettings;				/*< The MPU settings are defined as part of the port layer.  THIS 
  87:common/rtos/tasks.c **** 	#endif	
  88:common/rtos/tasks.c **** 	
  89:common/rtos/tasks.c **** 	xListItem				xGenericListItem;	/*< List item used to place the TCB in ready and blocked queues. */
  90:common/rtos/tasks.c **** 	xListItem				xEventListItem;		/*< List item used to place the TCB in event lists. */
  91:common/rtos/tasks.c **** 	unsigned portBASE_TYPE	uxPriority;			/*< The priority of the task where 0 is the lowest priority. 
  92:common/rtos/tasks.c **** 	portSTACK_TYPE			*pxStack;			/*< Points to the start of the stack. */
  93:common/rtos/tasks.c **** 	signed char				pcTaskName[ configMAX_TASK_NAME_LEN ];/*< Descriptive name given to the task when c
  94:common/rtos/tasks.c **** 
  95:common/rtos/tasks.c **** 	#if ( portSTACK_GROWTH > 0 )
  96:common/rtos/tasks.c **** 		portSTACK_TYPE *pxEndOfStack;			/*< Used for stack overflow checking on architectures where the s
  97:common/rtos/tasks.c **** 	#endif
  98:common/rtos/tasks.c **** 
  99:common/rtos/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
 100:common/rtos/tasks.c **** 		unsigned portBASE_TYPE uxCriticalNesting;
 101:common/rtos/tasks.c **** 	#endif
 102:common/rtos/tasks.c **** 
 103:common/rtos/tasks.c **** 	#if ( configUSE_TRACE_FACILITY == 1 )
 104:common/rtos/tasks.c **** 		unsigned portBASE_TYPE	uxTCBNumber;	/*< This is used for tracing the scheduler and making debuggi
 105:common/rtos/tasks.c **** 	#endif
 106:common/rtos/tasks.c **** 
 107:common/rtos/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
 108:common/rtos/tasks.c **** 		unsigned portBASE_TYPE uxBasePriority;	/*< The priority last assigned to the task - used by the p
 109:common/rtos/tasks.c **** 	#endif
 110:common/rtos/tasks.c **** 
 111:common/rtos/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
 112:common/rtos/tasks.c **** 		pdTASK_HOOK_CODE pxTaskTag;
 113:common/rtos/tasks.c **** 	#endif
 114:common/rtos/tasks.c **** 
 115:common/rtos/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
 116:common/rtos/tasks.c **** 		unsigned long ulRunTimeCounter;		/*< Used for calculating how much CPU time each task is utilisin
 117:common/rtos/tasks.c **** 	#endif
 118:common/rtos/tasks.c **** 
 119:common/rtos/tasks.c **** } tskTCB;
 120:common/rtos/tasks.c **** 
 121:common/rtos/tasks.c **** 
 122:common/rtos/tasks.c **** /*
 123:common/rtos/tasks.c ****  * Some kernel aware debuggers require data to be viewed to be global, rather
 124:common/rtos/tasks.c ****  * than file scope.
 125:common/rtos/tasks.c ****  */
 126:common/rtos/tasks.c **** #ifdef portREMOVE_STATIC_QUALIFIER
 127:common/rtos/tasks.c **** 	#define static
 128:common/rtos/tasks.c **** #endif
 129:common/rtos/tasks.c **** 
 130:common/rtos/tasks.c **** /*lint -e956 */
 131:common/rtos/tasks.c **** PRIVILEGED_DATA tskTCB * volatile pxCurrentTCB = NULL;
 132:common/rtos/tasks.c **** 
 133:common/rtos/tasks.c **** /* Lists for ready and blocked tasks. --------------------*/
 134:common/rtos/tasks.c **** 
 135:common/rtos/tasks.c **** PRIVILEGED_DATA static xList pxReadyTasksLists[ configMAX_PRIORITIES ];	/*< Prioritised ready tasks
 136:common/rtos/tasks.c **** PRIVILEGED_DATA static xList xDelayedTaskList1;							/*< Delayed tasks. */
 137:common/rtos/tasks.c **** PRIVILEGED_DATA static xList xDelayedTaskList2;							/*< Delayed tasks (two lists are used - one f
 138:common/rtos/tasks.c **** PRIVILEGED_DATA static xList * volatile pxDelayedTaskList ;				/*< Points to the delayed task list 
 139:common/rtos/tasks.c **** PRIVILEGED_DATA static xList * volatile pxOverflowDelayedTaskList;		/*< Points to the delayed task 
 140:common/rtos/tasks.c **** PRIVILEGED_DATA static xList xPendingReadyList;							/*< Tasks that have been readied while the sc
 141:common/rtos/tasks.c **** 
 142:common/rtos/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 143:common/rtos/tasks.c **** 
 144:common/rtos/tasks.c **** 	PRIVILEGED_DATA static volatile xList xTasksWaitingTermination;		/*< Tasks that have been deleted 
 145:common/rtos/tasks.c **** 	PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTasksDeleted = ( unsigned portBASE_TYPE )
 146:common/rtos/tasks.c **** 
 147:common/rtos/tasks.c **** #endif
 148:common/rtos/tasks.c **** 
 149:common/rtos/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 150:common/rtos/tasks.c **** 
 151:common/rtos/tasks.c **** 	PRIVILEGED_DATA static xList xSuspendedTaskList;					/*< Tasks that are currently suspended. */
 152:common/rtos/tasks.c **** 
 153:common/rtos/tasks.c **** #endif
 154:common/rtos/tasks.c **** 
 155:common/rtos/tasks.c **** /* File private variables. --------------------------------*/
 156:common/rtos/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxCurrentNumberOfTasks 	= ( unsigned portBAS
 157:common/rtos/tasks.c **** PRIVILEGED_DATA static volatile portTickType xTickCount 						= ( portTickType ) 0;
 158:common/rtos/tasks.c **** PRIVILEGED_DATA static unsigned portBASE_TYPE uxTopUsedPriority	 				= tskIDLE_PRIORITY;
 159:common/rtos/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxTopReadyPriority 		= tskIDLE_PRIORITY;
 160:common/rtos/tasks.c **** PRIVILEGED_DATA static volatile signed portBASE_TYPE xSchedulerRunning 			= pdFALSE;
 161:common/rtos/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxSchedulerSuspended	 	= ( unsigned portBASE
 162:common/rtos/tasks.c **** PRIVILEGED_DATA static volatile unsigned portBASE_TYPE uxMissedTicks 			= ( unsigned portBASE_TYPE 
 163:common/rtos/tasks.c **** PRIVILEGED_DATA static volatile portBASE_TYPE xMissedYield 						= ( portBASE_TYPE ) pdFALSE;
 164:common/rtos/tasks.c **** PRIVILEGED_DATA static volatile portBASE_TYPE xNumOfOverflows 					= ( portBASE_TYPE ) 0;
 165:common/rtos/tasks.c **** PRIVILEGED_DATA static unsigned portBASE_TYPE uxTaskNumber 						= ( unsigned portBASE_TYPE ) 0;
 166:common/rtos/tasks.c **** 
 167:common/rtos/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
 168:common/rtos/tasks.c **** 
 169:common/rtos/tasks.c **** 	PRIVILEGED_DATA static char pcStatsString[ 50 ] ;
 170:common/rtos/tasks.c **** 	PRIVILEGED_DATA static unsigned long ulTaskSwitchedInTime = 0UL;	/*< Holds the value of a timer/co
 171:common/rtos/tasks.c **** 	static void prvGenerateRunTimeStatsForTasksInList( const signed char *pcWriteBuffer, xList *pxList
 172:common/rtos/tasks.c **** 
 173:common/rtos/tasks.c **** #endif
 174:common/rtos/tasks.c **** 
 175:common/rtos/tasks.c **** /* Debugging and trace facilities private variables and macros. ------------*/
 176:common/rtos/tasks.c **** 
 177:common/rtos/tasks.c **** /*
 178:common/rtos/tasks.c ****  * The value used to fill the stack of a task when the task is created.  This
 179:common/rtos/tasks.c ****  * is used purely for checking the high water mark for tasks.
 180:common/rtos/tasks.c ****  */
 181:common/rtos/tasks.c **** #define tskSTACK_FILL_BYTE	( 0xa5 )
 182:common/rtos/tasks.c **** 
 183:common/rtos/tasks.c **** /*
 184:common/rtos/tasks.c ****  * Macros used by vListTask to indicate which state a task is in.
 185:common/rtos/tasks.c ****  */
 186:common/rtos/tasks.c **** #define tskBLOCKED_CHAR		( ( signed char ) 'B' )
 187:common/rtos/tasks.c **** #define tskREADY_CHAR		( ( signed char ) 'R' )
 188:common/rtos/tasks.c **** #define tskDELETED_CHAR		( ( signed char ) 'D' )
 189:common/rtos/tasks.c **** #define tskSUSPENDED_CHAR	( ( signed char ) 'S' )
 190:common/rtos/tasks.c **** 
 191:common/rtos/tasks.c **** /*
 192:common/rtos/tasks.c ****  * Macros and private variables used by the trace facility.
 193:common/rtos/tasks.c ****  */
 194:common/rtos/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 195:common/rtos/tasks.c **** 
 196:common/rtos/tasks.c **** 	#define tskSIZE_OF_EACH_TRACE_LINE			( ( unsigned long ) ( sizeof( unsigned long ) + sizeof( unsig
 197:common/rtos/tasks.c **** 	PRIVILEGED_DATA static volatile signed char * volatile pcTraceBuffer;
 198:common/rtos/tasks.c **** 	PRIVILEGED_DATA static signed char *pcTraceBufferStart;
 199:common/rtos/tasks.c **** 	PRIVILEGED_DATA static signed char *pcTraceBufferEnd;
 200:common/rtos/tasks.c **** 	PRIVILEGED_DATA static signed portBASE_TYPE xTracing = pdFALSE;
 201:common/rtos/tasks.c **** 	static unsigned portBASE_TYPE uxPreviousTask = 255;
 202:common/rtos/tasks.c **** 	PRIVILEGED_DATA static char pcStatusString[ 50 ];
 203:common/rtos/tasks.c **** 
 204:common/rtos/tasks.c **** #endif
 205:common/rtos/tasks.c **** 
 206:common/rtos/tasks.c **** /*-----------------------------------------------------------*/
 207:common/rtos/tasks.c **** 
 208:common/rtos/tasks.c **** /*
 209:common/rtos/tasks.c ****  * Macro that writes a trace of scheduler activity to a buffer.  This trace
 210:common/rtos/tasks.c ****  * shows which task is running when and is very useful as a debugging tool.
 211:common/rtos/tasks.c ****  * As this macro is called each context switch it is a good idea to undefine
 212:common/rtos/tasks.c ****  * it if not using the facility.
 213:common/rtos/tasks.c ****  */
 214:common/rtos/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 215:common/rtos/tasks.c **** 
 216:common/rtos/tasks.c **** 	#define vWriteTraceToBuffer()																	\
 217:common/rtos/tasks.c **** 	{																								\
 218:common/rtos/tasks.c **** 		if( xTracing )																				\
 219:common/rtos/tasks.c **** 		{																							\
 220:common/rtos/tasks.c **** 			if( uxPreviousTask != pxCurrentTCB->uxTCBNumber )										\
 221:common/rtos/tasks.c **** 			{																						\
 222:common/rtos/tasks.c **** 				if( ( pcTraceBuffer + tskSIZE_OF_EACH_TRACE_LINE ) < pcTraceBufferEnd )				\
 223:common/rtos/tasks.c **** 				{																					\
 224:common/rtos/tasks.c **** 					uxPreviousTask = pxCurrentTCB->uxTCBNumber;										\
 225:common/rtos/tasks.c **** 					*( unsigned long * ) pcTraceBuffer = ( unsigned long ) xTickCount;		\
 226:common/rtos/tasks.c **** 					pcTraceBuffer += sizeof( unsigned long );									\
 227:common/rtos/tasks.c **** 					*( unsigned long * ) pcTraceBuffer = ( unsigned long ) uxPreviousTask;	\
 228:common/rtos/tasks.c **** 					pcTraceBuffer += sizeof( unsigned long );									\
 229:common/rtos/tasks.c **** 				}																					\
 230:common/rtos/tasks.c **** 				else																				\
 231:common/rtos/tasks.c **** 				{																					\
 232:common/rtos/tasks.c **** 					xTracing = pdFALSE;																\
 233:common/rtos/tasks.c **** 				}																					\
 234:common/rtos/tasks.c **** 			}																						\
 235:common/rtos/tasks.c **** 		}																							\
 236:common/rtos/tasks.c **** 	}
 237:common/rtos/tasks.c **** 
 238:common/rtos/tasks.c **** #else
 239:common/rtos/tasks.c **** 
 240:common/rtos/tasks.c **** 	#define vWriteTraceToBuffer()
 241:common/rtos/tasks.c **** 
 242:common/rtos/tasks.c **** #endif
 243:common/rtos/tasks.c **** /*-----------------------------------------------------------*/
 244:common/rtos/tasks.c **** 
 245:common/rtos/tasks.c **** /*
 246:common/rtos/tasks.c ****  * Place the task represented by pxTCB into the appropriate ready queue for
 247:common/rtos/tasks.c ****  * the task.  It is inserted at the end of the list.  One quirk of this is
 248:common/rtos/tasks.c ****  * that if the task being inserted is at the same priority as the currently
 249:common/rtos/tasks.c ****  * executing task, then it will only be rescheduled after the currently
 250:common/rtos/tasks.c ****  * executing task has been rescheduled.
 251:common/rtos/tasks.c ****  */
 252:common/rtos/tasks.c **** #define prvAddTaskToReadyQueue( pxTCB )																			\
 253:common/rtos/tasks.c **** {																												\
 254:common/rtos/tasks.c **** 	if( pxTCB->uxPriority > uxTopReadyPriority )																\
 255:common/rtos/tasks.c **** 	{																											\
 256:common/rtos/tasks.c **** 		uxTopReadyPriority = pxTCB->uxPriority;																	\
 257:common/rtos/tasks.c **** 	}																											\
 258:common/rtos/tasks.c **** 	vListInsertEnd( ( xList * ) &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListIte
 259:common/rtos/tasks.c **** }
 260:common/rtos/tasks.c **** /*-----------------------------------------------------------*/
 261:common/rtos/tasks.c **** 
 262:common/rtos/tasks.c **** /*
 263:common/rtos/tasks.c ****  * Macro that looks at the list of tasks that are currently delayed to see if
 264:common/rtos/tasks.c ****  * any require waking.
 265:common/rtos/tasks.c ****  *
 266:common/rtos/tasks.c ****  * Tasks are stored in the queue in the order of their wake time - meaning
 267:common/rtos/tasks.c ****  * once one tasks has been found whose timer has not expired we need not look
 268:common/rtos/tasks.c ****  * any further down the list.
 269:common/rtos/tasks.c ****  */
 270:common/rtos/tasks.c **** #define prvCheckDelayedTasks()																						\
 271:common/rtos/tasks.c **** {																													\
 272:common/rtos/tasks.c **** register tskTCB *pxTCB;																								\
 273:common/rtos/tasks.c **** 																													\
 274:common/rtos/tasks.c **** 	while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ) ) != NULL )						\
 275:common/rtos/tasks.c **** 	{																												\
 276:common/rtos/tasks.c **** 		if( xTickCount < listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) ) )									\
 277:common/rtos/tasks.c **** 		{																											\
 278:common/rtos/tasks.c **** 			break;																									\
 279:common/rtos/tasks.c **** 		}																											\
 280:common/rtos/tasks.c **** 		vListRemove( &( pxTCB->xGenericListItem ) );																\
 281:common/rtos/tasks.c **** 		/* Is the task waiting on an event also? */																	\
 282:common/rtos/tasks.c **** 		if( pxTCB->xEventListItem.pvContainer )																		\
 283:common/rtos/tasks.c **** 		{																											\
 284:common/rtos/tasks.c **** 			vListRemove( &( pxTCB->xEventListItem ) );																\
 285:common/rtos/tasks.c **** 		}																											\
 286:common/rtos/tasks.c **** 		prvAddTaskToReadyQueue( pxTCB );																			\
 287:common/rtos/tasks.c **** 	}																												\
 288:common/rtos/tasks.c **** }
 289:common/rtos/tasks.c **** /*-----------------------------------------------------------*/
 290:common/rtos/tasks.c **** 
 291:common/rtos/tasks.c **** /*
 292:common/rtos/tasks.c ****  * Several functions take an xTaskHandle parameter that can optionally be NULL,
 293:common/rtos/tasks.c ****  * where NULL is used to indicate that the handle of the currently executing
 294:common/rtos/tasks.c ****  * task should be used in place of the parameter.  This macro simply checks to
 295:common/rtos/tasks.c ****  * see if the parameter is NULL and returns a pointer to the appropriate TCB.
 296:common/rtos/tasks.c ****  */
 297:common/rtos/tasks.c **** #define prvGetTCBFromHandle( pxHandle ) ( ( pxHandle == NULL ) ? ( tskTCB * ) pxCurrentTCB : ( tskT
 298:common/rtos/tasks.c **** 
 299:common/rtos/tasks.c **** 
 300:common/rtos/tasks.c **** /* File private functions. --------------------------------*/
 301:common/rtos/tasks.c **** 
 302:common/rtos/tasks.c **** /*
 303:common/rtos/tasks.c ****  * Utility to ready a TCB for a given task.  Mainly just copies the parameters
 304:common/rtos/tasks.c ****  * into the TCB structure.
 305:common/rtos/tasks.c ****  */
 306:common/rtos/tasks.c **** static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned po
 307:common/rtos/tasks.c **** 
 308:common/rtos/tasks.c **** /*
 309:common/rtos/tasks.c ****  * Utility to ready all the lists used by the scheduler.  This is called
 310:common/rtos/tasks.c ****  * automatically upon the creation of the first task.
 311:common/rtos/tasks.c ****  */
 312:common/rtos/tasks.c **** static void prvInitialiseTaskLists( void ) PRIVILEGED_FUNCTION;
 313:common/rtos/tasks.c **** 
 314:common/rtos/tasks.c **** /*
 315:common/rtos/tasks.c ****  * The idle task, which as all tasks is implemented as a never ending loop.
 316:common/rtos/tasks.c ****  * The idle task is automatically created and added to the ready lists upon
 317:common/rtos/tasks.c ****  * creation of the first user task.
 318:common/rtos/tasks.c ****  *
 319:common/rtos/tasks.c ****  * The portTASK_FUNCTION_PROTO() macro is used to allow port/compiler specific
 320:common/rtos/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
 321:common/rtos/tasks.c ****  *
 322:common/rtos/tasks.c ****  * void prvIdleTask( void *pvParameters );
 323:common/rtos/tasks.c ****  *
 324:common/rtos/tasks.c ****  */
 325:common/rtos/tasks.c **** static portTASK_FUNCTION_PROTO( prvIdleTask, pvParameters );
 326:common/rtos/tasks.c **** 
 327:common/rtos/tasks.c **** /*
 328:common/rtos/tasks.c ****  * Utility to free all memory allocated by the scheduler to hold a TCB,
 329:common/rtos/tasks.c ****  * including the stack pointed to by the TCB.
 330:common/rtos/tasks.c ****  *
 331:common/rtos/tasks.c ****  * This does not free memory allocated by the task itself (i.e. memory
 332:common/rtos/tasks.c ****  * allocated by calls to pvPortMalloc from within the tasks application code).
 333:common/rtos/tasks.c ****  */
 334:common/rtos/tasks.c **** #if ( ( INCLUDE_vTaskDelete == 1 ) || ( INCLUDE_vTaskCleanUpResources == 1 ) )
 335:common/rtos/tasks.c **** 
 336:common/rtos/tasks.c **** 	static void prvDeleteTCB( tskTCB *pxTCB ) PRIVILEGED_FUNCTION;
 337:common/rtos/tasks.c **** 
 338:common/rtos/tasks.c **** #endif
 339:common/rtos/tasks.c **** 
 340:common/rtos/tasks.c **** /*
 341:common/rtos/tasks.c ****  * Used only by the idle task.  This checks to see if anything has been placed
 342:common/rtos/tasks.c ****  * in the list of tasks waiting to be deleted.  If so the task is cleaned up
 343:common/rtos/tasks.c ****  * and its TCB deleted.
 344:common/rtos/tasks.c ****  */
 345:common/rtos/tasks.c **** static void prvCheckTasksWaitingTermination( void ) PRIVILEGED_FUNCTION;
 346:common/rtos/tasks.c **** 
 347:common/rtos/tasks.c **** /*
 348:common/rtos/tasks.c ****  * Allocates memory from the heap for a TCB and associated stack.  Checks the
 349:common/rtos/tasks.c ****  * allocation was successful.
 350:common/rtos/tasks.c ****  */
 351:common/rtos/tasks.c **** static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer 
 352:common/rtos/tasks.c **** 
 353:common/rtos/tasks.c **** /*
 354:common/rtos/tasks.c ****  * Called from vTaskList.  vListTasks details all the tasks currently under
 355:common/rtos/tasks.c ****  * control of the scheduler.  The tasks may be in one of a number of lists.
 356:common/rtos/tasks.c ****  * prvListTaskWithinSingleList accepts a list and details the tasks from
 357:common/rtos/tasks.c ****  * within just that list.
 358:common/rtos/tasks.c ****  *
 359:common/rtos/tasks.c ****  * THIS FUNCTION IS INTENDED FOR DEBUGGING ONLY, AND SHOULD NOT BE CALLED FROM
 360:common/rtos/tasks.c ****  * NORMAL APPLICATION CODE.
 361:common/rtos/tasks.c ****  */
 362:common/rtos/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
 363:common/rtos/tasks.c **** 
 364:common/rtos/tasks.c **** 	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed c
 365:common/rtos/tasks.c **** 
 366:common/rtos/tasks.c **** #endif
 367:common/rtos/tasks.c **** 
 368:common/rtos/tasks.c **** /*
 369:common/rtos/tasks.c ****  * When a task is created, the stack of the task is filled with a known value.
 370:common/rtos/tasks.c ****  * This function determines the 'high water mark' of the task stack by
 371:common/rtos/tasks.c ****  * determining how much of the stack remains at the original preset value.
 372:common/rtos/tasks.c ****  */
 373:common/rtos/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
 374:common/rtos/tasks.c **** 
 375:common/rtos/tasks.c **** 	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte ) PRIVILEGED_F
 376:common/rtos/tasks.c **** 
 377:common/rtos/tasks.c **** #endif
 378:common/rtos/tasks.c **** 
 379:common/rtos/tasks.c **** 
 380:common/rtos/tasks.c **** /*lint +e956 */
 381:common/rtos/tasks.c **** 
 382:common/rtos/tasks.c **** 
 383:common/rtos/tasks.c **** 
 384:common/rtos/tasks.c **** /*-----------------------------------------------------------
 385:common/rtos/tasks.c ****  * TASK CREATION API documented in task.h
 386:common/rtos/tasks.c ****  *----------------------------------------------------------*/
 387:common/rtos/tasks.c **** 
 388:common/rtos/tasks.c **** signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, 
 389:common/rtos/tasks.c **** {
 148              		.loc 1 389 1
 149              		.cfi_startproc
 150              		@ args = 16, pretend = 0, frame = 32
 151              		@ frame_needed = 1, uses_anonymous_args = 0
 152 0000 90B5     		push	{r4, r7, lr}
 153              	.LCFI0:
 154              		.cfi_def_cfa_offset 12
 155              		.cfi_offset 4, -12
 156              		.cfi_offset 7, -8
 157              		.cfi_offset 14, -4
 158 0002 8BB0     		sub	sp, sp, #44
 159              	.LCFI1:
 160              		.cfi_def_cfa_offset 56
 161 0004 02AF     		add	r7, sp, #8
 162              	.LCFI2:
 163              		.cfi_def_cfa 7, 48
 164 0006 F860     		str	r0, [r7, #12]
 165 0008 B960     		str	r1, [r7, #8]
 166 000a 3B60     		str	r3, [r7]
 167 000c 1346     		mov	r3, r2	@ movhi
 168 000e FB80     		strh	r3, [r7, #6]	@ movhi
 390:common/rtos/tasks.c **** signed portBASE_TYPE xReturn;
 391:common/rtos/tasks.c **** tskTCB * pxNewTCB;
 392:common/rtos/tasks.c **** 
 393:common/rtos/tasks.c **** 	/* Allocate the memory required by the TCB and stack for the new task,
 394:common/rtos/tasks.c **** 	checking that the allocation was successful. */
 395:common/rtos/tasks.c **** 	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
 169              		.loc 1 395 13
 170 0010 FB88     		ldrh	r3, [r7, #6]
 171 0012 B96B     		ldr	r1, [r7, #56]
 172 0014 1846     		mov	r0, r3
 173 0016 454B     		ldr	r3, .L11
 174 0018 9847     		blx	r3
 175              	.LVL0:
 176 001a B861     		str	r0, [r7, #24]
 396:common/rtos/tasks.c **** 
 397:common/rtos/tasks.c **** 	if( pxNewTCB != NULL )
 177              		.loc 1 397 4
 178 001c BB69     		ldr	r3, [r7, #24]
 179 001e 002B     		cmp	r3, #0
 180 0020 66D0     		beq	.L2
 181              	.LBB2:
 398:common/rtos/tasks.c **** 	{
 399:common/rtos/tasks.c **** 		portSTACK_TYPE *pxTopOfStack;
 400:common/rtos/tasks.c **** 
 401:common/rtos/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 402:common/rtos/tasks.c **** 			/* Should the task be created in privileged mode? */
 403:common/rtos/tasks.c **** 			portBASE_TYPE xRunPrivileged;
 404:common/rtos/tasks.c **** 			if( ( uxPriority & portPRIVILEGE_BIT ) != 0x00 )
 405:common/rtos/tasks.c **** 			{
 406:common/rtos/tasks.c **** 				xRunPrivileged = pdTRUE;
 407:common/rtos/tasks.c **** 			}
 408:common/rtos/tasks.c **** 			else
 409:common/rtos/tasks.c **** 			{
 410:common/rtos/tasks.c **** 				xRunPrivileged = pdFALSE;
 411:common/rtos/tasks.c **** 			}
 412:common/rtos/tasks.c **** 			uxPriority &= ~portPRIVILEGE_BIT;
 413:common/rtos/tasks.c **** 		#endif /* portUSING_MPU_WRAPPERS == 1 */
 414:common/rtos/tasks.c **** 
 415:common/rtos/tasks.c **** 		/* Calculate the top of stack address.  This depends on whether the
 416:common/rtos/tasks.c **** 		stack grows from high memory to low (as per the 80x86) or visa versa.
 417:common/rtos/tasks.c **** 		portSTACK_GROWTH is used to make the result positive or negative as
 418:common/rtos/tasks.c **** 		required by the port. */
 419:common/rtos/tasks.c **** 		#if( portSTACK_GROWTH < 0 )
 420:common/rtos/tasks.c **** 		{
 421:common/rtos/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
 182              		.loc 1 421 27
 183 0022 BB69     		ldr	r3, [r7, #24]
 184 0024 1A6B     		ldr	r2, [r3, #48]
 185              		.loc 1 421 37
 186 0026 FB88     		ldrh	r3, [r7, #6]
 187 0028 03F18043 		add	r3, r3, #1073741824
 188 002c 013B     		subs	r3, r3, #1
 189 002e 9B00     		lsls	r3, r3, #2
 190              		.loc 1 421 17
 191 0030 1344     		add	r3, r3, r2
 192 0032 7B61     		str	r3, [r7, #20]
 422:common/rtos/tasks.c **** 			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~
 193              		.loc 1 422 44
 194 0034 7B69     		ldr	r3, [r7, #20]
 195              		.loc 1 422 77
 196 0036 23F00703 		bic	r3, r3, #7
 197              		.loc 1 422 17
 198 003a 7B61     		str	r3, [r7, #20]
 423:common/rtos/tasks.c **** 		}
 424:common/rtos/tasks.c **** 		#else
 425:common/rtos/tasks.c **** 		{
 426:common/rtos/tasks.c **** 			pxTopOfStack = pxNewTCB->pxStack;
 427:common/rtos/tasks.c **** 
 428:common/rtos/tasks.c **** 			/* If we want to use stack checking on architectures that use
 429:common/rtos/tasks.c **** 			a positive stack growth direction then we also need to store the
 430:common/rtos/tasks.c **** 			other extreme of the stack space. */
 431:common/rtos/tasks.c **** 			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
 432:common/rtos/tasks.c **** 		}
 433:common/rtos/tasks.c **** 		#endif
 434:common/rtos/tasks.c **** 
 435:common/rtos/tasks.c **** 		/* Setup the newly allocated TCB with the initial state of the task. */
 436:common/rtos/tasks.c **** 		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
 199              		.loc 1 436 3
 200 003c FB88     		ldrh	r3, [r7, #6]
 201 003e 0093     		str	r3, [sp]
 202 0040 FB6B     		ldr	r3, [r7, #60]
 203 0042 3A6B     		ldr	r2, [r7, #48]
 204 0044 B968     		ldr	r1, [r7, #8]
 205 0046 B869     		ldr	r0, [r7, #24]
 206 0048 394C     		ldr	r4, .L11+4
 207 004a A047     		blx	r4
 208              	.LVL1:
 437:common/rtos/tasks.c **** 
 438:common/rtos/tasks.c **** 		/* Initialize the TCB stack to look as if the task was already running,
 439:common/rtos/tasks.c **** 		but had been interrupted by the scheduler.  The return address is set
 440:common/rtos/tasks.c **** 		to the start of the task function. Once the stack has been initialised
 441:common/rtos/tasks.c **** 		the	top of stack variable is updated. */
 442:common/rtos/tasks.c **** 		#if( portUSING_MPU_WRAPPERS == 1 )
 443:common/rtos/tasks.c **** 		{
 444:common/rtos/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPriv
 445:common/rtos/tasks.c **** 		}
 446:common/rtos/tasks.c **** 		#else
 447:common/rtos/tasks.c **** 		{
 448:common/rtos/tasks.c **** 			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 209              		.loc 1 448 29
 210 004c 3A68     		ldr	r2, [r7]
 211 004e F968     		ldr	r1, [r7, #12]
 212 0050 7869     		ldr	r0, [r7, #20]
 213 0052 384B     		ldr	r3, .L11+8
 214 0054 9847     		blx	r3
 215              	.LVL2:
 216 0056 0246     		mov	r2, r0
 217              		.loc 1 448 27
 218 0058 BB69     		ldr	r3, [r7, #24]
 219 005a 1A60     		str	r2, [r3]
 449:common/rtos/tasks.c **** 		}
 450:common/rtos/tasks.c **** 		#endif
 451:common/rtos/tasks.c **** 
 452:common/rtos/tasks.c **** 		/* We are going to manipulate the task queues to add this task to a
 453:common/rtos/tasks.c **** 		ready list, so must make sure no interrupts occur. */
 454:common/rtos/tasks.c **** 		portENTER_CRITICAL();
 220              		.loc 1 454 3
 221 005c 364B     		ldr	r3, .L11+12
 222 005e 9847     		blx	r3
 223              	.LVL3:
 455:common/rtos/tasks.c **** 		{
 456:common/rtos/tasks.c **** 			uxCurrentNumberOfTasks++;
 224              		.loc 1 456 26
 225 0060 364B     		ldr	r3, .L11+16
 226 0062 1B68     		ldr	r3, [r3]
 227 0064 0133     		adds	r3, r3, #1
 228 0066 354A     		ldr	r2, .L11+16
 229 0068 1360     		str	r3, [r2]
 457:common/rtos/tasks.c **** 			if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
 230              		.loc 1 457 31
 231 006a 344B     		ldr	r3, .L11+16
 232 006c 1B68     		ldr	r3, [r3]
 233              		.loc 1 457 6
 234 006e 012B     		cmp	r3, #1
 235 0070 05D1     		bne	.L3
 458:common/rtos/tasks.c **** 			{
 459:common/rtos/tasks.c **** 				/* As this is the first task it must also be the current task. */
 460:common/rtos/tasks.c **** 				pxCurrentTCB =  pxNewTCB;
 236              		.loc 1 460 18
 237 0072 334A     		ldr	r2, .L11+20
 238 0074 BB69     		ldr	r3, [r7, #24]
 239 0076 1360     		str	r3, [r2]
 461:common/rtos/tasks.c **** 
 462:common/rtos/tasks.c **** 				/* This is the first task to be created so do the preliminary
 463:common/rtos/tasks.c **** 				initialisation required.  We will not recover if this call
 464:common/rtos/tasks.c **** 				fails, but we will report the failure. */
 465:common/rtos/tasks.c **** 				prvInitialiseTaskLists();
 240              		.loc 1 465 5
 241 0078 324B     		ldr	r3, .L11+24
 242 007a 9847     		blx	r3
 243              	.LVL4:
 244 007c 0CE0     		b	.L4
 245              	.L3:
 466:common/rtos/tasks.c **** 			}
 467:common/rtos/tasks.c **** 			else
 468:common/rtos/tasks.c **** 			{
 469:common/rtos/tasks.c **** 				/* If the scheduler is not already running, make this task the
 470:common/rtos/tasks.c **** 				current task if it is the highest priority task to be created
 471:common/rtos/tasks.c **** 				so far. */
 472:common/rtos/tasks.c **** 				if( xSchedulerRunning == pdFALSE )
 246              		.loc 1 472 27
 247 007e 324B     		ldr	r3, .L11+28
 248 0080 1B68     		ldr	r3, [r3]
 249              		.loc 1 472 7
 250 0082 002B     		cmp	r3, #0
 251 0084 08D1     		bne	.L4
 473:common/rtos/tasks.c **** 				{
 474:common/rtos/tasks.c **** 					if( pxCurrentTCB->uxPriority <= uxPriority )
 252              		.loc 1 474 22
 253 0086 2E4B     		ldr	r3, .L11+20
 254 0088 1B68     		ldr	r3, [r3]
 255 008a DB6A     		ldr	r3, [r3, #44]
 256              		.loc 1 474 8
 257 008c 3A6B     		ldr	r2, [r7, #48]
 258 008e 9A42     		cmp	r2, r3
 259 0090 02D3     		bcc	.L4
 475:common/rtos/tasks.c **** 					{
 476:common/rtos/tasks.c **** 						pxCurrentTCB = pxNewTCB;
 260              		.loc 1 476 20
 261 0092 2B4A     		ldr	r2, .L11+20
 262 0094 BB69     		ldr	r3, [r7, #24]
 263 0096 1360     		str	r3, [r2]
 264              	.L4:
 477:common/rtos/tasks.c **** 					}
 478:common/rtos/tasks.c **** 				}
 479:common/rtos/tasks.c **** 			}
 480:common/rtos/tasks.c **** 
 481:common/rtos/tasks.c **** 			/* Remember the top priority to make context switching faster.  Use
 482:common/rtos/tasks.c **** 			the priority in pxNewTCB as this has been capped to a valid value. */
 483:common/rtos/tasks.c **** 			if( pxNewTCB->uxPriority > uxTopUsedPriority )
 265              		.loc 1 483 16
 266 0098 BB69     		ldr	r3, [r7, #24]
 267 009a DA6A     		ldr	r2, [r3, #44]
 268              		.loc 1 483 29
 269 009c 2B4B     		ldr	r3, .L11+32
 270 009e 1B68     		ldr	r3, [r3]
 271              		.loc 1 483 6
 272 00a0 9A42     		cmp	r2, r3
 273 00a2 03D9     		bls	.L5
 484:common/rtos/tasks.c **** 			{
 485:common/rtos/tasks.c **** 				uxTopUsedPriority = pxNewTCB->uxPriority;
 274              		.loc 1 485 33
 275 00a4 BB69     		ldr	r3, [r7, #24]
 276 00a6 DB6A     		ldr	r3, [r3, #44]
 277              		.loc 1 485 23
 278 00a8 284A     		ldr	r2, .L11+32
 279 00aa 1360     		str	r3, [r2]
 280              	.L5:
 486:common/rtos/tasks.c **** 			}
 487:common/rtos/tasks.c **** 
 488:common/rtos/tasks.c **** 			#if ( configUSE_TRACE_FACILITY == 1 )
 489:common/rtos/tasks.c **** 			{
 490:common/rtos/tasks.c **** 				/* Add a counter into the TCB for tracing only. */
 491:common/rtos/tasks.c **** 				pxNewTCB->uxTCBNumber = uxTaskNumber;
 492:common/rtos/tasks.c **** 			}
 493:common/rtos/tasks.c **** 			#endif
 494:common/rtos/tasks.c **** 			uxTaskNumber++;
 281              		.loc 1 494 16
 282 00ac 284B     		ldr	r3, .L11+36
 283 00ae 1B68     		ldr	r3, [r3]
 284 00b0 0133     		adds	r3, r3, #1
 285 00b2 274A     		ldr	r2, .L11+36
 286 00b4 1360     		str	r3, [r2]
 495:common/rtos/tasks.c **** 
 496:common/rtos/tasks.c **** 			prvAddTaskToReadyQueue( pxNewTCB );
 287              		.loc 1 496 4
 288 00b6 BB69     		ldr	r3, [r7, #24]
 289 00b8 DA6A     		ldr	r2, [r3, #44]
 290 00ba 264B     		ldr	r3, .L11+40
 291 00bc 1B68     		ldr	r3, [r3]
 292 00be 9A42     		cmp	r2, r3
 293 00c0 03D9     		bls	.L6
 294              		.loc 1 496 4 is_stmt 0 discriminator 1
 295 00c2 BB69     		ldr	r3, [r7, #24]
 296 00c4 DB6A     		ldr	r3, [r3, #44]
 297 00c6 234A     		ldr	r2, .L11+40
 298 00c8 1360     		str	r3, [r2]
 299              	.L6:
 300              		.loc 1 496 4 discriminator 3
 301 00ca BB69     		ldr	r3, [r7, #24]
 302 00cc DA6A     		ldr	r2, [r3, #44]
 303 00ce 1346     		mov	r3, r2
 304 00d0 9B00     		lsls	r3, r3, #2
 305 00d2 1344     		add	r3, r3, r2
 306 00d4 9B00     		lsls	r3, r3, #2
 307 00d6 204A     		ldr	r2, .L11+44
 308 00d8 1A44     		add	r2, r2, r3
 309 00da BB69     		ldr	r3, [r7, #24]
 310 00dc 0433     		adds	r3, r3, #4
 311 00de 1946     		mov	r1, r3
 312 00e0 1046     		mov	r0, r2
 313 00e2 1E4B     		ldr	r3, .L11+48
 314 00e4 9847     		blx	r3
 315              	.LVL5:
 497:common/rtos/tasks.c **** 
 498:common/rtos/tasks.c **** 			xReturn = pdPASS;
 316              		.loc 1 498 12 is_stmt 1 discriminator 3
 317 00e6 0123     		movs	r3, #1
 318 00e8 FB61     		str	r3, [r7, #28]
 499:common/rtos/tasks.c **** 			traceTASK_CREATE( pxNewTCB );
 500:common/rtos/tasks.c **** 		}
 501:common/rtos/tasks.c **** 		portEXIT_CRITICAL();
 319              		.loc 1 501 3 discriminator 3
 320 00ea 1D4B     		ldr	r3, .L11+52
 321 00ec 9847     		blx	r3
 322              	.LVL6:
 323              	.LBE2:
 324 00ee 02E0     		b	.L7
 325              	.L2:
 502:common/rtos/tasks.c **** 	}
 503:common/rtos/tasks.c **** 	else
 504:common/rtos/tasks.c **** 	{
 505:common/rtos/tasks.c **** 		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 326              		.loc 1 505 11
 327 00f0 4FF0FF33 		mov	r3, #-1
 328 00f4 FB61     		str	r3, [r7, #28]
 329              	.L7:
 506:common/rtos/tasks.c **** 		traceTASK_CREATE_FAILED( pxNewTCB );
 507:common/rtos/tasks.c **** 	}
 508:common/rtos/tasks.c **** 
 509:common/rtos/tasks.c **** 	if( xReturn == pdPASS )
 330              		.loc 1 509 4
 331 00f6 FB69     		ldr	r3, [r7, #28]
 332 00f8 012B     		cmp	r3, #1
 333 00fa 11D1     		bne	.L8
 510:common/rtos/tasks.c **** 	{
 511:common/rtos/tasks.c **** 		if( ( void * ) pxCreatedTask != NULL )
 334              		.loc 1 511 5
 335 00fc 7B6B     		ldr	r3, [r7, #52]
 336 00fe 002B     		cmp	r3, #0
 337 0100 02D0     		beq	.L9
 512:common/rtos/tasks.c **** 		{
 513:common/rtos/tasks.c **** 			/* Pass the TCB out - in an anonymous way.  The calling function/
 514:common/rtos/tasks.c **** 			task can use this as a handle to delete the task later if
 515:common/rtos/tasks.c **** 			required.*/
 516:common/rtos/tasks.c **** 			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 338              		.loc 1 516 19
 339 0102 7B6B     		ldr	r3, [r7, #52]
 340 0104 BA69     		ldr	r2, [r7, #24]
 341 0106 1A60     		str	r2, [r3]
 342              	.L9:
 517:common/rtos/tasks.c **** 		}
 518:common/rtos/tasks.c **** 
 519:common/rtos/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 343              		.loc 1 519 25
 344 0108 0F4B     		ldr	r3, .L11+28
 345 010a 1B68     		ldr	r3, [r3]
 346              		.loc 1 519 5
 347 010c 002B     		cmp	r3, #0
 348 010e 07D0     		beq	.L8
 520:common/rtos/tasks.c **** 		{
 521:common/rtos/tasks.c **** 			/* If the created task is of a higher priority than the current task
 522:common/rtos/tasks.c **** 			then it should run now. */
 523:common/rtos/tasks.c **** 			if( pxCurrentTCB->uxPriority < uxPriority )
 349              		.loc 1 523 20
 350 0110 0B4B     		ldr	r3, .L11+20
 351 0112 1B68     		ldr	r3, [r3]
 352 0114 DB6A     		ldr	r3, [r3, #44]
 353              		.loc 1 523 6
 354 0116 3A6B     		ldr	r2, [r7, #48]
 355 0118 9A42     		cmp	r2, r3
 356 011a 01D9     		bls	.L8
 524:common/rtos/tasks.c **** 			{
 525:common/rtos/tasks.c **** 				portYIELD_WITHIN_API();
 357              		.loc 1 525 5
 358 011c 114B     		ldr	r3, .L11+56
 359 011e 9847     		blx	r3
 360              	.LVL7:
 361              	.L8:
 526:common/rtos/tasks.c **** 			}
 527:common/rtos/tasks.c **** 		}
 528:common/rtos/tasks.c **** 	}
 529:common/rtos/tasks.c **** 
 530:common/rtos/tasks.c **** 	return xReturn;
 362              		.loc 1 530 9
 363 0120 FB69     		ldr	r3, [r7, #28]
 531:common/rtos/tasks.c **** }
 364              		.loc 1 531 1
 365 0122 1846     		mov	r0, r3
 366 0124 2437     		adds	r7, r7, #36
 367              	.LCFI3:
 368              		.cfi_def_cfa_offset 12
 369 0126 BD46     		mov	sp, r7
 370              	.LCFI4:
 371              		.cfi_def_cfa_register 13
 372              		@ sp needed
 373 0128 90BD     		pop	{r4, r7, pc}
 374              	.L12:
 375 012a 00BF     		.align	2
 376              	.L11:
 377 012c 00000000 		.word	prvAllocateTCBAndStack
 378 0130 00000000 		.word	prvInitialiseTCBVariables
 379 0134 00000000 		.word	pxPortInitialiseStack
 380 0138 00000000 		.word	vPortEnterCritical
 381 013c 00000000 		.word	uxCurrentNumberOfTasks
 382 0140 00000000 		.word	pxCurrentTCB
 383 0144 00000000 		.word	prvInitialiseTaskLists
 384 0148 00000000 		.word	xSchedulerRunning
 385 014c 00000000 		.word	uxTopUsedPriority
 386 0150 00000000 		.word	uxTaskNumber
 387 0154 00000000 		.word	uxTopReadyPriority
 388 0158 00000000 		.word	pxReadyTasksLists
 389 015c 00000000 		.word	vListInsertEnd
 390 0160 00000000 		.word	vPortExitCritical
 391 0164 00000000 		.word	vPortYieldFromISR
 392              		.cfi_endproc
 393              	.LFE30:
 395              		.section	.text.vTaskDelete,"ax",%progbits
 396              		.align	1
 397              		.global	vTaskDelete
 398              		.syntax unified
 399              		.thumb
 400              		.thumb_func
 402              	vTaskDelete:
 403              	.LFB31:
 532:common/rtos/tasks.c **** /*-----------------------------------------------------------*/
 533:common/rtos/tasks.c **** 
 534:common/rtos/tasks.c **** #if ( INCLUDE_vTaskDelete == 1 )
 535:common/rtos/tasks.c **** 
 536:common/rtos/tasks.c **** 	void vTaskDelete( xTaskHandle pxTaskToDelete )
 537:common/rtos/tasks.c **** 	{
 404              		.loc 1 537 2
 405              		.cfi_startproc
 406              		@ args = 0, pretend = 0, frame = 16
 407              		@ frame_needed = 1, uses_anonymous_args = 0
 408 0000 80B5     		push	{r7, lr}
 409              	.LCFI5:
 410              		.cfi_def_cfa_offset 8
 411              		.cfi_offset 7, -8
 412              		.cfi_offset 14, -4
 413 0002 84B0     		sub	sp, sp, #16
 414              	.LCFI6:
 415              		.cfi_def_cfa_offset 24
 416 0004 00AF     		add	r7, sp, #0
 417              	.LCFI7:
 418              		.cfi_def_cfa_register 7
 419 0006 7860     		str	r0, [r7, #4]
 538:common/rtos/tasks.c **** 	tskTCB *pxTCB;
 539:common/rtos/tasks.c **** 
 540:common/rtos/tasks.c **** 		portENTER_CRITICAL();
 420              		.loc 1 540 3
 421 0008 1E4B     		ldr	r3, .L20
 422 000a 9847     		blx	r3
 423              	.LVL8:
 541:common/rtos/tasks.c **** 		{
 542:common/rtos/tasks.c **** 			/* Ensure a yield is performed if the current task is being
 543:common/rtos/tasks.c **** 			deleted. */
 544:common/rtos/tasks.c **** 			if( pxTaskToDelete == pxCurrentTCB )
 424              		.loc 1 544 23
 425 000c 1E4B     		ldr	r3, .L20+4
 426 000e 1B68     		ldr	r3, [r3]
 427              		.loc 1 544 6
 428 0010 7A68     		ldr	r2, [r7, #4]
 429 0012 9A42     		cmp	r2, r3
 430 0014 01D1     		bne	.L14
 545:common/rtos/tasks.c **** 			{
 546:common/rtos/tasks.c **** 				pxTaskToDelete = NULL;
 431              		.loc 1 546 20
 432 0016 0023     		movs	r3, #0
 433 0018 7B60     		str	r3, [r7, #4]
 434              	.L14:
 547:common/rtos/tasks.c **** 			}
 548:common/rtos/tasks.c **** 
 549:common/rtos/tasks.c **** 			/* If null is passed in here then we are deleting ourselves. */
 550:common/rtos/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
 435              		.loc 1 550 12
 436 001a 7B68     		ldr	r3, [r7, #4]
 437 001c 002B     		cmp	r3, #0
 438 001e 02D1     		bne	.L15
 439              		.loc 1 550 12 is_stmt 0 discriminator 1
 440 0020 194B     		ldr	r3, .L20+4
 441 0022 1B68     		ldr	r3, [r3]
 442 0024 00E0     		b	.L16
 443              	.L15:
 444              		.loc 1 550 12 discriminator 2
 445 0026 7B68     		ldr	r3, [r7, #4]
 446              	.L16:
 447              		.loc 1 550 10 is_stmt 1 discriminator 4
 448 0028 FB60     		str	r3, [r7, #12]
 551:common/rtos/tasks.c **** 
 552:common/rtos/tasks.c **** 			/* Remove task from the ready list and place in the	termination list.
 553:common/rtos/tasks.c **** 			This will stop the task from be scheduled.  The idle task will check
 554:common/rtos/tasks.c **** 			the termination list and free up any memory allocated by the
 555:common/rtos/tasks.c **** 			scheduler for the TCB and stack. */
 556:common/rtos/tasks.c **** 			vListRemove( &( pxTCB->xGenericListItem ) );
 449              		.loc 1 556 4 discriminator 4
 450 002a FB68     		ldr	r3, [r7, #12]
 451 002c 0433     		adds	r3, r3, #4
 452 002e 1846     		mov	r0, r3
 453 0030 164B     		ldr	r3, .L20+8
 454 0032 9847     		blx	r3
 455              	.LVL9:
 557:common/rtos/tasks.c **** 
 558:common/rtos/tasks.c **** 			/* Is the task waiting on an event also? */
 559:common/rtos/tasks.c **** 			if( pxTCB->xEventListItem.pvContainer )
 456              		.loc 1 559 29 discriminator 4
 457 0034 FB68     		ldr	r3, [r7, #12]
 458 0036 9B6A     		ldr	r3, [r3, #40]
 459              		.loc 1 559 6 discriminator 4
 460 0038 002B     		cmp	r3, #0
 461 003a 04D0     		beq	.L17
 560:common/rtos/tasks.c **** 			{
 561:common/rtos/tasks.c **** 				vListRemove( &( pxTCB->xEventListItem ) );
 462              		.loc 1 561 5
 463 003c FB68     		ldr	r3, [r7, #12]
 464 003e 1833     		adds	r3, r3, #24
 465 0040 1846     		mov	r0, r3
 466 0042 124B     		ldr	r3, .L20+8
 467 0044 9847     		blx	r3
 468              	.LVL10:
 469              	.L17:
 562:common/rtos/tasks.c **** 			}
 563:common/rtos/tasks.c **** 
 564:common/rtos/tasks.c **** 			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
 470              		.loc 1 564 4
 471 0046 FB68     		ldr	r3, [r7, #12]
 472 0048 0433     		adds	r3, r3, #4
 473 004a 1946     		mov	r1, r3
 474 004c 1048     		ldr	r0, .L20+12
 475 004e 114B     		ldr	r3, .L20+16
 476 0050 9847     		blx	r3
 477              	.LVL11:
 565:common/rtos/tasks.c **** 
 566:common/rtos/tasks.c **** 			/* Increment the ucTasksDeleted variable so the idle task knows
 567:common/rtos/tasks.c **** 			there is a task that has been deleted and that it should therefore
 568:common/rtos/tasks.c **** 			check the xTasksWaitingTermination list. */
 569:common/rtos/tasks.c **** 			++uxTasksDeleted;
 478              		.loc 1 569 4
 479 0052 114B     		ldr	r3, .L20+20
 480 0054 1B68     		ldr	r3, [r3]
 481 0056 0133     		adds	r3, r3, #1
 482 0058 0F4A     		ldr	r2, .L20+20
 483 005a 1360     		str	r3, [r2]
 570:common/rtos/tasks.c **** 
 571:common/rtos/tasks.c **** 			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
 572:common/rtos/tasks.c **** 			can detect that the task lists need re-generating. */
 573:common/rtos/tasks.c **** 			uxTaskNumber++;
 484              		.loc 1 573 16
 485 005c 0F4B     		ldr	r3, .L20+24
 486 005e 1B68     		ldr	r3, [r3]
 487 0060 0133     		adds	r3, r3, #1
 488 0062 0E4A     		ldr	r2, .L20+24
 489 0064 1360     		str	r3, [r2]
 574:common/rtos/tasks.c **** 
 575:common/rtos/tasks.c **** 			traceTASK_DELETE( pxTCB );
 576:common/rtos/tasks.c **** 		}
 577:common/rtos/tasks.c **** 		portEXIT_CRITICAL();
 490              		.loc 1 577 3
 491 0066 0E4B     		ldr	r3, .L20+28
 492 0068 9847     		blx	r3
 493              	.LVL12:
 578:common/rtos/tasks.c **** 
 579:common/rtos/tasks.c **** 		/* Force a reschedule if we have just deleted the current task. */
 580:common/rtos/tasks.c **** 		if( xSchedulerRunning != pdFALSE )
 494              		.loc 1 580 25
 495 006a 0E4B     		ldr	r3, .L20+32
 496 006c 1B68     		ldr	r3, [r3]
 497              		.loc 1 580 5
 498 006e 002B     		cmp	r3, #0
 499 0070 04D0     		beq	.L19
 581:common/rtos/tasks.c **** 		{
 582:common/rtos/tasks.c **** 			if( ( void * ) pxTaskToDelete == NULL )
 500              		.loc 1 582 6
 501 0072 7B68     		ldr	r3, [r7, #4]
 502 0074 002B     		cmp	r3, #0
 503 0076 01D1     		bne	.L19
 583:common/rtos/tasks.c **** 			{
 584:common/rtos/tasks.c **** 				portYIELD_WITHIN_API();
 504              		.loc 1 584 5
 505 0078 0B4B     		ldr	r3, .L20+36
 506 007a 9847     		blx	r3
 507              	.LVL13:
 508              	.L19:
 585:common/rtos/tasks.c **** 			}
 586:common/rtos/tasks.c **** 		}
 587:common/rtos/tasks.c **** 	}
 509              		.loc 1 587 2
 510 007c 00BF     		nop
 511 007e 1037     		adds	r7, r7, #16
 512              	.LCFI8:
 513              		.cfi_def_cfa_offset 8
 514 0080 BD46     		mov	sp, r7
 515              	.LCFI9:
 516              		.cfi_def_cfa_register 13
 517              		@ sp needed
 518 0082 80BD     		pop	{r7, pc}
 519              	.L21:
 520              		.align	2
 521              	.L20:
 522 0084 00000000 		.word	vPortEnterCritical
 523 0088 00000000 		.word	pxCurrentTCB
 524 008c 00000000 		.word	vListRemove
 525 0090 00000000 		.word	xTasksWaitingTermination
 526 0094 00000000 		.word	vListInsertEnd
 527 0098 00000000 		.word	uxTasksDeleted
 528 009c 00000000 		.word	uxTaskNumber
 529 00a0 00000000 		.word	vPortExitCritical
 530 00a4 00000000 		.word	xSchedulerRunning
 531 00a8 00000000 		.word	vPortYieldFromISR
 532              		.cfi_endproc
 533              	.LFE31:
 535              		.section	.text.vTaskDelayUntil,"ax",%progbits
 536              		.align	1
 537              		.global	vTaskDelayUntil
 538              		.syntax unified
 539              		.thumb
 540              		.thumb_func
 542              	vTaskDelayUntil:
 543              	.LFB32:
 588:common/rtos/tasks.c **** 
 589:common/rtos/tasks.c **** #endif
 590:common/rtos/tasks.c **** 
 591:common/rtos/tasks.c **** 
 592:common/rtos/tasks.c **** 
 593:common/rtos/tasks.c **** 
 594:common/rtos/tasks.c **** 
 595:common/rtos/tasks.c **** 
 596:common/rtos/tasks.c **** /*-----------------------------------------------------------
 597:common/rtos/tasks.c ****  * TASK CONTROL API documented in task.h
 598:common/rtos/tasks.c ****  *----------------------------------------------------------*/
 599:common/rtos/tasks.c **** 
 600:common/rtos/tasks.c **** #if ( INCLUDE_vTaskDelayUntil == 1 )
 601:common/rtos/tasks.c **** 
 602:common/rtos/tasks.c **** 	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
 603:common/rtos/tasks.c **** 	{
 544              		.loc 1 603 2
 545              		.cfi_startproc
 546              		@ args = 0, pretend = 0, frame = 24
 547              		@ frame_needed = 1, uses_anonymous_args = 0
 548 0000 80B5     		push	{r7, lr}
 549              	.LCFI10:
 550              		.cfi_def_cfa_offset 8
 551              		.cfi_offset 7, -8
 552              		.cfi_offset 14, -4
 553 0002 86B0     		sub	sp, sp, #24
 554              	.LCFI11:
 555              		.cfi_def_cfa_offset 32
 556 0004 00AF     		add	r7, sp, #0
 557              	.LCFI12:
 558              		.cfi_def_cfa_register 7
 559 0006 7860     		str	r0, [r7, #4]
 560 0008 3960     		str	r1, [r7]
 604:common/rtos/tasks.c **** 	portTickType xTimeToWake;
 605:common/rtos/tasks.c **** 	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
 561              		.loc 1 605 33
 562 000a 0023     		movs	r3, #0
 563 000c 7B61     		str	r3, [r7, #20]
 606:common/rtos/tasks.c **** 
 607:common/rtos/tasks.c **** 		vTaskSuspendAll();
 564              		.loc 1 607 3
 565 000e 2D4B     		ldr	r3, .L30
 566 0010 9847     		blx	r3
 567              	.LVL14:
 608:common/rtos/tasks.c **** 		{
 609:common/rtos/tasks.c **** 			/* Generate the tick time at which the task wants to wake. */
 610:common/rtos/tasks.c **** 			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 568              		.loc 1 610 18
 569 0012 7B68     		ldr	r3, [r7, #4]
 570 0014 1B68     		ldr	r3, [r3]
 571              		.loc 1 610 16
 572 0016 3A68     		ldr	r2, [r7]
 573 0018 1344     		add	r3, r3, r2
 574 001a 3B61     		str	r3, [r7, #16]
 611:common/rtos/tasks.c **** 
 612:common/rtos/tasks.c **** 			if( xTickCount < *pxPreviousWakeTime )
 575              		.loc 1 612 21
 576 001c 7B68     		ldr	r3, [r7, #4]
 577 001e 1A68     		ldr	r2, [r3]
 578              		.loc 1 612 19
 579 0020 294B     		ldr	r3, .L30+4
 580 0022 1B68     		ldr	r3, [r3]
 581              		.loc 1 612 6
 582 0024 9A42     		cmp	r2, r3
 583 0026 0CD9     		bls	.L23
 613:common/rtos/tasks.c **** 			{
 614:common/rtos/tasks.c **** 				/* The tick count has overflowed since this function was
 615:common/rtos/tasks.c **** 				lasted called.  In this case the only time we should ever
 616:common/rtos/tasks.c **** 				actually delay is if the wake time has also	overflowed,
 617:common/rtos/tasks.c **** 				and the wake time is greater than the tick time.  When this
 618:common/rtos/tasks.c **** 				is the case it is as if neither time had overflowed. */
 619:common/rtos/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
 584              		.loc 1 619 25
 585 0028 7B68     		ldr	r3, [r7, #4]
 586 002a 1B68     		ldr	r3, [r3]
 587              		.loc 1 619 7
 588 002c 3A69     		ldr	r2, [r7, #16]
 589 002e 9A42     		cmp	r2, r3
 590 0030 13D2     		bcs	.L24
 591              		.loc 1 619 64 discriminator 1
 592 0032 254B     		ldr	r3, .L30+4
 593 0034 1B68     		ldr	r3, [r3]
 594              		.loc 1 619 47 discriminator 1
 595 0036 3A69     		ldr	r2, [r7, #16]
 596 0038 9A42     		cmp	r2, r3
 597 003a 0ED9     		bls	.L24
 620:common/rtos/tasks.c **** 				{
 621:common/rtos/tasks.c **** 					xShouldDelay = pdTRUE;
 598              		.loc 1 621 19
 599 003c 0123     		movs	r3, #1
 600 003e 7B61     		str	r3, [r7, #20]
 601 0040 0BE0     		b	.L24
 602              	.L23:
 622:common/rtos/tasks.c **** 				}
 623:common/rtos/tasks.c **** 			}
 624:common/rtos/tasks.c **** 			else
 625:common/rtos/tasks.c **** 			{
 626:common/rtos/tasks.c **** 				/* The tick time has not overflowed.  In this case we will
 627:common/rtos/tasks.c **** 				delay if either the wake time has overflowed, and/or the
 628:common/rtos/tasks.c **** 				tick time is less than the wake time. */
 629:common/rtos/tasks.c **** 				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
 603              		.loc 1 629 25
 604 0042 7B68     		ldr	r3, [r7, #4]
 605 0044 1B68     		ldr	r3, [r3]
 606              		.loc 1 629 7
 607 0046 3A69     		ldr	r2, [r7, #16]
 608 0048 9A42     		cmp	r2, r3
 609 004a 04D3     		bcc	.L25
 610              		.loc 1 629 64 discriminator 1
 611 004c 1E4B     		ldr	r3, .L30+4
 612 004e 1B68     		ldr	r3, [r3]
 613              		.loc 1 629 47 discriminator 1
 614 0050 3A69     		ldr	r2, [r7, #16]
 615 0052 9A42     		cmp	r2, r3
 616 0054 01D9     		bls	.L24
 617              	.L25:
 630:common/rtos/tasks.c **** 				{
 631:common/rtos/tasks.c **** 					xShouldDelay = pdTRUE;
 618              		.loc 1 631 19
 619 0056 0123     		movs	r3, #1
 620 0058 7B61     		str	r3, [r7, #20]
 621              	.L24:
 632:common/rtos/tasks.c **** 				}
 633:common/rtos/tasks.c **** 			}
 634:common/rtos/tasks.c **** 
 635:common/rtos/tasks.c **** 			/* Update the wake time ready for the next call. */
 636:common/rtos/tasks.c **** 			*pxPreviousWakeTime = xTimeToWake;
 622              		.loc 1 636 24
 623 005a 7B68     		ldr	r3, [r7, #4]
 624 005c 3A69     		ldr	r2, [r7, #16]
 625 005e 1A60     		str	r2, [r3]
 637:common/rtos/tasks.c **** 
 638:common/rtos/tasks.c **** 			if( xShouldDelay )
 626              		.loc 1 638 6
 627 0060 7B69     		ldr	r3, [r7, #20]
 628 0062 002B     		cmp	r3, #0
 629 0064 21D0     		beq	.L26
 639:common/rtos/tasks.c **** 			{
 640:common/rtos/tasks.c **** 				traceTASK_DELAY_UNTIL();
 641:common/rtos/tasks.c **** 
 642:common/rtos/tasks.c **** 				/* We must remove ourselves from the ready list before adding
 643:common/rtos/tasks.c **** 				ourselves to the blocked list as the same list item is used for
 644:common/rtos/tasks.c **** 				both lists. */
 645:common/rtos/tasks.c **** 				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 630              		.loc 1 645 49
 631 0066 194B     		ldr	r3, .L30+8
 632 0068 1B68     		ldr	r3, [r3]
 633              		.loc 1 645 5
 634 006a 0433     		adds	r3, r3, #4
 635 006c 1846     		mov	r0, r3
 636 006e 184B     		ldr	r3, .L30+12
 637 0070 9847     		blx	r3
 638              	.LVL15:
 646:common/rtos/tasks.c **** 
 647:common/rtos/tasks.c **** 				/* The list item will be inserted in wake time order. */
 648:common/rtos/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 639              		.loc 1 648 5
 640 0072 164B     		ldr	r3, .L30+8
 641 0074 1B68     		ldr	r3, [r3]
 642 0076 3A69     		ldr	r2, [r7, #16]
 643 0078 5A60     		str	r2, [r3, #4]
 649:common/rtos/tasks.c **** 
 650:common/rtos/tasks.c **** 				if( xTimeToWake < xTickCount )
 644              		.loc 1 650 21
 645 007a 134B     		ldr	r3, .L30+4
 646 007c 1B68     		ldr	r3, [r3]
 647              		.loc 1 650 7
 648 007e 3A69     		ldr	r2, [r7, #16]
 649 0080 9A42     		cmp	r2, r3
 650 0082 09D2     		bcs	.L27
 651:common/rtos/tasks.c **** 				{
 652:common/rtos/tasks.c **** 					/* Wake time has overflowed.  Place this item in the
 653:common/rtos/tasks.c **** 					overflow list. */
 654:common/rtos/tasks.c **** 					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericL
 651              		.loc 1 654 6
 652 0084 134B     		ldr	r3, .L30+16
 653 0086 1A68     		ldr	r2, [r3]
 654              		.loc 1 654 89
 655 0088 104B     		ldr	r3, .L30+8
 656 008a 1B68     		ldr	r3, [r3]
 657              		.loc 1 654 6
 658 008c 0433     		adds	r3, r3, #4
 659 008e 1946     		mov	r1, r3
 660 0090 1046     		mov	r0, r2
 661 0092 114B     		ldr	r3, .L30+20
 662 0094 9847     		blx	r3
 663              	.LVL16:
 664 0096 08E0     		b	.L26
 665              	.L27:
 655:common/rtos/tasks.c **** 				}
 656:common/rtos/tasks.c **** 				else
 657:common/rtos/tasks.c **** 				{
 658:common/rtos/tasks.c **** 					/* The wake time has not overflowed, so we can use the
 659:common/rtos/tasks.c **** 					current block list. */
 660:common/rtos/tasks.c **** 					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem 
 666              		.loc 1 660 6
 667 0098 104B     		ldr	r3, .L30+24
 668 009a 1A68     		ldr	r2, [r3]
 669              		.loc 1 660 81
 670 009c 0B4B     		ldr	r3, .L30+8
 671 009e 1B68     		ldr	r3, [r3]
 672              		.loc 1 660 6
 673 00a0 0433     		adds	r3, r3, #4
 674 00a2 1946     		mov	r1, r3
 675 00a4 1046     		mov	r0, r2
 676 00a6 0C4B     		ldr	r3, .L30+20
 677 00a8 9847     		blx	r3
 678              	.LVL17:
 679              	.L26:
 661:common/rtos/tasks.c **** 				}
 662:common/rtos/tasks.c **** 			}
 663:common/rtos/tasks.c **** 		}
 664:common/rtos/tasks.c **** 		xAlreadyYielded = xTaskResumeAll();
 680              		.loc 1 664 21
 681 00aa 0D4B     		ldr	r3, .L30+28
 682 00ac 9847     		blx	r3
 683              	.LVL18:
 684 00ae F860     		str	r0, [r7, #12]
 665:common/rtos/tasks.c **** 
 666:common/rtos/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 667:common/rtos/tasks.c **** 		have put ourselves to sleep. */
 668:common/rtos/tasks.c **** 		if( !xAlreadyYielded )
 685              		.loc 1 668 5
 686 00b0 FB68     		ldr	r3, [r7, #12]
 687 00b2 002B     		cmp	r3, #0
 688 00b4 01D1     		bne	.L29
 669:common/rtos/tasks.c **** 		{
 670:common/rtos/tasks.c **** 			portYIELD_WITHIN_API();
 689              		.loc 1 670 4
 690 00b6 0B4B     		ldr	r3, .L30+32
 691 00b8 9847     		blx	r3
 692              	.LVL19:
 693              	.L29:
 671:common/rtos/tasks.c **** 		}
 672:common/rtos/tasks.c **** 	}
 694              		.loc 1 672 2
 695 00ba 00BF     		nop
 696 00bc 1837     		adds	r7, r7, #24
 697              	.LCFI13:
 698              		.cfi_def_cfa_offset 8
 699 00be BD46     		mov	sp, r7
 700              	.LCFI14:
 701              		.cfi_def_cfa_register 13
 702              		@ sp needed
 703 00c0 80BD     		pop	{r7, pc}
 704              	.L31:
 705 00c2 00BF     		.align	2
 706              	.L30:
 707 00c4 00000000 		.word	vTaskSuspendAll
 708 00c8 00000000 		.word	xTickCount
 709 00cc 00000000 		.word	pxCurrentTCB
 710 00d0 00000000 		.word	vListRemove
 711 00d4 00000000 		.word	pxOverflowDelayedTaskList
 712 00d8 00000000 		.word	vListInsert
 713 00dc 00000000 		.word	pxDelayedTaskList
 714 00e0 00000000 		.word	xTaskResumeAll
 715 00e4 00000000 		.word	vPortYieldFromISR
 716              		.cfi_endproc
 717              	.LFE32:
 719              		.section	.text.vTaskDelay,"ax",%progbits
 720              		.align	1
 721              		.global	vTaskDelay
 722              		.syntax unified
 723              		.thumb
 724              		.thumb_func
 726              	vTaskDelay:
 727              	.LFB33:
 673:common/rtos/tasks.c **** 
 674:common/rtos/tasks.c **** #endif
 675:common/rtos/tasks.c **** /*-----------------------------------------------------------*/
 676:common/rtos/tasks.c **** 
 677:common/rtos/tasks.c **** #if ( INCLUDE_vTaskDelay == 1 )
 678:common/rtos/tasks.c **** 
 679:common/rtos/tasks.c **** 	void vTaskDelay( portTickType xTicksToDelay )
 680:common/rtos/tasks.c **** 	{
 728              		.loc 1 680 2
 729              		.cfi_startproc
 730              		@ args = 0, pretend = 0, frame = 16
 731              		@ frame_needed = 1, uses_anonymous_args = 0
 732 0000 80B5     		push	{r7, lr}
 733              	.LCFI15:
 734              		.cfi_def_cfa_offset 8
 735              		.cfi_offset 7, -8
 736              		.cfi_offset 14, -4
 737 0002 84B0     		sub	sp, sp, #16
 738              	.LCFI16:
 739              		.cfi_def_cfa_offset 24
 740 0004 00AF     		add	r7, sp, #0
 741              	.LCFI17:
 742              		.cfi_def_cfa_register 7
 743 0006 7860     		str	r0, [r7, #4]
 681:common/rtos/tasks.c **** 	portTickType xTimeToWake;
 682:common/rtos/tasks.c **** 	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 744              		.loc 1 682 23
 745 0008 0023     		movs	r3, #0
 746 000a FB60     		str	r3, [r7, #12]
 683:common/rtos/tasks.c **** 
 684:common/rtos/tasks.c **** 		/* A delay time of zero just forces a reschedule. */
 685:common/rtos/tasks.c **** 		if( xTicksToDelay > ( portTickType ) 0 )
 747              		.loc 1 685 5
 748 000c 7B68     		ldr	r3, [r7, #4]
 749 000e 002B     		cmp	r3, #0
 750 0010 2BD0     		beq	.L33
 686:common/rtos/tasks.c **** 		{
 687:common/rtos/tasks.c **** 			vTaskSuspendAll();
 751              		.loc 1 687 4
 752 0012 1A4B     		ldr	r3, .L38
 753 0014 9847     		blx	r3
 754              	.LVL20:
 688:common/rtos/tasks.c **** 			{
 689:common/rtos/tasks.c **** 				traceTASK_DELAY();
 690:common/rtos/tasks.c **** 
 691:common/rtos/tasks.c **** 				/* A task that is removed from the event list while the
 692:common/rtos/tasks.c **** 				scheduler is suspended will not get placed in the ready
 693:common/rtos/tasks.c **** 				list or removed from the blocked list until the scheduler
 694:common/rtos/tasks.c **** 				is resumed.
 695:common/rtos/tasks.c **** 
 696:common/rtos/tasks.c **** 				This task cannot be in an event list as it is the currently
 697:common/rtos/tasks.c **** 				executing task. */
 698:common/rtos/tasks.c **** 
 699:common/rtos/tasks.c **** 				/* Calculate the time to wake - this may overflow but this is
 700:common/rtos/tasks.c **** 				not a problem. */
 701:common/rtos/tasks.c **** 				xTimeToWake = xTickCount + xTicksToDelay;
 755              		.loc 1 701 30
 756 0016 1A4B     		ldr	r3, .L38+4
 757 0018 1B68     		ldr	r3, [r3]
 758              		.loc 1 701 17
 759 001a 7A68     		ldr	r2, [r7, #4]
 760 001c 1344     		add	r3, r3, r2
 761 001e BB60     		str	r3, [r7, #8]
 702:common/rtos/tasks.c **** 
 703:common/rtos/tasks.c **** 				/* We must remove ourselves from the ready list before adding
 704:common/rtos/tasks.c **** 				ourselves to the blocked list as the same list item is used for
 705:common/rtos/tasks.c **** 				both lists. */
 706:common/rtos/tasks.c **** 				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 762              		.loc 1 706 49
 763 0020 184B     		ldr	r3, .L38+8
 764 0022 1B68     		ldr	r3, [r3]
 765              		.loc 1 706 5
 766 0024 0433     		adds	r3, r3, #4
 767 0026 1846     		mov	r0, r3
 768 0028 174B     		ldr	r3, .L38+12
 769 002a 9847     		blx	r3
 770              	.LVL21:
 707:common/rtos/tasks.c **** 
 708:common/rtos/tasks.c **** 				/* The list item will be inserted in wake time order. */
 709:common/rtos/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 771              		.loc 1 709 5
 772 002c 154B     		ldr	r3, .L38+8
 773 002e 1B68     		ldr	r3, [r3]
 774 0030 BA68     		ldr	r2, [r7, #8]
 775 0032 5A60     		str	r2, [r3, #4]
 710:common/rtos/tasks.c **** 
 711:common/rtos/tasks.c **** 				if( xTimeToWake < xTickCount )
 776              		.loc 1 711 21
 777 0034 124B     		ldr	r3, .L38+4
 778 0036 1B68     		ldr	r3, [r3]
 779              		.loc 1 711 7
 780 0038 BA68     		ldr	r2, [r7, #8]
 781 003a 9A42     		cmp	r2, r3
 782 003c 09D2     		bcs	.L34
 712:common/rtos/tasks.c **** 				{
 713:common/rtos/tasks.c **** 					/* Wake time has overflowed.  Place this item in the
 714:common/rtos/tasks.c **** 					overflow list. */
 715:common/rtos/tasks.c **** 					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericL
 783              		.loc 1 715 6
 784 003e 134B     		ldr	r3, .L38+16
 785 0040 1A68     		ldr	r2, [r3]
 786              		.loc 1 715 89
 787 0042 104B     		ldr	r3, .L38+8
 788 0044 1B68     		ldr	r3, [r3]
 789              		.loc 1 715 6
 790 0046 0433     		adds	r3, r3, #4
 791 0048 1946     		mov	r1, r3
 792 004a 1046     		mov	r0, r2
 793 004c 104B     		ldr	r3, .L38+20
 794 004e 9847     		blx	r3
 795              	.LVL22:
 796 0050 08E0     		b	.L35
 797              	.L34:
 716:common/rtos/tasks.c **** 				}
 717:common/rtos/tasks.c **** 				else
 718:common/rtos/tasks.c **** 				{
 719:common/rtos/tasks.c **** 					/* The wake time has not overflowed, so we can use the
 720:common/rtos/tasks.c **** 					current block list. */
 721:common/rtos/tasks.c **** 					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem 
 798              		.loc 1 721 6
 799 0052 104B     		ldr	r3, .L38+24
 800 0054 1A68     		ldr	r2, [r3]
 801              		.loc 1 721 81
 802 0056 0B4B     		ldr	r3, .L38+8
 803 0058 1B68     		ldr	r3, [r3]
 804              		.loc 1 721 6
 805 005a 0433     		adds	r3, r3, #4
 806 005c 1946     		mov	r1, r3
 807 005e 1046     		mov	r0, r2
 808 0060 0B4B     		ldr	r3, .L38+20
 809 0062 9847     		blx	r3
 810              	.LVL23:
 811              	.L35:
 722:common/rtos/tasks.c **** 				}
 723:common/rtos/tasks.c **** 			}
 724:common/rtos/tasks.c **** 			xAlreadyYielded = xTaskResumeAll();
 812              		.loc 1 724 22
 813 0064 0C4B     		ldr	r3, .L38+28
 814 0066 9847     		blx	r3
 815              	.LVL24:
 816 0068 F860     		str	r0, [r7, #12]
 817              	.L33:
 725:common/rtos/tasks.c **** 		}
 726:common/rtos/tasks.c **** 
 727:common/rtos/tasks.c **** 		/* Force a reschedule if xTaskResumeAll has not already done so, we may
 728:common/rtos/tasks.c **** 		have put ourselves to sleep. */
 729:common/rtos/tasks.c **** 		if( !xAlreadyYielded )
 818              		.loc 1 729 5
 819 006a FB68     		ldr	r3, [r7, #12]
 820 006c 002B     		cmp	r3, #0
 821 006e 01D1     		bne	.L37
 730:common/rtos/tasks.c **** 		{
 731:common/rtos/tasks.c **** 			portYIELD_WITHIN_API();
 822              		.loc 1 731 4
 823 0070 0A4B     		ldr	r3, .L38+32
 824 0072 9847     		blx	r3
 825              	.LVL25:
 826              	.L37:
 732:common/rtos/tasks.c **** 		}
 733:common/rtos/tasks.c **** 	}
 827              		.loc 1 733 2
 828 0074 00BF     		nop
 829 0076 1037     		adds	r7, r7, #16
 830              	.LCFI18:
 831              		.cfi_def_cfa_offset 8
 832 0078 BD46     		mov	sp, r7
 833              	.LCFI19:
 834              		.cfi_def_cfa_register 13
 835              		@ sp needed
 836 007a 80BD     		pop	{r7, pc}
 837              	.L39:
 838              		.align	2
 839              	.L38:
 840 007c 00000000 		.word	vTaskSuspendAll
 841 0080 00000000 		.word	xTickCount
 842 0084 00000000 		.word	pxCurrentTCB
 843 0088 00000000 		.word	vListRemove
 844 008c 00000000 		.word	pxOverflowDelayedTaskList
 845 0090 00000000 		.word	vListInsert
 846 0094 00000000 		.word	pxDelayedTaskList
 847 0098 00000000 		.word	xTaskResumeAll
 848 009c 00000000 		.word	vPortYieldFromISR
 849              		.cfi_endproc
 850              	.LFE33:
 852              		.section	.text.uxTaskPriorityGet,"ax",%progbits
 853              		.align	1
 854              		.global	uxTaskPriorityGet
 855              		.syntax unified
 856              		.thumb
 857              		.thumb_func
 859              	uxTaskPriorityGet:
 860              	.LFB34:
 734:common/rtos/tasks.c **** 
 735:common/rtos/tasks.c **** #endif
 736:common/rtos/tasks.c **** /*-----------------------------------------------------------*/
 737:common/rtos/tasks.c **** 
 738:common/rtos/tasks.c **** #if ( INCLUDE_uxTaskPriorityGet == 1 )
 739:common/rtos/tasks.c **** 
 740:common/rtos/tasks.c **** 	unsigned portBASE_TYPE uxTaskPriorityGet( xTaskHandle pxTask )
 741:common/rtos/tasks.c **** 	{
 861              		.loc 1 741 2
 862              		.cfi_startproc
 863              		@ args = 0, pretend = 0, frame = 16
 864              		@ frame_needed = 1, uses_anonymous_args = 0
 865 0000 80B5     		push	{r7, lr}
 866              	.LCFI20:
 867              		.cfi_def_cfa_offset 8
 868              		.cfi_offset 7, -8
 869              		.cfi_offset 14, -4
 870 0002 84B0     		sub	sp, sp, #16
 871              	.LCFI21:
 872              		.cfi_def_cfa_offset 24
 873 0004 00AF     		add	r7, sp, #0
 874              	.LCFI22:
 875              		.cfi_def_cfa_register 7
 876 0006 7860     		str	r0, [r7, #4]
 742:common/rtos/tasks.c **** 	tskTCB *pxTCB;
 743:common/rtos/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
 744:common/rtos/tasks.c **** 
 745:common/rtos/tasks.c **** 		portENTER_CRITICAL();
 877              		.loc 1 745 3
 878 0008 094B     		ldr	r3, .L44
 879 000a 9847     		blx	r3
 880              	.LVL26:
 746:common/rtos/tasks.c **** 		{
 747:common/rtos/tasks.c **** 			/* If null is passed in here then we are changing the
 748:common/rtos/tasks.c **** 			priority of the calling function. */
 749:common/rtos/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 881              		.loc 1 749 12
 882 000c 7B68     		ldr	r3, [r7, #4]
 883 000e 002B     		cmp	r3, #0
 884 0010 02D1     		bne	.L41
 885              		.loc 1 749 12 is_stmt 0 discriminator 1
 886 0012 084B     		ldr	r3, .L44+4
 887 0014 1B68     		ldr	r3, [r3]
 888 0016 00E0     		b	.L42
 889              	.L41:
 890              		.loc 1 749 12 discriminator 2
 891 0018 7B68     		ldr	r3, [r7, #4]
 892              	.L42:
 893              		.loc 1 749 10 is_stmt 1 discriminator 4
 894 001a FB60     		str	r3, [r7, #12]
 750:common/rtos/tasks.c **** 			uxReturn = pxTCB->uxPriority;
 895              		.loc 1 750 13 discriminator 4
 896 001c FB68     		ldr	r3, [r7, #12]
 897 001e DB6A     		ldr	r3, [r3, #44]
 898 0020 BB60     		str	r3, [r7, #8]
 751:common/rtos/tasks.c **** 		}
 752:common/rtos/tasks.c **** 		portEXIT_CRITICAL();
 899              		.loc 1 752 3 discriminator 4
 900 0022 054B     		ldr	r3, .L44+8
 901 0024 9847     		blx	r3
 902              	.LVL27:
 753:common/rtos/tasks.c **** 
 754:common/rtos/tasks.c **** 		return uxReturn;
 903              		.loc 1 754 10 discriminator 4
 904 0026 BB68     		ldr	r3, [r7, #8]
 755:common/rtos/tasks.c **** 	}
 905              		.loc 1 755 2 discriminator 4
 906 0028 1846     		mov	r0, r3
 907 002a 1037     		adds	r7, r7, #16
 908              	.LCFI23:
 909              		.cfi_def_cfa_offset 8
 910 002c BD46     		mov	sp, r7
 911              	.LCFI24:
 912              		.cfi_def_cfa_register 13
 913              		@ sp needed
 914 002e 80BD     		pop	{r7, pc}
 915              	.L45:
 916              		.align	2
 917              	.L44:
 918 0030 00000000 		.word	vPortEnterCritical
 919 0034 00000000 		.word	pxCurrentTCB
 920 0038 00000000 		.word	vPortExitCritical
 921              		.cfi_endproc
 922              	.LFE34:
 924              		.section	.text.vTaskPrioritySet,"ax",%progbits
 925              		.align	1
 926              		.global	vTaskPrioritySet
 927              		.syntax unified
 928              		.thumb
 929              		.thumb_func
 931              	vTaskPrioritySet:
 932              	.LFB35:
 756:common/rtos/tasks.c **** 
 757:common/rtos/tasks.c **** #endif
 758:common/rtos/tasks.c **** /*-----------------------------------------------------------*/
 759:common/rtos/tasks.c **** 
 760:common/rtos/tasks.c **** #if ( INCLUDE_vTaskPrioritySet == 1 )
 761:common/rtos/tasks.c **** 
 762:common/rtos/tasks.c **** 	void vTaskPrioritySet( xTaskHandle pxTask, unsigned portBASE_TYPE uxNewPriority )
 763:common/rtos/tasks.c **** 	{
 933              		.loc 1 763 2
 934              		.cfi_startproc
 935              		@ args = 0, pretend = 0, frame = 24
 936              		@ frame_needed = 1, uses_anonymous_args = 0
 937 0000 80B5     		push	{r7, lr}
 938              	.LCFI25:
 939              		.cfi_def_cfa_offset 8
 940              		.cfi_offset 7, -8
 941              		.cfi_offset 14, -4
 942 0002 86B0     		sub	sp, sp, #24
 943              	.LCFI26:
 944              		.cfi_def_cfa_offset 32
 945 0004 00AF     		add	r7, sp, #0
 946              	.LCFI27:
 947              		.cfi_def_cfa_register 7
 948 0006 7860     		str	r0, [r7, #4]
 949 0008 3960     		str	r1, [r7]
 764:common/rtos/tasks.c **** 	tskTCB *pxTCB;
 765:common/rtos/tasks.c **** 	unsigned portBASE_TYPE uxCurrentPriority, xYieldRequired = pdFALSE;
 950              		.loc 1 765 44
 951 000a 0023     		movs	r3, #0
 952 000c 7B61     		str	r3, [r7, #20]
 766:common/rtos/tasks.c **** 
 767:common/rtos/tasks.c **** 		/* Ensure the new priority is valid. */
 768:common/rtos/tasks.c **** 		if( uxNewPriority >= configMAX_PRIORITIES )
 953              		.loc 1 768 5
 954 000e 3B68     		ldr	r3, [r7]
 955 0010 092B     		cmp	r3, #9
 956 0012 01D9     		bls	.L47
 769:common/rtos/tasks.c **** 		{
 770:common/rtos/tasks.c **** 			uxNewPriority = configMAX_PRIORITIES - 1;
 957              		.loc 1 770 18
 958 0014 0923     		movs	r3, #9
 959 0016 3B60     		str	r3, [r7]
 960              	.L47:
 771:common/rtos/tasks.c **** 		}
 772:common/rtos/tasks.c **** 
 773:common/rtos/tasks.c **** 		portENTER_CRITICAL();
 961              		.loc 1 773 3
 962 0018 354B     		ldr	r3, .L57
 963 001a 9847     		blx	r3
 964              	.LVL28:
 774:common/rtos/tasks.c **** 		{
 775:common/rtos/tasks.c **** 			if( pxTask == pxCurrentTCB )
 965              		.loc 1 775 15
 966 001c 354B     		ldr	r3, .L57+4
 967 001e 1B68     		ldr	r3, [r3]
 968              		.loc 1 775 6
 969 0020 7A68     		ldr	r2, [r7, #4]
 970 0022 9A42     		cmp	r2, r3
 971 0024 01D1     		bne	.L48
 776:common/rtos/tasks.c **** 			{
 777:common/rtos/tasks.c **** 				pxTask = NULL;
 972              		.loc 1 777 12
 973 0026 0023     		movs	r3, #0
 974 0028 7B60     		str	r3, [r7, #4]
 975              	.L48:
 778:common/rtos/tasks.c **** 			}
 779:common/rtos/tasks.c **** 
 780:common/rtos/tasks.c **** 			/* If null is passed in here then we are changing the
 781:common/rtos/tasks.c **** 			priority of the calling function. */
 782:common/rtos/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTask );
 976              		.loc 1 782 12
 977 002a 7B68     		ldr	r3, [r7, #4]
 978 002c 002B     		cmp	r3, #0
 979 002e 02D1     		bne	.L49
 980              		.loc 1 782 12 is_stmt 0 discriminator 1
 981 0030 304B     		ldr	r3, .L57+4
 982 0032 1B68     		ldr	r3, [r3]
 983 0034 00E0     		b	.L50
 984              	.L49:
 985              		.loc 1 782 12 discriminator 2
 986 0036 7B68     		ldr	r3, [r7, #4]
 987              	.L50:
 988              		.loc 1 782 10 is_stmt 1 discriminator 4
 989 0038 3B61     		str	r3, [r7, #16]
 783:common/rtos/tasks.c **** 
 784:common/rtos/tasks.c **** 			traceTASK_PRIORITY_SET( pxTask, uxNewPriority );
 785:common/rtos/tasks.c **** 
 786:common/rtos/tasks.c **** 			#if ( configUSE_MUTEXES == 1 )
 787:common/rtos/tasks.c **** 			{
 788:common/rtos/tasks.c **** 				uxCurrentPriority = pxTCB->uxBasePriority;
 990              		.loc 1 788 23 discriminator 4
 991 003a 3B69     		ldr	r3, [r7, #16]
 992 003c 5B6C     		ldr	r3, [r3, #68]
 993 003e FB60     		str	r3, [r7, #12]
 789:common/rtos/tasks.c **** 			}
 790:common/rtos/tasks.c **** 			#else
 791:common/rtos/tasks.c **** 			{
 792:common/rtos/tasks.c **** 				uxCurrentPriority = pxTCB->uxPriority;
 793:common/rtos/tasks.c **** 			}
 794:common/rtos/tasks.c **** 			#endif
 795:common/rtos/tasks.c **** 
 796:common/rtos/tasks.c **** 			if( uxCurrentPriority != uxNewPriority )
 994              		.loc 1 796 6 discriminator 4
 995 0040 FA68     		ldr	r2, [r7, #12]
 996 0042 3B68     		ldr	r3, [r7]
 997 0044 9A42     		cmp	r2, r3
 998 0046 4CD0     		beq	.L51
 797:common/rtos/tasks.c **** 			{
 798:common/rtos/tasks.c **** 				/* The priority change may have readied a task of higher
 799:common/rtos/tasks.c **** 				priority than the calling task. */
 800:common/rtos/tasks.c **** 				if( uxNewPriority > uxCurrentPriority )
 999              		.loc 1 800 7
 1000 0048 3A68     		ldr	r2, [r7]
 1001 004a FB68     		ldr	r3, [r7, #12]
 1002 004c 9A42     		cmp	r2, r3
 1003 004e 05D9     		bls	.L52
 801:common/rtos/tasks.c **** 				{
 802:common/rtos/tasks.c **** 					if( pxTask != NULL )
 1004              		.loc 1 802 8
 1005 0050 7B68     		ldr	r3, [r7, #4]
 1006 0052 002B     		cmp	r3, #0
 1007 0054 07D0     		beq	.L53
 803:common/rtos/tasks.c **** 					{
 804:common/rtos/tasks.c **** 						/* The priority of another task is being raised.  If we
 805:common/rtos/tasks.c **** 						were raising the priority of the currently running task
 806:common/rtos/tasks.c **** 						there would be no need to switch as it must have already
 807:common/rtos/tasks.c **** 						been the highest priority task. */
 808:common/rtos/tasks.c **** 						xYieldRequired = pdTRUE;
 1008              		.loc 1 808 22
 1009 0056 0123     		movs	r3, #1
 1010 0058 7B61     		str	r3, [r7, #20]
 1011 005a 04E0     		b	.L53
 1012              	.L52:
 809:common/rtos/tasks.c **** 					}
 810:common/rtos/tasks.c **** 				}
 811:common/rtos/tasks.c **** 				else if( pxTask == NULL )
 1013              		.loc 1 811 12
 1014 005c 7B68     		ldr	r3, [r7, #4]
 1015 005e 002B     		cmp	r3, #0
 1016 0060 01D1     		bne	.L53
 812:common/rtos/tasks.c **** 				{
 813:common/rtos/tasks.c **** 					/* Setting our own priority down means there may now be another
 814:common/rtos/tasks.c **** 					task of higher priority that is ready to execute. */
 815:common/rtos/tasks.c **** 					xYieldRequired = pdTRUE;
 1017              		.loc 1 815 21
 1018 0062 0123     		movs	r3, #1
 1019 0064 7B61     		str	r3, [r7, #20]
 1020              	.L53:
 816:common/rtos/tasks.c **** 				}
 817:common/rtos/tasks.c **** 
 818:common/rtos/tasks.c **** 
 819:common/rtos/tasks.c **** 
 820:common/rtos/tasks.c **** 				#if ( configUSE_MUTEXES == 1 )
 821:common/rtos/tasks.c **** 				{
 822:common/rtos/tasks.c **** 					/* Only change the priority being used if the task is not
 823:common/rtos/tasks.c **** 					currently using an inherited priority. */
 824:common/rtos/tasks.c **** 					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
 1021              		.loc 1 824 15
 1022 0066 3B69     		ldr	r3, [r7, #16]
 1023 0068 5A6C     		ldr	r2, [r3, #68]
 1024              		.loc 1 824 40
 1025 006a 3B69     		ldr	r3, [r7, #16]
 1026 006c DB6A     		ldr	r3, [r3, #44]
 1027              		.loc 1 824 8
 1028 006e 9A42     		cmp	r2, r3
 1029 0070 02D1     		bne	.L54
 825:common/rtos/tasks.c **** 					{
 826:common/rtos/tasks.c **** 						pxTCB->uxPriority = uxNewPriority;
 1030              		.loc 1 826 25
 1031 0072 3B69     		ldr	r3, [r7, #16]
 1032 0074 3A68     		ldr	r2, [r7]
 1033 0076 DA62     		str	r2, [r3, #44]
 1034              	.L54:
 827:common/rtos/tasks.c **** 					}
 828:common/rtos/tasks.c **** 
 829:common/rtos/tasks.c **** 					/* The base priority gets set whatever. */
 830:common/rtos/tasks.c **** 					pxTCB->uxBasePriority = uxNewPriority;
 1035              		.loc 1 830 28
 1036 0078 3B69     		ldr	r3, [r7, #16]
 1037 007a 3A68     		ldr	r2, [r7]
 1038 007c 5A64     		str	r2, [r3, #68]
 831:common/rtos/tasks.c **** 				}
 832:common/rtos/tasks.c **** 				#else
 833:common/rtos/tasks.c **** 				{
 834:common/rtos/tasks.c **** 					pxTCB->uxPriority = uxNewPriority;
 835:common/rtos/tasks.c **** 				}
 836:common/rtos/tasks.c **** 				#endif
 837:common/rtos/tasks.c **** 
 838:common/rtos/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) 
 1039              		.loc 1 838 5
 1040 007e 3B68     		ldr	r3, [r7]
 1041 0080 C3F10A02 		rsb	r2, r3, #10
 1042 0084 3B69     		ldr	r3, [r7, #16]
 1043 0086 9A61     		str	r2, [r3, #24]
 839:common/rtos/tasks.c **** 
 840:common/rtos/tasks.c **** 				/* If the task is in the blocked or suspended list we need do
 841:common/rtos/tasks.c **** 				nothing more than change it's priority variable. However, if
 842:common/rtos/tasks.c **** 				the task is in a ready list it needs to be removed and placed
 843:common/rtos/tasks.c **** 				in the queue appropriate to its new priority. */
 844:common/rtos/tasks.c **** 				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericLis
 1044              		.loc 1 844 9
 1045 0088 3B69     		ldr	r3, [r7, #16]
 1046 008a 5969     		ldr	r1, [r3, #20]
 1047 008c FA68     		ldr	r2, [r7, #12]
 1048 008e 1346     		mov	r3, r2
 1049 0090 9B00     		lsls	r3, r3, #2
 1050 0092 1344     		add	r3, r3, r2
 1051 0094 9B00     		lsls	r3, r3, #2
 1052 0096 184A     		ldr	r2, .L57+8
 1053 0098 1344     		add	r3, r3, r2
 1054              		.loc 1 844 7
 1055 009a 9942     		cmp	r1, r3
 1056 009c 1CD1     		bne	.L55
 845:common/rtos/tasks.c **** 				{
 846:common/rtos/tasks.c **** 					/* The task is currently in its ready list - remove before adding
 847:common/rtos/tasks.c **** 					it to it's new ready list.  As we are in a critical section we
 848:common/rtos/tasks.c **** 					can do this even if the scheduler is suspended. */
 849:common/rtos/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 1057              		.loc 1 849 6
 1058 009e 3B69     		ldr	r3, [r7, #16]
 1059 00a0 0433     		adds	r3, r3, #4
 1060 00a2 1846     		mov	r0, r3
 1061 00a4 154B     		ldr	r3, .L57+12
 1062 00a6 9847     		blx	r3
 1063              	.LVL29:
 850:common/rtos/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1064              		.loc 1 850 6
 1065 00a8 3B69     		ldr	r3, [r7, #16]
 1066 00aa DA6A     		ldr	r2, [r3, #44]
 1067 00ac 144B     		ldr	r3, .L57+16
 1068 00ae 1B68     		ldr	r3, [r3]
 1069 00b0 9A42     		cmp	r2, r3
 1070 00b2 03D9     		bls	.L56
 1071              		.loc 1 850 6 is_stmt 0 discriminator 1
 1072 00b4 3B69     		ldr	r3, [r7, #16]
 1073 00b6 DB6A     		ldr	r3, [r3, #44]
 1074 00b8 114A     		ldr	r2, .L57+16
 1075 00ba 1360     		str	r3, [r2]
 1076              	.L56:
 1077              		.loc 1 850 6 discriminator 3
 1078 00bc 3B69     		ldr	r3, [r7, #16]
 1079 00be DA6A     		ldr	r2, [r3, #44]
 1080 00c0 1346     		mov	r3, r2
 1081 00c2 9B00     		lsls	r3, r3, #2
 1082 00c4 1344     		add	r3, r3, r2
 1083 00c6 9B00     		lsls	r3, r3, #2
 1084 00c8 0B4A     		ldr	r2, .L57+8
 1085 00ca 1A44     		add	r2, r2, r3
 1086 00cc 3B69     		ldr	r3, [r7, #16]
 1087 00ce 0433     		adds	r3, r3, #4
 1088 00d0 1946     		mov	r1, r3
 1089 00d2 1046     		mov	r0, r2
 1090 00d4 0B4B     		ldr	r3, .L57+20
 1091 00d6 9847     		blx	r3
 1092              	.LVL30:
 1093              	.L55:
 851:common/rtos/tasks.c **** 				}
 852:common/rtos/tasks.c **** 
 853:common/rtos/tasks.c **** 				if( xYieldRequired == pdTRUE )
 1094              		.loc 1 853 7 is_stmt 1
 1095 00d8 7B69     		ldr	r3, [r7, #20]
 1096 00da 012B     		cmp	r3, #1
 1097 00dc 01D1     		bne	.L51
 854:common/rtos/tasks.c **** 				{
 855:common/rtos/tasks.c **** 					portYIELD_WITHIN_API();
 1098              		.loc 1 855 6
 1099 00de 0A4B     		ldr	r3, .L57+24
 1100 00e0 9847     		blx	r3
 1101              	.LVL31:
 1102              	.L51:
 856:common/rtos/tasks.c **** 				}
 857:common/rtos/tasks.c **** 			}
 858:common/rtos/tasks.c **** 		}
 859:common/rtos/tasks.c **** 		portEXIT_CRITICAL();
 1103              		.loc 1 859 3
 1104 00e2 0A4B     		ldr	r3, .L57+28
 1105 00e4 9847     		blx	r3
 1106              	.LVL32:
 860:common/rtos/tasks.c **** 	}
 1107              		.loc 1 860 2
 1108 00e6 00BF     		nop
 1109 00e8 1837     		adds	r7, r7, #24
 1110              	.LCFI28:
 1111              		.cfi_def_cfa_offset 8
 1112 00ea BD46     		mov	sp, r7
 1113              	.LCFI29:
 1114              		.cfi_def_cfa_register 13
 1115              		@ sp needed
 1116 00ec 80BD     		pop	{r7, pc}
 1117              	.L58:
 1118 00ee 00BF     		.align	2
 1119              	.L57:
 1120 00f0 00000000 		.word	vPortEnterCritical
 1121 00f4 00000000 		.word	pxCurrentTCB
 1122 00f8 00000000 		.word	pxReadyTasksLists
 1123 00fc 00000000 		.word	vListRemove
 1124 0100 00000000 		.word	uxTopReadyPriority
 1125 0104 00000000 		.word	vListInsertEnd
 1126 0108 00000000 		.word	vPortYieldFromISR
 1127 010c 00000000 		.word	vPortExitCritical
 1128              		.cfi_endproc
 1129              	.LFE35:
 1131              		.section	.text.vTaskSuspend,"ax",%progbits
 1132              		.align	1
 1133              		.global	vTaskSuspend
 1134              		.syntax unified
 1135              		.thumb
 1136              		.thumb_func
 1138              	vTaskSuspend:
 1139              	.LFB36:
 861:common/rtos/tasks.c **** 
 862:common/rtos/tasks.c **** #endif
 863:common/rtos/tasks.c **** /*-----------------------------------------------------------*/
 864:common/rtos/tasks.c **** 
 865:common/rtos/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 866:common/rtos/tasks.c **** 
 867:common/rtos/tasks.c **** 	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
 868:common/rtos/tasks.c **** 	{
 1140              		.loc 1 868 2
 1141              		.cfi_startproc
 1142              		@ args = 0, pretend = 0, frame = 16
 1143              		@ frame_needed = 1, uses_anonymous_args = 0
 1144 0000 80B5     		push	{r7, lr}
 1145              	.LCFI30:
 1146              		.cfi_def_cfa_offset 8
 1147              		.cfi_offset 7, -8
 1148              		.cfi_offset 14, -4
 1149 0002 84B0     		sub	sp, sp, #16
 1150              	.LCFI31:
 1151              		.cfi_def_cfa_offset 24
 1152 0004 00AF     		add	r7, sp, #0
 1153              	.LCFI32:
 1154              		.cfi_def_cfa_register 7
 1155 0006 7860     		str	r0, [r7, #4]
 869:common/rtos/tasks.c **** 	tskTCB *pxTCB;
 870:common/rtos/tasks.c **** 
 871:common/rtos/tasks.c **** 		portENTER_CRITICAL();
 1156              		.loc 1 871 3
 1157 0008 174B     		ldr	r3, .L66
 1158 000a 9847     		blx	r3
 1159              	.LVL33:
 872:common/rtos/tasks.c **** 		{
 873:common/rtos/tasks.c **** 			/* Ensure a yield is performed if the current task is being
 874:common/rtos/tasks.c **** 			suspended. */
 875:common/rtos/tasks.c **** 			if( pxTaskToSuspend == pxCurrentTCB )
 1160              		.loc 1 875 24
 1161 000c 174B     		ldr	r3, .L66+4
 1162 000e 1B68     		ldr	r3, [r3]
 1163              		.loc 1 875 6
 1164 0010 7A68     		ldr	r2, [r7, #4]
 1165 0012 9A42     		cmp	r2, r3
 1166 0014 01D1     		bne	.L60
 876:common/rtos/tasks.c **** 			{
 877:common/rtos/tasks.c **** 				pxTaskToSuspend = NULL;
 1167              		.loc 1 877 21
 1168 0016 0023     		movs	r3, #0
 1169 0018 7B60     		str	r3, [r7, #4]
 1170              	.L60:
 878:common/rtos/tasks.c **** 			}
 879:common/rtos/tasks.c **** 
 880:common/rtos/tasks.c **** 			/* If null is passed in here then we are suspending ourselves. */
 881:common/rtos/tasks.c **** 			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
 1171              		.loc 1 881 12
 1172 001a 7B68     		ldr	r3, [r7, #4]
 1173 001c 002B     		cmp	r3, #0
 1174 001e 02D1     		bne	.L61
 1175              		.loc 1 881 12 is_stmt 0 discriminator 1
 1176 0020 124B     		ldr	r3, .L66+4
 1177 0022 1B68     		ldr	r3, [r3]
 1178 0024 00E0     		b	.L62
 1179              	.L61:
 1180              		.loc 1 881 12 discriminator 2
 1181 0026 7B68     		ldr	r3, [r7, #4]
 1182              	.L62:
 1183              		.loc 1 881 10 is_stmt 1 discriminator 4
 1184 0028 FB60     		str	r3, [r7, #12]
 882:common/rtos/tasks.c **** 
 883:common/rtos/tasks.c **** 			traceTASK_SUSPEND( pxTCB );
 884:common/rtos/tasks.c **** 
 885:common/rtos/tasks.c **** 			/* Remove task from the ready/delayed list and place in the	suspended list. */
 886:common/rtos/tasks.c **** 			vListRemove( &( pxTCB->xGenericListItem ) );
 1185              		.loc 1 886 4 discriminator 4
 1186 002a FB68     		ldr	r3, [r7, #12]
 1187 002c 0433     		adds	r3, r3, #4
 1188 002e 1846     		mov	r0, r3
 1189 0030 0F4B     		ldr	r3, .L66+8
 1190 0032 9847     		blx	r3
 1191              	.LVL34:
 887:common/rtos/tasks.c **** 
 888:common/rtos/tasks.c **** 			/* Is the task waiting on an event also? */
 889:common/rtos/tasks.c **** 			if( pxTCB->xEventListItem.pvContainer )
 1192              		.loc 1 889 29 discriminator 4
 1193 0034 FB68     		ldr	r3, [r7, #12]
 1194 0036 9B6A     		ldr	r3, [r3, #40]
 1195              		.loc 1 889 6 discriminator 4
 1196 0038 002B     		cmp	r3, #0
 1197 003a 04D0     		beq	.L63
 890:common/rtos/tasks.c **** 			{
 891:common/rtos/tasks.c **** 				vListRemove( &( pxTCB->xEventListItem ) );
 1198              		.loc 1 891 5
 1199 003c FB68     		ldr	r3, [r7, #12]
 1200 003e 1833     		adds	r3, r3, #24
 1201 0040 1846     		mov	r0, r3
 1202 0042 0B4B     		ldr	r3, .L66+8
 1203 0044 9847     		blx	r3
 1204              	.LVL35:
 1205              	.L63:
 892:common/rtos/tasks.c **** 			}
 893:common/rtos/tasks.c **** 
 894:common/rtos/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
 1206              		.loc 1 894 4
 1207 0046 FB68     		ldr	r3, [r7, #12]
 1208 0048 0433     		adds	r3, r3, #4
 1209 004a 1946     		mov	r1, r3
 1210 004c 0948     		ldr	r0, .L66+12
 1211 004e 0A4B     		ldr	r3, .L66+16
 1212 0050 9847     		blx	r3
 1213              	.LVL36:
 895:common/rtos/tasks.c **** 		}
 896:common/rtos/tasks.c **** 		portEXIT_CRITICAL();
 1214              		.loc 1 896 3
 1215 0052 0A4B     		ldr	r3, .L66+20
 1216 0054 9847     		blx	r3
 1217              	.LVL37:
 897:common/rtos/tasks.c **** 
 898:common/rtos/tasks.c **** 		/* We may have just suspended the current task. */
 899:common/rtos/tasks.c **** 		if( ( void * ) pxTaskToSuspend == NULL )
 1218              		.loc 1 899 5
 1219 0056 7B68     		ldr	r3, [r7, #4]
 1220 0058 002B     		cmp	r3, #0
 1221 005a 01D1     		bne	.L65
 900:common/rtos/tasks.c **** 		{
 901:common/rtos/tasks.c **** 			portYIELD_WITHIN_API();
 1222              		.loc 1 901 4
 1223 005c 084B     		ldr	r3, .L66+24
 1224 005e 9847     		blx	r3
 1225              	.LVL38:
 1226              	.L65:
 902:common/rtos/tasks.c **** 		}
 903:common/rtos/tasks.c **** 	}
 1227              		.loc 1 903 2
 1228 0060 00BF     		nop
 1229 0062 1037     		adds	r7, r7, #16
 1230              	.LCFI33:
 1231              		.cfi_def_cfa_offset 8
 1232 0064 BD46     		mov	sp, r7
 1233              	.LCFI34:
 1234              		.cfi_def_cfa_register 13
 1235              		@ sp needed
 1236 0066 80BD     		pop	{r7, pc}
 1237              	.L67:
 1238              		.align	2
 1239              	.L66:
 1240 0068 00000000 		.word	vPortEnterCritical
 1241 006c 00000000 		.word	pxCurrentTCB
 1242 0070 00000000 		.word	vListRemove
 1243 0074 00000000 		.word	xSuspendedTaskList
 1244 0078 00000000 		.word	vListInsertEnd
 1245 007c 00000000 		.word	vPortExitCritical
 1246 0080 00000000 		.word	vPortYieldFromISR
 1247              		.cfi_endproc
 1248              	.LFE36:
 1250              		.section	.text.xTaskIsTaskSuspended,"ax",%progbits
 1251              		.align	1
 1252              		.global	xTaskIsTaskSuspended
 1253              		.syntax unified
 1254              		.thumb
 1255              		.thumb_func
 1257              	xTaskIsTaskSuspended:
 1258              	.LFB37:
 904:common/rtos/tasks.c **** 
 905:common/rtos/tasks.c **** #endif
 906:common/rtos/tasks.c **** /*-----------------------------------------------------------*/
 907:common/rtos/tasks.c **** 
 908:common/rtos/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 909:common/rtos/tasks.c **** 
 910:common/rtos/tasks.c **** 	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
 911:common/rtos/tasks.c **** 	{
 1259              		.loc 1 911 2
 1260              		.cfi_startproc
 1261              		@ args = 0, pretend = 0, frame = 16
 1262              		@ frame_needed = 1, uses_anonymous_args = 0
 1263              		@ link register save eliminated.
 1264 0000 80B4     		push	{r7}
 1265              	.LCFI35:
 1266              		.cfi_def_cfa_offset 4
 1267              		.cfi_offset 7, -4
 1268 0002 85B0     		sub	sp, sp, #20
 1269              	.LCFI36:
 1270              		.cfi_def_cfa_offset 24
 1271 0004 00AF     		add	r7, sp, #0
 1272              	.LCFI37:
 1273              		.cfi_def_cfa_register 7
 1274 0006 7860     		str	r0, [r7, #4]
 912:common/rtos/tasks.c **** 	portBASE_TYPE xReturn = pdFALSE;
 1275              		.loc 1 912 16
 1276 0008 0023     		movs	r3, #0
 1277 000a FB60     		str	r3, [r7, #12]
 913:common/rtos/tasks.c **** 	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
 1278              		.loc 1 913 23
 1279 000c 7B68     		ldr	r3, [r7, #4]
 1280 000e BB60     		str	r3, [r7, #8]
 914:common/rtos/tasks.c **** 
 915:common/rtos/tasks.c **** 		/* Is the task we are attempting to resume actually in the
 916:common/rtos/tasks.c **** 		suspended list? */
 917:common/rtos/tasks.c **** 		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
 1281              		.loc 1 917 7
 1282 0010 BB68     		ldr	r3, [r7, #8]
 1283 0012 5B69     		ldr	r3, [r3, #20]
 1284              		.loc 1 917 5
 1285 0014 094A     		ldr	r2, .L71
 1286 0016 9342     		cmp	r3, r2
 1287 0018 0AD1     		bne	.L69
 918:common/rtos/tasks.c **** 		{
 919:common/rtos/tasks.c **** 			/* Has the task already been resumed from within an ISR? */
 920:common/rtos/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
 1288              		.loc 1 920 8
 1289 001a BB68     		ldr	r3, [r7, #8]
 1290 001c 9B6A     		ldr	r3, [r3, #40]
 1291              		.loc 1 920 6
 1292 001e 084A     		ldr	r2, .L71+4
 1293 0020 9342     		cmp	r3, r2
 1294 0022 05D0     		beq	.L69
 921:common/rtos/tasks.c **** 			{
 922:common/rtos/tasks.c **** 				/* Is it in the suspended list because it is in the
 923:common/rtos/tasks.c **** 				Suspended state?  It is possible to be in the suspended
 924:common/rtos/tasks.c **** 				list because it is blocked on a task with no timeout
 925:common/rtos/tasks.c **** 				specified. */
 926:common/rtos/tasks.c **** 				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
 1295              		.loc 1 926 9
 1296 0024 BB68     		ldr	r3, [r7, #8]
 1297 0026 9B6A     		ldr	r3, [r3, #40]
 1298              		.loc 1 926 7
 1299 0028 002B     		cmp	r3, #0
 1300 002a 01D1     		bne	.L69
 927:common/rtos/tasks.c **** 				{
 928:common/rtos/tasks.c **** 					xReturn = pdTRUE;
 1301              		.loc 1 928 14
 1302 002c 0123     		movs	r3, #1
 1303 002e FB60     		str	r3, [r7, #12]
 1304              	.L69:
 929:common/rtos/tasks.c **** 				}
 930:common/rtos/tasks.c **** 			}
 931:common/rtos/tasks.c **** 		}
 932:common/rtos/tasks.c **** 
 933:common/rtos/tasks.c **** 		return xReturn;
 1305              		.loc 1 933 10
 1306 0030 FB68     		ldr	r3, [r7, #12]
 934:common/rtos/tasks.c **** 	}
 1307              		.loc 1 934 2
 1308 0032 1846     		mov	r0, r3
 1309 0034 1437     		adds	r7, r7, #20
 1310              	.LCFI38:
 1311              		.cfi_def_cfa_offset 4
 1312 0036 BD46     		mov	sp, r7
 1313              	.LCFI39:
 1314              		.cfi_def_cfa_register 13
 1315              		@ sp needed
 1316 0038 80BC     		pop	{r7}
 1317              	.LCFI40:
 1318              		.cfi_restore 7
 1319              		.cfi_def_cfa_offset 0
 1320 003a 7047     		bx	lr
 1321              	.L72:
 1322              		.align	2
 1323              	.L71:
 1324 003c 00000000 		.word	xSuspendedTaskList
 1325 0040 00000000 		.word	xPendingReadyList
 1326              		.cfi_endproc
 1327              	.LFE37:
 1329              		.section	.text.vTaskResume,"ax",%progbits
 1330              		.align	1
 1331              		.global	vTaskResume
 1332              		.syntax unified
 1333              		.thumb
 1334              		.thumb_func
 1336              	vTaskResume:
 1337              	.LFB38:
 935:common/rtos/tasks.c **** 
 936:common/rtos/tasks.c **** #endif
 937:common/rtos/tasks.c **** /*-----------------------------------------------------------*/
 938:common/rtos/tasks.c **** 
 939:common/rtos/tasks.c **** #if ( INCLUDE_vTaskSuspend == 1 )
 940:common/rtos/tasks.c **** 
 941:common/rtos/tasks.c **** 	void vTaskResume( xTaskHandle pxTaskToResume )
 942:common/rtos/tasks.c **** 	{
 1338              		.loc 1 942 2
 1339              		.cfi_startproc
 1340              		@ args = 0, pretend = 0, frame = 16
 1341              		@ frame_needed = 1, uses_anonymous_args = 0
 1342 0000 80B5     		push	{r7, lr}
 1343              	.LCFI41:
 1344              		.cfi_def_cfa_offset 8
 1345              		.cfi_offset 7, -8
 1346              		.cfi_offset 14, -4
 1347 0002 84B0     		sub	sp, sp, #16
 1348              	.LCFI42:
 1349              		.cfi_def_cfa_offset 24
 1350 0004 00AF     		add	r7, sp, #0
 1351              	.LCFI43:
 1352              		.cfi_def_cfa_register 7
 1353 0006 7860     		str	r0, [r7, #4]
 943:common/rtos/tasks.c **** 	tskTCB *pxTCB;
 944:common/rtos/tasks.c **** 
 945:common/rtos/tasks.c **** 		/* Remove the task from whichever list it is currently in, and place
 946:common/rtos/tasks.c **** 		it in the ready list. */
 947:common/rtos/tasks.c **** 		pxTCB = ( tskTCB * ) pxTaskToResume;
 1354              		.loc 1 947 9
 1355 0008 7B68     		ldr	r3, [r7, #4]
 1356 000a FB60     		str	r3, [r7, #12]
 948:common/rtos/tasks.c **** 
 949:common/rtos/tasks.c **** 		/* The parameter cannot be NULL as it is impossible to resume the
 950:common/rtos/tasks.c **** 		currently executing task. */
 951:common/rtos/tasks.c **** 		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
 1357              		.loc 1 951 5
 1358 000c FB68     		ldr	r3, [r7, #12]
 1359 000e 002B     		cmp	r3, #0
 1360 0010 34D0     		beq	.L77
 1361              		.loc 1 951 36 discriminator 1
 1362 0012 1C4B     		ldr	r3, .L78
 1363 0014 1B68     		ldr	r3, [r3]
 1364              		.loc 1 951 25 discriminator 1
 1365 0016 FA68     		ldr	r2, [r7, #12]
 1366 0018 9A42     		cmp	r2, r3
 1367 001a 2FD0     		beq	.L77
 952:common/rtos/tasks.c **** 		{
 953:common/rtos/tasks.c **** 			portENTER_CRITICAL();
 1368              		.loc 1 953 4
 1369 001c 1A4B     		ldr	r3, .L78+4
 1370 001e 9847     		blx	r3
 1371              	.LVL39:
 954:common/rtos/tasks.c **** 			{
 955:common/rtos/tasks.c **** 				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 1372              		.loc 1 955 9
 1373 0020 F868     		ldr	r0, [r7, #12]
 1374 0022 1A4B     		ldr	r3, .L78+8
 1375 0024 9847     		blx	r3
 1376              	.LVL40:
 1377 0026 0346     		mov	r3, r0
 1378              		.loc 1 955 7
 1379 0028 012B     		cmp	r3, #1
 1380 002a 25D1     		bne	.L75
 956:common/rtos/tasks.c **** 				{
 957:common/rtos/tasks.c **** 					traceTASK_RESUME( pxTCB );
 958:common/rtos/tasks.c **** 
 959:common/rtos/tasks.c **** 					/* As we are in a critical section we can access the ready
 960:common/rtos/tasks.c **** 					lists even if the scheduler is suspended. */
 961:common/rtos/tasks.c **** 					vListRemove(  &( pxTCB->xGenericListItem ) );
 1381              		.loc 1 961 6
 1382 002c FB68     		ldr	r3, [r7, #12]
 1383 002e 0433     		adds	r3, r3, #4
 1384 0030 1846     		mov	r0, r3
 1385 0032 174B     		ldr	r3, .L78+12
 1386 0034 9847     		blx	r3
 1387              	.LVL41:
 962:common/rtos/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1388              		.loc 1 962 6
 1389 0036 FB68     		ldr	r3, [r7, #12]
 1390 0038 DA6A     		ldr	r2, [r3, #44]
 1391 003a 164B     		ldr	r3, .L78+16
 1392 003c 1B68     		ldr	r3, [r3]
 1393 003e 9A42     		cmp	r2, r3
 1394 0040 03D9     		bls	.L76
 1395              		.loc 1 962 6 is_stmt 0 discriminator 1
 1396 0042 FB68     		ldr	r3, [r7, #12]
 1397 0044 DB6A     		ldr	r3, [r3, #44]
 1398 0046 134A     		ldr	r2, .L78+16
 1399 0048 1360     		str	r3, [r2]
 1400              	.L76:
 1401              		.loc 1 962 6 discriminator 3
 1402 004a FB68     		ldr	r3, [r7, #12]
 1403 004c DA6A     		ldr	r2, [r3, #44]
 1404 004e 1346     		mov	r3, r2
 1405 0050 9B00     		lsls	r3, r3, #2
 1406 0052 1344     		add	r3, r3, r2
 1407 0054 9B00     		lsls	r3, r3, #2
 1408 0056 104A     		ldr	r2, .L78+20
 1409 0058 1A44     		add	r2, r2, r3
 1410 005a FB68     		ldr	r3, [r7, #12]
 1411 005c 0433     		adds	r3, r3, #4
 1412 005e 1946     		mov	r1, r3
 1413 0060 1046     		mov	r0, r2
 1414 0062 0E4B     		ldr	r3, .L78+24
 1415 0064 9847     		blx	r3
 1416              	.LVL42:
 963:common/rtos/tasks.c **** 
 964:common/rtos/tasks.c **** 					/* We may have just resumed a higher priority task. */
 965:common/rtos/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1417              		.loc 1 965 15 is_stmt 1 discriminator 3
 1418 0066 FB68     		ldr	r3, [r7, #12]
 1419 0068 DA6A     		ldr	r2, [r3, #44]
 1420              		.loc 1 965 43 discriminator 3
 1421 006a 064B     		ldr	r3, .L78
 1422 006c 1B68     		ldr	r3, [r3]
 1423 006e DB6A     		ldr	r3, [r3, #44]
 1424              		.loc 1 965 8 discriminator 3
 1425 0070 9A42     		cmp	r2, r3
 1426 0072 01D3     		bcc	.L75
 966:common/rtos/tasks.c **** 					{
 967:common/rtos/tasks.c **** 						/* This yield may not cause the task just resumed to run, but
 968:common/rtos/tasks.c **** 						will leave the lists in the correct state for the next yield. */
 969:common/rtos/tasks.c **** 						portYIELD_WITHIN_API();
 1427              		.loc 1 969 7
 1428 0074 0A4B     		ldr	r3, .L78+28
 1429 0076 9847     		blx	r3
 1430              	.LVL43:
 1431              	.L75:
 970:common/rtos/tasks.c **** 					}
 971:common/rtos/tasks.c **** 				}
 972:common/rtos/tasks.c **** 			}
 973:common/rtos/tasks.c **** 			portEXIT_CRITICAL();
 1432              		.loc 1 973 4
 1433 0078 0A4B     		ldr	r3, .L78+32
 1434 007a 9847     		blx	r3
 1435              	.LVL44:
 1436              	.L77:
 974:common/rtos/tasks.c **** 		}
 975:common/rtos/tasks.c **** 	}
 1437              		.loc 1 975 2
 1438 007c 00BF     		nop
 1439 007e 1037     		adds	r7, r7, #16
 1440              	.LCFI44:
 1441              		.cfi_def_cfa_offset 8
 1442 0080 BD46     		mov	sp, r7
 1443              	.LCFI45:
 1444              		.cfi_def_cfa_register 13
 1445              		@ sp needed
 1446 0082 80BD     		pop	{r7, pc}
 1447              	.L79:
 1448              		.align	2
 1449              	.L78:
 1450 0084 00000000 		.word	pxCurrentTCB
 1451 0088 00000000 		.word	vPortEnterCritical
 1452 008c 00000000 		.word	xTaskIsTaskSuspended
 1453 0090 00000000 		.word	vListRemove
 1454 0094 00000000 		.word	uxTopReadyPriority
 1455 0098 00000000 		.word	pxReadyTasksLists
 1456 009c 00000000 		.word	vListInsertEnd
 1457 00a0 00000000 		.word	vPortYieldFromISR
 1458 00a4 00000000 		.word	vPortExitCritical
 1459              		.cfi_endproc
 1460              	.LFE38:
 1462              		.section	.text.xTaskResumeFromISR,"ax",%progbits
 1463              		.align	1
 1464              		.global	xTaskResumeFromISR
 1465              		.syntax unified
 1466              		.thumb
 1467              		.thumb_func
 1469              	xTaskResumeFromISR:
 1470              	.LFB39:
 976:common/rtos/tasks.c **** 
 977:common/rtos/tasks.c **** #endif
 978:common/rtos/tasks.c **** 
 979:common/rtos/tasks.c **** /*-----------------------------------------------------------*/
 980:common/rtos/tasks.c **** 
 981:common/rtos/tasks.c **** #if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
 982:common/rtos/tasks.c **** 
 983:common/rtos/tasks.c **** 	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
 984:common/rtos/tasks.c **** 	{
 1471              		.loc 1 984 2
 1472              		.cfi_startproc
 1473              		@ args = 0, pretend = 0, frame = 16
 1474              		@ frame_needed = 1, uses_anonymous_args = 0
 1475 0000 80B5     		push	{r7, lr}
 1476              	.LCFI46:
 1477              		.cfi_def_cfa_offset 8
 1478              		.cfi_offset 7, -8
 1479              		.cfi_offset 14, -4
 1480 0002 84B0     		sub	sp, sp, #16
 1481              	.LCFI47:
 1482              		.cfi_def_cfa_offset 24
 1483 0004 00AF     		add	r7, sp, #0
 1484              	.LCFI48:
 1485              		.cfi_def_cfa_register 7
 1486 0006 7860     		str	r0, [r7, #4]
 985:common/rtos/tasks.c **** 	portBASE_TYPE xYieldRequired = pdFALSE;
 1487              		.loc 1 985 16
 1488 0008 0023     		movs	r3, #0
 1489 000a FB60     		str	r3, [r7, #12]
 986:common/rtos/tasks.c **** 	tskTCB *pxTCB;
 987:common/rtos/tasks.c **** 
 988:common/rtos/tasks.c **** 		pxTCB = ( tskTCB * ) pxTaskToResume;
 1490              		.loc 1 988 9
 1491 000c 7B68     		ldr	r3, [r7, #4]
 1492 000e BB60     		str	r3, [r7, #8]
 989:common/rtos/tasks.c **** 
 990:common/rtos/tasks.c **** 		if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
 1493              		.loc 1 990 7
 1494 0010 B868     		ldr	r0, [r7, #8]
 1495 0012 1E4B     		ldr	r3, .L85
 1496 0014 9847     		blx	r3
 1497              	.LVL45:
 1498 0016 0346     		mov	r3, r0
 1499              		.loc 1 990 5
 1500 0018 012B     		cmp	r3, #1
 1501 001a 32D1     		bne	.L81
 991:common/rtos/tasks.c **** 		{
 992:common/rtos/tasks.c **** 			traceTASK_RESUME_FROM_ISR( pxTCB );
 993:common/rtos/tasks.c **** 
 994:common/rtos/tasks.c **** 			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 1502              		.loc 1 994 29
 1503 001c 1C4B     		ldr	r3, .L85+4
 1504 001e 1B68     		ldr	r3, [r3]
 1505              		.loc 1 994 6
 1506 0020 002B     		cmp	r3, #0
 1507 0022 28D1     		bne	.L82
 995:common/rtos/tasks.c **** 			{
 996:common/rtos/tasks.c **** 				xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
 1508              		.loc 1 996 29
 1509 0024 BB68     		ldr	r3, [r7, #8]
 1510 0026 DA6A     		ldr	r2, [r3, #44]
 1511              		.loc 1 996 57
 1512 0028 1A4B     		ldr	r3, .L85+8
 1513 002a 1B68     		ldr	r3, [r3]
 1514 002c DB6A     		ldr	r3, [r3, #44]
 1515              		.loc 1 996 42
 1516 002e 9A42     		cmp	r2, r3
 1517 0030 2CBF     		ite	cs
 1518 0032 0123     		movcs	r3, #1
 1519 0034 0023     		movcc	r3, #0
 1520 0036 DBB2     		uxtb	r3, r3
 1521              		.loc 1 996 20
 1522 0038 FB60     		str	r3, [r7, #12]
 997:common/rtos/tasks.c **** 				vListRemove(  &( pxTCB->xGenericListItem ) );
 1523              		.loc 1 997 5
 1524 003a BB68     		ldr	r3, [r7, #8]
 1525 003c 0433     		adds	r3, r3, #4
 1526 003e 1846     		mov	r0, r3
 1527 0040 154B     		ldr	r3, .L85+12
 1528 0042 9847     		blx	r3
 1529              	.LVL46:
 998:common/rtos/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );
 1530              		.loc 1 998 5
 1531 0044 BB68     		ldr	r3, [r7, #8]
 1532 0046 DA6A     		ldr	r2, [r3, #44]
 1533 0048 144B     		ldr	r3, .L85+16
 1534 004a 1B68     		ldr	r3, [r3]
 1535 004c 9A42     		cmp	r2, r3
 1536 004e 03D9     		bls	.L83
 1537              		.loc 1 998 5 is_stmt 0 discriminator 1
 1538 0050 BB68     		ldr	r3, [r7, #8]
 1539 0052 DB6A     		ldr	r3, [r3, #44]
 1540 0054 114A     		ldr	r2, .L85+16
 1541 0056 1360     		str	r3, [r2]
 1542              	.L83:
 1543              		.loc 1 998 5 discriminator 3
 1544 0058 BB68     		ldr	r3, [r7, #8]
 1545 005a DA6A     		ldr	r2, [r3, #44]
 1546 005c 1346     		mov	r3, r2
 1547 005e 9B00     		lsls	r3, r3, #2
 1548 0060 1344     		add	r3, r3, r2
 1549 0062 9B00     		lsls	r3, r3, #2
 1550 0064 0E4A     		ldr	r2, .L85+20
 1551 0066 1A44     		add	r2, r2, r3
 1552 0068 BB68     		ldr	r3, [r7, #8]
 1553 006a 0433     		adds	r3, r3, #4
 1554 006c 1946     		mov	r1, r3
 1555 006e 1046     		mov	r0, r2
 1556 0070 0C4B     		ldr	r3, .L85+24
 1557 0072 9847     		blx	r3
 1558              	.LVL47:
 1559 0074 05E0     		b	.L81
 1560              	.L82:
 999:common/rtos/tasks.c **** 			}
1000:common/rtos/tasks.c **** 			else
1001:common/rtos/tasks.c **** 			{
1002:common/rtos/tasks.c **** 				/* We cannot access the delayed or ready lists, so will hold this
1003:common/rtos/tasks.c **** 				task pending until the scheduler is resumed, at which point a
1004:common/rtos/tasks.c **** 				yield will be performed if necessary. */
1005:common/rtos/tasks.c **** 				vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
 1561              		.loc 1 1005 5 is_stmt 1
 1562 0076 BB68     		ldr	r3, [r7, #8]
 1563 0078 1833     		adds	r3, r3, #24
 1564 007a 1946     		mov	r1, r3
 1565 007c 0A48     		ldr	r0, .L85+28
 1566 007e 094B     		ldr	r3, .L85+24
 1567 0080 9847     		blx	r3
 1568              	.LVL48:
 1569              	.L81:
1006:common/rtos/tasks.c **** 			}
1007:common/rtos/tasks.c **** 		}
1008:common/rtos/tasks.c **** 
1009:common/rtos/tasks.c **** 		return xYieldRequired;
 1570              		.loc 1 1009 10
 1571 0082 FB68     		ldr	r3, [r7, #12]
1010:common/rtos/tasks.c **** 	}
 1572              		.loc 1 1010 2
 1573 0084 1846     		mov	r0, r3
 1574 0086 1037     		adds	r7, r7, #16
 1575              	.LCFI49:
 1576              		.cfi_def_cfa_offset 8
 1577 0088 BD46     		mov	sp, r7
 1578              	.LCFI50:
 1579              		.cfi_def_cfa_register 13
 1580              		@ sp needed
 1581 008a 80BD     		pop	{r7, pc}
 1582              	.L86:
 1583              		.align	2
 1584              	.L85:
 1585 008c 00000000 		.word	xTaskIsTaskSuspended
 1586 0090 00000000 		.word	uxSchedulerSuspended
 1587 0094 00000000 		.word	pxCurrentTCB
 1588 0098 00000000 		.word	vListRemove
 1589 009c 00000000 		.word	uxTopReadyPriority
 1590 00a0 00000000 		.word	pxReadyTasksLists
 1591 00a4 00000000 		.word	vListInsertEnd
 1592 00a8 00000000 		.word	xPendingReadyList
 1593              		.cfi_endproc
 1594              	.LFE39:
 1596              		.section	.rodata
 1597              		.align	2
 1598              	.LC0:
 1599 0000 49444C45 		.ascii	"IDLE\000"
 1599      00
 1600              		.section	.text.vTaskStartScheduler,"ax",%progbits
 1601              		.align	1
 1602              		.global	vTaskStartScheduler
 1603              		.syntax unified
 1604              		.thumb
 1605              		.thumb_func
 1607              	vTaskStartScheduler:
 1608              	.LFB40:
1011:common/rtos/tasks.c **** 
1012:common/rtos/tasks.c **** #endif
1013:common/rtos/tasks.c **** 
1014:common/rtos/tasks.c **** 
1015:common/rtos/tasks.c **** 
1016:common/rtos/tasks.c **** 
1017:common/rtos/tasks.c **** /*-----------------------------------------------------------
1018:common/rtos/tasks.c ****  * PUBLIC SCHEDULER CONTROL documented in task.h
1019:common/rtos/tasks.c ****  *----------------------------------------------------------*/
1020:common/rtos/tasks.c **** 
1021:common/rtos/tasks.c **** 
1022:common/rtos/tasks.c **** void vTaskStartScheduler( void )
1023:common/rtos/tasks.c **** {
 1609              		.loc 1 1023 1
 1610              		.cfi_startproc
 1611              		@ args = 0, pretend = 0, frame = 8
 1612              		@ frame_needed = 1, uses_anonymous_args = 0
 1613 0000 90B5     		push	{r4, r7, lr}
 1614              	.LCFI51:
 1615              		.cfi_def_cfa_offset 12
 1616              		.cfi_offset 4, -12
 1617              		.cfi_offset 7, -8
 1618              		.cfi_offset 14, -4
 1619 0002 87B0     		sub	sp, sp, #28
 1620              	.LCFI52:
 1621              		.cfi_def_cfa_offset 40
 1622 0004 04AF     		add	r7, sp, #16
 1623              	.LCFI53:
 1624              		.cfi_def_cfa 7, 24
1024:common/rtos/tasks.c **** portBASE_TYPE xReturn;
1025:common/rtos/tasks.c **** 
1026:common/rtos/tasks.c **** 	/* Add the idle task at the lowest priority. */
1027:common/rtos/tasks.c **** 	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL,
 1625              		.loc 1 1027 12
 1626 0006 0023     		movs	r3, #0
 1627 0008 0393     		str	r3, [sp, #12]
 1628 000a 0023     		movs	r3, #0
 1629 000c 0293     		str	r3, [sp, #8]
 1630 000e 0023     		movs	r3, #0
 1631 0010 0193     		str	r3, [sp, #4]
 1632 0012 0023     		movs	r3, #0
 1633 0014 0093     		str	r3, [sp]
 1634 0016 0023     		movs	r3, #0
 1635 0018 8022     		movs	r2, #128
 1636 001a 0C49     		ldr	r1, .L90
 1637 001c 0C48     		ldr	r0, .L90+4
 1638 001e 0D4C     		ldr	r4, .L90+8
 1639 0020 A047     		blx	r4
 1640              	.LVL49:
 1641 0022 7860     		str	r0, [r7, #4]
1028:common/rtos/tasks.c **** 
1029:common/rtos/tasks.c **** 	if( xReturn == pdPASS )
 1642              		.loc 1 1029 4
 1643 0024 7B68     		ldr	r3, [r7, #4]
 1644 0026 012B     		cmp	r3, #1
 1645 0028 0BD1     		bne	.L89
1030:common/rtos/tasks.c **** 	{
1031:common/rtos/tasks.c **** 		/* Interrupts are turned off here, to ensure a tick does not occur
1032:common/rtos/tasks.c **** 		before or during the call to xPortStartScheduler().  The stacks of
1033:common/rtos/tasks.c **** 		the created tasks contain a status word with interrupts switched on
1034:common/rtos/tasks.c **** 		so interrupts will automatically get re-enabled when the first task
1035:common/rtos/tasks.c **** 		starts to run.
1036:common/rtos/tasks.c **** 
1037:common/rtos/tasks.c **** 		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
1038:common/rtos/tasks.c **** 		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
1039:common/rtos/tasks.c **** 		portDISABLE_INTERRUPTS();
 1646              		.loc 1 1039 3
 1647              		.syntax unified
 1648              	@ 1039 "common/rtos/tasks.c" 1
 1649 002a 4FF0BF00 			mov r0, #191								
 1650 002e 80F31188 		msr basepri, r0							
 1651              	
 1652              	@ 0 "" 2
1040:common/rtos/tasks.c **** 
1041:common/rtos/tasks.c **** 		xSchedulerRunning = pdTRUE;
 1653              		.loc 1 1041 21
 1654              		.thumb
 1655              		.syntax unified
 1656 0032 094B     		ldr	r3, .L90+12
 1657 0034 0122     		movs	r2, #1
 1658 0036 1A60     		str	r2, [r3]
1042:common/rtos/tasks.c **** 		xTickCount = ( portTickType ) 0;
 1659              		.loc 1 1042 14
 1660 0038 084B     		ldr	r3, .L90+16
 1661 003a 0022     		movs	r2, #0
 1662 003c 1A60     		str	r2, [r3]
1043:common/rtos/tasks.c **** 
1044:common/rtos/tasks.c **** 		/* If configGENERATE_RUN_TIME_STATS is defined then the following
1045:common/rtos/tasks.c **** 		macro must be defined to configure the timer/counter used to generate
1046:common/rtos/tasks.c **** 		the run time counter time base. */
1047:common/rtos/tasks.c **** 		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
1048:common/rtos/tasks.c **** 
1049:common/rtos/tasks.c **** 		/* Setting up the timer tick is hardware specific and thus in the
1050:common/rtos/tasks.c **** 		portable interface. */
1051:common/rtos/tasks.c **** 		if( xPortStartScheduler() )
 1663              		.loc 1 1051 7
 1664 003e 084B     		ldr	r3, .L90+20
 1665 0040 9847     		blx	r3
 1666              	.LVL50:
 1667              	.L89:
1052:common/rtos/tasks.c **** 		{
1053:common/rtos/tasks.c **** 			/* Should not reach here as if the scheduler is running the
1054:common/rtos/tasks.c **** 			function will not return. */
1055:common/rtos/tasks.c **** 		}
1056:common/rtos/tasks.c **** 		else
1057:common/rtos/tasks.c **** 		{
1058:common/rtos/tasks.c **** 			/* Should only reach here if a task calls xTaskEndScheduler(). */
1059:common/rtos/tasks.c **** 		}
1060:common/rtos/tasks.c **** 	}
1061:common/rtos/tasks.c **** }
 1668              		.loc 1 1061 1
 1669 0042 00BF     		nop
 1670 0044 0C37     		adds	r7, r7, #12
 1671              	.LCFI54:
 1672              		.cfi_def_cfa_offset 12
 1673 0046 BD46     		mov	sp, r7
 1674              	.LCFI55:
 1675              		.cfi_def_cfa_register 13
 1676              		@ sp needed
 1677 0048 90BD     		pop	{r4, r7, pc}
 1678              	.L91:
 1679 004a 00BF     		.align	2
 1680              	.L90:
 1681 004c 00000000 		.word	.LC0
 1682 0050 00000000 		.word	prvIdleTask
 1683 0054 00000000 		.word	xTaskGenericCreate
 1684 0058 00000000 		.word	xSchedulerRunning
 1685 005c 00000000 		.word	xTickCount
 1686 0060 00000000 		.word	xPortStartScheduler
 1687              		.cfi_endproc
 1688              	.LFE40:
 1690              		.section	.text.vTaskEndScheduler,"ax",%progbits
 1691              		.align	1
 1692              		.global	vTaskEndScheduler
 1693              		.syntax unified
 1694              		.thumb
 1695              		.thumb_func
 1697              	vTaskEndScheduler:
 1698              	.LFB41:
1062:common/rtos/tasks.c **** /*-----------------------------------------------------------*/
1063:common/rtos/tasks.c **** 
1064:common/rtos/tasks.c **** void vTaskEndScheduler( void )
1065:common/rtos/tasks.c **** {
 1699              		.loc 1 1065 1
 1700              		.cfi_startproc
 1701              		@ args = 0, pretend = 0, frame = 0
 1702              		@ frame_needed = 1, uses_anonymous_args = 0
 1703 0000 80B5     		push	{r7, lr}
 1704              	.LCFI56:
 1705              		.cfi_def_cfa_offset 8
 1706              		.cfi_offset 7, -8
 1707              		.cfi_offset 14, -4
 1708 0002 00AF     		add	r7, sp, #0
 1709              	.LCFI57:
 1710              		.cfi_def_cfa_register 7
1066:common/rtos/tasks.c **** 	/* Stop the scheduler interrupts and call the portable scheduler end
1067:common/rtos/tasks.c **** 	routine so the original ISRs can be restored if necessary.  The port
1068:common/rtos/tasks.c **** 	layer must ensure interrupts enable	bit is left in the correct state. */
1069:common/rtos/tasks.c **** 	portDISABLE_INTERRUPTS();
 1711              		.loc 1 1069 2
 1712              		.syntax unified
 1713              	@ 1069 "common/rtos/tasks.c" 1
 1714 0004 4FF0BF00 			mov r0, #191								
 1715 0008 80F31188 		msr basepri, r0							
 1716              	
 1717              	@ 0 "" 2
1070:common/rtos/tasks.c **** 	xSchedulerRunning = pdFALSE;
 1718              		.loc 1 1070 20
 1719              		.thumb
 1720              		.syntax unified
 1721 000c 034B     		ldr	r3, .L93
 1722 000e 0022     		movs	r2, #0
 1723 0010 1A60     		str	r2, [r3]
1071:common/rtos/tasks.c **** 	vPortEndScheduler();
 1724              		.loc 1 1071 2
 1725 0012 034B     		ldr	r3, .L93+4
 1726 0014 9847     		blx	r3
 1727              	.LVL51:
1072:common/rtos/tasks.c **** }
 1728              		.loc 1 1072 1
 1729 0016 00BF     		nop
 1730 0018 80BD     		pop	{r7, pc}
 1731              	.L94:
 1732 001a 00BF     		.align	2
 1733              	.L93:
 1734 001c 00000000 		.word	xSchedulerRunning
 1735 0020 00000000 		.word	vPortEndScheduler
 1736              		.cfi_endproc
 1737              	.LFE41:
 1739              		.section	.text.vTaskSuspendAll,"ax",%progbits
 1740              		.align	1
 1741              		.global	vTaskSuspendAll
 1742              		.syntax unified
 1743              		.thumb
 1744              		.thumb_func
 1746              	vTaskSuspendAll:
 1747              	.LFB42:
1073:common/rtos/tasks.c **** /*----------------------------------------------------------*/
1074:common/rtos/tasks.c **** 
1075:common/rtos/tasks.c **** void vTaskSuspendAll( void )
1076:common/rtos/tasks.c **** {
 1748              		.loc 1 1076 1
 1749              		.cfi_startproc
 1750              		@ args = 0, pretend = 0, frame = 0
 1751              		@ frame_needed = 1, uses_anonymous_args = 0
 1752              		@ link register save eliminated.
 1753 0000 80B4     		push	{r7}
 1754              	.LCFI58:
 1755              		.cfi_def_cfa_offset 4
 1756              		.cfi_offset 7, -4
 1757 0002 00AF     		add	r7, sp, #0
 1758              	.LCFI59:
 1759              		.cfi_def_cfa_register 7
1077:common/rtos/tasks.c **** 	/* A critical section is not required as the variable is of type
1078:common/rtos/tasks.c **** 	portBASE_TYPE. */
1079:common/rtos/tasks.c **** 	++uxSchedulerSuspended;
 1760              		.loc 1 1079 2
 1761 0004 044B     		ldr	r3, .L96
 1762 0006 1B68     		ldr	r3, [r3]
 1763 0008 0133     		adds	r3, r3, #1
 1764 000a 034A     		ldr	r2, .L96
 1765 000c 1360     		str	r3, [r2]
1080:common/rtos/tasks.c **** }
 1766              		.loc 1 1080 1
 1767 000e 00BF     		nop
 1768 0010 BD46     		mov	sp, r7
 1769              	.LCFI60:
 1770              		.cfi_def_cfa_register 13
 1771              		@ sp needed
 1772 0012 80BC     		pop	{r7}
 1773              	.LCFI61:
 1774              		.cfi_restore 7
 1775              		.cfi_def_cfa_offset 0
 1776 0014 7047     		bx	lr
 1777              	.L97:
 1778 0016 00BF     		.align	2
 1779              	.L96:
 1780 0018 00000000 		.word	uxSchedulerSuspended
 1781              		.cfi_endproc
 1782              	.LFE42:
 1784              		.section	.text.xTaskResumeAll,"ax",%progbits
 1785              		.align	1
 1786              		.global	xTaskResumeAll
 1787              		.syntax unified
 1788              		.thumb
 1789              		.thumb_func
 1791              	xTaskResumeAll:
 1792              	.LFB43:
1081:common/rtos/tasks.c **** /*----------------------------------------------------------*/
1082:common/rtos/tasks.c **** 
1083:common/rtos/tasks.c **** signed portBASE_TYPE xTaskResumeAll( void )
1084:common/rtos/tasks.c **** {
 1793              		.loc 1 1084 1
 1794              		.cfi_startproc
 1795              		@ args = 0, pretend = 0, frame = 8
 1796              		@ frame_needed = 1, uses_anonymous_args = 0
 1797 0000 90B5     		push	{r4, r7, lr}
 1798              	.LCFI62:
 1799              		.cfi_def_cfa_offset 12
 1800              		.cfi_offset 4, -12
 1801              		.cfi_offset 7, -8
 1802              		.cfi_offset 14, -4
 1803 0002 83B0     		sub	sp, sp, #12
 1804              	.LCFI63:
 1805              		.cfi_def_cfa_offset 24
 1806 0004 00AF     		add	r7, sp, #0
 1807              	.LCFI64:
 1808              		.cfi_def_cfa_register 7
1085:common/rtos/tasks.c **** register tskTCB *pxTCB;
1086:common/rtos/tasks.c **** signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 1809              		.loc 1 1086 22
 1810 0006 0023     		movs	r3, #0
 1811 0008 7B60     		str	r3, [r7, #4]
1087:common/rtos/tasks.c **** 
1088:common/rtos/tasks.c **** 	/* It is possible that an ISR caused a task to be removed from an event
1089:common/rtos/tasks.c **** 	list while the scheduler was suspended.  If this was the case then the
1090:common/rtos/tasks.c **** 	removed task will have been added to the xPendingReadyList.  Once the
1091:common/rtos/tasks.c **** 	scheduler has been resumed it is safe to move all the pending ready
1092:common/rtos/tasks.c **** 	tasks from this list into their appropriate ready list. */
1093:common/rtos/tasks.c **** 	portENTER_CRITICAL();
 1812              		.loc 1 1093 2
 1813 000a 354B     		ldr	r3, .L110
 1814 000c 9847     		blx	r3
 1815              	.LVL52:
1094:common/rtos/tasks.c **** 	{
1095:common/rtos/tasks.c **** 		--uxSchedulerSuspended;
 1816              		.loc 1 1095 3
 1817 000e 354B     		ldr	r3, .L110+4
 1818 0010 1B68     		ldr	r3, [r3]
 1819 0012 013B     		subs	r3, r3, #1
 1820 0014 334A     		ldr	r2, .L110+4
 1821 0016 1360     		str	r3, [r2]
1096:common/rtos/tasks.c **** 
1097:common/rtos/tasks.c **** 		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 1822              		.loc 1 1097 28
 1823 0018 324B     		ldr	r3, .L110+4
 1824 001a 1B68     		ldr	r3, [r3]
 1825              		.loc 1 1097 5
 1826 001c 002B     		cmp	r3, #0
 1827 001e 57D1     		bne	.L99
1098:common/rtos/tasks.c **** 		{
1099:common/rtos/tasks.c **** 			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
 1828              		.loc 1 1099 31
 1829 0020 314B     		ldr	r3, .L110+8
 1830 0022 1B68     		ldr	r3, [r3]
 1831              		.loc 1 1099 6
 1832 0024 002B     		cmp	r3, #0
 1833 0026 53D0     		beq	.L99
 1834              	.LBB3:
1100:common/rtos/tasks.c **** 			{
1101:common/rtos/tasks.c **** 				portBASE_TYPE xYieldRequired = pdFALSE;
 1835              		.loc 1 1101 19
 1836 0028 0023     		movs	r3, #0
 1837 002a 3B60     		str	r3, [r7]
1102:common/rtos/tasks.c **** 
1103:common/rtos/tasks.c **** 				/* Move any readied tasks from the pending list into the
1104:common/rtos/tasks.c **** 				appropriate ready list. */
1105:common/rtos/tasks.c **** 				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) 
 1838              		.loc 1 1105 10
 1839 002c 24E0     		b	.L100
 1840              	.L104:
1106:common/rtos/tasks.c **** 				{
1107:common/rtos/tasks.c **** 					vListRemove( &( pxTCB->xEventListItem ) );
 1841              		.loc 1 1107 6
 1842 002e 04F11803 		add	r3, r4, #24
 1843 0032 1846     		mov	r0, r3
 1844 0034 2D4B     		ldr	r3, .L110+12
 1845 0036 9847     		blx	r3
 1846              	.LVL53:
1108:common/rtos/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 1847              		.loc 1 1108 6
 1848 0038 231D     		adds	r3, r4, #4
 1849 003a 1846     		mov	r0, r3
 1850 003c 2B4B     		ldr	r3, .L110+12
 1851 003e 9847     		blx	r3
 1852              	.LVL54:
1109:common/rtos/tasks.c **** 					prvAddTaskToReadyQueue( pxTCB );
 1853              		.loc 1 1109 6
 1854 0040 E26A     		ldr	r2, [r4, #44]
 1855 0042 2B4B     		ldr	r3, .L110+16
 1856 0044 1B68     		ldr	r3, [r3]
 1857 0046 9A42     		cmp	r2, r3
 1858 0048 02D9     		bls	.L101
 1859              		.loc 1 1109 6 is_stmt 0 discriminator 1
 1860 004a E36A     		ldr	r3, [r4, #44]
 1861 004c 284A     		ldr	r2, .L110+16
 1862 004e 1360     		str	r3, [r2]
 1863              	.L101:
 1864              		.loc 1 1109 6 discriminator 3
 1865 0050 E26A     		ldr	r2, [r4, #44]
 1866 0052 1346     		mov	r3, r2
 1867 0054 9B00     		lsls	r3, r3, #2
 1868 0056 1344     		add	r3, r3, r2
 1869 0058 9B00     		lsls	r3, r3, #2
 1870 005a 264A     		ldr	r2, .L110+20
 1871 005c 1344     		add	r3, r3, r2
 1872 005e 221D     		adds	r2, r4, #4
 1873 0060 1146     		mov	r1, r2
 1874 0062 1846     		mov	r0, r3
 1875 0064 244B     		ldr	r3, .L110+24
 1876 0066 9847     		blx	r3
 1877              	.LVL55:
1110:common/rtos/tasks.c **** 
1111:common/rtos/tasks.c **** 					/* If we have moved a task that has a priority higher than
1112:common/rtos/tasks.c **** 					the current task then we should yield. */
1113:common/rtos/tasks.c **** 					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 1878              		.loc 1 1113 15 is_stmt 1 discriminator 3
 1879 0068 E26A     		ldr	r2, [r4, #44]
 1880              		.loc 1 1113 43 discriminator 3
 1881 006a 244B     		ldr	r3, .L110+28
 1882 006c 1B68     		ldr	r3, [r3]
 1883 006e DB6A     		ldr	r3, [r3, #44]
 1884              		.loc 1 1113 8 discriminator 3
 1885 0070 9A42     		cmp	r2, r3
 1886 0072 01D3     		bcc	.L100
1114:common/rtos/tasks.c **** 					{
1115:common/rtos/tasks.c **** 						xYieldRequired = pdTRUE;
 1887              		.loc 1 1115 22
 1888 0074 0123     		movs	r3, #1
 1889 0076 3B60     		str	r3, [r7]
 1890              	.L100:
1105:common/rtos/tasks.c **** 				{
 1891              		.loc 1 1105 35
 1892 0078 214B     		ldr	r3, .L110+32
 1893 007a 1B68     		ldr	r3, [r3]
1105:common/rtos/tasks.c **** 				{
 1894              		.loc 1 1105 22
 1895 007c 002B     		cmp	r3, #0
 1896 007e 03D0     		beq	.L102
1105:common/rtos/tasks.c **** 				{
 1897              		.loc 1 1105 35 discriminator 1
 1898 0080 1F4B     		ldr	r3, .L110+32
 1899 0082 DB68     		ldr	r3, [r3, #12]
1105:common/rtos/tasks.c **** 				{
 1900              		.loc 1 1105 22 discriminator 1
 1901 0084 DB68     		ldr	r3, [r3, #12]
 1902 0086 00E0     		b	.L103
 1903              	.L102:
1105:common/rtos/tasks.c **** 				{
 1904              		.loc 1 1105 22 is_stmt 0 discriminator 2
 1905 0088 0023     		movs	r3, #0
 1906              	.L103:
1105:common/rtos/tasks.c **** 				{
 1907              		.loc 1 1105 20 is_stmt 1 discriminator 4
 1908 008a 1C46     		mov	r4, r3
1105:common/rtos/tasks.c **** 				{
 1909              		.loc 1 1105 10 discriminator 4
 1910 008c 002C     		cmp	r4, #0
 1911 008e CED1     		bne	.L104
1116:common/rtos/tasks.c **** 					}
1117:common/rtos/tasks.c **** 				}
1118:common/rtos/tasks.c **** 
1119:common/rtos/tasks.c **** 				/* If any ticks occurred while the scheduler was suspended then
1120:common/rtos/tasks.c **** 				they should be processed now.  This ensures the tick count does not
1121:common/rtos/tasks.c **** 				slip, and that any delayed tasks are resumed at the correct time. */
1122:common/rtos/tasks.c **** 				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
 1912              		.loc 1 1122 23
 1913 0090 1C4B     		ldr	r3, .L110+36
 1914 0092 1B68     		ldr	r3, [r3]
 1915              		.loc 1 1122 7
 1916 0094 002B     		cmp	r3, #0
 1917 0096 0DD0     		beq	.L105
1123:common/rtos/tasks.c **** 				{
1124:common/rtos/tasks.c **** 					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
 1918              		.loc 1 1124 11
 1919 0098 06E0     		b	.L106
 1920              	.L107:
1125:common/rtos/tasks.c **** 					{
1126:common/rtos/tasks.c **** 						vTaskIncrementTick();
 1921              		.loc 1 1126 7
 1922 009a 1B4B     		ldr	r3, .L110+40
 1923 009c 9847     		blx	r3
 1924              	.LVL56:
1127:common/rtos/tasks.c **** 						--uxMissedTicks;
 1925              		.loc 1 1127 7
 1926 009e 194B     		ldr	r3, .L110+36
 1927 00a0 1B68     		ldr	r3, [r3]
 1928 00a2 013B     		subs	r3, r3, #1
 1929 00a4 174A     		ldr	r2, .L110+36
 1930 00a6 1360     		str	r3, [r2]
 1931              	.L106:
1124:common/rtos/tasks.c **** 					{
 1932              		.loc 1 1124 27
 1933 00a8 164B     		ldr	r3, .L110+36
 1934 00aa 1B68     		ldr	r3, [r3]
1124:common/rtos/tasks.c **** 					{
 1935              		.loc 1 1124 11
 1936 00ac 002B     		cmp	r3, #0
 1937 00ae F4D1     		bne	.L107
1128:common/rtos/tasks.c **** 					}
1129:common/rtos/tasks.c **** 
1130:common/rtos/tasks.c **** 					/* As we have processed some ticks it is appropriate to yield
1131:common/rtos/tasks.c **** 					to ensure the highest priority task that is ready to run is
1132:common/rtos/tasks.c **** 					the task actually running. */
1133:common/rtos/tasks.c **** 					#if configUSE_PREEMPTION == 1
1134:common/rtos/tasks.c **** 					{
1135:common/rtos/tasks.c **** 						xYieldRequired = pdTRUE;
 1938              		.loc 1 1135 22
 1939 00b0 0123     		movs	r3, #1
 1940 00b2 3B60     		str	r3, [r7]
 1941              	.L105:
1136:common/rtos/tasks.c **** 					}
1137:common/rtos/tasks.c **** 					#endif
1138:common/rtos/tasks.c **** 				}
1139:common/rtos/tasks.c **** 
1140:common/rtos/tasks.c **** 				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
 1942              		.loc 1 1140 7
 1943 00b4 3B68     		ldr	r3, [r7]
 1944 00b6 012B     		cmp	r3, #1
 1945 00b8 03D0     		beq	.L108
 1946              		.loc 1 1140 56 discriminator 1
 1947 00ba 144B     		ldr	r3, .L110+44
 1948 00bc 1B68     		ldr	r3, [r3]
 1949              		.loc 1 1140 38 discriminator 1
 1950 00be 012B     		cmp	r3, #1
 1951 00c0 06D1     		bne	.L99
 1952              	.L108:
1141:common/rtos/tasks.c **** 				{
1142:common/rtos/tasks.c **** 					xAlreadyYielded = pdTRUE;
 1953              		.loc 1 1142 22
 1954 00c2 0123     		movs	r3, #1
 1955 00c4 7B60     		str	r3, [r7, #4]
1143:common/rtos/tasks.c **** 					xMissedYield = pdFALSE;
 1956              		.loc 1 1143 19
 1957 00c6 114B     		ldr	r3, .L110+44
 1958 00c8 0022     		movs	r2, #0
 1959 00ca 1A60     		str	r2, [r3]
1144:common/rtos/tasks.c **** 					portYIELD_WITHIN_API();
 1960              		.loc 1 1144 6
 1961 00cc 104B     		ldr	r3, .L110+48
 1962 00ce 9847     		blx	r3
 1963              	.LVL57:
 1964              	.L99:
 1965              	.LBE3:
1145:common/rtos/tasks.c **** 				}
1146:common/rtos/tasks.c **** 			}
1147:common/rtos/tasks.c **** 		}
1148:common/rtos/tasks.c **** 	}
1149:common/rtos/tasks.c **** 	portEXIT_CRITICAL();
 1966              		.loc 1 1149 2
 1967 00d0 104B     		ldr	r3, .L110+52
 1968 00d2 9847     		blx	r3
 1969              	.LVL58:
1150:common/rtos/tasks.c **** 
1151:common/rtos/tasks.c **** 	return xAlreadyYielded;
 1970              		.loc 1 1151 9
 1971 00d4 7B68     		ldr	r3, [r7, #4]
1152:common/rtos/tasks.c **** }
 1972              		.loc 1 1152 1
 1973 00d6 1846     		mov	r0, r3
 1974 00d8 0C37     		adds	r7, r7, #12
 1975              	.LCFI65:
 1976              		.cfi_def_cfa_offset 12
 1977 00da BD46     		mov	sp, r7
 1978              	.LCFI66:
 1979              		.cfi_def_cfa_register 13
 1980              		@ sp needed
 1981 00dc 90BD     		pop	{r4, r7, pc}
 1982              	.L111:
 1983 00de 00BF     		.align	2
 1984              	.L110:
 1985 00e0 00000000 		.word	vPortEnterCritical
 1986 00e4 00000000 		.word	uxSchedulerSuspended
 1987 00e8 00000000 		.word	uxCurrentNumberOfTasks
 1988 00ec 00000000 		.word	vListRemove
 1989 00f0 00000000 		.word	uxTopReadyPriority
 1990 00f4 00000000 		.word	pxReadyTasksLists
 1991 00f8 00000000 		.word	vListInsertEnd
 1992 00fc 00000000 		.word	pxCurrentTCB
 1993 0100 00000000 		.word	xPendingReadyList
 1994 0104 00000000 		.word	uxMissedTicks
 1995 0108 00000000 		.word	vTaskIncrementTick
 1996 010c 00000000 		.word	xMissedYield
 1997 0110 00000000 		.word	vPortYieldFromISR
 1998 0114 00000000 		.word	vPortExitCritical
 1999              		.cfi_endproc
 2000              	.LFE43:
 2002              		.section	.text.xTaskGetTickCount,"ax",%progbits
 2003              		.align	1
 2004              		.global	xTaskGetTickCount
 2005              		.syntax unified
 2006              		.thumb
 2007              		.thumb_func
 2009              	xTaskGetTickCount:
 2010              	.LFB44:
1153:common/rtos/tasks.c **** 
1154:common/rtos/tasks.c **** 
1155:common/rtos/tasks.c **** 
1156:common/rtos/tasks.c **** 
1157:common/rtos/tasks.c **** 
1158:common/rtos/tasks.c **** 
1159:common/rtos/tasks.c **** /*-----------------------------------------------------------
1160:common/rtos/tasks.c ****  * PUBLIC TASK UTILITIES documented in task.h
1161:common/rtos/tasks.c ****  *----------------------------------------------------------*/
1162:common/rtos/tasks.c **** 
1163:common/rtos/tasks.c **** 
1164:common/rtos/tasks.c **** 
1165:common/rtos/tasks.c **** portTickType xTaskGetTickCount( void )
1166:common/rtos/tasks.c **** {
 2011              		.loc 1 1166 1
 2012              		.cfi_startproc
 2013              		@ args = 0, pretend = 0, frame = 8
 2014              		@ frame_needed = 1, uses_anonymous_args = 0
 2015 0000 80B5     		push	{r7, lr}
 2016              	.LCFI67:
 2017              		.cfi_def_cfa_offset 8
 2018              		.cfi_offset 7, -8
 2019              		.cfi_offset 14, -4
 2020 0002 82B0     		sub	sp, sp, #8
 2021              	.LCFI68:
 2022              		.cfi_def_cfa_offset 16
 2023 0004 00AF     		add	r7, sp, #0
 2024              	.LCFI69:
 2025              		.cfi_def_cfa_register 7
1167:common/rtos/tasks.c **** portTickType xTicks;
1168:common/rtos/tasks.c **** 
1169:common/rtos/tasks.c **** 	/* Critical section required if running on a 16 bit processor. */
1170:common/rtos/tasks.c **** 	portENTER_CRITICAL();
 2026              		.loc 1 1170 2
 2027 0006 064B     		ldr	r3, .L114
 2028 0008 9847     		blx	r3
 2029              	.LVL59:
1171:common/rtos/tasks.c **** 	{
1172:common/rtos/tasks.c **** 		xTicks = xTickCount;
 2030              		.loc 1 1172 10
 2031 000a 064B     		ldr	r3, .L114+4
 2032 000c 1B68     		ldr	r3, [r3]
 2033 000e 7B60     		str	r3, [r7, #4]
1173:common/rtos/tasks.c **** 	}
1174:common/rtos/tasks.c **** 	portEXIT_CRITICAL();
 2034              		.loc 1 1174 2
 2035 0010 054B     		ldr	r3, .L114+8
 2036 0012 9847     		blx	r3
 2037              	.LVL60:
1175:common/rtos/tasks.c **** 
1176:common/rtos/tasks.c **** 	return xTicks;
 2038              		.loc 1 1176 9
 2039 0014 7B68     		ldr	r3, [r7, #4]
1177:common/rtos/tasks.c **** }
 2040              		.loc 1 1177 1
 2041 0016 1846     		mov	r0, r3
 2042 0018 0837     		adds	r7, r7, #8
 2043              	.LCFI70:
 2044              		.cfi_def_cfa_offset 8
 2045 001a BD46     		mov	sp, r7
 2046              	.LCFI71:
 2047              		.cfi_def_cfa_register 13
 2048              		@ sp needed
 2049 001c 80BD     		pop	{r7, pc}
 2050              	.L115:
 2051 001e 00BF     		.align	2
 2052              	.L114:
 2053 0020 00000000 		.word	vPortEnterCritical
 2054 0024 00000000 		.word	xTickCount
 2055 0028 00000000 		.word	vPortExitCritical
 2056              		.cfi_endproc
 2057              	.LFE44:
 2059              		.section	.text.uxTaskGetNumberOfTasks,"ax",%progbits
 2060              		.align	1
 2061              		.global	uxTaskGetNumberOfTasks
 2062              		.syntax unified
 2063              		.thumb
 2064              		.thumb_func
 2066              	uxTaskGetNumberOfTasks:
 2067              	.LFB45:
1178:common/rtos/tasks.c **** /*-----------------------------------------------------------*/
1179:common/rtos/tasks.c **** 
1180:common/rtos/tasks.c **** unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
1181:common/rtos/tasks.c **** {
 2068              		.loc 1 1181 1
 2069              		.cfi_startproc
 2070              		@ args = 0, pretend = 0, frame = 0
 2071              		@ frame_needed = 1, uses_anonymous_args = 0
 2072              		@ link register save eliminated.
 2073 0000 80B4     		push	{r7}
 2074              	.LCFI72:
 2075              		.cfi_def_cfa_offset 4
 2076              		.cfi_offset 7, -4
 2077 0002 00AF     		add	r7, sp, #0
 2078              	.LCFI73:
 2079              		.cfi_def_cfa_register 7
1182:common/rtos/tasks.c **** 	/* A critical section is not required because the variables are of type
1183:common/rtos/tasks.c **** 	portBASE_TYPE. */
1184:common/rtos/tasks.c **** 	return uxCurrentNumberOfTasks;
 2080              		.loc 1 1184 9
 2081 0004 024B     		ldr	r3, .L118
 2082 0006 1B68     		ldr	r3, [r3]
1185:common/rtos/tasks.c **** }
 2083              		.loc 1 1185 1
 2084 0008 1846     		mov	r0, r3
 2085 000a BD46     		mov	sp, r7
 2086              	.LCFI74:
 2087              		.cfi_def_cfa_register 13
 2088              		@ sp needed
 2089 000c 80BC     		pop	{r7}
 2090              	.LCFI75:
 2091              		.cfi_restore 7
 2092              		.cfi_def_cfa_offset 0
 2093 000e 7047     		bx	lr
 2094              	.L119:
 2095              		.align	2
 2096              	.L118:
 2097 0010 00000000 		.word	uxCurrentNumberOfTasks
 2098              		.cfi_endproc
 2099              	.LFE45:
 2101              		.section	.text.vTaskIncrementTick,"ax",%progbits
 2102              		.align	1
 2103              		.global	vTaskIncrementTick
 2104              		.syntax unified
 2105              		.thumb
 2106              		.thumb_func
 2108              	vTaskIncrementTick:
 2109              	.LFB46:
1186:common/rtos/tasks.c **** /*-----------------------------------------------------------*/
1187:common/rtos/tasks.c **** 
1188:common/rtos/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1189:common/rtos/tasks.c **** 
1190:common/rtos/tasks.c **** 	void vTaskList( signed char *pcWriteBuffer )
1191:common/rtos/tasks.c **** 	{
1192:common/rtos/tasks.c **** 	unsigned portBASE_TYPE uxQueue;
1193:common/rtos/tasks.c **** 
1194:common/rtos/tasks.c **** 		/* This is a VERY costly function that should be used for debug only.
1195:common/rtos/tasks.c **** 		It leaves interrupts disabled for a LONG time. */
1196:common/rtos/tasks.c **** 
1197:common/rtos/tasks.c **** 		vTaskSuspendAll();
1198:common/rtos/tasks.c **** 		{
1199:common/rtos/tasks.c **** 			/* Run through all the lists that could potentially contain a TCB and
1200:common/rtos/tasks.c **** 			report the task name, state and stack high water mark. */
1201:common/rtos/tasks.c **** 
1202:common/rtos/tasks.c **** 			pcWriteBuffer[ 0 ] = ( signed char ) 0x00;
1203:common/rtos/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
1204:common/rtos/tasks.c **** 
1205:common/rtos/tasks.c **** 			uxQueue = uxTopUsedPriority + 1;
1206:common/rtos/tasks.c **** 
1207:common/rtos/tasks.c **** 			do
1208:common/rtos/tasks.c **** 			{
1209:common/rtos/tasks.c **** 				uxQueue--;
1210:common/rtos/tasks.c **** 
1211:common/rtos/tasks.c **** 				if( !listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) )
1212:common/rtos/tasks.c **** 				{
1213:common/rtos/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueue ] ), tsk
1214:common/rtos/tasks.c **** 				}
1215:common/rtos/tasks.c **** 			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
1216:common/rtos/tasks.c **** 
1217:common/rtos/tasks.c **** 			if( !listLIST_IS_EMPTY( pxDelayedTaskList ) )
1218:common/rtos/tasks.c **** 			{
1219:common/rtos/tasks.c **** 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, tskBLOCKED_CHAR );
1220:common/rtos/tasks.c **** 			}
1221:common/rtos/tasks.c **** 
1222:common/rtos/tasks.c **** 			if( !listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) )
1223:common/rtos/tasks.c **** 			{
1224:common/rtos/tasks.c **** 				prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, tskBLOCKED_C
1225:common/rtos/tasks.c **** 			}
1226:common/rtos/tasks.c **** 
1227:common/rtos/tasks.c **** 			#if( INCLUDE_vTaskDelete == 1 )
1228:common/rtos/tasks.c **** 			{
1229:common/rtos/tasks.c **** 				if( !listLIST_IS_EMPTY( &xTasksWaitingTermination ) )
1230:common/rtos/tasks.c **** 				{
1231:common/rtos/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &xTasksWaitingTermination, tskDELETED_
1232:common/rtos/tasks.c **** 				}
1233:common/rtos/tasks.c **** 			}
1234:common/rtos/tasks.c **** 			#endif
1235:common/rtos/tasks.c **** 
1236:common/rtos/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1237:common/rtos/tasks.c **** 			{
1238:common/rtos/tasks.c **** 				if( !listLIST_IS_EMPTY( &xSuspendedTaskList ) )
1239:common/rtos/tasks.c **** 				{
1240:common/rtos/tasks.c **** 					prvListTaskWithinSingleList( pcWriteBuffer, ( xList * ) &xSuspendedTaskList, tskSUSPENDED_CHAR
1241:common/rtos/tasks.c **** 				}
1242:common/rtos/tasks.c **** 			}
1243:common/rtos/tasks.c **** 			#endif
1244:common/rtos/tasks.c **** 		}
1245:common/rtos/tasks.c **** 		xTaskResumeAll();
1246:common/rtos/tasks.c **** 	}
1247:common/rtos/tasks.c **** 
1248:common/rtos/tasks.c **** #endif
1249:common/rtos/tasks.c **** /*----------------------------------------------------------*/
1250:common/rtos/tasks.c **** 
1251:common/rtos/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
1252:common/rtos/tasks.c **** 
1253:common/rtos/tasks.c **** 	void vTaskGetRunTimeStats( signed char *pcWriteBuffer )
1254:common/rtos/tasks.c **** 	{
1255:common/rtos/tasks.c **** 	unsigned portBASE_TYPE uxQueue;
1256:common/rtos/tasks.c **** 	unsigned long ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
1257:common/rtos/tasks.c **** 
1258:common/rtos/tasks.c **** 		/* This is a VERY costly function that should be used for debug only.
1259:common/rtos/tasks.c **** 		It leaves interrupts disabled for a LONG time. */
1260:common/rtos/tasks.c **** 
1261:common/rtos/tasks.c **** 		vTaskSuspendAll();
1262:common/rtos/tasks.c **** 		{
1263:common/rtos/tasks.c **** 			/* Run through all the lists that could potentially contain a TCB,
1264:common/rtos/tasks.c **** 			generating a table of run timer percentages in the provided
1265:common/rtos/tasks.c **** 			buffer. */
1266:common/rtos/tasks.c **** 
1267:common/rtos/tasks.c **** 			pcWriteBuffer[ 0 ] = ( signed char ) 0x00;
1268:common/rtos/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( const char * ) "\r\n" );
1269:common/rtos/tasks.c **** 
1270:common/rtos/tasks.c **** 			uxQueue = uxTopUsedPriority + 1;
1271:common/rtos/tasks.c **** 
1272:common/rtos/tasks.c **** 			do
1273:common/rtos/tasks.c **** 			{
1274:common/rtos/tasks.c **** 				uxQueue--;
1275:common/rtos/tasks.c **** 
1276:common/rtos/tasks.c **** 				if( !listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxQueue ] ) ) )
1277:common/rtos/tasks.c **** 				{
1278:common/rtos/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) &( pxReadyTasksLists[ uxQueu
1279:common/rtos/tasks.c **** 				}
1280:common/rtos/tasks.c **** 			}while( uxQueue > ( unsigned short ) tskIDLE_PRIORITY );
1281:common/rtos/tasks.c **** 
1282:common/rtos/tasks.c **** 			if( !listLIST_IS_EMPTY( pxDelayedTaskList ) )
1283:common/rtos/tasks.c **** 			{
1284:common/rtos/tasks.c **** 				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxDelayedTaskList, ulTotalRun
1285:common/rtos/tasks.c **** 			}
1286:common/rtos/tasks.c **** 
1287:common/rtos/tasks.c **** 			if( !listLIST_IS_EMPTY( pxOverflowDelayedTaskList ) )
1288:common/rtos/tasks.c **** 			{
1289:common/rtos/tasks.c **** 				prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) pxOverflowDelayedTaskList, ul
1290:common/rtos/tasks.c **** 			}
1291:common/rtos/tasks.c **** 
1292:common/rtos/tasks.c **** 			#if ( INCLUDE_vTaskDelete == 1 )
1293:common/rtos/tasks.c **** 			{
1294:common/rtos/tasks.c **** 				if( !listLIST_IS_EMPTY( &xTasksWaitingTermination ) )
1295:common/rtos/tasks.c **** 				{
1296:common/rtos/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) &xTasksWaitingTermination, u
1297:common/rtos/tasks.c **** 				}
1298:common/rtos/tasks.c **** 			}
1299:common/rtos/tasks.c **** 			#endif
1300:common/rtos/tasks.c **** 
1301:common/rtos/tasks.c **** 			#if ( INCLUDE_vTaskSuspend == 1 )
1302:common/rtos/tasks.c **** 			{
1303:common/rtos/tasks.c **** 				if( !listLIST_IS_EMPTY( &xSuspendedTaskList ) )
1304:common/rtos/tasks.c **** 				{
1305:common/rtos/tasks.c **** 					prvGenerateRunTimeStatsForTasksInList( pcWriteBuffer, ( xList * ) &xSuspendedTaskList, ulTotal
1306:common/rtos/tasks.c **** 				}
1307:common/rtos/tasks.c **** 			}
1308:common/rtos/tasks.c **** 			#endif
1309:common/rtos/tasks.c **** 		}
1310:common/rtos/tasks.c **** 		xTaskResumeAll();
1311:common/rtos/tasks.c **** 	}
1312:common/rtos/tasks.c **** 
1313:common/rtos/tasks.c **** #endif
1314:common/rtos/tasks.c **** /*----------------------------------------------------------*/
1315:common/rtos/tasks.c **** 
1316:common/rtos/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1317:common/rtos/tasks.c **** 
1318:common/rtos/tasks.c **** 	void vTaskStartTrace( signed char * pcBuffer, unsigned long ulBufferSize )
1319:common/rtos/tasks.c **** 	{
1320:common/rtos/tasks.c **** 		portENTER_CRITICAL();
1321:common/rtos/tasks.c **** 		{
1322:common/rtos/tasks.c **** 			pcTraceBuffer = ( signed char * )pcBuffer;
1323:common/rtos/tasks.c **** 			pcTraceBufferStart = pcBuffer;
1324:common/rtos/tasks.c **** 			pcTraceBufferEnd = pcBuffer + ( ulBufferSize - tskSIZE_OF_EACH_TRACE_LINE );
1325:common/rtos/tasks.c **** 			xTracing = pdTRUE;
1326:common/rtos/tasks.c **** 		}
1327:common/rtos/tasks.c **** 		portEXIT_CRITICAL();
1328:common/rtos/tasks.c **** 	}
1329:common/rtos/tasks.c **** 
1330:common/rtos/tasks.c **** #endif
1331:common/rtos/tasks.c **** /*----------------------------------------------------------*/
1332:common/rtos/tasks.c **** 
1333:common/rtos/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
1334:common/rtos/tasks.c **** 
1335:common/rtos/tasks.c **** 	unsigned long ulTaskEndTrace( void )
1336:common/rtos/tasks.c **** 	{
1337:common/rtos/tasks.c **** 	unsigned long ulBufferLength;
1338:common/rtos/tasks.c **** 
1339:common/rtos/tasks.c **** 		portENTER_CRITICAL();
1340:common/rtos/tasks.c **** 			xTracing = pdFALSE;
1341:common/rtos/tasks.c **** 		portEXIT_CRITICAL();
1342:common/rtos/tasks.c **** 
1343:common/rtos/tasks.c **** 		ulBufferLength = ( unsigned long ) ( pcTraceBuffer - pcTraceBufferStart );
1344:common/rtos/tasks.c **** 
1345:common/rtos/tasks.c **** 		return ulBufferLength;
1346:common/rtos/tasks.c **** 	}
1347:common/rtos/tasks.c **** 
1348:common/rtos/tasks.c **** #endif
1349:common/rtos/tasks.c **** 
1350:common/rtos/tasks.c **** 
1351:common/rtos/tasks.c **** 
1352:common/rtos/tasks.c **** /*-----------------------------------------------------------
1353:common/rtos/tasks.c ****  * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
1354:common/rtos/tasks.c ****  * documented in task.h
1355:common/rtos/tasks.c ****  *----------------------------------------------------------*/
1356:common/rtos/tasks.c **** 
1357:common/rtos/tasks.c **** 
1358:common/rtos/tasks.c **** void vTaskIncrementTick( void )
1359:common/rtos/tasks.c **** {
 2110              		.loc 1 1359 1
 2111              		.cfi_startproc
 2112              		@ args = 0, pretend = 0, frame = 8
 2113              		@ frame_needed = 1, uses_anonymous_args = 0
 2114 0000 90B5     		push	{r4, r7, lr}
 2115              	.LCFI76:
 2116              		.cfi_def_cfa_offset 12
 2117              		.cfi_offset 4, -12
 2118              		.cfi_offset 7, -8
 2119              		.cfi_offset 14, -4
 2120 0002 83B0     		sub	sp, sp, #12
 2121              	.LCFI77:
 2122              		.cfi_def_cfa_offset 24
 2123 0004 00AF     		add	r7, sp, #0
 2124              	.LCFI78:
 2125              		.cfi_def_cfa_register 7
1360:common/rtos/tasks.c **** 	/* Called by the portable layer each time a tick interrupt occurs.
1361:common/rtos/tasks.c **** 	Increments the tick then checks to see if the new tick value will cause any
1362:common/rtos/tasks.c **** 	tasks to be unblocked. */
1363:common/rtos/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 2126              		.loc 1 1363 27
 2127 0006 324B     		ldr	r3, .L135
 2128 0008 1B68     		ldr	r3, [r3]
 2129              		.loc 1 1363 4
 2130 000a 002B     		cmp	r3, #0
 2131 000c 4CD1     		bne	.L121
1364:common/rtos/tasks.c **** 	{
1365:common/rtos/tasks.c **** 		++xTickCount;
 2132              		.loc 1 1365 3
 2133 000e 314B     		ldr	r3, .L135+4
 2134 0010 1B68     		ldr	r3, [r3]
 2135 0012 0133     		adds	r3, r3, #1
 2136 0014 2F4A     		ldr	r2, .L135+4
 2137 0016 1360     		str	r3, [r2]
1366:common/rtos/tasks.c **** 		if( xTickCount == ( portTickType ) 0 )
 2138              		.loc 1 1366 18
 2139 0018 2E4B     		ldr	r3, .L135+4
 2140 001a 1B68     		ldr	r3, [r3]
 2141              		.loc 1 1366 5
 2142 001c 002B     		cmp	r3, #0
 2143 001e 34D1     		bne	.L123
 2144              	.LBB4:
1367:common/rtos/tasks.c **** 		{
1368:common/rtos/tasks.c **** 			xList *pxTemp;
1369:common/rtos/tasks.c **** 
1370:common/rtos/tasks.c **** 			/* Tick count has overflowed so we need to swap the delay lists.
1371:common/rtos/tasks.c **** 			If there are any items in pxDelayedTaskList here then there is
1372:common/rtos/tasks.c **** 			an error! */
1373:common/rtos/tasks.c **** 			pxTemp = pxDelayedTaskList;
 2145              		.loc 1 1373 11
 2146 0020 2D4B     		ldr	r3, .L135+8
 2147 0022 1B68     		ldr	r3, [r3]
 2148 0024 7B60     		str	r3, [r7, #4]
1374:common/rtos/tasks.c **** 			pxDelayedTaskList = pxOverflowDelayedTaskList;
 2149              		.loc 1 1374 22
 2150 0026 2D4B     		ldr	r3, .L135+12
 2151 0028 1B68     		ldr	r3, [r3]
 2152 002a 2B4A     		ldr	r2, .L135+8
 2153 002c 1360     		str	r3, [r2]
1375:common/rtos/tasks.c **** 			pxOverflowDelayedTaskList = pxTemp;
 2154              		.loc 1 1375 30
 2155 002e 2B4A     		ldr	r2, .L135+12
 2156 0030 7B68     		ldr	r3, [r7, #4]
 2157 0032 1360     		str	r3, [r2]
1376:common/rtos/tasks.c **** 			xNumOfOverflows++;
 2158              		.loc 1 1376 19
 2159 0034 2A4B     		ldr	r3, .L135+16
 2160 0036 1B68     		ldr	r3, [r3]
 2161 0038 0133     		adds	r3, r3, #1
 2162 003a 294A     		ldr	r2, .L135+16
 2163 003c 1360     		str	r3, [r2]
 2164              	.LBE4:
 2165              	.LBB5:
1377:common/rtos/tasks.c **** 		}
1378:common/rtos/tasks.c **** 
1379:common/rtos/tasks.c **** 		/* See if this tick has made a timeout expire. */
1380:common/rtos/tasks.c **** 		prvCheckDelayedTasks();
 2166              		.loc 1 1380 3
 2167 003e 24E0     		b	.L123
 2168              	.L130:
 2169              		.loc 1 1380 3 is_stmt 0 discriminator 13
 2170 0040 6268     		ldr	r2, [r4, #4]
 2171 0042 244B     		ldr	r3, .L135+4
 2172 0044 1B68     		ldr	r3, [r3]
 2173 0046 9A42     		cmp	r2, r3
 2174 0048 36D8     		bhi	.L133
 2175              		.loc 1 1380 3 discriminator 1
 2176 004a 231D     		adds	r3, r4, #4
 2177 004c 1846     		mov	r0, r3
 2178 004e 254B     		ldr	r3, .L135+20
 2179 0050 9847     		blx	r3
 2180              	.LVL61:
 2181 0052 A36A     		ldr	r3, [r4, #40]
 2182 0054 002B     		cmp	r3, #0
 2183 0056 04D0     		beq	.L126
 2184              		.loc 1 1380 3 discriminator 2
 2185 0058 04F11803 		add	r3, r4, #24
 2186 005c 1846     		mov	r0, r3
 2187 005e 214B     		ldr	r3, .L135+20
 2188 0060 9847     		blx	r3
 2189              	.LVL62:
 2190              	.L126:
 2191              		.loc 1 1380 3 discriminator 4
 2192 0062 E26A     		ldr	r2, [r4, #44]
 2193 0064 204B     		ldr	r3, .L135+24
 2194 0066 1B68     		ldr	r3, [r3]
 2195 0068 9A42     		cmp	r2, r3
 2196 006a 02D9     		bls	.L127
 2197              		.loc 1 1380 3 discriminator 5
 2198 006c E36A     		ldr	r3, [r4, #44]
 2199 006e 1E4A     		ldr	r2, .L135+24
 2200 0070 1360     		str	r3, [r2]
 2201              	.L127:
 2202              		.loc 1 1380 3 discriminator 7
 2203 0072 E26A     		ldr	r2, [r4, #44]
 2204 0074 1346     		mov	r3, r2
 2205 0076 9B00     		lsls	r3, r3, #2
 2206 0078 1344     		add	r3, r3, r2
 2207 007a 9B00     		lsls	r3, r3, #2
 2208 007c 1B4A     		ldr	r2, .L135+28
 2209 007e 1344     		add	r3, r3, r2
 2210 0080 221D     		adds	r2, r4, #4
 2211 0082 1146     		mov	r1, r2
 2212 0084 1846     		mov	r0, r3
 2213 0086 1A4B     		ldr	r3, .L135+32
 2214 0088 9847     		blx	r3
 2215              	.LVL63:
 2216              	.L123:
 2217              		.loc 1 1380 3 discriminator 8
 2218 008a 134B     		ldr	r3, .L135+8
 2219 008c 1B68     		ldr	r3, [r3]
 2220 008e 1B68     		ldr	r3, [r3]
 2221 0090 002B     		cmp	r3, #0
 2222 0092 04D0     		beq	.L128
 2223              		.loc 1 1380 3 discriminator 9
 2224 0094 104B     		ldr	r3, .L135+8
 2225 0096 1B68     		ldr	r3, [r3]
 2226 0098 DB68     		ldr	r3, [r3, #12]
 2227 009a DB68     		ldr	r3, [r3, #12]
 2228 009c 00E0     		b	.L129
 2229              	.L128:
 2230              		.loc 1 1380 3 discriminator 10
 2231 009e 0023     		movs	r3, #0
 2232              	.L129:
 2233              		.loc 1 1380 3 discriminator 12
 2234 00a0 1C46     		mov	r4, r3
 2235 00a2 002C     		cmp	r4, #0
 2236 00a4 CCD1     		bne	.L130
 2237 00a6 08E0     		b	.L131
 2238              	.L121:
 2239              	.LBE5:
1381:common/rtos/tasks.c **** 	}
1382:common/rtos/tasks.c **** 	else
1383:common/rtos/tasks.c **** 	{
1384:common/rtos/tasks.c **** 		++uxMissedTicks;
 2240              		.loc 1 1384 3 is_stmt 1
 2241 00a8 124B     		ldr	r3, .L135+36
 2242 00aa 1B68     		ldr	r3, [r3]
 2243 00ac 0133     		adds	r3, r3, #1
 2244 00ae 114A     		ldr	r2, .L135+36
 2245 00b0 1360     		str	r3, [r2]
 2246              	.LBB6:
1385:common/rtos/tasks.c **** 
1386:common/rtos/tasks.c **** 		/* The tick hook gets called at regular intervals, even if the
1387:common/rtos/tasks.c **** 		scheduler is locked. */
1388:common/rtos/tasks.c **** 		#if ( configUSE_TICK_HOOK == 1 )
1389:common/rtos/tasks.c **** 		{
1390:common/rtos/tasks.c **** 			extern void vApplicationTickHook( void );
1391:common/rtos/tasks.c **** 
1392:common/rtos/tasks.c **** 			vApplicationTickHook();
 2247              		.loc 1 1392 4
 2248 00b2 114B     		ldr	r3, .L135+40
 2249 00b4 9847     		blx	r3
 2250              	.LVL64:
 2251 00b6 00E0     		b	.L131
 2252              	.L133:
 2253              	.LBE6:
 2254              	.LBB7:
1380:common/rtos/tasks.c **** 	}
 2255              		.loc 1 1380 3
 2256 00b8 00BF     		nop
 2257              	.L131:
 2258              	.LBE7:
 2259              	.LBB8:
1393:common/rtos/tasks.c **** 		}
1394:common/rtos/tasks.c **** 		#endif
1395:common/rtos/tasks.c **** 	}
1396:common/rtos/tasks.c **** 
1397:common/rtos/tasks.c **** 	#if ( configUSE_TICK_HOOK == 1 )
1398:common/rtos/tasks.c **** 	{
1399:common/rtos/tasks.c **** 		extern void vApplicationTickHook( void );
1400:common/rtos/tasks.c **** 
1401:common/rtos/tasks.c **** 		/* Guard against the tick hook being called when the missed tick
1402:common/rtos/tasks.c **** 		count is being unwound (when the scheduler is being unlocked. */
1403:common/rtos/tasks.c **** 		if( uxMissedTicks == 0 )
 2260              		.loc 1 1403 21
 2261 00ba 0E4B     		ldr	r3, .L135+36
 2262 00bc 1B68     		ldr	r3, [r3]
 2263              		.loc 1 1403 5
 2264 00be 002B     		cmp	r3, #0
 2265 00c0 01D1     		bne	.L134
1404:common/rtos/tasks.c **** 		{
1405:common/rtos/tasks.c **** 			vApplicationTickHook();
 2266              		.loc 1 1405 4
 2267 00c2 0D4B     		ldr	r3, .L135+40
 2268 00c4 9847     		blx	r3
 2269              	.LVL65:
 2270              	.L134:
 2271              	.LBE8:
1406:common/rtos/tasks.c **** 		}
1407:common/rtos/tasks.c **** 	}
1408:common/rtos/tasks.c **** 	#endif
1409:common/rtos/tasks.c **** 
1410:common/rtos/tasks.c **** 	traceTASK_INCREMENT_TICK( xTickCount );
1411:common/rtos/tasks.c **** }
 2272              		.loc 1 1411 1
 2273 00c6 00BF     		nop
 2274 00c8 0C37     		adds	r7, r7, #12
 2275              	.LCFI79:
 2276              		.cfi_def_cfa_offset 12
 2277 00ca BD46     		mov	sp, r7
 2278              	.LCFI80:
 2279              		.cfi_def_cfa_register 13
 2280              		@ sp needed
 2281 00cc 90BD     		pop	{r4, r7, pc}
 2282              	.L136:
 2283 00ce 00BF     		.align	2
 2284              	.L135:
 2285 00d0 00000000 		.word	uxSchedulerSuspended
 2286 00d4 00000000 		.word	xTickCount
 2287 00d8 00000000 		.word	pxDelayedTaskList
 2288 00dc 00000000 		.word	pxOverflowDelayedTaskList
 2289 00e0 00000000 		.word	xNumOfOverflows
 2290 00e4 00000000 		.word	vListRemove
 2291 00e8 00000000 		.word	uxTopReadyPriority
 2292 00ec 00000000 		.word	pxReadyTasksLists
 2293 00f0 00000000 		.word	vListInsertEnd
 2294 00f4 00000000 		.word	uxMissedTicks
 2295 00f8 00000000 		.word	vApplicationTickHook
 2296              		.cfi_endproc
 2297              	.LFE46:
 2299              		.section	.text.vTaskSwitchContext,"ax",%progbits
 2300              		.align	1
 2301              		.global	vTaskSwitchContext
 2302              		.syntax unified
 2303              		.thumb
 2304              		.thumb_func
 2306              	vTaskSwitchContext:
 2307              	.LFB47:
1412:common/rtos/tasks.c **** /*-----------------------------------------------------------*/
1413:common/rtos/tasks.c **** 
1414:common/rtos/tasks.c **** #if ( ( INCLUDE_vTaskCleanUpResources == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )
1415:common/rtos/tasks.c **** 
1416:common/rtos/tasks.c **** 	void vTaskCleanUpResources( void )
1417:common/rtos/tasks.c **** 	{
1418:common/rtos/tasks.c **** 	unsigned short usQueue;
1419:common/rtos/tasks.c **** 	volatile tskTCB *pxTCB;
1420:common/rtos/tasks.c **** 
1421:common/rtos/tasks.c **** 		usQueue = ( unsigned short ) uxTopUsedPriority + ( unsigned short ) 1;
1422:common/rtos/tasks.c **** 
1423:common/rtos/tasks.c **** 		/* Remove any TCB's from the ready queues. */
1424:common/rtos/tasks.c **** 		do
1425:common/rtos/tasks.c **** 		{
1426:common/rtos/tasks.c **** 			usQueue--;
1427:common/rtos/tasks.c **** 
1428:common/rtos/tasks.c **** 			while( !listLIST_IS_EMPTY( &( pxReadyTasksLists[ usQueue ] ) ) )
1429:common/rtos/tasks.c **** 			{
1430:common/rtos/tasks.c **** 				listGET_OWNER_OF_NEXT_ENTRY( pxTCB, &( pxReadyTasksLists[ usQueue ] ) );
1431:common/rtos/tasks.c **** 				vListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) );
1432:common/rtos/tasks.c **** 
1433:common/rtos/tasks.c **** 				prvDeleteTCB( ( tskTCB * ) pxTCB );
1434:common/rtos/tasks.c **** 			}
1435:common/rtos/tasks.c **** 		}while( usQueue > ( unsigned short ) tskIDLE_PRIORITY );
1436:common/rtos/tasks.c **** 
1437:common/rtos/tasks.c **** 		/* Remove any TCB's from the delayed queue. */
1438:common/rtos/tasks.c **** 		while( !listLIST_IS_EMPTY( &xDelayedTaskList1 ) )
1439:common/rtos/tasks.c **** 		{
1440:common/rtos/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxTCB, &xDelayedTaskList1 );
1441:common/rtos/tasks.c **** 			vListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) );
1442:common/rtos/tasks.c **** 
1443:common/rtos/tasks.c **** 			prvDeleteTCB( ( tskTCB * ) pxTCB );
1444:common/rtos/tasks.c **** 		}
1445:common/rtos/tasks.c **** 
1446:common/rtos/tasks.c **** 		/* Remove any TCB's from the overflow delayed queue. */
1447:common/rtos/tasks.c **** 		while( !listLIST_IS_EMPTY( &xDelayedTaskList2 ) )
1448:common/rtos/tasks.c **** 		{
1449:common/rtos/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxTCB, &xDelayedTaskList2 );
1450:common/rtos/tasks.c **** 			vListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) );
1451:common/rtos/tasks.c **** 
1452:common/rtos/tasks.c **** 			prvDeleteTCB( ( tskTCB * ) pxTCB );
1453:common/rtos/tasks.c **** 		}
1454:common/rtos/tasks.c **** 
1455:common/rtos/tasks.c **** 		while( !listLIST_IS_EMPTY( &xSuspendedTaskList ) )
1456:common/rtos/tasks.c **** 		{
1457:common/rtos/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxTCB, &xSuspendedTaskList );
1458:common/rtos/tasks.c **** 			vListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) );
1459:common/rtos/tasks.c **** 
1460:common/rtos/tasks.c **** 			prvDeleteTCB( ( tskTCB * ) pxTCB );
1461:common/rtos/tasks.c **** 		}
1462:common/rtos/tasks.c **** 	}
1463:common/rtos/tasks.c **** 
1464:common/rtos/tasks.c **** #endif
1465:common/rtos/tasks.c **** /*-----------------------------------------------------------*/
1466:common/rtos/tasks.c **** 
1467:common/rtos/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1468:common/rtos/tasks.c **** 
1469:common/rtos/tasks.c **** 	void vTaskSetApplicationTaskTag( xTaskHandle xTask, pdTASK_HOOK_CODE pxTagValue )
1470:common/rtos/tasks.c **** 	{
1471:common/rtos/tasks.c **** 	tskTCB *xTCB;
1472:common/rtos/tasks.c **** 
1473:common/rtos/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
1474:common/rtos/tasks.c **** 		if( xTask == NULL )
1475:common/rtos/tasks.c **** 		{
1476:common/rtos/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1477:common/rtos/tasks.c **** 		}
1478:common/rtos/tasks.c **** 		else
1479:common/rtos/tasks.c **** 		{
1480:common/rtos/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1481:common/rtos/tasks.c **** 		}
1482:common/rtos/tasks.c **** 
1483:common/rtos/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
1484:common/rtos/tasks.c **** 		the value can be accessed from an interrupt. */
1485:common/rtos/tasks.c **** 		portENTER_CRITICAL();
1486:common/rtos/tasks.c **** 			xTCB->pxTaskTag = pxTagValue;
1487:common/rtos/tasks.c **** 		portEXIT_CRITICAL();
1488:common/rtos/tasks.c **** 	}
1489:common/rtos/tasks.c **** 
1490:common/rtos/tasks.c **** #endif
1491:common/rtos/tasks.c **** /*-----------------------------------------------------------*/
1492:common/rtos/tasks.c **** 
1493:common/rtos/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1494:common/rtos/tasks.c **** 
1495:common/rtos/tasks.c **** 	pdTASK_HOOK_CODE xTaskGetApplicationTaskTag( xTaskHandle xTask )
1496:common/rtos/tasks.c **** 	{
1497:common/rtos/tasks.c **** 	tskTCB *xTCB;
1498:common/rtos/tasks.c **** 	pdTASK_HOOK_CODE xReturn;
1499:common/rtos/tasks.c **** 
1500:common/rtos/tasks.c **** 		/* If xTask is NULL then we are setting our own task hook. */
1501:common/rtos/tasks.c **** 		if( xTask == NULL )
1502:common/rtos/tasks.c **** 		{
1503:common/rtos/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1504:common/rtos/tasks.c **** 		}
1505:common/rtos/tasks.c **** 		else
1506:common/rtos/tasks.c **** 		{
1507:common/rtos/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1508:common/rtos/tasks.c **** 		}
1509:common/rtos/tasks.c **** 
1510:common/rtos/tasks.c **** 		/* Save the hook function in the TCB.  A critical section is required as
1511:common/rtos/tasks.c **** 		the value can be accessed from an interrupt. */
1512:common/rtos/tasks.c **** 		portENTER_CRITICAL();
1513:common/rtos/tasks.c **** 			xReturn = xTCB->pxTaskTag;
1514:common/rtos/tasks.c **** 		portEXIT_CRITICAL();
1515:common/rtos/tasks.c **** 
1516:common/rtos/tasks.c **** 		return xReturn;
1517:common/rtos/tasks.c **** 	}
1518:common/rtos/tasks.c **** 
1519:common/rtos/tasks.c **** #endif
1520:common/rtos/tasks.c **** /*-----------------------------------------------------------*/
1521:common/rtos/tasks.c **** 
1522:common/rtos/tasks.c **** #if ( configUSE_APPLICATION_TASK_TAG == 1 )
1523:common/rtos/tasks.c **** 
1524:common/rtos/tasks.c **** 	portBASE_TYPE xTaskCallApplicationTaskHook( xTaskHandle xTask, void *pvParameter )
1525:common/rtos/tasks.c **** 	{
1526:common/rtos/tasks.c **** 	tskTCB *xTCB;
1527:common/rtos/tasks.c **** 	portBASE_TYPE xReturn;
1528:common/rtos/tasks.c **** 
1529:common/rtos/tasks.c **** 		/* If xTask is NULL then we are calling our own task hook. */
1530:common/rtos/tasks.c **** 		if( xTask == NULL )
1531:common/rtos/tasks.c **** 		{
1532:common/rtos/tasks.c **** 			xTCB = ( tskTCB * ) pxCurrentTCB;
1533:common/rtos/tasks.c **** 		}
1534:common/rtos/tasks.c **** 		else
1535:common/rtos/tasks.c **** 		{
1536:common/rtos/tasks.c **** 			xTCB = ( tskTCB * ) xTask;
1537:common/rtos/tasks.c **** 		}
1538:common/rtos/tasks.c **** 
1539:common/rtos/tasks.c **** 		if( xTCB->pxTaskTag != NULL )
1540:common/rtos/tasks.c **** 		{
1541:common/rtos/tasks.c **** 			xReturn = xTCB->pxTaskTag( pvParameter );
1542:common/rtos/tasks.c **** 		}
1543:common/rtos/tasks.c **** 		else
1544:common/rtos/tasks.c **** 		{
1545:common/rtos/tasks.c **** 			xReturn = pdFAIL;
1546:common/rtos/tasks.c **** 		}
1547:common/rtos/tasks.c **** 
1548:common/rtos/tasks.c **** 		return xReturn;
1549:common/rtos/tasks.c **** 	}
1550:common/rtos/tasks.c **** 
1551:common/rtos/tasks.c **** #endif
1552:common/rtos/tasks.c **** /*-----------------------------------------------------------*/
1553:common/rtos/tasks.c **** 
1554:common/rtos/tasks.c **** void vTaskSwitchContext( void )
1555:common/rtos/tasks.c **** {
 2308              		.loc 1 1555 1
 2309              		.cfi_startproc
 2310              		@ args = 0, pretend = 0, frame = 8
 2311              		@ frame_needed = 1, uses_anonymous_args = 0
 2312              		@ link register save eliminated.
 2313 0000 80B4     		push	{r7}
 2314              	.LCFI81:
 2315              		.cfi_def_cfa_offset 4
 2316              		.cfi_offset 7, -4
 2317 0002 83B0     		sub	sp, sp, #12
 2318              	.LCFI82:
 2319              		.cfi_def_cfa_offset 16
 2320 0004 00AF     		add	r7, sp, #0
 2321              	.LCFI83:
 2322              		.cfi_def_cfa_register 7
1556:common/rtos/tasks.c **** 	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 2323              		.loc 1 1556 27
 2324 0006 1D4B     		ldr	r3, .L143
 2325 0008 1B68     		ldr	r3, [r3]
 2326              		.loc 1 1556 4
 2327 000a 002B     		cmp	r3, #0
 2328 000c 08D0     		beq	.L140
1557:common/rtos/tasks.c **** 	{
1558:common/rtos/tasks.c **** 		/* The scheduler is currently suspended - do not allow a context
1559:common/rtos/tasks.c **** 		switch. */
1560:common/rtos/tasks.c **** 		xMissedYield = pdTRUE;
 2329              		.loc 1 1560 16
 2330 000e 1C4B     		ldr	r3, .L143+4
 2331 0010 0122     		movs	r2, #1
 2332 0012 1A60     		str	r2, [r3]
1561:common/rtos/tasks.c **** 		return;
 2333              		.loc 1 1561 3
 2334 0014 2DE0     		b	.L137
 2335              	.L141:
1562:common/rtos/tasks.c **** 	}
1563:common/rtos/tasks.c **** 
1564:common/rtos/tasks.c **** 	traceTASK_SWITCHED_OUT();
1565:common/rtos/tasks.c **** 
1566:common/rtos/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
1567:common/rtos/tasks.c **** 	{
1568:common/rtos/tasks.c **** 		unsigned long ulTempCounter = portGET_RUN_TIME_COUNTER_VALUE();
1569:common/rtos/tasks.c **** 
1570:common/rtos/tasks.c **** 			/* Add the amount of time the task has been running to the accumulated
1571:common/rtos/tasks.c **** 			time so far.  The time the task started running was stored in
1572:common/rtos/tasks.c **** 			ulTaskSwitchedInTime.  Note that there is no overflow protection here
1573:common/rtos/tasks.c **** 			so count values are only valid until the timer overflows.  Generally
1574:common/rtos/tasks.c **** 			this will be about 1 hour assuming a 1uS timer increment. */
1575:common/rtos/tasks.c **** 			pxCurrentTCB->ulRunTimeCounter += ( ulTempCounter - ulTaskSwitchedInTime );
1576:common/rtos/tasks.c **** 			ulTaskSwitchedInTime = ulTempCounter;
1577:common/rtos/tasks.c **** 	}
1578:common/rtos/tasks.c **** 	#endif
1579:common/rtos/tasks.c **** 
1580:common/rtos/tasks.c **** 	taskFIRST_CHECK_FOR_STACK_OVERFLOW();
1581:common/rtos/tasks.c **** 	taskSECOND_CHECK_FOR_STACK_OVERFLOW();
1582:common/rtos/tasks.c **** 
1583:common/rtos/tasks.c **** 	/* Find the highest priority queue that contains ready tasks. */
1584:common/rtos/tasks.c **** 	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
1585:common/rtos/tasks.c **** 	{
1586:common/rtos/tasks.c **** 		--uxTopReadyPriority;
 2336              		.loc 1 1586 3
 2337 0016 1B4B     		ldr	r3, .L143+8
 2338 0018 1B68     		ldr	r3, [r3]
 2339 001a 013B     		subs	r3, r3, #1
 2340 001c 194A     		ldr	r2, .L143+8
 2341 001e 1360     		str	r3, [r2]
 2342              	.L140:
1584:common/rtos/tasks.c **** 	{
 2343              		.loc 1 1584 9
 2344 0020 184B     		ldr	r3, .L143+8
 2345 0022 1A68     		ldr	r2, [r3]
 2346 0024 1849     		ldr	r1, .L143+12
 2347 0026 1346     		mov	r3, r2
 2348 0028 9B00     		lsls	r3, r3, #2
 2349 002a 1344     		add	r3, r3, r2
 2350 002c 9B00     		lsls	r3, r3, #2
 2351 002e 0B44     		add	r3, r3, r1
 2352 0030 1B68     		ldr	r3, [r3]
1584:common/rtos/tasks.c **** 	{
 2353              		.loc 1 1584 7
 2354 0032 002B     		cmp	r3, #0
 2355 0034 EFD0     		beq	.L141
 2356              	.LBB9:
1587:common/rtos/tasks.c **** 	}
1588:common/rtos/tasks.c **** 
1589:common/rtos/tasks.c **** 	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
1590:common/rtos/tasks.c **** 	same priority get an equal share of the processor time. */
1591:common/rtos/tasks.c **** 	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
 2357              		.loc 1 1591 2
 2358 0036 134B     		ldr	r3, .L143+8
 2359 0038 1A68     		ldr	r2, [r3]
 2360 003a 1346     		mov	r3, r2
 2361 003c 9B00     		lsls	r3, r3, #2
 2362 003e 1344     		add	r3, r3, r2
 2363 0040 9B00     		lsls	r3, r3, #2
 2364 0042 114A     		ldr	r2, .L143+12
 2365 0044 1344     		add	r3, r3, r2
 2366 0046 7B60     		str	r3, [r7, #4]
 2367 0048 7B68     		ldr	r3, [r7, #4]
 2368 004a 5B68     		ldr	r3, [r3, #4]
 2369 004c 5A68     		ldr	r2, [r3, #4]
 2370 004e 7B68     		ldr	r3, [r7, #4]
 2371 0050 5A60     		str	r2, [r3, #4]
 2372 0052 7B68     		ldr	r3, [r7, #4]
 2373 0054 5A68     		ldr	r2, [r3, #4]
 2374 0056 7B68     		ldr	r3, [r7, #4]
 2375 0058 0833     		adds	r3, r3, #8
 2376 005a 9A42     		cmp	r2, r3
 2377 005c 04D1     		bne	.L142
 2378              		.loc 1 1591 2 is_stmt 0 discriminator 1
 2379 005e 7B68     		ldr	r3, [r7, #4]
 2380 0060 5B68     		ldr	r3, [r3, #4]
 2381 0062 5A68     		ldr	r2, [r3, #4]
 2382 0064 7B68     		ldr	r3, [r7, #4]
 2383 0066 5A60     		str	r2, [r3, #4]
 2384              	.L142:
 2385              		.loc 1 1591 2 discriminator 3
 2386 0068 7B68     		ldr	r3, [r7, #4]
 2387 006a 5B68     		ldr	r3, [r3, #4]
 2388 006c DB68     		ldr	r3, [r3, #12]
 2389 006e 074A     		ldr	r2, .L143+16
 2390 0070 1360     		str	r3, [r2]
 2391              	.L137:
 2392              	.LBE9:
1592:common/rtos/tasks.c **** 
1593:common/rtos/tasks.c **** 	traceTASK_SWITCHED_IN();
1594:common/rtos/tasks.c **** 	vWriteTraceToBuffer();
1595:common/rtos/tasks.c **** }
 2393              		.loc 1 1595 1 is_stmt 1
 2394 0072 0C37     		adds	r7, r7, #12
 2395              	.LCFI84:
 2396              		.cfi_def_cfa_offset 4
 2397 0074 BD46     		mov	sp, r7
 2398              	.LCFI85:
 2399              		.cfi_def_cfa_register 13
 2400              		@ sp needed
 2401 0076 80BC     		pop	{r7}
 2402              	.LCFI86:
 2403              		.cfi_restore 7
 2404              		.cfi_def_cfa_offset 0
 2405 0078 7047     		bx	lr
 2406              	.L144:
 2407 007a 00BF     		.align	2
 2408              	.L143:
 2409 007c 00000000 		.word	uxSchedulerSuspended
 2410 0080 00000000 		.word	xMissedYield
 2411 0084 00000000 		.word	uxTopReadyPriority
 2412 0088 00000000 		.word	pxReadyTasksLists
 2413 008c 00000000 		.word	pxCurrentTCB
 2414              		.cfi_endproc
 2415              	.LFE47:
 2417              		.section	.text.vTaskPlaceOnEventList,"ax",%progbits
 2418              		.align	1
 2419              		.global	vTaskPlaceOnEventList
 2420              		.syntax unified
 2421              		.thumb
 2422              		.thumb_func
 2424              	vTaskPlaceOnEventList:
 2425              	.LFB48:
1596:common/rtos/tasks.c **** /*-----------------------------------------------------------*/
1597:common/rtos/tasks.c **** 
1598:common/rtos/tasks.c **** void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
1599:common/rtos/tasks.c **** {
 2426              		.loc 1 1599 1
 2427              		.cfi_startproc
 2428              		@ args = 0, pretend = 0, frame = 16
 2429              		@ frame_needed = 1, uses_anonymous_args = 0
 2430 0000 80B5     		push	{r7, lr}
 2431              	.LCFI87:
 2432              		.cfi_def_cfa_offset 8
 2433              		.cfi_offset 7, -8
 2434              		.cfi_offset 14, -4
 2435 0002 84B0     		sub	sp, sp, #16
 2436              	.LCFI88:
 2437              		.cfi_def_cfa_offset 24
 2438 0004 00AF     		add	r7, sp, #0
 2439              	.LCFI89:
 2440              		.cfi_def_cfa_register 7
 2441 0006 7860     		str	r0, [r7, #4]
 2442 0008 3960     		str	r1, [r7]
1600:common/rtos/tasks.c **** portTickType xTimeToWake;
1601:common/rtos/tasks.c **** 
1602:common/rtos/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1603:common/rtos/tasks.c **** 	SCHEDULER SUSPENDED. */
1604:common/rtos/tasks.c **** 
1605:common/rtos/tasks.c **** 	/* Place the event list item of the TCB in the appropriate event list.
1606:common/rtos/tasks.c **** 	This is placed in the list in priority order so the highest priority task
1607:common/rtos/tasks.c **** 	is the first to be woken by the event. */
1608:common/rtos/tasks.c **** 	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
 2443              		.loc 1 1608 71
 2444 000a 1F4B     		ldr	r3, .L150
 2445 000c 1B68     		ldr	r3, [r3]
 2446              		.loc 1 1608 2
 2447 000e 1833     		adds	r3, r3, #24
 2448 0010 1946     		mov	r1, r3
 2449 0012 7868     		ldr	r0, [r7, #4]
 2450 0014 1D4B     		ldr	r3, .L150+4
 2451 0016 9847     		blx	r3
 2452              	.LVL66:
1609:common/rtos/tasks.c **** 
1610:common/rtos/tasks.c **** 	/* We must remove ourselves from the ready list before adding ourselves
1611:common/rtos/tasks.c **** 	to the blocked list as the same list item is used for both lists.  We have
1612:common/rtos/tasks.c **** 	exclusive access to the ready lists as the scheduler is locked. */
1613:common/rtos/tasks.c **** 	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 2453              		.loc 1 1613 46
 2454 0018 1B4B     		ldr	r3, .L150
 2455 001a 1B68     		ldr	r3, [r3]
 2456              		.loc 1 1613 2
 2457 001c 0433     		adds	r3, r3, #4
 2458 001e 1846     		mov	r0, r3
 2459 0020 1B4B     		ldr	r3, .L150+8
 2460 0022 9847     		blx	r3
 2461              	.LVL67:
1614:common/rtos/tasks.c **** 
1615:common/rtos/tasks.c **** 
1616:common/rtos/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
1617:common/rtos/tasks.c **** 	{
1618:common/rtos/tasks.c **** 		if( xTicksToWait == portMAX_DELAY )
 2462              		.loc 1 1618 5
 2463 0024 3B68     		ldr	r3, [r7]
 2464 0026 B3F1FF3F 		cmp	r3, #-1
 2465 002a 07D1     		bne	.L146
1619:common/rtos/tasks.c **** 		{
1620:common/rtos/tasks.c **** 			/* Add ourselves to the suspended task list instead of a delayed task
1621:common/rtos/tasks.c **** 			list to ensure we are not woken by a timing event.  We will block
1622:common/rtos/tasks.c **** 			indefinitely. */
1623:common/rtos/tasks.c **** 			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListIt
 2466              		.loc 1 1623 84
 2467 002c 164B     		ldr	r3, .L150
 2468 002e 1B68     		ldr	r3, [r3]
 2469              		.loc 1 1623 4
 2470 0030 0433     		adds	r3, r3, #4
 2471 0032 1946     		mov	r1, r3
 2472 0034 1748     		ldr	r0, .L150+12
 2473 0036 184B     		ldr	r3, .L150+16
 2474 0038 9847     		blx	r3
 2475              	.LVL68:
1624:common/rtos/tasks.c **** 		}
1625:common/rtos/tasks.c **** 		else
1626:common/rtos/tasks.c **** 		{
1627:common/rtos/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
1628:common/rtos/tasks.c **** 			not occur.  This may overflow but this doesn't matter. */
1629:common/rtos/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
1630:common/rtos/tasks.c **** 
1631:common/rtos/tasks.c **** 			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
1632:common/rtos/tasks.c **** 
1633:common/rtos/tasks.c **** 			if( xTimeToWake < xTickCount )
1634:common/rtos/tasks.c **** 			{
1635:common/rtos/tasks.c **** 				/* Wake time has overflowed.  Place this item in the overflow list. */
1636:common/rtos/tasks.c **** 				vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericLi
1637:common/rtos/tasks.c **** 			}
1638:common/rtos/tasks.c **** 			else
1639:common/rtos/tasks.c **** 			{
1640:common/rtos/tasks.c **** 				/* The wake time has not overflowed, so we can use the current block list. */
1641:common/rtos/tasks.c **** 				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem )
1642:common/rtos/tasks.c **** 			}
1643:common/rtos/tasks.c **** 		}
1644:common/rtos/tasks.c **** 	}
1645:common/rtos/tasks.c **** 	#else
1646:common/rtos/tasks.c **** 	{
1647:common/rtos/tasks.c **** 			/* Calculate the time at which the task should be woken if the event does
1648:common/rtos/tasks.c **** 			not occur.  This may overflow but this doesn't matter. */
1649:common/rtos/tasks.c **** 			xTimeToWake = xTickCount + xTicksToWait;
1650:common/rtos/tasks.c **** 
1651:common/rtos/tasks.c **** 			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
1652:common/rtos/tasks.c **** 
1653:common/rtos/tasks.c **** 			if( xTimeToWake < xTickCount )
1654:common/rtos/tasks.c **** 			{
1655:common/rtos/tasks.c **** 				/* Wake time has overflowed.  Place this item in the overflow list. */
1656:common/rtos/tasks.c **** 				vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericLi
1657:common/rtos/tasks.c **** 			}
1658:common/rtos/tasks.c **** 			else
1659:common/rtos/tasks.c **** 			{
1660:common/rtos/tasks.c **** 				/* The wake time has not overflowed, so we can use the current block list. */
1661:common/rtos/tasks.c **** 				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem )
1662:common/rtos/tasks.c **** 			}
1663:common/rtos/tasks.c **** 	}
1664:common/rtos/tasks.c **** 	#endif
1665:common/rtos/tasks.c **** }
 2476              		.loc 1 1665 1
 2477 003a 20E0     		b	.L149
 2478              	.L146:
1629:common/rtos/tasks.c **** 
 2479              		.loc 1 1629 29
 2480 003c 174B     		ldr	r3, .L150+20
 2481 003e 1B68     		ldr	r3, [r3]
1629:common/rtos/tasks.c **** 
 2482              		.loc 1 1629 16
 2483 0040 3A68     		ldr	r2, [r7]
 2484 0042 1344     		add	r3, r3, r2
 2485 0044 FB60     		str	r3, [r7, #12]
1631:common/rtos/tasks.c **** 
 2486              		.loc 1 1631 4
 2487 0046 104B     		ldr	r3, .L150
 2488 0048 1B68     		ldr	r3, [r3]
 2489 004a FA68     		ldr	r2, [r7, #12]
 2490 004c 5A60     		str	r2, [r3, #4]
1633:common/rtos/tasks.c **** 			{
 2491              		.loc 1 1633 20
 2492 004e 134B     		ldr	r3, .L150+20
 2493 0050 1B68     		ldr	r3, [r3]
1633:common/rtos/tasks.c **** 			{
 2494              		.loc 1 1633 6
 2495 0052 FA68     		ldr	r2, [r7, #12]
 2496 0054 9A42     		cmp	r2, r3
 2497 0056 09D2     		bcs	.L148
1636:common/rtos/tasks.c **** 			}
 2498              		.loc 1 1636 5
 2499 0058 114B     		ldr	r3, .L150+24
 2500 005a 1A68     		ldr	r2, [r3]
1636:common/rtos/tasks.c **** 			}
 2501              		.loc 1 1636 88
 2502 005c 0A4B     		ldr	r3, .L150
 2503 005e 1B68     		ldr	r3, [r3]
1636:common/rtos/tasks.c **** 			}
 2504              		.loc 1 1636 5
 2505 0060 0433     		adds	r3, r3, #4
 2506 0062 1946     		mov	r1, r3
 2507 0064 1046     		mov	r0, r2
 2508 0066 094B     		ldr	r3, .L150+4
 2509 0068 9847     		blx	r3
 2510              	.LVL69:
 2511              		.loc 1 1665 1
 2512 006a 08E0     		b	.L149
 2513              	.L148:
1641:common/rtos/tasks.c **** 			}
 2514              		.loc 1 1641 5
 2515 006c 0D4B     		ldr	r3, .L150+28
 2516 006e 1A68     		ldr	r2, [r3]
1641:common/rtos/tasks.c **** 			}
 2517              		.loc 1 1641 80
 2518 0070 054B     		ldr	r3, .L150
 2519 0072 1B68     		ldr	r3, [r3]
1641:common/rtos/tasks.c **** 			}
 2520              		.loc 1 1641 5
 2521 0074 0433     		adds	r3, r3, #4
 2522 0076 1946     		mov	r1, r3
 2523 0078 1046     		mov	r0, r2
 2524 007a 044B     		ldr	r3, .L150+4
 2525 007c 9847     		blx	r3
 2526              	.LVL70:
 2527              	.L149:
 2528              		.loc 1 1665 1
 2529 007e 00BF     		nop
 2530 0080 1037     		adds	r7, r7, #16
 2531              	.LCFI90:
 2532              		.cfi_def_cfa_offset 8
 2533 0082 BD46     		mov	sp, r7
 2534              	.LCFI91:
 2535              		.cfi_def_cfa_register 13
 2536              		@ sp needed
 2537 0084 80BD     		pop	{r7, pc}
 2538              	.L151:
 2539 0086 00BF     		.align	2
 2540              	.L150:
 2541 0088 00000000 		.word	pxCurrentTCB
 2542 008c 00000000 		.word	vListInsert
 2543 0090 00000000 		.word	vListRemove
 2544 0094 00000000 		.word	xSuspendedTaskList
 2545 0098 00000000 		.word	vListInsertEnd
 2546 009c 00000000 		.word	xTickCount
 2547 00a0 00000000 		.word	pxOverflowDelayedTaskList
 2548 00a4 00000000 		.word	pxDelayedTaskList
 2549              		.cfi_endproc
 2550              	.LFE48:
 2552              		.section	.text.xTaskRemoveFromEventList,"ax",%progbits
 2553              		.align	1
 2554              		.global	xTaskRemoveFromEventList
 2555              		.syntax unified
 2556              		.thumb
 2557              		.thumb_func
 2559              	xTaskRemoveFromEventList:
 2560              	.LFB49:
1666:common/rtos/tasks.c **** /*-----------------------------------------------------------*/
1667:common/rtos/tasks.c **** 
1668:common/rtos/tasks.c **** signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
1669:common/rtos/tasks.c **** {
 2561              		.loc 1 1669 1
 2562              		.cfi_startproc
 2563              		@ args = 0, pretend = 0, frame = 16
 2564              		@ frame_needed = 1, uses_anonymous_args = 0
 2565 0000 80B5     		push	{r7, lr}
 2566              	.LCFI92:
 2567              		.cfi_def_cfa_offset 8
 2568              		.cfi_offset 7, -8
 2569              		.cfi_offset 14, -4
 2570 0002 84B0     		sub	sp, sp, #16
 2571              	.LCFI93:
 2572              		.cfi_def_cfa_offset 24
 2573 0004 00AF     		add	r7, sp, #0
 2574              	.LCFI94:
 2575              		.cfi_def_cfa_register 7
 2576 0006 7860     		str	r0, [r7, #4]
1670:common/rtos/tasks.c **** tskTCB *pxUnblockedTCB;
1671:common/rtos/tasks.c **** portBASE_TYPE xReturn;
1672:common/rtos/tasks.c **** 
1673:common/rtos/tasks.c **** 	/* THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED OR THE
1674:common/rtos/tasks.c **** 	SCHEDULER SUSPENDED.  It can also be called from within an ISR. */
1675:common/rtos/tasks.c **** 
1676:common/rtos/tasks.c **** 	/* The event list is sorted in priority order, so we can remove the
1677:common/rtos/tasks.c **** 	first in the list, remove the TCB from the delayed list, and add
1678:common/rtos/tasks.c **** 	it to the ready list.
1679:common/rtos/tasks.c **** 
1680:common/rtos/tasks.c **** 	If an event is for a queue that is locked then this function will never
1681:common/rtos/tasks.c **** 	get called - the lock count on the queue will get modified instead.  This
1682:common/rtos/tasks.c **** 	means we can always expect exclusive access to the event list here. */
1683:common/rtos/tasks.c **** 	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 2577              		.loc 1 1683 32
 2578 0008 7B68     		ldr	r3, [r7, #4]
 2579 000a 1B68     		ldr	r3, [r3]
 2580              		.loc 1 1683 19
 2581 000c 002B     		cmp	r3, #0
 2582 000e 03D0     		beq	.L153
 2583              		.loc 1 1683 32 discriminator 1
 2584 0010 7B68     		ldr	r3, [r7, #4]
 2585 0012 DB68     		ldr	r3, [r3, #12]
 2586              		.loc 1 1683 19 discriminator 1
 2587 0014 DB68     		ldr	r3, [r3, #12]
 2588 0016 00E0     		b	.L154
 2589              	.L153:
 2590              		.loc 1 1683 19 is_stmt 0 discriminator 2
 2591 0018 0023     		movs	r3, #0
 2592              	.L154:
 2593              		.loc 1 1683 17 is_stmt 1 discriminator 4
 2594 001a BB60     		str	r3, [r7, #8]
1684:common/rtos/tasks.c **** 	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
 2595              		.loc 1 1684 2 discriminator 4
 2596 001c BB68     		ldr	r3, [r7, #8]
 2597 001e 1833     		adds	r3, r3, #24
 2598 0020 1846     		mov	r0, r3
 2599 0022 1D4B     		ldr	r3, .L161
 2600 0024 9847     		blx	r3
 2601              	.LVL71:
1685:common/rtos/tasks.c **** 
1686:common/rtos/tasks.c **** 	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 2602              		.loc 1 1686 27 discriminator 4
 2603 0026 1D4B     		ldr	r3, .L161+4
 2604 0028 1B68     		ldr	r3, [r3]
 2605              		.loc 1 1686 4 discriminator 4
 2606 002a 002B     		cmp	r3, #0
 2607 002c 1DD1     		bne	.L155
1687:common/rtos/tasks.c **** 	{
1688:common/rtos/tasks.c **** 		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
 2608              		.loc 1 1688 3
 2609 002e BB68     		ldr	r3, [r7, #8]
 2610 0030 0433     		adds	r3, r3, #4
 2611 0032 1846     		mov	r0, r3
 2612 0034 184B     		ldr	r3, .L161
 2613 0036 9847     		blx	r3
 2614              	.LVL72:
1689:common/rtos/tasks.c **** 		prvAddTaskToReadyQueue( pxUnblockedTCB );
 2615              		.loc 1 1689 3
 2616 0038 BB68     		ldr	r3, [r7, #8]
 2617 003a DA6A     		ldr	r2, [r3, #44]
 2618 003c 184B     		ldr	r3, .L161+8
 2619 003e 1B68     		ldr	r3, [r3]
 2620 0040 9A42     		cmp	r2, r3
 2621 0042 03D9     		bls	.L156
 2622              		.loc 1 1689 3 is_stmt 0 discriminator 1
 2623 0044 BB68     		ldr	r3, [r7, #8]
 2624 0046 DB6A     		ldr	r3, [r3, #44]
 2625 0048 154A     		ldr	r2, .L161+8
 2626 004a 1360     		str	r3, [r2]
 2627              	.L156:
 2628              		.loc 1 1689 3 discriminator 3
 2629 004c BB68     		ldr	r3, [r7, #8]
 2630 004e DA6A     		ldr	r2, [r3, #44]
 2631 0050 1346     		mov	r3, r2
 2632 0052 9B00     		lsls	r3, r3, #2
 2633 0054 1344     		add	r3, r3, r2
 2634 0056 9B00     		lsls	r3, r3, #2
 2635 0058 124A     		ldr	r2, .L161+12
 2636 005a 1A44     		add	r2, r2, r3
 2637 005c BB68     		ldr	r3, [r7, #8]
 2638 005e 0433     		adds	r3, r3, #4
 2639 0060 1946     		mov	r1, r3
 2640 0062 1046     		mov	r0, r2
 2641 0064 104B     		ldr	r3, .L161+16
 2642 0066 9847     		blx	r3
 2643              	.LVL73:
 2644 0068 05E0     		b	.L157
 2645              	.L155:
1690:common/rtos/tasks.c **** 	}
1691:common/rtos/tasks.c **** 	else
1692:common/rtos/tasks.c **** 	{
1693:common/rtos/tasks.c **** 		/* We cannot access the delayed or ready lists, so will hold this
1694:common/rtos/tasks.c **** 		task pending until the scheduler is resumed. */
1695:common/rtos/tasks.c **** 		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 2646              		.loc 1 1695 3 is_stmt 1
 2647 006a BB68     		ldr	r3, [r7, #8]
 2648 006c 1833     		adds	r3, r3, #24
 2649 006e 1946     		mov	r1, r3
 2650 0070 0E48     		ldr	r0, .L161+20
 2651 0072 0D4B     		ldr	r3, .L161+16
 2652 0074 9847     		blx	r3
 2653              	.LVL74:
 2654              	.L157:
1696:common/rtos/tasks.c **** 	}
1697:common/rtos/tasks.c **** 
1698:common/rtos/tasks.c **** 	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
 2655              		.loc 1 1698 20
 2656 0076 BB68     		ldr	r3, [r7, #8]
 2657 0078 DA6A     		ldr	r2, [r3, #44]
 2658              		.loc 1 1698 48
 2659 007a 0D4B     		ldr	r3, .L161+24
 2660 007c 1B68     		ldr	r3, [r3]
 2661 007e DB6A     		ldr	r3, [r3, #44]
 2662              		.loc 1 1698 4
 2663 0080 9A42     		cmp	r2, r3
 2664 0082 02D3     		bcc	.L158
1699:common/rtos/tasks.c **** 	{
1700:common/rtos/tasks.c **** 		/* Return true if the task removed from the event list has
1701:common/rtos/tasks.c **** 		a higher priority than the calling task.  This allows
1702:common/rtos/tasks.c **** 		the calling task to know if it should force a context
1703:common/rtos/tasks.c **** 		switch now. */
1704:common/rtos/tasks.c **** 		xReturn = pdTRUE;
 2665              		.loc 1 1704 11
 2666 0084 0123     		movs	r3, #1
 2667 0086 FB60     		str	r3, [r7, #12]
 2668 0088 01E0     		b	.L159
 2669              	.L158:
1705:common/rtos/tasks.c **** 	}
1706:common/rtos/tasks.c **** 	else
1707:common/rtos/tasks.c **** 	{
1708:common/rtos/tasks.c **** 		xReturn = pdFALSE;
 2670              		.loc 1 1708 11
 2671 008a 0023     		movs	r3, #0
 2672 008c FB60     		str	r3, [r7, #12]
 2673              	.L159:
1709:common/rtos/tasks.c **** 	}
1710:common/rtos/tasks.c **** 
1711:common/rtos/tasks.c **** 	return xReturn;
 2674              		.loc 1 1711 9
 2675 008e FB68     		ldr	r3, [r7, #12]
1712:common/rtos/tasks.c **** }
 2676              		.loc 1 1712 1
 2677 0090 1846     		mov	r0, r3
 2678 0092 1037     		adds	r7, r7, #16
 2679              	.LCFI95:
 2680              		.cfi_def_cfa_offset 8
 2681 0094 BD46     		mov	sp, r7
 2682              	.LCFI96:
 2683              		.cfi_def_cfa_register 13
 2684              		@ sp needed
 2685 0096 80BD     		pop	{r7, pc}
 2686              	.L162:
 2687              		.align	2
 2688              	.L161:
 2689 0098 00000000 		.word	vListRemove
 2690 009c 00000000 		.word	uxSchedulerSuspended
 2691 00a0 00000000 		.word	uxTopReadyPriority
 2692 00a4 00000000 		.word	pxReadyTasksLists
 2693 00a8 00000000 		.word	vListInsertEnd
 2694 00ac 00000000 		.word	xPendingReadyList
 2695 00b0 00000000 		.word	pxCurrentTCB
 2696              		.cfi_endproc
 2697              	.LFE49:
 2699              		.section	.text.vTaskSetTimeOutState,"ax",%progbits
 2700              		.align	1
 2701              		.global	vTaskSetTimeOutState
 2702              		.syntax unified
 2703              		.thumb
 2704              		.thumb_func
 2706              	vTaskSetTimeOutState:
 2707              	.LFB50:
1713:common/rtos/tasks.c **** /*-----------------------------------------------------------*/
1714:common/rtos/tasks.c **** 
1715:common/rtos/tasks.c **** void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
1716:common/rtos/tasks.c **** {
 2708              		.loc 1 1716 1
 2709              		.cfi_startproc
 2710              		@ args = 0, pretend = 0, frame = 8
 2711              		@ frame_needed = 1, uses_anonymous_args = 0
 2712              		@ link register save eliminated.
 2713 0000 80B4     		push	{r7}
 2714              	.LCFI97:
 2715              		.cfi_def_cfa_offset 4
 2716              		.cfi_offset 7, -4
 2717 0002 83B0     		sub	sp, sp, #12
 2718              	.LCFI98:
 2719              		.cfi_def_cfa_offset 16
 2720 0004 00AF     		add	r7, sp, #0
 2721              	.LCFI99:
 2722              		.cfi_def_cfa_register 7
 2723 0006 7860     		str	r0, [r7, #4]
1717:common/rtos/tasks.c **** 	pxTimeOut->xOverflowCount = xNumOfOverflows;
 2724              		.loc 1 1717 28
 2725 0008 064B     		ldr	r3, .L164
 2726 000a 1A68     		ldr	r2, [r3]
 2727 000c 7B68     		ldr	r3, [r7, #4]
 2728 000e 1A60     		str	r2, [r3]
1718:common/rtos/tasks.c **** 	pxTimeOut->xTimeOnEntering = xTickCount;
 2729              		.loc 1 1718 29
 2730 0010 054B     		ldr	r3, .L164+4
 2731 0012 1A68     		ldr	r2, [r3]
 2732 0014 7B68     		ldr	r3, [r7, #4]
 2733 0016 5A60     		str	r2, [r3, #4]
1719:common/rtos/tasks.c **** }
 2734              		.loc 1 1719 1
 2735 0018 00BF     		nop
 2736 001a 0C37     		adds	r7, r7, #12
 2737              	.LCFI100:
 2738              		.cfi_def_cfa_offset 4
 2739 001c BD46     		mov	sp, r7
 2740              	.LCFI101:
 2741              		.cfi_def_cfa_register 13
 2742              		@ sp needed
 2743 001e 80BC     		pop	{r7}
 2744              	.LCFI102:
 2745              		.cfi_restore 7
 2746              		.cfi_def_cfa_offset 0
 2747 0020 7047     		bx	lr
 2748              	.L165:
 2749 0022 00BF     		.align	2
 2750              	.L164:
 2751 0024 00000000 		.word	xNumOfOverflows
 2752 0028 00000000 		.word	xTickCount
 2753              		.cfi_endproc
 2754              	.LFE50:
 2756              		.section	.text.xTaskCheckForTimeOut,"ax",%progbits
 2757              		.align	1
 2758              		.global	xTaskCheckForTimeOut
 2759              		.syntax unified
 2760              		.thumb
 2761              		.thumb_func
 2763              	xTaskCheckForTimeOut:
 2764              	.LFB51:
1720:common/rtos/tasks.c **** /*-----------------------------------------------------------*/
1721:common/rtos/tasks.c **** 
1722:common/rtos/tasks.c **** portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToW
1723:common/rtos/tasks.c **** {
 2765              		.loc 1 1723 1
 2766              		.cfi_startproc
 2767              		@ args = 0, pretend = 0, frame = 16
 2768              		@ frame_needed = 1, uses_anonymous_args = 0
 2769 0000 80B5     		push	{r7, lr}
 2770              	.LCFI103:
 2771              		.cfi_def_cfa_offset 8
 2772              		.cfi_offset 7, -8
 2773              		.cfi_offset 14, -4
 2774 0002 84B0     		sub	sp, sp, #16
 2775              	.LCFI104:
 2776              		.cfi_def_cfa_offset 24
 2777 0004 00AF     		add	r7, sp, #0
 2778              	.LCFI105:
 2779              		.cfi_def_cfa_register 7
 2780 0006 7860     		str	r0, [r7, #4]
 2781 0008 3960     		str	r1, [r7]
1724:common/rtos/tasks.c **** portBASE_TYPE xReturn;
1725:common/rtos/tasks.c **** 
1726:common/rtos/tasks.c **** 	portENTER_CRITICAL();
 2782              		.loc 1 1726 2
 2783 000a 1D4B     		ldr	r3, .L172
 2784 000c 9847     		blx	r3
 2785              	.LVL75:
1727:common/rtos/tasks.c **** 	{
1728:common/rtos/tasks.c **** 		#if ( INCLUDE_vTaskSuspend == 1 )
1729:common/rtos/tasks.c **** 			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
1730:common/rtos/tasks.c **** 			the maximum block time then the task should block indefinitely, and
1731:common/rtos/tasks.c **** 			therefore never time out. */
1732:common/rtos/tasks.c **** 			if( *pxTicksToWait == portMAX_DELAY )
 2786              		.loc 1 1732 8
 2787 000e 3B68     		ldr	r3, [r7]
 2788 0010 1B68     		ldr	r3, [r3]
 2789              		.loc 1 1732 6
 2790 0012 B3F1FF3F 		cmp	r3, #-1
 2791 0016 02D1     		bne	.L167
1733:common/rtos/tasks.c **** 			{
1734:common/rtos/tasks.c **** 				xReturn = pdFALSE;
 2792              		.loc 1 1734 13
 2793 0018 0023     		movs	r3, #0
 2794 001a FB60     		str	r3, [r7, #12]
 2795 001c 29E0     		b	.L168
 2796              	.L167:
1735:common/rtos/tasks.c **** 			}
1736:common/rtos/tasks.c **** 			else /* We are not blocking indefinitely, perform the checks below. */
1737:common/rtos/tasks.c **** 		#endif
1738:common/rtos/tasks.c **** 
1739:common/rtos/tasks.c **** 		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTi
 2797              		.loc 1 1739 37
 2798 001e 7B68     		ldr	r3, [r7, #4]
 2799 0020 1A68     		ldr	r2, [r3]
 2800              		.loc 1 1739 25
 2801 0022 184B     		ldr	r3, .L172+4
 2802 0024 1B68     		ldr	r3, [r3]
 2803              		.loc 1 1739 5
 2804 0026 9A42     		cmp	r2, r3
 2805 0028 08D0     		beq	.L169
 2806              		.loc 1 1739 118 discriminator 1
 2807 002a 7B68     		ldr	r3, [r7, #4]
 2808 002c 5A68     		ldr	r2, [r3, #4]
 2809              		.loc 1 1739 61 discriminator 1
 2810 002e 164B     		ldr	r3, .L172+8
 2811 0030 1B68     		ldr	r3, [r3]
 2812              		.loc 1 1739 56 discriminator 1
 2813 0032 9A42     		cmp	r2, r3
 2814 0034 02D8     		bhi	.L169
1740:common/rtos/tasks.c **** 		{
1741:common/rtos/tasks.c **** 			/* The tick count is greater than the time at which vTaskSetTimeout()
1742:common/rtos/tasks.c **** 			was called, but has also overflowed since vTaskSetTimeOut() was called.
1743:common/rtos/tasks.c **** 			It must have wrapped all the way around and gone past us again. This
1744:common/rtos/tasks.c **** 			passed since vTaskSetTimeout() was called. */
1745:common/rtos/tasks.c **** 			xReturn = pdTRUE;
 2815              		.loc 1 1745 12
 2816 0036 0123     		movs	r3, #1
 2817 0038 FB60     		str	r3, [r7, #12]
 2818 003a 1AE0     		b	.L168
 2819              	.L169:
1746:common/rtos/tasks.c **** 		}
1747:common/rtos/tasks.c **** 		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEn
 2820              		.loc 1 1747 33
 2821 003c 124B     		ldr	r3, .L172+8
 2822 003e 1A68     		ldr	r2, [r3]
 2823              		.loc 1 1747 89
 2824 0040 7B68     		ldr	r3, [r7, #4]
 2825 0042 5B68     		ldr	r3, [r3, #4]
 2826              		.loc 1 1747 14
 2827 0044 D21A     		subs	r2, r2, r3
 2828              		.loc 1 1747 113
 2829 0046 3B68     		ldr	r3, [r7]
 2830 0048 1B68     		ldr	r3, [r3]
 2831              		.loc 1 1747 10
 2832 004a 9A42     		cmp	r2, r3
 2833 004c 0FD2     		bcs	.L170
1748:common/rtos/tasks.c **** 		{
1749:common/rtos/tasks.c **** 			/* Not a genuine timeout. Adjust parameters for time remaining. */
1750:common/rtos/tasks.c **** 			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
 2834              		.loc 1 1750 24
 2835 004e 0E4B     		ldr	r3, .L172+8
 2836 0050 1A68     		ldr	r2, [r3]
 2837              		.loc 1 1750 80
 2838 0052 7B68     		ldr	r3, [r7, #4]
 2839 0054 5B68     		ldr	r3, [r3, #4]
 2840              		.loc 1 1750 52
 2841 0056 D31A     		subs	r3, r2, r3
 2842              		.loc 1 1750 19
 2843 0058 3A68     		ldr	r2, [r7]
 2844 005a 1268     		ldr	r2, [r2]
 2845 005c D21A     		subs	r2, r2, r3
 2846 005e 3B68     		ldr	r3, [r7]
 2847 0060 1A60     		str	r2, [r3]
1751:common/rtos/tasks.c **** 			vTaskSetTimeOutState( pxTimeOut );
 2848              		.loc 1 1751 4
 2849 0062 7868     		ldr	r0, [r7, #4]
 2850 0064 094B     		ldr	r3, .L172+12
 2851 0066 9847     		blx	r3
 2852              	.LVL76:
1752:common/rtos/tasks.c **** 			xReturn = pdFALSE;
 2853              		.loc 1 1752 12
 2854 0068 0023     		movs	r3, #0
 2855 006a FB60     		str	r3, [r7, #12]
 2856 006c 01E0     		b	.L168
 2857              	.L170:
1753:common/rtos/tasks.c **** 		}
1754:common/rtos/tasks.c **** 		else
1755:common/rtos/tasks.c **** 		{
1756:common/rtos/tasks.c **** 			xReturn = pdTRUE;
 2858              		.loc 1 1756 12
 2859 006e 0123     		movs	r3, #1
 2860 0070 FB60     		str	r3, [r7, #12]
 2861              	.L168:
1757:common/rtos/tasks.c **** 		}
1758:common/rtos/tasks.c **** 	}
1759:common/rtos/tasks.c **** 	portEXIT_CRITICAL();
 2862              		.loc 1 1759 2
 2863 0072 074B     		ldr	r3, .L172+16
 2864 0074 9847     		blx	r3
 2865              	.LVL77:
1760:common/rtos/tasks.c **** 
1761:common/rtos/tasks.c **** 	return xReturn;
 2866              		.loc 1 1761 9
 2867 0076 FB68     		ldr	r3, [r7, #12]
1762:common/rtos/tasks.c **** }
 2868              		.loc 1 1762 1
 2869 0078 1846     		mov	r0, r3
 2870 007a 1037     		adds	r7, r7, #16
 2871              	.LCFI106:
 2872              		.cfi_def_cfa_offset 8
 2873 007c BD46     		mov	sp, r7
 2874              	.LCFI107:
 2875              		.cfi_def_cfa_register 13
 2876              		@ sp needed
 2877 007e 80BD     		pop	{r7, pc}
 2878              	.L173:
 2879              		.align	2
 2880              	.L172:
 2881 0080 00000000 		.word	vPortEnterCritical
 2882 0084 00000000 		.word	xNumOfOverflows
 2883 0088 00000000 		.word	xTickCount
 2884 008c 00000000 		.word	vTaskSetTimeOutState
 2885 0090 00000000 		.word	vPortExitCritical
 2886              		.cfi_endproc
 2887              	.LFE51:
 2889              		.section	.text.vTaskMissedYield,"ax",%progbits
 2890              		.align	1
 2891              		.global	vTaskMissedYield
 2892              		.syntax unified
 2893              		.thumb
 2894              		.thumb_func
 2896              	vTaskMissedYield:
 2897              	.LFB52:
1763:common/rtos/tasks.c **** /*-----------------------------------------------------------*/
1764:common/rtos/tasks.c **** 
1765:common/rtos/tasks.c **** void vTaskMissedYield( void )
1766:common/rtos/tasks.c **** {
 2898              		.loc 1 1766 1
 2899              		.cfi_startproc
 2900              		@ args = 0, pretend = 0, frame = 0
 2901              		@ frame_needed = 1, uses_anonymous_args = 0
 2902              		@ link register save eliminated.
 2903 0000 80B4     		push	{r7}
 2904              	.LCFI108:
 2905              		.cfi_def_cfa_offset 4
 2906              		.cfi_offset 7, -4
 2907 0002 00AF     		add	r7, sp, #0
 2908              	.LCFI109:
 2909              		.cfi_def_cfa_register 7
1767:common/rtos/tasks.c **** 	xMissedYield = pdTRUE;
 2910              		.loc 1 1767 15
 2911 0004 034B     		ldr	r3, .L175
 2912 0006 0122     		movs	r2, #1
 2913 0008 1A60     		str	r2, [r3]
1768:common/rtos/tasks.c **** }
 2914              		.loc 1 1768 1
 2915 000a 00BF     		nop
 2916 000c BD46     		mov	sp, r7
 2917              	.LCFI110:
 2918              		.cfi_def_cfa_register 13
 2919              		@ sp needed
 2920 000e 80BC     		pop	{r7}
 2921              	.LCFI111:
 2922              		.cfi_restore 7
 2923              		.cfi_def_cfa_offset 0
 2924 0010 7047     		bx	lr
 2925              	.L176:
 2926 0012 00BF     		.align	2
 2927              	.L175:
 2928 0014 00000000 		.word	xMissedYield
 2929              		.cfi_endproc
 2930              	.LFE52:
 2932              		.section	.text.prvIdleTask,"ax",%progbits
 2933              		.align	1
 2934              		.syntax unified
 2935              		.thumb
 2936              		.thumb_func
 2938              	prvIdleTask:
 2939              	.LFB53:
1769:common/rtos/tasks.c **** 
1770:common/rtos/tasks.c **** /*
1771:common/rtos/tasks.c ****  * -----------------------------------------------------------
1772:common/rtos/tasks.c ****  * The Idle task.
1773:common/rtos/tasks.c ****  * ----------------------------------------------------------
1774:common/rtos/tasks.c ****  *
1775:common/rtos/tasks.c ****  * The portTASK_FUNCTION() macro is used to allow port/compiler specific
1776:common/rtos/tasks.c ****  * language extensions.  The equivalent prototype for this function is:
1777:common/rtos/tasks.c ****  *
1778:common/rtos/tasks.c ****  * void prvIdleTask( void *pvParameters );
1779:common/rtos/tasks.c ****  *
1780:common/rtos/tasks.c ****  */
1781:common/rtos/tasks.c **** static portTASK_FUNCTION( prvIdleTask, pvParameters )
1782:common/rtos/tasks.c **** {
 2940              		.loc 1 1782 1
 2941              		.cfi_startproc
 2942              		@ args = 0, pretend = 0, frame = 8
 2943              		@ frame_needed = 1, uses_anonymous_args = 0
 2944 0000 80B5     		push	{r7, lr}
 2945              	.LCFI112:
 2946              		.cfi_def_cfa_offset 8
 2947              		.cfi_offset 7, -8
 2948              		.cfi_offset 14, -4
 2949 0002 82B0     		sub	sp, sp, #8
 2950              	.LCFI113:
 2951              		.cfi_def_cfa_offset 16
 2952 0004 00AF     		add	r7, sp, #0
 2953              	.LCFI114:
 2954              		.cfi_def_cfa_register 7
 2955 0006 7860     		str	r0, [r7, #4]
 2956              	.L179:
1783:common/rtos/tasks.c **** 	/* Stop warnings. */
1784:common/rtos/tasks.c **** 	( void ) pvParameters;
1785:common/rtos/tasks.c **** 
1786:common/rtos/tasks.c **** 	for( ;; )
1787:common/rtos/tasks.c **** 	{
1788:common/rtos/tasks.c **** 		/* See if any tasks have been deleted. */
1789:common/rtos/tasks.c **** 		prvCheckTasksWaitingTermination();
 2957              		.loc 1 1789 3
 2958 0008 054B     		ldr	r3, .L180
 2959 000a 9847     		blx	r3
 2960              	.LVL78:
1790:common/rtos/tasks.c **** 
1791:common/rtos/tasks.c **** 		#if ( configUSE_PREEMPTION == 0 )
1792:common/rtos/tasks.c **** 		{
1793:common/rtos/tasks.c **** 			/* If we are not using preemption we keep forcing a task switch to
1794:common/rtos/tasks.c **** 			see if any other task has become available.  If we are using
1795:common/rtos/tasks.c **** 			preemption we don't need to do this as any task becoming available
1796:common/rtos/tasks.c **** 			will automatically get the processor anyway. */
1797:common/rtos/tasks.c **** 			taskYIELD();
1798:common/rtos/tasks.c **** 		}
1799:common/rtos/tasks.c **** 		#endif
1800:common/rtos/tasks.c **** 
1801:common/rtos/tasks.c **** 		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
1802:common/rtos/tasks.c **** 		{
1803:common/rtos/tasks.c **** 			/* When using preemption tasks of equal priority will be
1804:common/rtos/tasks.c **** 			timesliced.  If a task that is sharing the idle priority is ready
1805:common/rtos/tasks.c **** 			to run then the idle task should yield before the end of the
1806:common/rtos/tasks.c **** 			timeslice.
1807:common/rtos/tasks.c **** 
1808:common/rtos/tasks.c **** 			A critical region is not required here as we are just reading from
1809:common/rtos/tasks.c **** 			the list, and an occasional incorrect value will not matter.  If
1810:common/rtos/tasks.c **** 			the ready list at the idle priority contains more than one task
1811:common/rtos/tasks.c **** 			then a task other than the idle task is ready to execute. */
1812:common/rtos/tasks.c **** 			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_
 2961              		.loc 1 1812 8
 2962 000c 054B     		ldr	r3, .L180+4
 2963 000e 1B68     		ldr	r3, [r3]
 2964              		.loc 1 1812 6
 2965 0010 012B     		cmp	r3, #1
 2966 0012 01D9     		bls	.L178
1813:common/rtos/tasks.c **** 			{
1814:common/rtos/tasks.c **** 				taskYIELD();
 2967              		.loc 1 1814 5
 2968 0014 044B     		ldr	r3, .L180+8
 2969 0016 9847     		blx	r3
 2970              	.LVL79:
 2971              	.L178:
 2972              	.LBB10:
1815:common/rtos/tasks.c **** 			}
1816:common/rtos/tasks.c **** 		}
1817:common/rtos/tasks.c **** 		#endif
1818:common/rtos/tasks.c **** 
1819:common/rtos/tasks.c **** 		#if ( configUSE_IDLE_HOOK == 1 )
1820:common/rtos/tasks.c **** 		{
1821:common/rtos/tasks.c **** 			extern void vApplicationIdleHook( void );
1822:common/rtos/tasks.c **** 
1823:common/rtos/tasks.c **** 			/* Call the user defined function from within the idle task.  This
1824:common/rtos/tasks.c **** 			allows the application designer to add background functionality
1825:common/rtos/tasks.c **** 			without the overhead of a separate task.
1826:common/rtos/tasks.c **** 			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
1827:common/rtos/tasks.c **** 			CALL A FUNCTION THAT MIGHT BLOCK. */
1828:common/rtos/tasks.c **** 			vApplicationIdleHook();
 2973              		.loc 1 1828 4
 2974 0018 044B     		ldr	r3, .L180+12
 2975 001a 9847     		blx	r3
 2976              	.LVL80:
 2977              	.LBE10:
1789:common/rtos/tasks.c **** 
 2978              		.loc 1 1789 3
 2979 001c F4E7     		b	.L179
 2980              	.L181:
 2981 001e 00BF     		.align	2
 2982              	.L180:
 2983 0020 00000000 		.word	prvCheckTasksWaitingTermination
 2984 0024 00000000 		.word	pxReadyTasksLists
 2985 0028 00000000 		.word	vPortYieldFromISR
 2986 002c 00000000 		.word	vApplicationIdleHook
 2987              		.cfi_endproc
 2988              	.LFE53:
 2990              		.section	.text.prvInitialiseTCBVariables,"ax",%progbits
 2991              		.align	1
 2992              		.syntax unified
 2993              		.thumb
 2994              		.thumb_func
 2996              	prvInitialiseTCBVariables:
 2997              	.LFB54:
1829:common/rtos/tasks.c **** 		}
1830:common/rtos/tasks.c **** 		#endif
1831:common/rtos/tasks.c **** 	}
1832:common/rtos/tasks.c **** } /*lint !e715 pvParameters is not accessed but all task functions require the same prototype. */
1833:common/rtos/tasks.c **** 
1834:common/rtos/tasks.c **** 
1835:common/rtos/tasks.c **** 
1836:common/rtos/tasks.c **** 
1837:common/rtos/tasks.c **** 
1838:common/rtos/tasks.c **** 
1839:common/rtos/tasks.c **** 
1840:common/rtos/tasks.c **** /*-----------------------------------------------------------
1841:common/rtos/tasks.c ****  * File private functions documented at the top of the file.
1842:common/rtos/tasks.c ****  *----------------------------------------------------------*/
1843:common/rtos/tasks.c **** 
1844:common/rtos/tasks.c **** 
1845:common/rtos/tasks.c **** 
1846:common/rtos/tasks.c **** static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned po
1847:common/rtos/tasks.c **** {
 2998              		.loc 1 1847 1
 2999              		.cfi_startproc
 3000              		@ args = 4, pretend = 0, frame = 16
 3001              		@ frame_needed = 1, uses_anonymous_args = 0
 3002 0000 80B5     		push	{r7, lr}
 3003              	.LCFI115:
 3004              		.cfi_def_cfa_offset 8
 3005              		.cfi_offset 7, -8
 3006              		.cfi_offset 14, -4
 3007 0002 84B0     		sub	sp, sp, #16
 3008              	.LCFI116:
 3009              		.cfi_def_cfa_offset 24
 3010 0004 00AF     		add	r7, sp, #0
 3011              	.LCFI117:
 3012              		.cfi_def_cfa_register 7
 3013 0006 F860     		str	r0, [r7, #12]
 3014 0008 B960     		str	r1, [r7, #8]
 3015 000a 7A60     		str	r2, [r7, #4]
 3016 000c 3B60     		str	r3, [r7]
1848:common/rtos/tasks.c **** 	/* Store the function name in the TCB. */
1849:common/rtos/tasks.c **** 	#if configMAX_TASK_NAME_LEN > 1
1850:common/rtos/tasks.c **** 	{
1851:common/rtos/tasks.c **** 		/* Don't bring strncpy into the build unnecessarily. */
1852:common/rtos/tasks.c **** 		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK
 3017              		.loc 1 1852 23
 3018 000e FB68     		ldr	r3, [r7, #12]
 3019 0010 3433     		adds	r3, r3, #52
 3020              		.loc 1 1852 3
 3021 0012 1022     		movs	r2, #16
 3022 0014 B968     		ldr	r1, [r7, #8]
 3023 0016 1846     		mov	r0, r3
 3024 0018 144B     		ldr	r3, .L184
 3025 001a 9847     		blx	r3
 3026              	.LVL81:
1853:common/rtos/tasks.c **** 	}
1854:common/rtos/tasks.c **** 	#endif
1855:common/rtos/tasks.c **** 	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = '\0';
 3027              		.loc 1 1855 89
 3028 001c FB68     		ldr	r3, [r7, #12]
 3029 001e 0022     		movs	r2, #0
 3030 0020 83F84320 		strb	r2, [r3, #67]
1856:common/rtos/tasks.c **** 
1857:common/rtos/tasks.c **** 	/* This is used as an array index so must ensure it's not too large.  First
1858:common/rtos/tasks.c **** 	remove the privilege bit if one is present. */
1859:common/rtos/tasks.c **** 	if( uxPriority >= configMAX_PRIORITIES )
 3031              		.loc 1 1859 4
 3032 0024 7B68     		ldr	r3, [r7, #4]
 3033 0026 092B     		cmp	r3, #9
 3034 0028 01D9     		bls	.L183
1860:common/rtos/tasks.c **** 	{
1861:common/rtos/tasks.c **** 		uxPriority = configMAX_PRIORITIES - 1;
 3035              		.loc 1 1861 14
 3036 002a 0923     		movs	r3, #9
 3037 002c 7B60     		str	r3, [r7, #4]
 3038              	.L183:
1862:common/rtos/tasks.c **** 	}
1863:common/rtos/tasks.c **** 
1864:common/rtos/tasks.c **** 	pxTCB->uxPriority = uxPriority;
 3039              		.loc 1 1864 20
 3040 002e FB68     		ldr	r3, [r7, #12]
 3041 0030 7A68     		ldr	r2, [r7, #4]
 3042 0032 DA62     		str	r2, [r3, #44]
1865:common/rtos/tasks.c **** 	#if ( configUSE_MUTEXES == 1 )
1866:common/rtos/tasks.c **** 	{
1867:common/rtos/tasks.c **** 		pxTCB->uxBasePriority = uxPriority;
 3043              		.loc 1 1867 25
 3044 0034 FB68     		ldr	r3, [r7, #12]
 3045 0036 7A68     		ldr	r2, [r7, #4]
 3046 0038 5A64     		str	r2, [r3, #68]
1868:common/rtos/tasks.c **** 	}
1869:common/rtos/tasks.c **** 	#endif
1870:common/rtos/tasks.c **** 
1871:common/rtos/tasks.c **** 	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 3047              		.loc 1 1871 2
 3048 003a FB68     		ldr	r3, [r7, #12]
 3049 003c 0433     		adds	r3, r3, #4
 3050 003e 1846     		mov	r0, r3
 3051 0040 0B4B     		ldr	r3, .L184+4
 3052 0042 9847     		blx	r3
 3053              	.LVL82:
1872:common/rtos/tasks.c **** 	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 3054              		.loc 1 1872 2
 3055 0044 FB68     		ldr	r3, [r7, #12]
 3056 0046 1833     		adds	r3, r3, #24
 3057 0048 1846     		mov	r0, r3
 3058 004a 094B     		ldr	r3, .L184+4
 3059 004c 9847     		blx	r3
 3060              	.LVL83:
1873:common/rtos/tasks.c **** 
1874:common/rtos/tasks.c **** 	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
1875:common/rtos/tasks.c **** 	back to	the containing TCB from a generic item in a list. */
1876:common/rtos/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 3061              		.loc 1 1876 2
 3062 004e FB68     		ldr	r3, [r7, #12]
 3063 0050 FA68     		ldr	r2, [r7, #12]
 3064 0052 1A61     		str	r2, [r3, #16]
1877:common/rtos/tasks.c **** 
1878:common/rtos/tasks.c **** 	/* Event lists are always in priority order. */
1879:common/rtos/tasks.c **** 	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPri
 3065              		.loc 1 1879 2
 3066 0054 7B68     		ldr	r3, [r7, #4]
 3067 0056 C3F10A02 		rsb	r2, r3, #10
 3068 005a FB68     		ldr	r3, [r7, #12]
 3069 005c 9A61     		str	r2, [r3, #24]
1880:common/rtos/tasks.c **** 	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 3070              		.loc 1 1880 2
 3071 005e FB68     		ldr	r3, [r7, #12]
 3072 0060 FA68     		ldr	r2, [r7, #12]
 3073 0062 5A62     		str	r2, [r3, #36]
1881:common/rtos/tasks.c **** 
1882:common/rtos/tasks.c **** 	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
1883:common/rtos/tasks.c **** 	{
1884:common/rtos/tasks.c **** 		pxTCB->uxCriticalNesting = ( unsigned portBASE_TYPE ) 0;
1885:common/rtos/tasks.c **** 	}
1886:common/rtos/tasks.c **** 	#endif
1887:common/rtos/tasks.c **** 
1888:common/rtos/tasks.c **** 	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
1889:common/rtos/tasks.c **** 	{
1890:common/rtos/tasks.c **** 		pxTCB->pxTaskTag = NULL;
1891:common/rtos/tasks.c **** 	}
1892:common/rtos/tasks.c **** 	#endif
1893:common/rtos/tasks.c **** 
1894:common/rtos/tasks.c **** 	#if ( configGENERATE_RUN_TIME_STATS == 1 )
1895:common/rtos/tasks.c **** 	{
1896:common/rtos/tasks.c **** 		pxTCB->ulRunTimeCounter = 0UL;
1897:common/rtos/tasks.c **** 	}
1898:common/rtos/tasks.c **** 	#endif
1899:common/rtos/tasks.c **** 
1900:common/rtos/tasks.c **** 	#if ( portUSING_MPU_WRAPPERS == 1 )
1901:common/rtos/tasks.c **** 	{
1902:common/rtos/tasks.c **** 		vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, pxTCB->pxStack, usStackDepth );
1903:common/rtos/tasks.c **** 	}
1904:common/rtos/tasks.c **** 	#else
1905:common/rtos/tasks.c **** 	{
1906:common/rtos/tasks.c **** 		( void ) xRegions;
1907:common/rtos/tasks.c **** 		( void ) usStackDepth;
1908:common/rtos/tasks.c **** 	}
1909:common/rtos/tasks.c **** 	#endif
1910:common/rtos/tasks.c **** }
 3074              		.loc 1 1910 1
 3075 0064 00BF     		nop
 3076 0066 1037     		adds	r7, r7, #16
 3077              	.LCFI118:
 3078              		.cfi_def_cfa_offset 8
 3079 0068 BD46     		mov	sp, r7
 3080              	.LCFI119:
 3081              		.cfi_def_cfa_register 13
 3082              		@ sp needed
 3083 006a 80BD     		pop	{r7, pc}
 3084              	.L185:
 3085              		.align	2
 3086              	.L184:
 3087 006c 00000000 		.word	strncpy
 3088 0070 00000000 		.word	vListInitialiseItem
 3089              		.cfi_endproc
 3090              	.LFE54:
 3092              		.section	.text.prvInitialiseTaskLists,"ax",%progbits
 3093              		.align	1
 3094              		.syntax unified
 3095              		.thumb
 3096              		.thumb_func
 3098              	prvInitialiseTaskLists:
 3099              	.LFB55:
1911:common/rtos/tasks.c **** /*-----------------------------------------------------------*/
1912:common/rtos/tasks.c **** 
1913:common/rtos/tasks.c **** #if ( portUSING_MPU_WRAPPERS == 1 )
1914:common/rtos/tasks.c **** 
1915:common/rtos/tasks.c **** 	void vTaskAllocateMPURegions( xTaskHandle xTaskToModify, const xMemoryRegion * const xRegions )
1916:common/rtos/tasks.c **** 	{
1917:common/rtos/tasks.c **** 	tskTCB *pxTCB;
1918:common/rtos/tasks.c **** 	
1919:common/rtos/tasks.c **** 		if( xTaskToModify == pxCurrentTCB )
1920:common/rtos/tasks.c **** 		{
1921:common/rtos/tasks.c **** 			xTaskToModify = NULL;
1922:common/rtos/tasks.c **** 		}
1923:common/rtos/tasks.c **** 
1924:common/rtos/tasks.c **** 		/* If null is passed in here then we are deleting ourselves. */
1925:common/rtos/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTaskToModify );
1926:common/rtos/tasks.c **** 
1927:common/rtos/tasks.c ****         vPortStoreTaskMPUSettings( &( pxTCB->xMPUSettings ), xRegions, NULL, 0 );
1928:common/rtos/tasks.c **** 	}
1929:common/rtos/tasks.c **** 	/*-----------------------------------------------------------*/
1930:common/rtos/tasks.c **** #endif
1931:common/rtos/tasks.c **** 
1932:common/rtos/tasks.c **** static void prvInitialiseTaskLists( void )
1933:common/rtos/tasks.c **** {
 3100              		.loc 1 1933 1
 3101              		.cfi_startproc
 3102              		@ args = 0, pretend = 0, frame = 8
 3103              		@ frame_needed = 1, uses_anonymous_args = 0
 3104 0000 80B5     		push	{r7, lr}
 3105              	.LCFI120:
 3106              		.cfi_def_cfa_offset 8
 3107              		.cfi_offset 7, -8
 3108              		.cfi_offset 14, -4
 3109 0002 82B0     		sub	sp, sp, #8
 3110              	.LCFI121:
 3111              		.cfi_def_cfa_offset 16
 3112 0004 00AF     		add	r7, sp, #0
 3113              	.LCFI122:
 3114              		.cfi_def_cfa_register 7
1934:common/rtos/tasks.c **** unsigned portBASE_TYPE uxPriority;
1935:common/rtos/tasks.c **** 
1936:common/rtos/tasks.c **** 	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 3115              		.loc 1 1936 18
 3116 0006 0023     		movs	r3, #0
 3117 0008 7B60     		str	r3, [r7, #4]
 3118              		.loc 1 1936 2
 3119 000a 0CE0     		b	.L187
 3120              	.L188:
1937:common/rtos/tasks.c **** 	{
1938:common/rtos/tasks.c **** 		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
 3121              		.loc 1 1938 3 discriminator 3
 3122 000c 7A68     		ldr	r2, [r7, #4]
 3123 000e 1346     		mov	r3, r2
 3124 0010 9B00     		lsls	r3, r3, #2
 3125 0012 1344     		add	r3, r3, r2
 3126 0014 9B00     		lsls	r3, r3, #2
 3127 0016 124A     		ldr	r2, .L189
 3128 0018 1344     		add	r3, r3, r2
 3129 001a 1846     		mov	r0, r3
 3130 001c 114B     		ldr	r3, .L189+4
 3131 001e 9847     		blx	r3
 3132              	.LVL84:
1936:common/rtos/tasks.c **** 	{
 3133              		.loc 1 1936 68 discriminator 3
 3134 0020 7B68     		ldr	r3, [r7, #4]
 3135 0022 0133     		adds	r3, r3, #1
 3136 0024 7B60     		str	r3, [r7, #4]
 3137              	.L187:
1936:common/rtos/tasks.c **** 	{
 3138              		.loc 1 1936 2 discriminator 1
 3139 0026 7B68     		ldr	r3, [r7, #4]
 3140 0028 092B     		cmp	r3, #9
 3141 002a EFD9     		bls	.L188
1939:common/rtos/tasks.c **** 	}
1940:common/rtos/tasks.c **** 
1941:common/rtos/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList1 );
 3142              		.loc 1 1941 2
 3143 002c 0E48     		ldr	r0, .L189+8
 3144 002e 0D4B     		ldr	r3, .L189+4
 3145 0030 9847     		blx	r3
 3146              	.LVL85:
1942:common/rtos/tasks.c **** 	vListInitialise( ( xList * ) &xDelayedTaskList2 );
 3147              		.loc 1 1942 2
 3148 0032 0E48     		ldr	r0, .L189+12
 3149 0034 0B4B     		ldr	r3, .L189+4
 3150 0036 9847     		blx	r3
 3151              	.LVL86:
1943:common/rtos/tasks.c **** 	vListInitialise( ( xList * ) &xPendingReadyList );
 3152              		.loc 1 1943 2
 3153 0038 0D48     		ldr	r0, .L189+16
 3154 003a 0A4B     		ldr	r3, .L189+4
 3155 003c 9847     		blx	r3
 3156              	.LVL87:
1944:common/rtos/tasks.c **** 
1945:common/rtos/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
1946:common/rtos/tasks.c **** 	{
1947:common/rtos/tasks.c **** 		vListInitialise( ( xList * ) &xTasksWaitingTermination );
 3157              		.loc 1 1947 3
 3158 003e 0D48     		ldr	r0, .L189+20
 3159 0040 084B     		ldr	r3, .L189+4
 3160 0042 9847     		blx	r3
 3161              	.LVL88:
1948:common/rtos/tasks.c **** 	}
1949:common/rtos/tasks.c **** 	#endif
1950:common/rtos/tasks.c **** 
1951:common/rtos/tasks.c **** 	#if ( INCLUDE_vTaskSuspend == 1 )
1952:common/rtos/tasks.c **** 	{
1953:common/rtos/tasks.c **** 		vListInitialise( ( xList * ) &xSuspendedTaskList );
 3162              		.loc 1 1953 3
 3163 0044 0C48     		ldr	r0, .L189+24
 3164 0046 074B     		ldr	r3, .L189+4
 3165 0048 9847     		blx	r3
 3166              	.LVL89:
1954:common/rtos/tasks.c **** 	}
1955:common/rtos/tasks.c **** 	#endif
1956:common/rtos/tasks.c **** 
1957:common/rtos/tasks.c **** 	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
1958:common/rtos/tasks.c **** 	using list2. */
1959:common/rtos/tasks.c **** 	pxDelayedTaskList = &xDelayedTaskList1;
 3167              		.loc 1 1959 20
 3168 004a 0C4B     		ldr	r3, .L189+28
 3169 004c 064A     		ldr	r2, .L189+8
 3170 004e 1A60     		str	r2, [r3]
1960:common/rtos/tasks.c **** 	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 3171              		.loc 1 1960 28
 3172 0050 0B4B     		ldr	r3, .L189+32
 3173 0052 064A     		ldr	r2, .L189+12
 3174 0054 1A60     		str	r2, [r3]
1961:common/rtos/tasks.c **** }
 3175              		.loc 1 1961 1
 3176 0056 00BF     		nop
 3177 0058 0837     		adds	r7, r7, #8
 3178              	.LCFI123:
 3179              		.cfi_def_cfa_offset 8
 3180 005a BD46     		mov	sp, r7
 3181              	.LCFI124:
 3182              		.cfi_def_cfa_register 13
 3183              		@ sp needed
 3184 005c 80BD     		pop	{r7, pc}
 3185              	.L190:
 3186 005e 00BF     		.align	2
 3187              	.L189:
 3188 0060 00000000 		.word	pxReadyTasksLists
 3189 0064 00000000 		.word	vListInitialise
 3190 0068 00000000 		.word	xDelayedTaskList1
 3191 006c 00000000 		.word	xDelayedTaskList2
 3192 0070 00000000 		.word	xPendingReadyList
 3193 0074 00000000 		.word	xTasksWaitingTermination
 3194 0078 00000000 		.word	xSuspendedTaskList
 3195 007c 00000000 		.word	pxDelayedTaskList
 3196 0080 00000000 		.word	pxOverflowDelayedTaskList
 3197              		.cfi_endproc
 3198              	.LFE55:
 3200              		.section	.text.prvCheckTasksWaitingTermination,"ax",%progbits
 3201              		.align	1
 3202              		.syntax unified
 3203              		.thumb
 3204              		.thumb_func
 3206              	prvCheckTasksWaitingTermination:
 3207              	.LFB56:
1962:common/rtos/tasks.c **** /*-----------------------------------------------------------*/
1963:common/rtos/tasks.c **** 
1964:common/rtos/tasks.c **** static void prvCheckTasksWaitingTermination( void )
1965:common/rtos/tasks.c **** {
 3208              		.loc 1 1965 1
 3209              		.cfi_startproc
 3210              		@ args = 0, pretend = 0, frame = 8
 3211              		@ frame_needed = 1, uses_anonymous_args = 0
 3212 0000 80B5     		push	{r7, lr}
 3213              	.LCFI125:
 3214              		.cfi_def_cfa_offset 8
 3215              		.cfi_offset 7, -8
 3216              		.cfi_offset 14, -4
 3217 0002 82B0     		sub	sp, sp, #8
 3218              	.LCFI126:
 3219              		.cfi_def_cfa_offset 16
 3220 0004 00AF     		add	r7, sp, #0
 3221              	.LCFI127:
 3222              		.cfi_def_cfa_register 7
 3223              	.LBB11:
1966:common/rtos/tasks.c **** 	#if ( INCLUDE_vTaskDelete == 1 )
1967:common/rtos/tasks.c **** 	{
1968:common/rtos/tasks.c **** 		portBASE_TYPE xListIsEmpty;
1969:common/rtos/tasks.c **** 
1970:common/rtos/tasks.c **** 		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
1971:common/rtos/tasks.c **** 		too often in the idle task. */
1972:common/rtos/tasks.c **** 		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
 3224              		.loc 1 1972 22
 3225 0006 1B4B     		ldr	r3, .L196
 3226 0008 1B68     		ldr	r3, [r3]
 3227              		.loc 1 1972 5
 3228 000a 002B     		cmp	r3, #0
 3229 000c 2ED0     		beq	.L195
1973:common/rtos/tasks.c **** 		{
1974:common/rtos/tasks.c **** 			vTaskSuspendAll();
 3230              		.loc 1 1974 4
 3231 000e 1A4B     		ldr	r3, .L196+4
 3232 0010 9847     		blx	r3
 3233              	.LVL90:
1975:common/rtos/tasks.c **** 				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 3234              		.loc 1 1975 20
 3235 0012 1A4B     		ldr	r3, .L196+8
 3236 0014 1B68     		ldr	r3, [r3]
 3237 0016 002B     		cmp	r3, #0
 3238 0018 0CBF     		ite	eq
 3239 001a 0123     		moveq	r3, #1
 3240 001c 0023     		movne	r3, #0
 3241 001e DBB2     		uxtb	r3, r3
 3242              		.loc 1 1975 18
 3243 0020 7B60     		str	r3, [r7, #4]
1976:common/rtos/tasks.c **** 			xTaskResumeAll();
 3244              		.loc 1 1976 4
 3245 0022 174B     		ldr	r3, .L196+12
 3246 0024 9847     		blx	r3
 3247              	.LVL91:
1977:common/rtos/tasks.c **** 
1978:common/rtos/tasks.c **** 			if( !xListIsEmpty )
 3248              		.loc 1 1978 6
 3249 0026 7B68     		ldr	r3, [r7, #4]
 3250 0028 002B     		cmp	r3, #0
 3251 002a 1FD1     		bne	.L195
 3252              	.LBB12:
1979:common/rtos/tasks.c **** 			{
1980:common/rtos/tasks.c **** 				tskTCB *pxTCB;
1981:common/rtos/tasks.c **** 
1982:common/rtos/tasks.c **** 				portENTER_CRITICAL();
 3253              		.loc 1 1982 5
 3254 002c 154B     		ldr	r3, .L196+16
 3255 002e 9847     		blx	r3
 3256              	.LVL92:
1983:common/rtos/tasks.c **** 				{
1984:common/rtos/tasks.c **** 					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
 3257              		.loc 1 1984 27
 3258 0030 124B     		ldr	r3, .L196+8
 3259 0032 1B68     		ldr	r3, [r3]
 3260              		.loc 1 1984 14
 3261 0034 002B     		cmp	r3, #0
 3262 0036 03D0     		beq	.L193
 3263              		.loc 1 1984 27 discriminator 1
 3264 0038 134B     		ldr	r3, .L196+20
 3265 003a 5B68     		ldr	r3, [r3, #4]
 3266              		.loc 1 1984 14 discriminator 1
 3267 003c DB68     		ldr	r3, [r3, #12]
 3268 003e 00E0     		b	.L194
 3269              	.L193:
 3270              		.loc 1 1984 14 is_stmt 0 discriminator 2
 3271 0040 0023     		movs	r3, #0
 3272              	.L194:
 3273              		.loc 1 1984 12 is_stmt 1 discriminator 4
 3274 0042 3B60     		str	r3, [r7]
1985:common/rtos/tasks.c **** 					vListRemove( &( pxTCB->xGenericListItem ) );
 3275              		.loc 1 1985 6 discriminator 4
 3276 0044 3B68     		ldr	r3, [r7]
 3277 0046 0433     		adds	r3, r3, #4
 3278 0048 1846     		mov	r0, r3
 3279 004a 104B     		ldr	r3, .L196+24
 3280 004c 9847     		blx	r3
 3281              	.LVL93:
1986:common/rtos/tasks.c **** 					--uxCurrentNumberOfTasks;
 3282              		.loc 1 1986 6 discriminator 4
 3283 004e 104B     		ldr	r3, .L196+28
 3284 0050 1B68     		ldr	r3, [r3]
 3285 0052 013B     		subs	r3, r3, #1
 3286 0054 0E4A     		ldr	r2, .L196+28
 3287 0056 1360     		str	r3, [r2]
1987:common/rtos/tasks.c **** 					--uxTasksDeleted;
 3288              		.loc 1 1987 6 discriminator 4
 3289 0058 064B     		ldr	r3, .L196
 3290 005a 1B68     		ldr	r3, [r3]
 3291 005c 013B     		subs	r3, r3, #1
 3292 005e 054A     		ldr	r2, .L196
 3293 0060 1360     		str	r3, [r2]
1988:common/rtos/tasks.c **** 				}
1989:common/rtos/tasks.c **** 				portEXIT_CRITICAL();
 3294              		.loc 1 1989 5 discriminator 4
 3295 0062 0C4B     		ldr	r3, .L196+32
 3296 0064 9847     		blx	r3
 3297              	.LVL94:
1990:common/rtos/tasks.c **** 
1991:common/rtos/tasks.c **** 				prvDeleteTCB( pxTCB );
 3298              		.loc 1 1991 5 discriminator 4
 3299 0066 3868     		ldr	r0, [r7]
 3300 0068 0B4B     		ldr	r3, .L196+36
 3301 006a 9847     		blx	r3
 3302              	.LVL95:
 3303              	.L195:
 3304              	.LBE12:
 3305              	.LBE11:
1992:common/rtos/tasks.c **** 			}
1993:common/rtos/tasks.c **** 		}
1994:common/rtos/tasks.c **** 	}
1995:common/rtos/tasks.c **** 	#endif
1996:common/rtos/tasks.c **** }
 3306              		.loc 1 1996 1
 3307 006c 00BF     		nop
 3308 006e 0837     		adds	r7, r7, #8
 3309              	.LCFI128:
 3310              		.cfi_def_cfa_offset 8
 3311 0070 BD46     		mov	sp, r7
 3312              	.LCFI129:
 3313              		.cfi_def_cfa_register 13
 3314              		@ sp needed
 3315 0072 80BD     		pop	{r7, pc}
 3316              	.L197:
 3317              		.align	2
 3318              	.L196:
 3319 0074 00000000 		.word	uxTasksDeleted
 3320 0078 00000000 		.word	vTaskSuspendAll
 3321 007c 00000000 		.word	xTasksWaitingTermination
 3322 0080 00000000 		.word	xTaskResumeAll
 3323 0084 00000000 		.word	vPortEnterCritical
 3324 0088 08000000 		.word	xTasksWaitingTermination+8
 3325 008c 00000000 		.word	vListRemove
 3326 0090 00000000 		.word	uxCurrentNumberOfTasks
 3327 0094 00000000 		.word	vPortExitCritical
 3328 0098 00000000 		.word	prvDeleteTCB
 3329              		.cfi_endproc
 3330              	.LFE56:
 3332              		.section	.text.prvAllocateTCBAndStack,"ax",%progbits
 3333              		.align	1
 3334              		.syntax unified
 3335              		.thumb
 3336              		.thumb_func
 3338              	prvAllocateTCBAndStack:
 3339              	.LFB57:
1997:common/rtos/tasks.c **** /*-----------------------------------------------------------*/
1998:common/rtos/tasks.c **** 
1999:common/rtos/tasks.c **** static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer 
2000:common/rtos/tasks.c **** {
 3340              		.loc 1 2000 1
 3341              		.cfi_startproc
 3342              		@ args = 0, pretend = 0, frame = 16
 3343              		@ frame_needed = 1, uses_anonymous_args = 0
 3344 0000 80B5     		push	{r7, lr}
 3345              	.LCFI130:
 3346              		.cfi_def_cfa_offset 8
 3347              		.cfi_offset 7, -8
 3348              		.cfi_offset 14, -4
 3349 0002 84B0     		sub	sp, sp, #16
 3350              	.LCFI131:
 3351              		.cfi_def_cfa_offset 24
 3352 0004 00AF     		add	r7, sp, #0
 3353              	.LCFI132:
 3354              		.cfi_def_cfa_register 7
 3355 0006 0346     		mov	r3, r0
 3356 0008 3960     		str	r1, [r7]
 3357 000a FB80     		strh	r3, [r7, #6]	@ movhi
2001:common/rtos/tasks.c **** tskTCB *pxNewTCB;
2002:common/rtos/tasks.c **** 
2003:common/rtos/tasks.c **** 	/* Allocate space for the TCB.  Where the memory comes from depends on
2004:common/rtos/tasks.c **** 	the implementation of the port malloc function. */
2005:common/rtos/tasks.c **** 	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
 3358              		.loc 1 2005 26
 3359 000c 4820     		movs	r0, #72
 3360 000e 124B     		ldr	r3, .L202
 3361 0010 9847     		blx	r3
 3362              	.LVL96:
 3363 0012 F860     		str	r0, [r7, #12]
2006:common/rtos/tasks.c **** 
2007:common/rtos/tasks.c **** 	if( pxNewTCB != NULL )
 3364              		.loc 1 2007 4
 3365 0014 FB68     		ldr	r3, [r7, #12]
 3366 0016 002B     		cmp	r3, #0
 3367 0018 19D0     		beq	.L199
2008:common/rtos/tasks.c **** 	{
2009:common/rtos/tasks.c **** 		/* Allocate space for the stack used by the task being created.
2010:common/rtos/tasks.c **** 		The base of the stack memory stored in the TCB so the task can
2011:common/rtos/tasks.c **** 		be deleted later if required. */
2012:common/rtos/tasks.c **** 		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * size
 3368              		.loc 1 2012 44
 3369 001a FB88     		ldrh	r3, [r7, #6]
 3370 001c 9B00     		lsls	r3, r3, #2
 3371 001e 1846     		mov	r0, r3
 3372 0020 0D4B     		ldr	r3, .L202
 3373 0022 9847     		blx	r3
 3374              	.LVL97:
 3375 0024 0246     		mov	r2, r0
 3376              		.loc 1 2012 21
 3377 0026 FB68     		ldr	r3, [r7, #12]
 3378 0028 1A63     		str	r2, [r3, #48]
2013:common/rtos/tasks.c **** 
2014:common/rtos/tasks.c **** 		if( pxNewTCB->pxStack == NULL )
 3379              		.loc 1 2014 15
 3380 002a FB68     		ldr	r3, [r7, #12]
 3381 002c 1B6B     		ldr	r3, [r3, #48]
 3382              		.loc 1 2014 5
 3383 002e 002B     		cmp	r3, #0
 3384 0030 05D1     		bne	.L200
2015:common/rtos/tasks.c **** 		{
2016:common/rtos/tasks.c **** 			/* Could not allocate the stack.  Delete the allocated TCB. */
2017:common/rtos/tasks.c **** 			vPortFree( pxNewTCB );
 3385              		.loc 1 2017 4
 3386 0032 F868     		ldr	r0, [r7, #12]
 3387 0034 094B     		ldr	r3, .L202+4
 3388 0036 9847     		blx	r3
 3389              	.LVL98:
2018:common/rtos/tasks.c **** 			pxNewTCB = NULL;
 3390              		.loc 1 2018 13
 3391 0038 0023     		movs	r3, #0
 3392 003a FB60     		str	r3, [r7, #12]
 3393 003c 07E0     		b	.L199
 3394              	.L200:
2019:common/rtos/tasks.c **** 		}
2020:common/rtos/tasks.c **** 		else
2021:common/rtos/tasks.c **** 		{
2022:common/rtos/tasks.c **** 			/* Just to help debugging. */
2023:common/rtos/tasks.c **** 			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
 3395              		.loc 1 2023 20
 3396 003e FB68     		ldr	r3, [r7, #12]
 3397 0040 186B     		ldr	r0, [r3, #48]
 3398              		.loc 1 2023 4
 3399 0042 FB88     		ldrh	r3, [r7, #6]
 3400 0044 9B00     		lsls	r3, r3, #2
 3401 0046 1A46     		mov	r2, r3
 3402 0048 A521     		movs	r1, #165
 3403 004a 054B     		ldr	r3, .L202+8
 3404 004c 9847     		blx	r3
 3405              	.LVL99:
 3406              	.L199:
2024:common/rtos/tasks.c **** 		}
2025:common/rtos/tasks.c **** 	}
2026:common/rtos/tasks.c **** 
2027:common/rtos/tasks.c **** 	return pxNewTCB;
 3407              		.loc 1 2027 9
 3408 004e FB68     		ldr	r3, [r7, #12]
2028:common/rtos/tasks.c **** }
 3409              		.loc 1 2028 1
 3410 0050 1846     		mov	r0, r3
 3411 0052 1037     		adds	r7, r7, #16
 3412              	.LCFI133:
 3413              		.cfi_def_cfa_offset 8
 3414 0054 BD46     		mov	sp, r7
 3415              	.LCFI134:
 3416              		.cfi_def_cfa_register 13
 3417              		@ sp needed
 3418 0056 80BD     		pop	{r7, pc}
 3419              	.L203:
 3420              		.align	2
 3421              	.L202:
 3422 0058 00000000 		.word	pvPortMalloc
 3423 005c 00000000 		.word	vPortFree
 3424 0060 00000000 		.word	memset
 3425              		.cfi_endproc
 3426              	.LFE57:
 3428              		.section	.text.prvDeleteTCB,"ax",%progbits
 3429              		.align	1
 3430              		.syntax unified
 3431              		.thumb
 3432              		.thumb_func
 3434              	prvDeleteTCB:
 3435              	.LFB58:
2029:common/rtos/tasks.c **** /*-----------------------------------------------------------*/
2030:common/rtos/tasks.c **** 
2031:common/rtos/tasks.c **** #if ( configUSE_TRACE_FACILITY == 1 )
2032:common/rtos/tasks.c **** 
2033:common/rtos/tasks.c **** 	static void prvListTaskWithinSingleList( const signed char *pcWriteBuffer, xList *pxList, signed c
2034:common/rtos/tasks.c **** 	{
2035:common/rtos/tasks.c **** 	volatile tskTCB *pxNextTCB, *pxFirstTCB;
2036:common/rtos/tasks.c **** 	unsigned short usStackRemaining;
2037:common/rtos/tasks.c **** 
2038:common/rtos/tasks.c **** 		/* Write the details of all the TCB's in pxList into the buffer. */
2039:common/rtos/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
2040:common/rtos/tasks.c **** 		do
2041:common/rtos/tasks.c **** 		{
2042:common/rtos/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
2043:common/rtos/tasks.c **** 			#if ( portSTACK_GROWTH > 0 )
2044:common/rtos/tasks.c **** 			{
2045:common/rtos/tasks.c **** 				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxEndOfStack );
2046:common/rtos/tasks.c **** 			}
2047:common/rtos/tasks.c **** 			#else
2048:common/rtos/tasks.c **** 			{
2049:common/rtos/tasks.c **** 				usStackRemaining = usTaskCheckFreeStackSpace( ( unsigned char * ) pxNextTCB->pxStack );
2050:common/rtos/tasks.c **** 			}
2051:common/rtos/tasks.c **** 			#endif			
2052:common/rtos/tasks.c **** 			
2053:common/rtos/tasks.c **** 			sprintf( pcStatusString, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", pxNextTCB->pcTaskName, cStatus, 
2054:common/rtos/tasks.c **** 			strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatusString );
2055:common/rtos/tasks.c **** 
2056:common/rtos/tasks.c **** 		} while( pxNextTCB != pxFirstTCB );
2057:common/rtos/tasks.c **** 	}
2058:common/rtos/tasks.c **** 
2059:common/rtos/tasks.c **** #endif
2060:common/rtos/tasks.c **** /*-----------------------------------------------------------*/
2061:common/rtos/tasks.c **** 
2062:common/rtos/tasks.c **** #if ( configGENERATE_RUN_TIME_STATS == 1 )
2063:common/rtos/tasks.c **** 
2064:common/rtos/tasks.c **** 	static void prvGenerateRunTimeStatsForTasksInList( const signed char *pcWriteBuffer, xList *pxList
2065:common/rtos/tasks.c **** 	{
2066:common/rtos/tasks.c **** 	volatile tskTCB *pxNextTCB, *pxFirstTCB;
2067:common/rtos/tasks.c **** 	unsigned long ulStatsAsPercentage;
2068:common/rtos/tasks.c **** 
2069:common/rtos/tasks.c **** 		/* Write the run time stats of all the TCB's in pxList into the buffer. */
2070:common/rtos/tasks.c **** 		listGET_OWNER_OF_NEXT_ENTRY( pxFirstTCB, pxList );
2071:common/rtos/tasks.c **** 		do
2072:common/rtos/tasks.c **** 		{
2073:common/rtos/tasks.c **** 			/* Get next TCB in from the list. */
2074:common/rtos/tasks.c **** 			listGET_OWNER_OF_NEXT_ENTRY( pxNextTCB, pxList );
2075:common/rtos/tasks.c **** 
2076:common/rtos/tasks.c **** 			/* Divide by zero check. */
2077:common/rtos/tasks.c **** 			if( ulTotalRunTime > 0UL )
2078:common/rtos/tasks.c **** 			{
2079:common/rtos/tasks.c **** 				/* Has the task run at all? */
2080:common/rtos/tasks.c **** 				if( pxNextTCB->ulRunTimeCounter == 0 )
2081:common/rtos/tasks.c **** 				{
2082:common/rtos/tasks.c **** 					/* The task has used no CPU time at all. */
2083:common/rtos/tasks.c **** 					sprintf( pcStatsString, ( char * ) "%s\t\t0\t\t0%%\r\n", pxNextTCB->pcTaskName );
2084:common/rtos/tasks.c **** 				}
2085:common/rtos/tasks.c **** 				else
2086:common/rtos/tasks.c **** 				{
2087:common/rtos/tasks.c **** 					/* What percentage of the total run time as the task used?
2088:common/rtos/tasks.c **** 					This will always be rounded down to the nearest integer. */
2089:common/rtos/tasks.c **** 					ulStatsAsPercentage = ( 100UL * pxNextTCB->ulRunTimeCounter ) / ulTotalRunTime;
2090:common/rtos/tasks.c **** 
2091:common/rtos/tasks.c **** 					if( ulStatsAsPercentage > 0UL )
2092:common/rtos/tasks.c **** 					{
2093:common/rtos/tasks.c **** 						sprintf( pcStatsString, ( char * ) "%s\t\t%u\t\t%u%%\r\n", pxNextTCB->pcTaskName, ( unsigned 
2094:common/rtos/tasks.c **** 					}
2095:common/rtos/tasks.c **** 					else
2096:common/rtos/tasks.c **** 					{
2097:common/rtos/tasks.c **** 						/* If the percentage is zero here then the task has
2098:common/rtos/tasks.c **** 						consumed less than 1% of the total run time. */
2099:common/rtos/tasks.c **** 						sprintf( pcStatsString, ( char * ) "%s\t\t%u\t\t<1%%\r\n", pxNextTCB->pcTaskName, ( unsigned 
2100:common/rtos/tasks.c **** 					}
2101:common/rtos/tasks.c **** 				}
2102:common/rtos/tasks.c **** 
2103:common/rtos/tasks.c **** 				strcat( ( char * ) pcWriteBuffer, ( char * ) pcStatsString );
2104:common/rtos/tasks.c **** 			}
2105:common/rtos/tasks.c **** 
2106:common/rtos/tasks.c **** 		} while( pxNextTCB != pxFirstTCB );
2107:common/rtos/tasks.c **** 	}
2108:common/rtos/tasks.c **** 
2109:common/rtos/tasks.c **** #endif
2110:common/rtos/tasks.c **** /*-----------------------------------------------------------*/
2111:common/rtos/tasks.c **** 
2112:common/rtos/tasks.c **** #if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
2113:common/rtos/tasks.c **** 
2114:common/rtos/tasks.c **** 	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
2115:common/rtos/tasks.c **** 	{
2116:common/rtos/tasks.c **** 	register unsigned short usCount = 0;
2117:common/rtos/tasks.c **** 
2118:common/rtos/tasks.c **** 		while( *pucStackByte == tskSTACK_FILL_BYTE )
2119:common/rtos/tasks.c **** 		{
2120:common/rtos/tasks.c **** 			pucStackByte -= portSTACK_GROWTH;
2121:common/rtos/tasks.c **** 			usCount++;
2122:common/rtos/tasks.c **** 		}
2123:common/rtos/tasks.c **** 
2124:common/rtos/tasks.c **** 		usCount /= sizeof( portSTACK_TYPE );
2125:common/rtos/tasks.c **** 
2126:common/rtos/tasks.c **** 		return usCount;
2127:common/rtos/tasks.c **** 	}
2128:common/rtos/tasks.c **** 
2129:common/rtos/tasks.c **** #endif
2130:common/rtos/tasks.c **** /*-----------------------------------------------------------*/
2131:common/rtos/tasks.c **** 
2132:common/rtos/tasks.c **** #if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )
2133:common/rtos/tasks.c **** 
2134:common/rtos/tasks.c **** 	unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask )
2135:common/rtos/tasks.c **** 	{
2136:common/rtos/tasks.c **** 	tskTCB *pxTCB;
2137:common/rtos/tasks.c **** 	unsigned char *pcEndOfStack;
2138:common/rtos/tasks.c **** 	unsigned portBASE_TYPE uxReturn;
2139:common/rtos/tasks.c **** 
2140:common/rtos/tasks.c **** 		pxTCB = prvGetTCBFromHandle( xTask );
2141:common/rtos/tasks.c **** 
2142:common/rtos/tasks.c **** 		#if portSTACK_GROWTH < 0
2143:common/rtos/tasks.c **** 		{
2144:common/rtos/tasks.c **** 			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
2145:common/rtos/tasks.c **** 		}
2146:common/rtos/tasks.c **** 		#else
2147:common/rtos/tasks.c **** 		{
2148:common/rtos/tasks.c **** 			pcEndOfStack = ( unsigned char * ) pxTCB->pxEndOfStack;
2149:common/rtos/tasks.c **** 		}
2150:common/rtos/tasks.c **** 		#endif
2151:common/rtos/tasks.c **** 
2152:common/rtos/tasks.c **** 		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );
2153:common/rtos/tasks.c **** 
2154:common/rtos/tasks.c **** 		return uxReturn;
2155:common/rtos/tasks.c **** 	}
2156:common/rtos/tasks.c **** 
2157:common/rtos/tasks.c **** #endif
2158:common/rtos/tasks.c **** /*-----------------------------------------------------------*/
2159:common/rtos/tasks.c **** 
2160:common/rtos/tasks.c **** #if ( ( INCLUDE_vTaskDelete == 1 ) || ( INCLUDE_vTaskCleanUpResources == 1 ) )
2161:common/rtos/tasks.c **** 
2162:common/rtos/tasks.c **** 	static void prvDeleteTCB( tskTCB *pxTCB )
2163:common/rtos/tasks.c **** 	{
 3436              		.loc 1 2163 2
 3437              		.cfi_startproc
 3438              		@ args = 0, pretend = 0, frame = 8
 3439              		@ frame_needed = 1, uses_anonymous_args = 0
 3440 0000 80B5     		push	{r7, lr}
 3441              	.LCFI135:
 3442              		.cfi_def_cfa_offset 8
 3443              		.cfi_offset 7, -8
 3444              		.cfi_offset 14, -4
 3445 0002 82B0     		sub	sp, sp, #8
 3446              	.LCFI136:
 3447              		.cfi_def_cfa_offset 16
 3448 0004 00AF     		add	r7, sp, #0
 3449              	.LCFI137:
 3450              		.cfi_def_cfa_register 7
 3451 0006 7860     		str	r0, [r7, #4]
2164:common/rtos/tasks.c **** 		/* Free up the memory allocated by the scheduler for the task.  It is up to
2165:common/rtos/tasks.c **** 		the task to free any memory allocated at the application level. */
2166:common/rtos/tasks.c **** 		vPortFreeAligned( pxTCB->pxStack );
 3452              		.loc 1 2166 3
 3453 0008 7B68     		ldr	r3, [r7, #4]
 3454 000a 1B6B     		ldr	r3, [r3, #48]
 3455 000c 1846     		mov	r0, r3
 3456 000e 044B     		ldr	r3, .L205
 3457 0010 9847     		blx	r3
 3458              	.LVL100:
2167:common/rtos/tasks.c **** 		vPortFree( pxTCB );
 3459              		.loc 1 2167 3
 3460 0012 7868     		ldr	r0, [r7, #4]
 3461 0014 024B     		ldr	r3, .L205
 3462 0016 9847     		blx	r3
 3463              	.LVL101:
2168:common/rtos/tasks.c **** 	}
 3464              		.loc 1 2168 2
 3465 0018 00BF     		nop
 3466 001a 0837     		adds	r7, r7, #8
 3467              	.LCFI138:
 3468              		.cfi_def_cfa_offset 8
 3469 001c BD46     		mov	sp, r7
 3470              	.LCFI139:
 3471              		.cfi_def_cfa_register 13
 3472              		@ sp needed
 3473 001e 80BD     		pop	{r7, pc}
 3474              	.L206:
 3475              		.align	2
 3476              	.L205:
 3477 0020 00000000 		.word	vPortFree
 3478              		.cfi_endproc
 3479              	.LFE58:
 3481              		.section	.text.xTaskGetCurrentTaskHandle,"ax",%progbits
 3482              		.align	1
 3483              		.global	xTaskGetCurrentTaskHandle
 3484              		.syntax unified
 3485              		.thumb
 3486              		.thumb_func
 3488              	xTaskGetCurrentTaskHandle:
 3489              	.LFB59:
2169:common/rtos/tasks.c **** 
2170:common/rtos/tasks.c **** #endif
2171:common/rtos/tasks.c **** 
2172:common/rtos/tasks.c **** 
2173:common/rtos/tasks.c **** /*-----------------------------------------------------------*/
2174:common/rtos/tasks.c **** 
2175:common/rtos/tasks.c **** #if ( INCLUDE_xTaskGetCurrentTaskHandle == 1 )
2176:common/rtos/tasks.c **** 
2177:common/rtos/tasks.c **** 	xTaskHandle xTaskGetCurrentTaskHandle( void )
2178:common/rtos/tasks.c **** 	{
 3490              		.loc 1 2178 2
 3491              		.cfi_startproc
 3492              		@ args = 0, pretend = 0, frame = 8
 3493              		@ frame_needed = 1, uses_anonymous_args = 0
 3494              		@ link register save eliminated.
 3495 0000 80B4     		push	{r7}
 3496              	.LCFI140:
 3497              		.cfi_def_cfa_offset 4
 3498              		.cfi_offset 7, -4
 3499 0002 83B0     		sub	sp, sp, #12
 3500              	.LCFI141:
 3501              		.cfi_def_cfa_offset 16
 3502 0004 00AF     		add	r7, sp, #0
 3503              	.LCFI142:
 3504              		.cfi_def_cfa_register 7
2179:common/rtos/tasks.c **** 	xTaskHandle xReturn;
2180:common/rtos/tasks.c **** 
2181:common/rtos/tasks.c **** 		/* A critical section is not required as this is not called from
2182:common/rtos/tasks.c **** 		an interrupt and the current TCB will always be the same for any
2183:common/rtos/tasks.c **** 		individual execution thread. */
2184:common/rtos/tasks.c **** 		xReturn = pxCurrentTCB;
 3505              		.loc 1 2184 11
 3506 0006 044B     		ldr	r3, .L209
 3507 0008 1B68     		ldr	r3, [r3]
 3508 000a 7B60     		str	r3, [r7, #4]
2185:common/rtos/tasks.c **** 
2186:common/rtos/tasks.c **** 		return xReturn;
 3509              		.loc 1 2186 10
 3510 000c 7B68     		ldr	r3, [r7, #4]
2187:common/rtos/tasks.c **** 	}
 3511              		.loc 1 2187 2
 3512 000e 1846     		mov	r0, r3
 3513 0010 0C37     		adds	r7, r7, #12
 3514              	.LCFI143:
 3515              		.cfi_def_cfa_offset 4
 3516 0012 BD46     		mov	sp, r7
 3517              	.LCFI144:
 3518              		.cfi_def_cfa_register 13
 3519              		@ sp needed
 3520 0014 80BC     		pop	{r7}
 3521              	.LCFI145:
 3522              		.cfi_restore 7
 3523              		.cfi_def_cfa_offset 0
 3524 0016 7047     		bx	lr
 3525              	.L210:
 3526              		.align	2
 3527              	.L209:
 3528 0018 00000000 		.word	pxCurrentTCB
 3529              		.cfi_endproc
 3530              	.LFE59:
 3532              		.section	.text.vTaskPriorityInherit,"ax",%progbits
 3533              		.align	1
 3534              		.global	vTaskPriorityInherit
 3535              		.syntax unified
 3536              		.thumb
 3537              		.thumb_func
 3539              	vTaskPriorityInherit:
 3540              	.LFB60:
2188:common/rtos/tasks.c **** 
2189:common/rtos/tasks.c **** #endif
2190:common/rtos/tasks.c **** 
2191:common/rtos/tasks.c **** /*-----------------------------------------------------------*/
2192:common/rtos/tasks.c **** 
2193:common/rtos/tasks.c **** #if ( INCLUDE_xTaskGetSchedulerState == 1 )
2194:common/rtos/tasks.c **** 
2195:common/rtos/tasks.c **** 	portBASE_TYPE xTaskGetSchedulerState( void )
2196:common/rtos/tasks.c **** 	{
2197:common/rtos/tasks.c **** 	portBASE_TYPE xReturn;
2198:common/rtos/tasks.c **** 
2199:common/rtos/tasks.c **** 		if( xSchedulerRunning == pdFALSE )
2200:common/rtos/tasks.c **** 		{
2201:common/rtos/tasks.c **** 			xReturn = taskSCHEDULER_NOT_STARTED;
2202:common/rtos/tasks.c **** 		}
2203:common/rtos/tasks.c **** 		else
2204:common/rtos/tasks.c **** 		{
2205:common/rtos/tasks.c **** 			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
2206:common/rtos/tasks.c **** 			{
2207:common/rtos/tasks.c **** 				xReturn = taskSCHEDULER_RUNNING;
2208:common/rtos/tasks.c **** 			}
2209:common/rtos/tasks.c **** 			else
2210:common/rtos/tasks.c **** 			{
2211:common/rtos/tasks.c **** 				xReturn = taskSCHEDULER_SUSPENDED;
2212:common/rtos/tasks.c **** 			}
2213:common/rtos/tasks.c **** 		}
2214:common/rtos/tasks.c **** 
2215:common/rtos/tasks.c **** 		return xReturn;
2216:common/rtos/tasks.c **** 	}
2217:common/rtos/tasks.c **** 
2218:common/rtos/tasks.c **** #endif
2219:common/rtos/tasks.c **** /*-----------------------------------------------------------*/
2220:common/rtos/tasks.c **** 
2221:common/rtos/tasks.c **** #if ( configUSE_MUTEXES == 1 )
2222:common/rtos/tasks.c **** 
2223:common/rtos/tasks.c **** 	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
2224:common/rtos/tasks.c **** 	{
 3541              		.loc 1 2224 2
 3542              		.cfi_startproc
 3543              		@ args = 0, pretend = 0, frame = 16
 3544              		@ frame_needed = 1, uses_anonymous_args = 0
 3545 0000 80B5     		push	{r7, lr}
 3546              	.LCFI146:
 3547              		.cfi_def_cfa_offset 8
 3548              		.cfi_offset 7, -8
 3549              		.cfi_offset 14, -4
 3550 0002 84B0     		sub	sp, sp, #16
 3551              	.LCFI147:
 3552              		.cfi_def_cfa_offset 24
 3553 0004 00AF     		add	r7, sp, #0
 3554              	.LCFI148:
 3555              		.cfi_def_cfa_register 7
 3556 0006 7860     		str	r0, [r7, #4]
2225:common/rtos/tasks.c **** 	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
 3557              		.loc 1 2225 17
 3558 0008 7B68     		ldr	r3, [r7, #4]
 3559 000a FB60     		str	r3, [r7, #12]
2226:common/rtos/tasks.c **** 
2227:common/rtos/tasks.c **** 		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
 3560              		.loc 1 2227 12
 3561 000c FB68     		ldr	r3, [r7, #12]
 3562 000e DA6A     		ldr	r2, [r3, #44]
 3563              		.loc 1 2227 39
 3564 0010 214B     		ldr	r3, .L216
 3565 0012 1B68     		ldr	r3, [r3]
 3566 0014 DB6A     		ldr	r3, [r3, #44]
 3567              		.loc 1 2227 5
 3568 0016 9A42     		cmp	r2, r3
 3569 0018 3AD2     		bcs	.L215
2228:common/rtos/tasks.c **** 		{
2229:common/rtos/tasks.c **** 			/* Adjust the mutex holder state to account for its new priority. */
2230:common/rtos/tasks.c **** 			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxC
 3570              		.loc 1 2230 4
 3571 001a 1F4B     		ldr	r3, .L216
 3572 001c 1B68     		ldr	r3, [r3]
 3573 001e DB6A     		ldr	r3, [r3, #44]
 3574 0020 C3F10A02 		rsb	r2, r3, #10
 3575 0024 FB68     		ldr	r3, [r7, #12]
 3576 0026 9A61     		str	r2, [r3, #24]
2231:common/rtos/tasks.c **** 
2232:common/rtos/tasks.c **** 			/* If the task being modified is in the ready state it will need to
2233:common/rtos/tasks.c **** 			be moved in to a new list. */
2234:common/rtos/tasks.c **** 			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericList
 3577              		.loc 1 2234 8
 3578 0028 FB68     		ldr	r3, [r7, #12]
 3579 002a 5969     		ldr	r1, [r3, #20]
 3580 002c FB68     		ldr	r3, [r7, #12]
 3581 002e DA6A     		ldr	r2, [r3, #44]
 3582 0030 1346     		mov	r3, r2
 3583 0032 9B00     		lsls	r3, r3, #2
 3584 0034 1344     		add	r3, r3, r2
 3585 0036 9B00     		lsls	r3, r3, #2
 3586 0038 184A     		ldr	r2, .L216+4
 3587 003a 1344     		add	r3, r3, r2
 3588              		.loc 1 2234 6
 3589 003c 9942     		cmp	r1, r3
 3590 003e 22D1     		bne	.L213
2235:common/rtos/tasks.c **** 			{
2236:common/rtos/tasks.c **** 				vListRemove( &( pxTCB->xGenericListItem ) );
 3591              		.loc 1 2236 5
 3592 0040 FB68     		ldr	r3, [r7, #12]
 3593 0042 0433     		adds	r3, r3, #4
 3594 0044 1846     		mov	r0, r3
 3595 0046 164B     		ldr	r3, .L216+8
 3596 0048 9847     		blx	r3
 3597              	.LVL102:
2237:common/rtos/tasks.c **** 
2238:common/rtos/tasks.c **** 				/* Inherit the priority before being moved into the new list. */
2239:common/rtos/tasks.c **** 				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 3598              		.loc 1 2239 37
 3599 004a 134B     		ldr	r3, .L216
 3600 004c 1B68     		ldr	r3, [r3]
 3601 004e DA6A     		ldr	r2, [r3, #44]
 3602              		.loc 1 2239 23
 3603 0050 FB68     		ldr	r3, [r7, #12]
 3604 0052 DA62     		str	r2, [r3, #44]
2240:common/rtos/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );
 3605              		.loc 1 2240 5
 3606 0054 FB68     		ldr	r3, [r7, #12]
 3607 0056 DA6A     		ldr	r2, [r3, #44]
 3608 0058 124B     		ldr	r3, .L216+12
 3609 005a 1B68     		ldr	r3, [r3]
 3610 005c 9A42     		cmp	r2, r3
 3611 005e 03D9     		bls	.L214
 3612              		.loc 1 2240 5 is_stmt 0 discriminator 1
 3613 0060 FB68     		ldr	r3, [r7, #12]
 3614 0062 DB6A     		ldr	r3, [r3, #44]
 3615 0064 0F4A     		ldr	r2, .L216+12
 3616 0066 1360     		str	r3, [r2]
 3617              	.L214:
 3618              		.loc 1 2240 5 discriminator 3
 3619 0068 FB68     		ldr	r3, [r7, #12]
 3620 006a DA6A     		ldr	r2, [r3, #44]
 3621 006c 1346     		mov	r3, r2
 3622 006e 9B00     		lsls	r3, r3, #2
 3623 0070 1344     		add	r3, r3, r2
 3624 0072 9B00     		lsls	r3, r3, #2
 3625 0074 094A     		ldr	r2, .L216+4
 3626 0076 1A44     		add	r2, r2, r3
 3627 0078 FB68     		ldr	r3, [r7, #12]
 3628 007a 0433     		adds	r3, r3, #4
 3629 007c 1946     		mov	r1, r3
 3630 007e 1046     		mov	r0, r2
 3631 0080 094B     		ldr	r3, .L216+16
 3632 0082 9847     		blx	r3
 3633              	.LVL103:
2241:common/rtos/tasks.c **** 			}
2242:common/rtos/tasks.c **** 			else
2243:common/rtos/tasks.c **** 			{
2244:common/rtos/tasks.c **** 				/* Just inherit the priority. */
2245:common/rtos/tasks.c **** 				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
2246:common/rtos/tasks.c **** 			}
2247:common/rtos/tasks.c **** 		}
2248:common/rtos/tasks.c **** 	}
 3634              		.loc 1 2248 2 is_stmt 1 discriminator 3
 3635 0084 04E0     		b	.L215
 3636              	.L213:
2245:common/rtos/tasks.c **** 			}
 3637              		.loc 1 2245 37
 3638 0086 044B     		ldr	r3, .L216
 3639 0088 1B68     		ldr	r3, [r3]
 3640 008a DA6A     		ldr	r2, [r3, #44]
2245:common/rtos/tasks.c **** 			}
 3641              		.loc 1 2245 23
 3642 008c FB68     		ldr	r3, [r7, #12]
 3643 008e DA62     		str	r2, [r3, #44]
 3644              	.L215:
 3645              		.loc 1 2248 2
 3646 0090 00BF     		nop
 3647 0092 1037     		adds	r7, r7, #16
 3648              	.LCFI149:
 3649              		.cfi_def_cfa_offset 8
 3650 0094 BD46     		mov	sp, r7
 3651              	.LCFI150:
 3652              		.cfi_def_cfa_register 13
 3653              		@ sp needed
 3654 0096 80BD     		pop	{r7, pc}
 3655              	.L217:
 3656              		.align	2
 3657              	.L216:
 3658 0098 00000000 		.word	pxCurrentTCB
 3659 009c 00000000 		.word	pxReadyTasksLists
 3660 00a0 00000000 		.word	vListRemove
 3661 00a4 00000000 		.word	uxTopReadyPriority
 3662 00a8 00000000 		.word	vListInsertEnd
 3663              		.cfi_endproc
 3664              	.LFE60:
 3666              		.section	.text.vTaskPriorityDisinherit,"ax",%progbits
 3667              		.align	1
 3668              		.global	vTaskPriorityDisinherit
 3669              		.syntax unified
 3670              		.thumb
 3671              		.thumb_func
 3673              	vTaskPriorityDisinherit:
 3674              	.LFB61:
2249:common/rtos/tasks.c **** 
2250:common/rtos/tasks.c **** #endif
2251:common/rtos/tasks.c **** /*-----------------------------------------------------------*/
2252:common/rtos/tasks.c **** 
2253:common/rtos/tasks.c **** #if ( configUSE_MUTEXES == 1 )
2254:common/rtos/tasks.c **** 
2255:common/rtos/tasks.c **** 	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
2256:common/rtos/tasks.c **** 	{
 3675              		.loc 1 2256 2
 3676              		.cfi_startproc
 3677              		@ args = 0, pretend = 0, frame = 16
 3678              		@ frame_needed = 1, uses_anonymous_args = 0
 3679 0000 80B5     		push	{r7, lr}
 3680              	.LCFI151:
 3681              		.cfi_def_cfa_offset 8
 3682              		.cfi_offset 7, -8
 3683              		.cfi_offset 14, -4
 3684 0002 84B0     		sub	sp, sp, #16
 3685              	.LCFI152:
 3686              		.cfi_def_cfa_offset 24
 3687 0004 00AF     		add	r7, sp, #0
 3688              	.LCFI153:
 3689              		.cfi_def_cfa_register 7
 3690 0006 7860     		str	r0, [r7, #4]
2257:common/rtos/tasks.c **** 	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
 3691              		.loc 1 2257 17
 3692 0008 7B68     		ldr	r3, [r7, #4]
 3693 000a FB60     		str	r3, [r7, #12]
2258:common/rtos/tasks.c **** 
2259:common/rtos/tasks.c **** 		if( pxMutexHolder != NULL )
 3694              		.loc 1 2259 5
 3695 000c 7B68     		ldr	r3, [r7, #4]
 3696 000e 002B     		cmp	r3, #0
 3697 0010 2CD0     		beq	.L221
2260:common/rtos/tasks.c **** 		{
2261:common/rtos/tasks.c **** 			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 3698              		.loc 1 2261 13
 3699 0012 FB68     		ldr	r3, [r7, #12]
 3700 0014 DA6A     		ldr	r2, [r3, #44]
 3701              		.loc 1 2261 34
 3702 0016 FB68     		ldr	r3, [r7, #12]
 3703 0018 5B6C     		ldr	r3, [r3, #68]
 3704              		.loc 1 2261 6
 3705 001a 9A42     		cmp	r2, r3
 3706 001c 26D0     		beq	.L221
2262:common/rtos/tasks.c **** 			{
2263:common/rtos/tasks.c **** 				/* We must be the running task to be able to give the mutex back.
2264:common/rtos/tasks.c **** 				Remove ourselves from the ready list we currently appear in. */
2265:common/rtos/tasks.c **** 				vListRemove( &( pxTCB->xGenericListItem ) );
 3707              		.loc 1 2265 5
 3708 001e FB68     		ldr	r3, [r7, #12]
 3709 0020 0433     		adds	r3, r3, #4
 3710 0022 1846     		mov	r0, r3
 3711 0024 134B     		ldr	r3, .L222
 3712 0026 9847     		blx	r3
 3713              	.LVL104:
2266:common/rtos/tasks.c **** 
2267:common/rtos/tasks.c **** 				/* Disinherit the priority before adding ourselves into the new
2268:common/rtos/tasks.c **** 				ready list. */
2269:common/rtos/tasks.c **** 				pxTCB->uxPriority = pxTCB->uxBasePriority;
 3714              		.loc 1 2269 30
 3715 0028 FB68     		ldr	r3, [r7, #12]
 3716 002a 5A6C     		ldr	r2, [r3, #68]
 3717              		.loc 1 2269 23
 3718 002c FB68     		ldr	r3, [r7, #12]
 3719 002e DA62     		str	r2, [r3, #44]
2270:common/rtos/tasks.c **** 				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) px
 3720              		.loc 1 2270 5
 3721 0030 FB68     		ldr	r3, [r7, #12]
 3722 0032 DB6A     		ldr	r3, [r3, #44]
 3723 0034 C3F10A02 		rsb	r2, r3, #10
 3724 0038 FB68     		ldr	r3, [r7, #12]
 3725 003a 9A61     		str	r2, [r3, #24]
2271:common/rtos/tasks.c **** 				prvAddTaskToReadyQueue( pxTCB );
 3726              		.loc 1 2271 5
 3727 003c FB68     		ldr	r3, [r7, #12]
 3728 003e DA6A     		ldr	r2, [r3, #44]
 3729 0040 0D4B     		ldr	r3, .L222+4
 3730 0042 1B68     		ldr	r3, [r3]
 3731 0044 9A42     		cmp	r2, r3
 3732 0046 03D9     		bls	.L220
 3733              		.loc 1 2271 5 is_stmt 0 discriminator 1
 3734 0048 FB68     		ldr	r3, [r7, #12]
 3735 004a DB6A     		ldr	r3, [r3, #44]
 3736 004c 0A4A     		ldr	r2, .L222+4
 3737 004e 1360     		str	r3, [r2]
 3738              	.L220:
 3739              		.loc 1 2271 5 discriminator 3
 3740 0050 FB68     		ldr	r3, [r7, #12]
 3741 0052 DA6A     		ldr	r2, [r3, #44]
 3742 0054 1346     		mov	r3, r2
 3743 0056 9B00     		lsls	r3, r3, #2
 3744 0058 1344     		add	r3, r3, r2
 3745 005a 9B00     		lsls	r3, r3, #2
 3746 005c 074A     		ldr	r2, .L222+8
 3747 005e 1A44     		add	r2, r2, r3
 3748 0060 FB68     		ldr	r3, [r7, #12]
 3749 0062 0433     		adds	r3, r3, #4
 3750 0064 1946     		mov	r1, r3
 3751 0066 1046     		mov	r0, r2
 3752 0068 054B     		ldr	r3, .L222+12
 3753 006a 9847     		blx	r3
 3754              	.LVL105:
 3755              	.L221:
2272:common/rtos/tasks.c **** 			}
2273:common/rtos/tasks.c **** 		}
2274:common/rtos/tasks.c **** 	}
 3756              		.loc 1 2274 2 is_stmt 1
 3757 006c 00BF     		nop
 3758 006e 1037     		adds	r7, r7, #16
 3759              	.LCFI154:
 3760              		.cfi_def_cfa_offset 8
 3761 0070 BD46     		mov	sp, r7
 3762              	.LCFI155:
 3763              		.cfi_def_cfa_register 13
 3764              		@ sp needed
 3765 0072 80BD     		pop	{r7, pc}
 3766              	.L223:
 3767              		.align	2
 3768              	.L222:
 3769 0074 00000000 		.word	vListRemove
 3770 0078 00000000 		.word	uxTopReadyPriority
 3771 007c 00000000 		.word	pxReadyTasksLists
 3772 0080 00000000 		.word	vListInsertEnd
 3773              		.cfi_endproc
 3774              	.LFE61:
 3776              		.text
 3777              	.Letext0:
 3778              		.file 2 "c:\\program files (x86)\\gnu arm embedded toolchain\\10 2021.10\\lib\\gcc\\arm-none-eabi\
 3779              		.file 3 "common/rtos/include/projdefs.h"
 3780              		.file 4 "common/rtos/portable/GCC/ARM_CM3/portmacro.h"
 3781              		.file 5 "common/rtos/include/list.h"
 3782              		.file 6 "common/rtos/include/task.h"
 3783              		.file 7 "common/rtos/include/portable.h"
 3784              		.file 8 "<built-in>"
DEFINED SYMBOLS
                            *ABS*:00000000 tasks.c
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:22     .bss.pxCurrentTCB:00000000 pxCurrentTCB
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:19     .bss.pxCurrentTCB:00000000 $d
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:25     .bss.pxReadyTasksLists:00000000 $d
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:28     .bss.pxReadyTasksLists:00000000 pxReadyTasksLists
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:31     .bss.xDelayedTaskList1:00000000 $d
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:34     .bss.xDelayedTaskList1:00000000 xDelayedTaskList1
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:37     .bss.xDelayedTaskList2:00000000 $d
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:40     .bss.xDelayedTaskList2:00000000 xDelayedTaskList2
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:43     .bss.pxDelayedTaskList:00000000 $d
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:46     .bss.pxDelayedTaskList:00000000 pxDelayedTaskList
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:49     .bss.pxOverflowDelayedTaskList:00000000 $d
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:52     .bss.pxOverflowDelayedTaskList:00000000 pxOverflowDelayedTaskList
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:55     .bss.xPendingReadyList:00000000 $d
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:58     .bss.xPendingReadyList:00000000 xPendingReadyList
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:61     .bss.xTasksWaitingTermination:00000000 $d
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:64     .bss.xTasksWaitingTermination:00000000 xTasksWaitingTermination
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:67     .bss.uxTasksDeleted:00000000 $d
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:70     .bss.uxTasksDeleted:00000000 uxTasksDeleted
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:73     .bss.xSuspendedTaskList:00000000 $d
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:76     .bss.xSuspendedTaskList:00000000 xSuspendedTaskList
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:79     .bss.uxCurrentNumberOfTasks:00000000 $d
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:82     .bss.uxCurrentNumberOfTasks:00000000 uxCurrentNumberOfTasks
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:85     .bss.xTickCount:00000000 $d
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:88     .bss.xTickCount:00000000 xTickCount
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:91     .bss.uxTopUsedPriority:00000000 $d
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:94     .bss.uxTopUsedPriority:00000000 uxTopUsedPriority
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:97     .bss.uxTopReadyPriority:00000000 $d
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:100    .bss.uxTopReadyPriority:00000000 uxTopReadyPriority
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:103    .bss.xSchedulerRunning:00000000 $d
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:106    .bss.xSchedulerRunning:00000000 xSchedulerRunning
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:109    .bss.uxSchedulerSuspended:00000000 $d
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:112    .bss.uxSchedulerSuspended:00000000 uxSchedulerSuspended
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:115    .bss.uxMissedTicks:00000000 $d
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:118    .bss.uxMissedTicks:00000000 uxMissedTicks
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:121    .bss.xMissedYield:00000000 $d
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:124    .bss.xMissedYield:00000000 xMissedYield
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:127    .bss.xNumOfOverflows:00000000 $d
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:130    .bss.xNumOfOverflows:00000000 xNumOfOverflows
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:133    .bss.uxTaskNumber:00000000 $d
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:136    .bss.uxTaskNumber:00000000 uxTaskNumber
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:139    .text.xTaskGenericCreate:00000000 $t
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:145    .text.xTaskGenericCreate:00000000 xTaskGenericCreate
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:377    .text.xTaskGenericCreate:0000012c $d
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:3338   .text.prvAllocateTCBAndStack:00000000 prvAllocateTCBAndStack
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:2996   .text.prvInitialiseTCBVariables:00000000 prvInitialiseTCBVariables
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:3098   .text.prvInitialiseTaskLists:00000000 prvInitialiseTaskLists
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:396    .text.vTaskDelete:00000000 $t
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:402    .text.vTaskDelete:00000000 vTaskDelete
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:522    .text.vTaskDelete:00000084 $d
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:536    .text.vTaskDelayUntil:00000000 $t
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:542    .text.vTaskDelayUntil:00000000 vTaskDelayUntil
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:707    .text.vTaskDelayUntil:000000c4 $d
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:1746   .text.vTaskSuspendAll:00000000 vTaskSuspendAll
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:1791   .text.xTaskResumeAll:00000000 xTaskResumeAll
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:720    .text.vTaskDelay:00000000 $t
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:726    .text.vTaskDelay:00000000 vTaskDelay
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:840    .text.vTaskDelay:0000007c $d
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:853    .text.uxTaskPriorityGet:00000000 $t
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:859    .text.uxTaskPriorityGet:00000000 uxTaskPriorityGet
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:918    .text.uxTaskPriorityGet:00000030 $d
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:925    .text.vTaskPrioritySet:00000000 $t
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:931    .text.vTaskPrioritySet:00000000 vTaskPrioritySet
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:1120   .text.vTaskPrioritySet:000000f0 $d
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:1132   .text.vTaskSuspend:00000000 $t
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:1138   .text.vTaskSuspend:00000000 vTaskSuspend
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:1240   .text.vTaskSuspend:00000068 $d
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:1251   .text.xTaskIsTaskSuspended:00000000 $t
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:1257   .text.xTaskIsTaskSuspended:00000000 xTaskIsTaskSuspended
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:1324   .text.xTaskIsTaskSuspended:0000003c $d
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:1330   .text.vTaskResume:00000000 $t
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:1336   .text.vTaskResume:00000000 vTaskResume
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:1450   .text.vTaskResume:00000084 $d
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:1463   .text.xTaskResumeFromISR:00000000 $t
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:1469   .text.xTaskResumeFromISR:00000000 xTaskResumeFromISR
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:1585   .text.xTaskResumeFromISR:0000008c $d
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:1597   .rodata:00000000 $d
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:1601   .text.vTaskStartScheduler:00000000 $t
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:1607   .text.vTaskStartScheduler:00000000 vTaskStartScheduler
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:1681   .text.vTaskStartScheduler:0000004c $d
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:2938   .text.prvIdleTask:00000000 prvIdleTask
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:1691   .text.vTaskEndScheduler:00000000 $t
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:1697   .text.vTaskEndScheduler:00000000 vTaskEndScheduler
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:1734   .text.vTaskEndScheduler:0000001c $d
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:1740   .text.vTaskSuspendAll:00000000 $t
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:1780   .text.vTaskSuspendAll:00000018 $d
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:1785   .text.xTaskResumeAll:00000000 $t
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:1985   .text.xTaskResumeAll:000000e0 $d
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:2108   .text.vTaskIncrementTick:00000000 vTaskIncrementTick
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:2003   .text.xTaskGetTickCount:00000000 $t
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:2009   .text.xTaskGetTickCount:00000000 xTaskGetTickCount
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:2053   .text.xTaskGetTickCount:00000020 $d
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:2060   .text.uxTaskGetNumberOfTasks:00000000 $t
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:2066   .text.uxTaskGetNumberOfTasks:00000000 uxTaskGetNumberOfTasks
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:2097   .text.uxTaskGetNumberOfTasks:00000010 $d
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:2102   .text.vTaskIncrementTick:00000000 $t
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:2285   .text.vTaskIncrementTick:000000d0 $d
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:2300   .text.vTaskSwitchContext:00000000 $t
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:2306   .text.vTaskSwitchContext:00000000 vTaskSwitchContext
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:2409   .text.vTaskSwitchContext:0000007c $d
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:2418   .text.vTaskPlaceOnEventList:00000000 $t
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:2424   .text.vTaskPlaceOnEventList:00000000 vTaskPlaceOnEventList
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:2541   .text.vTaskPlaceOnEventList:00000088 $d
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:2553   .text.xTaskRemoveFromEventList:00000000 $t
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:2559   .text.xTaskRemoveFromEventList:00000000 xTaskRemoveFromEventList
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:2689   .text.xTaskRemoveFromEventList:00000098 $d
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:2700   .text.vTaskSetTimeOutState:00000000 $t
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:2706   .text.vTaskSetTimeOutState:00000000 vTaskSetTimeOutState
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:2751   .text.vTaskSetTimeOutState:00000024 $d
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:2757   .text.xTaskCheckForTimeOut:00000000 $t
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:2763   .text.xTaskCheckForTimeOut:00000000 xTaskCheckForTimeOut
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:2881   .text.xTaskCheckForTimeOut:00000080 $d
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:2890   .text.vTaskMissedYield:00000000 $t
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:2896   .text.vTaskMissedYield:00000000 vTaskMissedYield
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:2928   .text.vTaskMissedYield:00000014 $d
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:2933   .text.prvIdleTask:00000000 $t
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:2983   .text.prvIdleTask:00000020 $d
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:3206   .text.prvCheckTasksWaitingTermination:00000000 prvCheckTasksWaitingTermination
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:2991   .text.prvInitialiseTCBVariables:00000000 $t
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:3087   .text.prvInitialiseTCBVariables:0000006c $d
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:3093   .text.prvInitialiseTaskLists:00000000 $t
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:3188   .text.prvInitialiseTaskLists:00000060 $d
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:3201   .text.prvCheckTasksWaitingTermination:00000000 $t
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:3319   .text.prvCheckTasksWaitingTermination:00000074 $d
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:3434   .text.prvDeleteTCB:00000000 prvDeleteTCB
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:3333   .text.prvAllocateTCBAndStack:00000000 $t
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:3422   .text.prvAllocateTCBAndStack:00000058 $d
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:3429   .text.prvDeleteTCB:00000000 $t
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:3477   .text.prvDeleteTCB:00000020 $d
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:3482   .text.xTaskGetCurrentTaskHandle:00000000 $t
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:3488   .text.xTaskGetCurrentTaskHandle:00000000 xTaskGetCurrentTaskHandle
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:3528   .text.xTaskGetCurrentTaskHandle:00000018 $d
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:3533   .text.vTaskPriorityInherit:00000000 $t
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:3539   .text.vTaskPriorityInherit:00000000 vTaskPriorityInherit
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:3658   .text.vTaskPriorityInherit:00000098 $d
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:3667   .text.vTaskPriorityDisinherit:00000000 $t
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:3673   .text.vTaskPriorityDisinherit:00000000 vTaskPriorityDisinherit
C:\Users\Admin\AppData\Local\Temp\ccLQKCOv.s:3769   .text.vTaskPriorityDisinherit:00000074 $d

UNDEFINED SYMBOLS
pxPortInitialiseStack
vPortEnterCritical
vListInsertEnd
vPortExitCritical
vPortYieldFromISR
vListRemove
vListInsert
xPortStartScheduler
vPortEndScheduler
vApplicationTickHook
vApplicationIdleHook
strncpy
vListInitialiseItem
vListInitialise
pvPortMalloc
vPortFree
memset
