
OBJECTS/windcatcher.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00015930  08000000  08000000  00010000  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000658  20000000  08015930  00030000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000908c  20000658  08015f88  00030658  2**3
                  ALLOC
  3 ._usrstack    00000100  200096e4  0801f014  00030658  2**0
                  ALLOC
  4 .comment      00000049  00000000  00000000  00030658  2**0
                  CONTENTS, READONLY
  5 .debug_aranges 00001c08  00000000  00000000  000306a1  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  6 .debug_info   00021559  00000000  00000000  000322a9  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  7 .debug_abbrev 00005ebf  00000000  00000000  00053802  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  8 .debug_line   00012cda  00000000  00000000  000596c1  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
  9 .debug_frame  00007310  00000000  00000000  0006c39c  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .debug_str    00007286  00000000  00000000  000736ac  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_loc    0000e9ba  00000000  00000000  0007a932  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_ranges 00001978  00000000  00000000  000892ec  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .ARM.attributes 0000002b  00000000  00000000  0008ac64  2**0
                  CONTENTS, READONLY

Disassembly of section .text:

08000000 <g_pfnVectorsStartup>:
 8000000:	00 c0 00 20 f9 10 00 08                             ... ....

08000008 <memcpy>:
 8000008:	4684      	mov	ip, r0
 800000a:	ea41 0300 	orr.w	r3, r1, r0
 800000e:	f013 0303 	ands.w	r3, r3, #3
 8000012:	d149      	bne.n	80000a8 <memcpy+0xa0>
 8000014:	3a40      	subs	r2, #64	; 0x40
 8000016:	d323      	bcc.n	8000060 <memcpy+0x58>
 8000018:	680b      	ldr	r3, [r1, #0]
 800001a:	6003      	str	r3, [r0, #0]
 800001c:	684b      	ldr	r3, [r1, #4]
 800001e:	6043      	str	r3, [r0, #4]
 8000020:	688b      	ldr	r3, [r1, #8]
 8000022:	6083      	str	r3, [r0, #8]
 8000024:	68cb      	ldr	r3, [r1, #12]
 8000026:	60c3      	str	r3, [r0, #12]
 8000028:	690b      	ldr	r3, [r1, #16]
 800002a:	6103      	str	r3, [r0, #16]
 800002c:	694b      	ldr	r3, [r1, #20]
 800002e:	6143      	str	r3, [r0, #20]
 8000030:	698b      	ldr	r3, [r1, #24]
 8000032:	6183      	str	r3, [r0, #24]
 8000034:	69cb      	ldr	r3, [r1, #28]
 8000036:	61c3      	str	r3, [r0, #28]
 8000038:	6a0b      	ldr	r3, [r1, #32]
 800003a:	6203      	str	r3, [r0, #32]
 800003c:	6a4b      	ldr	r3, [r1, #36]	; 0x24
 800003e:	6243      	str	r3, [r0, #36]	; 0x24
 8000040:	6a8b      	ldr	r3, [r1, #40]	; 0x28
 8000042:	6283      	str	r3, [r0, #40]	; 0x28
 8000044:	6acb      	ldr	r3, [r1, #44]	; 0x2c
 8000046:	62c3      	str	r3, [r0, #44]	; 0x2c
 8000048:	6b0b      	ldr	r3, [r1, #48]	; 0x30
 800004a:	6303      	str	r3, [r0, #48]	; 0x30
 800004c:	6b4b      	ldr	r3, [r1, #52]	; 0x34
 800004e:	6343      	str	r3, [r0, #52]	; 0x34
 8000050:	6b8b      	ldr	r3, [r1, #56]	; 0x38
 8000052:	6383      	str	r3, [r0, #56]	; 0x38
 8000054:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
 8000056:	63c3      	str	r3, [r0, #60]	; 0x3c
 8000058:	3040      	adds	r0, #64	; 0x40
 800005a:	3140      	adds	r1, #64	; 0x40
 800005c:	3a40      	subs	r2, #64	; 0x40
 800005e:	d2db      	bcs.n	8000018 <memcpy+0x10>
 8000060:	3230      	adds	r2, #48	; 0x30
 8000062:	d30b      	bcc.n	800007c <memcpy+0x74>
 8000064:	680b      	ldr	r3, [r1, #0]
 8000066:	6003      	str	r3, [r0, #0]
 8000068:	684b      	ldr	r3, [r1, #4]
 800006a:	6043      	str	r3, [r0, #4]
 800006c:	688b      	ldr	r3, [r1, #8]
 800006e:	6083      	str	r3, [r0, #8]
 8000070:	68cb      	ldr	r3, [r1, #12]
 8000072:	60c3      	str	r3, [r0, #12]
 8000074:	3010      	adds	r0, #16
 8000076:	3110      	adds	r1, #16
 8000078:	3a10      	subs	r2, #16
 800007a:	d2f3      	bcs.n	8000064 <memcpy+0x5c>
 800007c:	320c      	adds	r2, #12
 800007e:	d305      	bcc.n	800008c <memcpy+0x84>
 8000080:	f851 3b04 	ldr.w	r3, [r1], #4
 8000084:	f840 3b04 	str.w	r3, [r0], #4
 8000088:	3a04      	subs	r2, #4
 800008a:	d2f9      	bcs.n	8000080 <memcpy+0x78>
 800008c:	3204      	adds	r2, #4
 800008e:	d008      	beq.n	80000a2 <memcpy+0x9a>
 8000090:	07d2      	lsls	r2, r2, #31
 8000092:	bf1c      	itt	ne
 8000094:	f811 3b01 	ldrbne.w	r3, [r1], #1
 8000098:	f800 3b01 	strbne.w	r3, [r0], #1
 800009c:	d301      	bcc.n	80000a2 <memcpy+0x9a>
 800009e:	880b      	ldrh	r3, [r1, #0]
 80000a0:	8003      	strh	r3, [r0, #0]
 80000a2:	4660      	mov	r0, ip
 80000a4:	4770      	bx	lr
 80000a6:	bf00      	nop
 80000a8:	2a08      	cmp	r2, #8
 80000aa:	d313      	bcc.n	80000d4 <memcpy+0xcc>
 80000ac:	078b      	lsls	r3, r1, #30
 80000ae:	d0b1      	beq.n	8000014 <memcpy+0xc>
 80000b0:	f010 0303 	ands.w	r3, r0, #3
 80000b4:	d0ae      	beq.n	8000014 <memcpy+0xc>
 80000b6:	f1c3 0304 	rsb	r3, r3, #4
 80000ba:	1ad2      	subs	r2, r2, r3
 80000bc:	07db      	lsls	r3, r3, #31
 80000be:	bf1c      	itt	ne
 80000c0:	f811 3b01 	ldrbne.w	r3, [r1], #1
 80000c4:	f800 3b01 	strbne.w	r3, [r0], #1
 80000c8:	d3a4      	bcc.n	8000014 <memcpy+0xc>
 80000ca:	f831 3b02 	ldrh.w	r3, [r1], #2
 80000ce:	f820 3b02 	strh.w	r3, [r0], #2
 80000d2:	e79f      	b.n	8000014 <memcpy+0xc>
 80000d4:	3a04      	subs	r2, #4
 80000d6:	d3d9      	bcc.n	800008c <memcpy+0x84>
 80000d8:	3a01      	subs	r2, #1
 80000da:	f811 3b01 	ldrb.w	r3, [r1], #1
 80000de:	f800 3b01 	strb.w	r3, [r0], #1
 80000e2:	d2f9      	bcs.n	80000d8 <memcpy+0xd0>
 80000e4:	780b      	ldrb	r3, [r1, #0]
 80000e6:	7003      	strb	r3, [r0, #0]
 80000e8:	784b      	ldrb	r3, [r1, #1]
 80000ea:	7043      	strb	r3, [r0, #1]
 80000ec:	788b      	ldrb	r3, [r1, #2]
 80000ee:	7083      	strb	r3, [r0, #2]
 80000f0:	4660      	mov	r0, ip
 80000f2:	4770      	bx	lr

080000f4 <strcmp>:
 80000f4:	ea80 0c01 	eor.w	ip, r0, r1
 80000f8:	f01c 0f03 	tst.w	ip, #3
 80000fc:	d137      	bne.n	800016e <strcmp+0x7a>
 80000fe:	f010 0c03 	ands.w	ip, r0, #3
 8000102:	f020 0003 	bic.w	r0, r0, #3
 8000106:	f021 0103 	bic.w	r1, r1, #3
 800010a:	f850 2b04 	ldr.w	r2, [r0], #4
 800010e:	bf08      	it	eq
 8000110:	f851 3b04 	ldreq.w	r3, [r1], #4
 8000114:	d00e      	beq.n	8000134 <strcmp+0x40>
 8000116:	f08c 0c03 	eor.w	ip, ip, #3
 800011a:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 800011e:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 8000122:	fa23 fc0c 	lsr.w	ip, r3, ip
 8000126:	f851 3b04 	ldr.w	r3, [r1], #4
 800012a:	ea42 020c 	orr.w	r2, r2, ip
 800012e:	ea43 030c 	orr.w	r3, r3, ip
 8000132:	bf00      	nop
 8000134:	f1a2 3c01 	sub.w	ip, r2, #16843009	; 0x1010101
 8000138:	429a      	cmp	r2, r3
 800013a:	bf01      	itttt	eq
 800013c:	ea2c 0c02 	biceq.w	ip, ip, r2
 8000140:	f01c 3f80 	tsteq.w	ip, #2155905152	; 0x80808080
 8000144:	f850 2b04 	ldreq.w	r2, [r0], #4
 8000148:	f851 3b04 	ldreq.w	r3, [r1], #4
 800014c:	d0f2      	beq.n	8000134 <strcmp+0x40>
 800014e:	ea4f 6002 	mov.w	r0, r2, lsl #24
 8000152:	ea4f 2212 	mov.w	r2, r2, lsr #8
 8000156:	2801      	cmp	r0, #1
 8000158:	bf28      	it	cs
 800015a:	ebb0 6f03 	cmpcs.w	r0, r3, lsl #24
 800015e:	bf08      	it	eq
 8000160:	0a1b      	lsreq	r3, r3, #8
 8000162:	d0f4      	beq.n	800014e <strcmp+0x5a>
 8000164:	f003 03ff 	and.w	r3, r3, #255	; 0xff
 8000168:	0e00      	lsrs	r0, r0, #24
 800016a:	1ac0      	subs	r0, r0, r3
 800016c:	4770      	bx	lr
 800016e:	f010 0f03 	tst.w	r0, #3
 8000172:	d00a      	beq.n	800018a <strcmp+0x96>
 8000174:	f810 2b01 	ldrb.w	r2, [r0], #1
 8000178:	f811 3b01 	ldrb.w	r3, [r1], #1
 800017c:	2a01      	cmp	r2, #1
 800017e:	bf28      	it	cs
 8000180:	429a      	cmpcs	r2, r3
 8000182:	d0f4      	beq.n	800016e <strcmp+0x7a>
 8000184:	eba2 0003 	sub.w	r0, r2, r3
 8000188:	4770      	bx	lr
 800018a:	f84d 5d04 	str.w	r5, [sp, #-4]!
 800018e:	f850 2b04 	ldr.w	r2, [r0], #4
 8000192:	f001 0503 	and.w	r5, r1, #3
 8000196:	f021 0103 	bic.w	r1, r1, #3
 800019a:	f851 3b04 	ldr.w	r3, [r1], #4
 800019e:	2d02      	cmp	r5, #2
 80001a0:	d026      	beq.n	80001f0 <strcmp+0xfc>
 80001a2:	d84d      	bhi.n	8000240 <strcmp+0x14c>
 80001a4:	f022 457f 	bic.w	r5, r2, #4278190080	; 0xff000000
 80001a8:	ebb5 2f13 	cmp.w	r5, r3, lsr #8
 80001ac:	f1a2 3c01 	sub.w	ip, r2, #16843009	; 0x1010101
 80001b0:	ea2c 0c02 	bic.w	ip, ip, r2
 80001b4:	d10d      	bne.n	80001d2 <strcmp+0xde>
 80001b6:	f01c 3c80 	ands.w	ip, ip, #2155905152	; 0x80808080
 80001ba:	bf08      	it	eq
 80001bc:	f851 3b04 	ldreq.w	r3, [r1], #4
 80001c0:	d10a      	bne.n	80001d8 <strcmp+0xe4>
 80001c2:	ea85 0502 	eor.w	r5, r5, r2
 80001c6:	ebb5 6f03 	cmp.w	r5, r3, lsl #24
 80001ca:	d10c      	bne.n	80001e6 <strcmp+0xf2>
 80001cc:	f850 2b04 	ldr.w	r2, [r0], #4
 80001d0:	e7e8      	b.n	80001a4 <strcmp+0xb0>
 80001d2:	ea4f 2313 	mov.w	r3, r3, lsr #8
 80001d6:	e05b      	b.n	8000290 <strcmp+0x19c>
 80001d8:	f03c 4c7f 	bics.w	ip, ip, #4278190080	; 0xff000000
 80001dc:	d154      	bne.n	8000288 <strcmp+0x194>
 80001de:	780b      	ldrb	r3, [r1, #0]
 80001e0:	ea4f 6512 	mov.w	r5, r2, lsr #24
 80001e4:	e054      	b.n	8000290 <strcmp+0x19c>
 80001e6:	ea4f 6512 	mov.w	r5, r2, lsr #24
 80001ea:	f003 03ff 	and.w	r3, r3, #255	; 0xff
 80001ee:	e04f      	b.n	8000290 <strcmp+0x19c>
 80001f0:	ea4f 4502 	mov.w	r5, r2, lsl #16
 80001f4:	f1a2 3c01 	sub.w	ip, r2, #16843009	; 0x1010101
 80001f8:	ea4f 4515 	mov.w	r5, r5, lsr #16
 80001fc:	ea2c 0c02 	bic.w	ip, ip, r2
 8000200:	ebb5 4f13 	cmp.w	r5, r3, lsr #16
 8000204:	d118      	bne.n	8000238 <strcmp+0x144>
 8000206:	f01c 3c80 	ands.w	ip, ip, #2155905152	; 0x80808080
 800020a:	bf08      	it	eq
 800020c:	f851 3b04 	ldreq.w	r3, [r1], #4
 8000210:	d107      	bne.n	8000222 <strcmp+0x12e>
 8000212:	ea85 0502 	eor.w	r5, r5, r2
 8000216:	ebb5 4f03 	cmp.w	r5, r3, lsl #16
 800021a:	d109      	bne.n	8000230 <strcmp+0x13c>
 800021c:	f850 2b04 	ldr.w	r2, [r0], #4
 8000220:	e7e6      	b.n	80001f0 <strcmp+0xfc>
 8000222:	ea5f 4c0c 	movs.w	ip, ip, lsl #16
 8000226:	d12f      	bne.n	8000288 <strcmp+0x194>
 8000228:	880b      	ldrh	r3, [r1, #0]
 800022a:	ea4f 4512 	mov.w	r5, r2, lsr #16
 800022e:	e02f      	b.n	8000290 <strcmp+0x19c>
 8000230:	ea4f 4303 	mov.w	r3, r3, lsl #16
 8000234:	ea4f 4512 	mov.w	r5, r2, lsr #16
 8000238:	ea4f 4313 	mov.w	r3, r3, lsr #16
 800023c:	e028      	b.n	8000290 <strcmp+0x19c>
 800023e:	bf00      	nop
 8000240:	f002 05ff 	and.w	r5, r2, #255	; 0xff
 8000244:	ebb5 6f13 	cmp.w	r5, r3, lsr #24
 8000248:	f1a2 3c01 	sub.w	ip, r2, #16843009	; 0x1010101
 800024c:	ea2c 0c02 	bic.w	ip, ip, r2
 8000250:	d10d      	bne.n	800026e <strcmp+0x17a>
 8000252:	f01c 3c80 	ands.w	ip, ip, #2155905152	; 0x80808080
 8000256:	bf08      	it	eq
 8000258:	f851 3b04 	ldreq.w	r3, [r1], #4
 800025c:	d10a      	bne.n	8000274 <strcmp+0x180>
 800025e:	ea85 0502 	eor.w	r5, r5, r2
 8000262:	ebb5 2f03 	cmp.w	r5, r3, lsl #8
 8000266:	d10a      	bne.n	800027e <strcmp+0x18a>
 8000268:	f850 2b04 	ldr.w	r2, [r0], #4
 800026c:	e7e8      	b.n	8000240 <strcmp+0x14c>
 800026e:	ea4f 6313 	mov.w	r3, r3, lsr #24
 8000272:	e00d      	b.n	8000290 <strcmp+0x19c>
 8000274:	f012 0fff 	tst.w	r2, #255	; 0xff
 8000278:	d006      	beq.n	8000288 <strcmp+0x194>
 800027a:	f851 3b04 	ldr.w	r3, [r1], #4
 800027e:	ea4f 2512 	mov.w	r5, r2, lsr #8
 8000282:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8000286:	e003      	b.n	8000290 <strcmp+0x19c>
 8000288:	f04f 0000 	mov.w	r0, #0
 800028c:	bc20      	pop	{r5}
 800028e:	4770      	bx	lr
 8000290:	f005 02ff 	and.w	r2, r5, #255	; 0xff
 8000294:	f003 00ff 	and.w	r0, r3, #255	; 0xff
 8000298:	2801      	cmp	r0, #1
 800029a:	bf28      	it	cs
 800029c:	4290      	cmpcs	r0, r2
 800029e:	bf04      	itt	eq
 80002a0:	0a2d      	lsreq	r5, r5, #8
 80002a2:	0a1b      	lsreq	r3, r3, #8
 80002a4:	d0f4      	beq.n	8000290 <strcmp+0x19c>
 80002a6:	eba2 0000 	sub.w	r0, r2, r0
 80002aa:	bc20      	pop	{r5}
 80002ac:	4770      	bx	lr
 80002ae:	bf00      	nop

080002b0 <__aeabi_fmul>:
 80002b0:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80002b4:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 80002b8:	bf1e      	ittt	ne
 80002ba:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 80002be:	ea92 0f0c 	teqne	r2, ip
 80002c2:	ea93 0f0c 	teqne	r3, ip
 80002c6:	d06f      	beq.n	80003a8 <__aeabi_fmul+0xf8>
 80002c8:	441a      	add	r2, r3
 80002ca:	ea80 0c01 	eor.w	ip, r0, r1
 80002ce:	0240      	lsls	r0, r0, #9
 80002d0:	bf18      	it	ne
 80002d2:	ea5f 2141 	movsne.w	r1, r1, lsl #9
 80002d6:	d01e      	beq.n	8000316 <__aeabi_fmul+0x66>
 80002d8:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 80002dc:	ea43 1050 	orr.w	r0, r3, r0, lsr #5
 80002e0:	ea43 1151 	orr.w	r1, r3, r1, lsr #5
 80002e4:	fba0 3101 	umull	r3, r1, r0, r1
 80002e8:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
 80002ec:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
 80002f0:	bf3e      	ittt	cc
 80002f2:	0049      	lslcc	r1, r1, #1
 80002f4:	ea41 71d3 	orrcc.w	r1, r1, r3, lsr #31
 80002f8:	005b      	lslcc	r3, r3, #1
 80002fa:	ea40 0001 	orr.w	r0, r0, r1
 80002fe:	f162 027f 	sbc.w	r2, r2, #127	; 0x7f
 8000302:	2afd      	cmp	r2, #253	; 0xfd
 8000304:	d81d      	bhi.n	8000342 <__aeabi_fmul+0x92>
 8000306:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 800030a:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 800030e:	bf08      	it	eq
 8000310:	f020 0001 	biceq.w	r0, r0, #1
 8000314:	4770      	bx	lr
 8000316:	f090 0f00 	teq	r0, #0
 800031a:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
 800031e:	bf08      	it	eq
 8000320:	0249      	lsleq	r1, r1, #9
 8000322:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 8000326:	ea40 2051 	orr.w	r0, r0, r1, lsr #9
 800032a:	3a7f      	subs	r2, #127	; 0x7f
 800032c:	bfc2      	ittt	gt
 800032e:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
 8000332:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 8000336:	4770      	bxgt	lr
 8000338:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 800033c:	f04f 0300 	mov.w	r3, #0
 8000340:	3a01      	subs	r2, #1
 8000342:	dc5d      	bgt.n	8000400 <__aeabi_fmul+0x150>
 8000344:	f112 0f19 	cmn.w	r2, #25
 8000348:	bfdc      	itt	le
 800034a:	f000 4000 	andle.w	r0, r0, #2147483648	; 0x80000000
 800034e:	4770      	bxle	lr
 8000350:	f1c2 0200 	rsb	r2, r2, #0
 8000354:	0041      	lsls	r1, r0, #1
 8000356:	fa21 f102 	lsr.w	r1, r1, r2
 800035a:	f1c2 0220 	rsb	r2, r2, #32
 800035e:	fa00 fc02 	lsl.w	ip, r0, r2
 8000362:	ea5f 0031 	movs.w	r0, r1, rrx
 8000366:	f140 0000 	adc.w	r0, r0, #0
 800036a:	ea53 034c 	orrs.w	r3, r3, ip, lsl #1
 800036e:	bf08      	it	eq
 8000370:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 8000374:	4770      	bx	lr
 8000376:	f092 0f00 	teq	r2, #0
 800037a:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
 800037e:	bf02      	ittt	eq
 8000380:	0040      	lsleq	r0, r0, #1
 8000382:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
 8000386:	3a01      	subeq	r2, #1
 8000388:	d0f9      	beq.n	800037e <__aeabi_fmul+0xce>
 800038a:	ea40 000c 	orr.w	r0, r0, ip
 800038e:	f093 0f00 	teq	r3, #0
 8000392:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 8000396:	bf02      	ittt	eq
 8000398:	0049      	lsleq	r1, r1, #1
 800039a:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
 800039e:	3b01      	subeq	r3, #1
 80003a0:	d0f9      	beq.n	8000396 <__aeabi_fmul+0xe6>
 80003a2:	ea41 010c 	orr.w	r1, r1, ip
 80003a6:	e78f      	b.n	80002c8 <__aeabi_fmul+0x18>
 80003a8:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 80003ac:	ea92 0f0c 	teq	r2, ip
 80003b0:	bf18      	it	ne
 80003b2:	ea93 0f0c 	teqne	r3, ip
 80003b6:	d00a      	beq.n	80003ce <__aeabi_fmul+0x11e>
 80003b8:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
 80003bc:	bf18      	it	ne
 80003be:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
 80003c2:	d1d8      	bne.n	8000376 <__aeabi_fmul+0xc6>
 80003c4:	ea80 0001 	eor.w	r0, r0, r1
 80003c8:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 80003cc:	4770      	bx	lr
 80003ce:	f090 0f00 	teq	r0, #0
 80003d2:	bf17      	itett	ne
 80003d4:	f090 4f00 	teqne	r0, #2147483648	; 0x80000000
 80003d8:	4608      	moveq	r0, r1
 80003da:	f091 0f00 	teqne	r1, #0
 80003de:	f091 4f00 	teqne	r1, #2147483648	; 0x80000000
 80003e2:	d014      	beq.n	800040e <__aeabi_fmul+0x15e>
 80003e4:	ea92 0f0c 	teq	r2, ip
 80003e8:	d101      	bne.n	80003ee <__aeabi_fmul+0x13e>
 80003ea:	0242      	lsls	r2, r0, #9
 80003ec:	d10f      	bne.n	800040e <__aeabi_fmul+0x15e>
 80003ee:	ea93 0f0c 	teq	r3, ip
 80003f2:	d103      	bne.n	80003fc <__aeabi_fmul+0x14c>
 80003f4:	024b      	lsls	r3, r1, #9
 80003f6:	bf18      	it	ne
 80003f8:	4608      	movne	r0, r1
 80003fa:	d108      	bne.n	800040e <__aeabi_fmul+0x15e>
 80003fc:	ea80 0001 	eor.w	r0, r0, r1
 8000400:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 8000404:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8000408:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 800040c:	4770      	bx	lr
 800040e:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8000412:	f440 0040 	orr.w	r0, r0, #12582912	; 0xc00000
 8000416:	4770      	bx	lr

08000418 <__aeabi_drsub>:
 8000418:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 800041c:	e002      	b.n	8000424 <__adddf3>
 800041e:	bf00      	nop

08000420 <__aeabi_dsub>:
 8000420:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

08000424 <__adddf3>:
 8000424:	b530      	push	{r4, r5, lr}
 8000426:	ea4f 0441 	mov.w	r4, r1, lsl #1
 800042a:	ea4f 0543 	mov.w	r5, r3, lsl #1
 800042e:	ea94 0f05 	teq	r4, r5
 8000432:	bf08      	it	eq
 8000434:	ea90 0f02 	teqeq	r0, r2
 8000438:	bf1f      	itttt	ne
 800043a:	ea54 0c00 	orrsne.w	ip, r4, r0
 800043e:	ea55 0c02 	orrsne.w	ip, r5, r2
 8000442:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 8000446:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 800044a:	f000 80e2 	beq.w	8000612 <__adddf3+0x1ee>
 800044e:	ea4f 5454 	mov.w	r4, r4, lsr #21
 8000452:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 8000456:	bfb8      	it	lt
 8000458:	426d      	neglt	r5, r5
 800045a:	dd0c      	ble.n	8000476 <__adddf3+0x52>
 800045c:	442c      	add	r4, r5
 800045e:	ea80 0202 	eor.w	r2, r0, r2
 8000462:	ea81 0303 	eor.w	r3, r1, r3
 8000466:	ea82 0000 	eor.w	r0, r2, r0
 800046a:	ea83 0101 	eor.w	r1, r3, r1
 800046e:	ea80 0202 	eor.w	r2, r0, r2
 8000472:	ea81 0303 	eor.w	r3, r1, r3
 8000476:	2d36      	cmp	r5, #54	; 0x36
 8000478:	bf88      	it	hi
 800047a:	bd30      	pophi	{r4, r5, pc}
 800047c:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000480:	ea4f 3101 	mov.w	r1, r1, lsl #12
 8000484:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 8000488:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 800048c:	d002      	beq.n	8000494 <__adddf3+0x70>
 800048e:	4240      	negs	r0, r0
 8000490:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000494:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 8000498:	ea4f 3303 	mov.w	r3, r3, lsl #12
 800049c:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 80004a0:	d002      	beq.n	80004a8 <__adddf3+0x84>
 80004a2:	4252      	negs	r2, r2
 80004a4:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 80004a8:	ea94 0f05 	teq	r4, r5
 80004ac:	f000 80a7 	beq.w	80005fe <__adddf3+0x1da>
 80004b0:	f1a4 0401 	sub.w	r4, r4, #1
 80004b4:	f1d5 0e20 	rsbs	lr, r5, #32
 80004b8:	db0d      	blt.n	80004d6 <__adddf3+0xb2>
 80004ba:	fa02 fc0e 	lsl.w	ip, r2, lr
 80004be:	fa22 f205 	lsr.w	r2, r2, r5
 80004c2:	1880      	adds	r0, r0, r2
 80004c4:	f141 0100 	adc.w	r1, r1, #0
 80004c8:	fa03 f20e 	lsl.w	r2, r3, lr
 80004cc:	1880      	adds	r0, r0, r2
 80004ce:	fa43 f305 	asr.w	r3, r3, r5
 80004d2:	4159      	adcs	r1, r3
 80004d4:	e00e      	b.n	80004f4 <__adddf3+0xd0>
 80004d6:	f1a5 0520 	sub.w	r5, r5, #32
 80004da:	f10e 0e20 	add.w	lr, lr, #32
 80004de:	2a01      	cmp	r2, #1
 80004e0:	fa03 fc0e 	lsl.w	ip, r3, lr
 80004e4:	bf28      	it	cs
 80004e6:	f04c 0c02 	orrcs.w	ip, ip, #2
 80004ea:	fa43 f305 	asr.w	r3, r3, r5
 80004ee:	18c0      	adds	r0, r0, r3
 80004f0:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 80004f4:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80004f8:	d507      	bpl.n	800050a <__adddf3+0xe6>
 80004fa:	f04f 0e00 	mov.w	lr, #0
 80004fe:	f1dc 0c00 	rsbs	ip, ip, #0
 8000502:	eb7e 0000 	sbcs.w	r0, lr, r0
 8000506:	eb6e 0101 	sbc.w	r1, lr, r1
 800050a:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 800050e:	d31b      	bcc.n	8000548 <__adddf3+0x124>
 8000510:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 8000514:	d30c      	bcc.n	8000530 <__adddf3+0x10c>
 8000516:	0849      	lsrs	r1, r1, #1
 8000518:	ea5f 0030 	movs.w	r0, r0, rrx
 800051c:	ea4f 0c3c 	mov.w	ip, ip, rrx
 8000520:	f104 0401 	add.w	r4, r4, #1
 8000524:	ea4f 5244 	mov.w	r2, r4, lsl #21
 8000528:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 800052c:	f080 809a 	bcs.w	8000664 <__adddf3+0x240>
 8000530:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 8000534:	bf08      	it	eq
 8000536:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 800053a:	f150 0000 	adcs.w	r0, r0, #0
 800053e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8000542:	ea41 0105 	orr.w	r1, r1, r5
 8000546:	bd30      	pop	{r4, r5, pc}
 8000548:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 800054c:	4140      	adcs	r0, r0
 800054e:	eb41 0101 	adc.w	r1, r1, r1
 8000552:	3c01      	subs	r4, #1
 8000554:	bf28      	it	cs
 8000556:	f5b1 1f80 	cmpcs.w	r1, #1048576	; 0x100000
 800055a:	d2e9      	bcs.n	8000530 <__adddf3+0x10c>
 800055c:	f091 0f00 	teq	r1, #0
 8000560:	bf04      	itt	eq
 8000562:	4601      	moveq	r1, r0
 8000564:	2000      	moveq	r0, #0
 8000566:	fab1 f381 	clz	r3, r1
 800056a:	bf08      	it	eq
 800056c:	3320      	addeq	r3, #32
 800056e:	f1a3 030b 	sub.w	r3, r3, #11
 8000572:	f1b3 0220 	subs.w	r2, r3, #32
 8000576:	da0c      	bge.n	8000592 <__adddf3+0x16e>
 8000578:	320c      	adds	r2, #12
 800057a:	dd08      	ble.n	800058e <__adddf3+0x16a>
 800057c:	f102 0c14 	add.w	ip, r2, #20
 8000580:	f1c2 020c 	rsb	r2, r2, #12
 8000584:	fa01 f00c 	lsl.w	r0, r1, ip
 8000588:	fa21 f102 	lsr.w	r1, r1, r2
 800058c:	e00c      	b.n	80005a8 <__adddf3+0x184>
 800058e:	f102 0214 	add.w	r2, r2, #20
 8000592:	bfd8      	it	le
 8000594:	f1c2 0c20 	rsble	ip, r2, #32
 8000598:	fa01 f102 	lsl.w	r1, r1, r2
 800059c:	fa20 fc0c 	lsr.w	ip, r0, ip
 80005a0:	bfdc      	itt	le
 80005a2:	ea41 010c 	orrle.w	r1, r1, ip
 80005a6:	4090      	lslle	r0, r2
 80005a8:	1ae4      	subs	r4, r4, r3
 80005aa:	bfa2      	ittt	ge
 80005ac:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 80005b0:	4329      	orrge	r1, r5
 80005b2:	bd30      	popge	{r4, r5, pc}
 80005b4:	ea6f 0404 	mvn.w	r4, r4
 80005b8:	3c1f      	subs	r4, #31
 80005ba:	da1c      	bge.n	80005f6 <__adddf3+0x1d2>
 80005bc:	340c      	adds	r4, #12
 80005be:	dc0e      	bgt.n	80005de <__adddf3+0x1ba>
 80005c0:	f104 0414 	add.w	r4, r4, #20
 80005c4:	f1c4 0220 	rsb	r2, r4, #32
 80005c8:	fa20 f004 	lsr.w	r0, r0, r4
 80005cc:	fa01 f302 	lsl.w	r3, r1, r2
 80005d0:	ea40 0003 	orr.w	r0, r0, r3
 80005d4:	fa21 f304 	lsr.w	r3, r1, r4
 80005d8:	ea45 0103 	orr.w	r1, r5, r3
 80005dc:	bd30      	pop	{r4, r5, pc}
 80005de:	f1c4 040c 	rsb	r4, r4, #12
 80005e2:	f1c4 0220 	rsb	r2, r4, #32
 80005e6:	fa20 f002 	lsr.w	r0, r0, r2
 80005ea:	fa01 f304 	lsl.w	r3, r1, r4
 80005ee:	ea40 0003 	orr.w	r0, r0, r3
 80005f2:	4629      	mov	r1, r5
 80005f4:	bd30      	pop	{r4, r5, pc}
 80005f6:	fa21 f004 	lsr.w	r0, r1, r4
 80005fa:	4629      	mov	r1, r5
 80005fc:	bd30      	pop	{r4, r5, pc}
 80005fe:	f094 0f00 	teq	r4, #0
 8000602:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 8000606:	bf06      	itte	eq
 8000608:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 800060c:	3401      	addeq	r4, #1
 800060e:	3d01      	subne	r5, #1
 8000610:	e74e      	b.n	80004b0 <__adddf3+0x8c>
 8000612:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 8000616:	bf18      	it	ne
 8000618:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 800061c:	d029      	beq.n	8000672 <__adddf3+0x24e>
 800061e:	ea94 0f05 	teq	r4, r5
 8000622:	bf08      	it	eq
 8000624:	ea90 0f02 	teqeq	r0, r2
 8000628:	d005      	beq.n	8000636 <__adddf3+0x212>
 800062a:	ea54 0c00 	orrs.w	ip, r4, r0
 800062e:	bf04      	itt	eq
 8000630:	4619      	moveq	r1, r3
 8000632:	4610      	moveq	r0, r2
 8000634:	bd30      	pop	{r4, r5, pc}
 8000636:	ea91 0f03 	teq	r1, r3
 800063a:	bf1e      	ittt	ne
 800063c:	2100      	movne	r1, #0
 800063e:	2000      	movne	r0, #0
 8000640:	bd30      	popne	{r4, r5, pc}
 8000642:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 8000646:	d105      	bne.n	8000654 <__adddf3+0x230>
 8000648:	0040      	lsls	r0, r0, #1
 800064a:	4149      	adcs	r1, r1
 800064c:	bf28      	it	cs
 800064e:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 8000652:	bd30      	pop	{r4, r5, pc}
 8000654:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 8000658:	bf3c      	itt	cc
 800065a:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 800065e:	bd30      	popcc	{r4, r5, pc}
 8000660:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8000664:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 8000668:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 800066c:	f04f 0000 	mov.w	r0, #0
 8000670:	bd30      	pop	{r4, r5, pc}
 8000672:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 8000676:	bf1a      	itte	ne
 8000678:	4619      	movne	r1, r3
 800067a:	4610      	movne	r0, r2
 800067c:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 8000680:	bf1c      	itt	ne
 8000682:	460b      	movne	r3, r1
 8000684:	4602      	movne	r2, r0
 8000686:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 800068a:	bf06      	itte	eq
 800068c:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 8000690:	ea91 0f03 	teqeq	r1, r3
 8000694:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 8000698:	bd30      	pop	{r4, r5, pc}
 800069a:	bf00      	nop

0800069c <__aeabi_ui2d>:
 800069c:	f090 0f00 	teq	r0, #0
 80006a0:	bf04      	itt	eq
 80006a2:	2100      	moveq	r1, #0
 80006a4:	4770      	bxeq	lr
 80006a6:	b530      	push	{r4, r5, lr}
 80006a8:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80006ac:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80006b0:	f04f 0500 	mov.w	r5, #0
 80006b4:	f04f 0100 	mov.w	r1, #0
 80006b8:	e750      	b.n	800055c <__adddf3+0x138>
 80006ba:	bf00      	nop

080006bc <__aeabi_i2d>:
 80006bc:	f090 0f00 	teq	r0, #0
 80006c0:	bf04      	itt	eq
 80006c2:	2100      	moveq	r1, #0
 80006c4:	4770      	bxeq	lr
 80006c6:	b530      	push	{r4, r5, lr}
 80006c8:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80006cc:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80006d0:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 80006d4:	bf48      	it	mi
 80006d6:	4240      	negmi	r0, r0
 80006d8:	f04f 0100 	mov.w	r1, #0
 80006dc:	e73e      	b.n	800055c <__adddf3+0x138>
 80006de:	bf00      	nop

080006e0 <__aeabi_f2d>:
 80006e0:	0042      	lsls	r2, r0, #1
 80006e2:	ea4f 01e2 	mov.w	r1, r2, asr #3
 80006e6:	ea4f 0131 	mov.w	r1, r1, rrx
 80006ea:	ea4f 7002 	mov.w	r0, r2, lsl #28
 80006ee:	bf1f      	itttt	ne
 80006f0:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 80006f4:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 80006f8:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 80006fc:	4770      	bxne	lr
 80006fe:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
 8000702:	bf08      	it	eq
 8000704:	4770      	bxeq	lr
 8000706:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
 800070a:	bf04      	itt	eq
 800070c:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
 8000710:	4770      	bxeq	lr
 8000712:	b530      	push	{r4, r5, lr}
 8000714:	f44f 7460 	mov.w	r4, #896	; 0x380
 8000718:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 800071c:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8000720:	e71c      	b.n	800055c <__adddf3+0x138>
 8000722:	bf00      	nop

08000724 <__aeabi_ul2d>:
 8000724:	ea50 0201 	orrs.w	r2, r0, r1
 8000728:	bf08      	it	eq
 800072a:	4770      	bxeq	lr
 800072c:	b530      	push	{r4, r5, lr}
 800072e:	f04f 0500 	mov.w	r5, #0
 8000732:	e00a      	b.n	800074a <__aeabi_l2d+0x16>

08000734 <__aeabi_l2d>:
 8000734:	ea50 0201 	orrs.w	r2, r0, r1
 8000738:	bf08      	it	eq
 800073a:	4770      	bxeq	lr
 800073c:	b530      	push	{r4, r5, lr}
 800073e:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 8000742:	d502      	bpl.n	800074a <__aeabi_l2d+0x16>
 8000744:	4240      	negs	r0, r0
 8000746:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800074a:	f44f 6480 	mov.w	r4, #1024	; 0x400
 800074e:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000752:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 8000756:	f43f aed8 	beq.w	800050a <__adddf3+0xe6>
 800075a:	f04f 0203 	mov.w	r2, #3
 800075e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8000762:	bf18      	it	ne
 8000764:	3203      	addne	r2, #3
 8000766:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 800076a:	bf18      	it	ne
 800076c:	3203      	addne	r2, #3
 800076e:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 8000772:	f1c2 0320 	rsb	r3, r2, #32
 8000776:	fa00 fc03 	lsl.w	ip, r0, r3
 800077a:	fa20 f002 	lsr.w	r0, r0, r2
 800077e:	fa01 fe03 	lsl.w	lr, r1, r3
 8000782:	ea40 000e 	orr.w	r0, r0, lr
 8000786:	fa21 f102 	lsr.w	r1, r1, r2
 800078a:	4414      	add	r4, r2
 800078c:	e6bd      	b.n	800050a <__adddf3+0xe6>
 800078e:	bf00      	nop

08000790 <__aeabi_dmul>:
 8000790:	b570      	push	{r4, r5, r6, lr}
 8000792:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8000796:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 800079a:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 800079e:	bf1d      	ittte	ne
 80007a0:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 80007a4:	ea94 0f0c 	teqne	r4, ip
 80007a8:	ea95 0f0c 	teqne	r5, ip
 80007ac:	f000 f8de 	bleq	800096c <__aeabi_dmul+0x1dc>
 80007b0:	442c      	add	r4, r5
 80007b2:	ea81 0603 	eor.w	r6, r1, r3
 80007b6:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 80007ba:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 80007be:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 80007c2:	bf18      	it	ne
 80007c4:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 80007c8:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80007cc:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 80007d0:	d038      	beq.n	8000844 <__aeabi_dmul+0xb4>
 80007d2:	fba0 ce02 	umull	ip, lr, r0, r2
 80007d6:	f04f 0500 	mov.w	r5, #0
 80007da:	fbe1 e502 	umlal	lr, r5, r1, r2
 80007de:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 80007e2:	fbe0 e503 	umlal	lr, r5, r0, r3
 80007e6:	f04f 0600 	mov.w	r6, #0
 80007ea:	fbe1 5603 	umlal	r5, r6, r1, r3
 80007ee:	f09c 0f00 	teq	ip, #0
 80007f2:	bf18      	it	ne
 80007f4:	f04e 0e01 	orrne.w	lr, lr, #1
 80007f8:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 80007fc:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 8000800:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 8000804:	d204      	bcs.n	8000810 <__aeabi_dmul+0x80>
 8000806:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 800080a:	416d      	adcs	r5, r5
 800080c:	eb46 0606 	adc.w	r6, r6, r6
 8000810:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 8000814:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 8000818:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 800081c:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 8000820:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 8000824:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 8000828:	bf88      	it	hi
 800082a:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 800082e:	d81e      	bhi.n	800086e <__aeabi_dmul+0xde>
 8000830:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 8000834:	bf08      	it	eq
 8000836:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 800083a:	f150 0000 	adcs.w	r0, r0, #0
 800083e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8000842:	bd70      	pop	{r4, r5, r6, pc}
 8000844:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 8000848:	ea46 0101 	orr.w	r1, r6, r1
 800084c:	ea40 0002 	orr.w	r0, r0, r2
 8000850:	ea81 0103 	eor.w	r1, r1, r3
 8000854:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 8000858:	bfc2      	ittt	gt
 800085a:	ebd4 050c 	rsbsgt	r5, r4, ip
 800085e:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 8000862:	bd70      	popgt	{r4, r5, r6, pc}
 8000864:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000868:	f04f 0e00 	mov.w	lr, #0
 800086c:	3c01      	subs	r4, #1
 800086e:	f300 80ab 	bgt.w	80009c8 <__aeabi_dmul+0x238>
 8000872:	f114 0f36 	cmn.w	r4, #54	; 0x36
 8000876:	bfde      	ittt	le
 8000878:	2000      	movle	r0, #0
 800087a:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 800087e:	bd70      	pople	{r4, r5, r6, pc}
 8000880:	f1c4 0400 	rsb	r4, r4, #0
 8000884:	3c20      	subs	r4, #32
 8000886:	da35      	bge.n	80008f4 <__aeabi_dmul+0x164>
 8000888:	340c      	adds	r4, #12
 800088a:	dc1b      	bgt.n	80008c4 <__aeabi_dmul+0x134>
 800088c:	f104 0414 	add.w	r4, r4, #20
 8000890:	f1c4 0520 	rsb	r5, r4, #32
 8000894:	fa00 f305 	lsl.w	r3, r0, r5
 8000898:	fa20 f004 	lsr.w	r0, r0, r4
 800089c:	fa01 f205 	lsl.w	r2, r1, r5
 80008a0:	ea40 0002 	orr.w	r0, r0, r2
 80008a4:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 80008a8:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 80008ac:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 80008b0:	fa21 f604 	lsr.w	r6, r1, r4
 80008b4:	eb42 0106 	adc.w	r1, r2, r6
 80008b8:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80008bc:	bf08      	it	eq
 80008be:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80008c2:	bd70      	pop	{r4, r5, r6, pc}
 80008c4:	f1c4 040c 	rsb	r4, r4, #12
 80008c8:	f1c4 0520 	rsb	r5, r4, #32
 80008cc:	fa00 f304 	lsl.w	r3, r0, r4
 80008d0:	fa20 f005 	lsr.w	r0, r0, r5
 80008d4:	fa01 f204 	lsl.w	r2, r1, r4
 80008d8:	ea40 0002 	orr.w	r0, r0, r2
 80008dc:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80008e0:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 80008e4:	f141 0100 	adc.w	r1, r1, #0
 80008e8:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80008ec:	bf08      	it	eq
 80008ee:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80008f2:	bd70      	pop	{r4, r5, r6, pc}
 80008f4:	f1c4 0520 	rsb	r5, r4, #32
 80008f8:	fa00 f205 	lsl.w	r2, r0, r5
 80008fc:	ea4e 0e02 	orr.w	lr, lr, r2
 8000900:	fa20 f304 	lsr.w	r3, r0, r4
 8000904:	fa01 f205 	lsl.w	r2, r1, r5
 8000908:	ea43 0302 	orr.w	r3, r3, r2
 800090c:	fa21 f004 	lsr.w	r0, r1, r4
 8000910:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000914:	fa21 f204 	lsr.w	r2, r1, r4
 8000918:	ea20 0002 	bic.w	r0, r0, r2
 800091c:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 8000920:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000924:	bf08      	it	eq
 8000926:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800092a:	bd70      	pop	{r4, r5, r6, pc}
 800092c:	f094 0f00 	teq	r4, #0
 8000930:	d10f      	bne.n	8000952 <__aeabi_dmul+0x1c2>
 8000932:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 8000936:	0040      	lsls	r0, r0, #1
 8000938:	eb41 0101 	adc.w	r1, r1, r1
 800093c:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8000940:	bf08      	it	eq
 8000942:	3c01      	subeq	r4, #1
 8000944:	d0f7      	beq.n	8000936 <__aeabi_dmul+0x1a6>
 8000946:	ea41 0106 	orr.w	r1, r1, r6
 800094a:	f095 0f00 	teq	r5, #0
 800094e:	bf18      	it	ne
 8000950:	4770      	bxne	lr
 8000952:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 8000956:	0052      	lsls	r2, r2, #1
 8000958:	eb43 0303 	adc.w	r3, r3, r3
 800095c:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 8000960:	bf08      	it	eq
 8000962:	3d01      	subeq	r5, #1
 8000964:	d0f7      	beq.n	8000956 <__aeabi_dmul+0x1c6>
 8000966:	ea43 0306 	orr.w	r3, r3, r6
 800096a:	4770      	bx	lr
 800096c:	ea94 0f0c 	teq	r4, ip
 8000970:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8000974:	bf18      	it	ne
 8000976:	ea95 0f0c 	teqne	r5, ip
 800097a:	d00c      	beq.n	8000996 <__aeabi_dmul+0x206>
 800097c:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000980:	bf18      	it	ne
 8000982:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000986:	d1d1      	bne.n	800092c <__aeabi_dmul+0x19c>
 8000988:	ea81 0103 	eor.w	r1, r1, r3
 800098c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000990:	f04f 0000 	mov.w	r0, #0
 8000994:	bd70      	pop	{r4, r5, r6, pc}
 8000996:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 800099a:	bf06      	itte	eq
 800099c:	4610      	moveq	r0, r2
 800099e:	4619      	moveq	r1, r3
 80009a0:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80009a4:	d019      	beq.n	80009da <__aeabi_dmul+0x24a>
 80009a6:	ea94 0f0c 	teq	r4, ip
 80009aa:	d102      	bne.n	80009b2 <__aeabi_dmul+0x222>
 80009ac:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 80009b0:	d113      	bne.n	80009da <__aeabi_dmul+0x24a>
 80009b2:	ea95 0f0c 	teq	r5, ip
 80009b6:	d105      	bne.n	80009c4 <__aeabi_dmul+0x234>
 80009b8:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 80009bc:	bf1c      	itt	ne
 80009be:	4610      	movne	r0, r2
 80009c0:	4619      	movne	r1, r3
 80009c2:	d10a      	bne.n	80009da <__aeabi_dmul+0x24a>
 80009c4:	ea81 0103 	eor.w	r1, r1, r3
 80009c8:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80009cc:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 80009d0:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 80009d4:	f04f 0000 	mov.w	r0, #0
 80009d8:	bd70      	pop	{r4, r5, r6, pc}
 80009da:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 80009de:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 80009e2:	bd70      	pop	{r4, r5, r6, pc}

080009e4 <__aeabi_ddiv>:
 80009e4:	b570      	push	{r4, r5, r6, lr}
 80009e6:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80009ea:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 80009ee:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 80009f2:	bf1d      	ittte	ne
 80009f4:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 80009f8:	ea94 0f0c 	teqne	r4, ip
 80009fc:	ea95 0f0c 	teqne	r5, ip
 8000a00:	f000 f8a7 	bleq	8000b52 <__aeabi_ddiv+0x16e>
 8000a04:	eba4 0405 	sub.w	r4, r4, r5
 8000a08:	ea81 0e03 	eor.w	lr, r1, r3
 8000a0c:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8000a10:	ea4f 3101 	mov.w	r1, r1, lsl #12
 8000a14:	f000 8088 	beq.w	8000b28 <__aeabi_ddiv+0x144>
 8000a18:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8000a1c:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 8000a20:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 8000a24:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 8000a28:	ea4f 2202 	mov.w	r2, r2, lsl #8
 8000a2c:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 8000a30:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 8000a34:	ea4f 2600 	mov.w	r6, r0, lsl #8
 8000a38:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 8000a3c:	429d      	cmp	r5, r3
 8000a3e:	bf08      	it	eq
 8000a40:	4296      	cmpeq	r6, r2
 8000a42:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 8000a46:	f504 7440 	add.w	r4, r4, #768	; 0x300
 8000a4a:	d202      	bcs.n	8000a52 <__aeabi_ddiv+0x6e>
 8000a4c:	085b      	lsrs	r3, r3, #1
 8000a4e:	ea4f 0232 	mov.w	r2, r2, rrx
 8000a52:	1ab6      	subs	r6, r6, r2
 8000a54:	eb65 0503 	sbc.w	r5, r5, r3
 8000a58:	085b      	lsrs	r3, r3, #1
 8000a5a:	ea4f 0232 	mov.w	r2, r2, rrx
 8000a5e:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 8000a62:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 8000a66:	ebb6 0e02 	subs.w	lr, r6, r2
 8000a6a:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000a6e:	bf22      	ittt	cs
 8000a70:	1ab6      	subcs	r6, r6, r2
 8000a72:	4675      	movcs	r5, lr
 8000a74:	ea40 000c 	orrcs.w	r0, r0, ip
 8000a78:	085b      	lsrs	r3, r3, #1
 8000a7a:	ea4f 0232 	mov.w	r2, r2, rrx
 8000a7e:	ebb6 0e02 	subs.w	lr, r6, r2
 8000a82:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000a86:	bf22      	ittt	cs
 8000a88:	1ab6      	subcs	r6, r6, r2
 8000a8a:	4675      	movcs	r5, lr
 8000a8c:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 8000a90:	085b      	lsrs	r3, r3, #1
 8000a92:	ea4f 0232 	mov.w	r2, r2, rrx
 8000a96:	ebb6 0e02 	subs.w	lr, r6, r2
 8000a9a:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000a9e:	bf22      	ittt	cs
 8000aa0:	1ab6      	subcs	r6, r6, r2
 8000aa2:	4675      	movcs	r5, lr
 8000aa4:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8000aa8:	085b      	lsrs	r3, r3, #1
 8000aaa:	ea4f 0232 	mov.w	r2, r2, rrx
 8000aae:	ebb6 0e02 	subs.w	lr, r6, r2
 8000ab2:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000ab6:	bf22      	ittt	cs
 8000ab8:	1ab6      	subcs	r6, r6, r2
 8000aba:	4675      	movcs	r5, lr
 8000abc:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8000ac0:	ea55 0e06 	orrs.w	lr, r5, r6
 8000ac4:	d018      	beq.n	8000af8 <__aeabi_ddiv+0x114>
 8000ac6:	ea4f 1505 	mov.w	r5, r5, lsl #4
 8000aca:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 8000ace:	ea4f 1606 	mov.w	r6, r6, lsl #4
 8000ad2:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8000ad6:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 8000ada:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 8000ade:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 8000ae2:	d1c0      	bne.n	8000a66 <__aeabi_ddiv+0x82>
 8000ae4:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8000ae8:	d10b      	bne.n	8000b02 <__aeabi_ddiv+0x11e>
 8000aea:	ea41 0100 	orr.w	r1, r1, r0
 8000aee:	f04f 0000 	mov.w	r0, #0
 8000af2:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 8000af6:	e7b6      	b.n	8000a66 <__aeabi_ddiv+0x82>
 8000af8:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8000afc:	bf04      	itt	eq
 8000afe:	4301      	orreq	r1, r0
 8000b00:	2000      	moveq	r0, #0
 8000b02:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 8000b06:	bf88      	it	hi
 8000b08:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 8000b0c:	f63f aeaf 	bhi.w	800086e <__aeabi_dmul+0xde>
 8000b10:	ebb5 0c03 	subs.w	ip, r5, r3
 8000b14:	bf04      	itt	eq
 8000b16:	ebb6 0c02 	subseq.w	ip, r6, r2
 8000b1a:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 8000b1e:	f150 0000 	adcs.w	r0, r0, #0
 8000b22:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8000b26:	bd70      	pop	{r4, r5, r6, pc}
 8000b28:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 8000b2c:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 8000b30:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 8000b34:	bfc2      	ittt	gt
 8000b36:	ebd4 050c 	rsbsgt	r5, r4, ip
 8000b3a:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 8000b3e:	bd70      	popgt	{r4, r5, r6, pc}
 8000b40:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000b44:	f04f 0e00 	mov.w	lr, #0
 8000b48:	3c01      	subs	r4, #1
 8000b4a:	e690      	b.n	800086e <__aeabi_dmul+0xde>
 8000b4c:	ea45 0e06 	orr.w	lr, r5, r6
 8000b50:	e68d      	b.n	800086e <__aeabi_dmul+0xde>
 8000b52:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8000b56:	ea94 0f0c 	teq	r4, ip
 8000b5a:	bf08      	it	eq
 8000b5c:	ea95 0f0c 	teqeq	r5, ip
 8000b60:	f43f af3b 	beq.w	80009da <__aeabi_dmul+0x24a>
 8000b64:	ea94 0f0c 	teq	r4, ip
 8000b68:	d10a      	bne.n	8000b80 <__aeabi_ddiv+0x19c>
 8000b6a:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8000b6e:	f47f af34 	bne.w	80009da <__aeabi_dmul+0x24a>
 8000b72:	ea95 0f0c 	teq	r5, ip
 8000b76:	f47f af25 	bne.w	80009c4 <__aeabi_dmul+0x234>
 8000b7a:	4610      	mov	r0, r2
 8000b7c:	4619      	mov	r1, r3
 8000b7e:	e72c      	b.n	80009da <__aeabi_dmul+0x24a>
 8000b80:	ea95 0f0c 	teq	r5, ip
 8000b84:	d106      	bne.n	8000b94 <__aeabi_ddiv+0x1b0>
 8000b86:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8000b8a:	f43f aefd 	beq.w	8000988 <__aeabi_dmul+0x1f8>
 8000b8e:	4610      	mov	r0, r2
 8000b90:	4619      	mov	r1, r3
 8000b92:	e722      	b.n	80009da <__aeabi_dmul+0x24a>
 8000b94:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000b98:	bf18      	it	ne
 8000b9a:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000b9e:	f47f aec5 	bne.w	800092c <__aeabi_dmul+0x19c>
 8000ba2:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 8000ba6:	f47f af0d 	bne.w	80009c4 <__aeabi_dmul+0x234>
 8000baa:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 8000bae:	f47f aeeb 	bne.w	8000988 <__aeabi_dmul+0x1f8>
 8000bb2:	e712      	b.n	80009da <__aeabi_dmul+0x24a>

08000bb4 <__gedf2>:
 8000bb4:	f04f 3cff 	mov.w	ip, #4294967295
 8000bb8:	e006      	b.n	8000bc8 <__cmpdf2+0x4>
 8000bba:	bf00      	nop

08000bbc <__ledf2>:
 8000bbc:	f04f 0c01 	mov.w	ip, #1
 8000bc0:	e002      	b.n	8000bc8 <__cmpdf2+0x4>
 8000bc2:	bf00      	nop

08000bc4 <__cmpdf2>:
 8000bc4:	f04f 0c01 	mov.w	ip, #1
 8000bc8:	f84d cd04 	str.w	ip, [sp, #-4]!
 8000bcc:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000bd0:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000bd4:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000bd8:	bf18      	it	ne
 8000bda:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 8000bde:	d01b      	beq.n	8000c18 <__cmpdf2+0x54>
 8000be0:	b001      	add	sp, #4
 8000be2:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 8000be6:	bf0c      	ite	eq
 8000be8:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 8000bec:	ea91 0f03 	teqne	r1, r3
 8000bf0:	bf02      	ittt	eq
 8000bf2:	ea90 0f02 	teqeq	r0, r2
 8000bf6:	2000      	moveq	r0, #0
 8000bf8:	4770      	bxeq	lr
 8000bfa:	f110 0f00 	cmn.w	r0, #0
 8000bfe:	ea91 0f03 	teq	r1, r3
 8000c02:	bf58      	it	pl
 8000c04:	4299      	cmppl	r1, r3
 8000c06:	bf08      	it	eq
 8000c08:	4290      	cmpeq	r0, r2
 8000c0a:	bf2c      	ite	cs
 8000c0c:	17d8      	asrcs	r0, r3, #31
 8000c0e:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 8000c12:	f040 0001 	orr.w	r0, r0, #1
 8000c16:	4770      	bx	lr
 8000c18:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000c1c:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000c20:	d102      	bne.n	8000c28 <__cmpdf2+0x64>
 8000c22:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 8000c26:	d107      	bne.n	8000c38 <__cmpdf2+0x74>
 8000c28:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000c2c:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000c30:	d1d6      	bne.n	8000be0 <__cmpdf2+0x1c>
 8000c32:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 8000c36:	d0d3      	beq.n	8000be0 <__cmpdf2+0x1c>
 8000c38:	f85d 0b04 	ldr.w	r0, [sp], #4
 8000c3c:	4770      	bx	lr
 8000c3e:	bf00      	nop

08000c40 <__aeabi_cdrcmple>:
 8000c40:	4684      	mov	ip, r0
 8000c42:	4610      	mov	r0, r2
 8000c44:	4662      	mov	r2, ip
 8000c46:	468c      	mov	ip, r1
 8000c48:	4619      	mov	r1, r3
 8000c4a:	4663      	mov	r3, ip
 8000c4c:	e000      	b.n	8000c50 <__aeabi_cdcmpeq>
 8000c4e:	bf00      	nop

08000c50 <__aeabi_cdcmpeq>:
 8000c50:	b501      	push	{r0, lr}
 8000c52:	f7ff ffb7 	bl	8000bc4 <__cmpdf2>
 8000c56:	2800      	cmp	r0, #0
 8000c58:	bf48      	it	mi
 8000c5a:	f110 0f00 	cmnmi.w	r0, #0
 8000c5e:	bd01      	pop	{r0, pc}

08000c60 <__aeabi_dcmpeq>:
 8000c60:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000c64:	f7ff fff4 	bl	8000c50 <__aeabi_cdcmpeq>
 8000c68:	bf0c      	ite	eq
 8000c6a:	2001      	moveq	r0, #1
 8000c6c:	2000      	movne	r0, #0
 8000c6e:	f85d fb08 	ldr.w	pc, [sp], #8
 8000c72:	bf00      	nop

08000c74 <__aeabi_dcmplt>:
 8000c74:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000c78:	f7ff ffea 	bl	8000c50 <__aeabi_cdcmpeq>
 8000c7c:	bf34      	ite	cc
 8000c7e:	2001      	movcc	r0, #1
 8000c80:	2000      	movcs	r0, #0
 8000c82:	f85d fb08 	ldr.w	pc, [sp], #8
 8000c86:	bf00      	nop

08000c88 <__aeabi_dcmple>:
 8000c88:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000c8c:	f7ff ffe0 	bl	8000c50 <__aeabi_cdcmpeq>
 8000c90:	bf94      	ite	ls
 8000c92:	2001      	movls	r0, #1
 8000c94:	2000      	movhi	r0, #0
 8000c96:	f85d fb08 	ldr.w	pc, [sp], #8
 8000c9a:	bf00      	nop

08000c9c <__aeabi_dcmpge>:
 8000c9c:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000ca0:	f7ff ffce 	bl	8000c40 <__aeabi_cdrcmple>
 8000ca4:	bf94      	ite	ls
 8000ca6:	2001      	movls	r0, #1
 8000ca8:	2000      	movhi	r0, #0
 8000caa:	f85d fb08 	ldr.w	pc, [sp], #8
 8000cae:	bf00      	nop

08000cb0 <__aeabi_dcmpgt>:
 8000cb0:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000cb4:	f7ff ffc4 	bl	8000c40 <__aeabi_cdrcmple>
 8000cb8:	bf34      	ite	cc
 8000cba:	2001      	movcc	r0, #1
 8000cbc:	2000      	movcs	r0, #0
 8000cbe:	f85d fb08 	ldr.w	pc, [sp], #8
 8000cc2:	bf00      	nop

08000cc4 <__aeabi_d2uiz>:
 8000cc4:	004a      	lsls	r2, r1, #1
 8000cc6:	d211      	bcs.n	8000cec <__aeabi_d2uiz+0x28>
 8000cc8:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 8000ccc:	d211      	bcs.n	8000cf2 <__aeabi_d2uiz+0x2e>
 8000cce:	d50d      	bpl.n	8000cec <__aeabi_d2uiz+0x28>
 8000cd0:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 8000cd4:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 8000cd8:	d40e      	bmi.n	8000cf8 <__aeabi_d2uiz+0x34>
 8000cda:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000cde:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8000ce2:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 8000ce6:	fa23 f002 	lsr.w	r0, r3, r2
 8000cea:	4770      	bx	lr
 8000cec:	f04f 0000 	mov.w	r0, #0
 8000cf0:	4770      	bx	lr
 8000cf2:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 8000cf6:	d102      	bne.n	8000cfe <__aeabi_d2uiz+0x3a>
 8000cf8:	f04f 30ff 	mov.w	r0, #4294967295
 8000cfc:	4770      	bx	lr
 8000cfe:	f04f 0000 	mov.w	r0, #0
 8000d02:	4770      	bx	lr

08000d04 <__aeabi_d2f>:
 8000d04:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8000d08:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
 8000d0c:	bf24      	itt	cs
 8000d0e:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
 8000d12:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
 8000d16:	d90d      	bls.n	8000d34 <__aeabi_d2f+0x30>
 8000d18:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 8000d1c:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 8000d20:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 8000d24:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
 8000d28:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 8000d2c:	bf08      	it	eq
 8000d2e:	f020 0001 	biceq.w	r0, r0, #1
 8000d32:	4770      	bx	lr
 8000d34:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
 8000d38:	d121      	bne.n	8000d7e <__aeabi_d2f+0x7a>
 8000d3a:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
 8000d3e:	bfbc      	itt	lt
 8000d40:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
 8000d44:	4770      	bxlt	lr
 8000d46:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000d4a:	ea4f 5252 	mov.w	r2, r2, lsr #21
 8000d4e:	f1c2 0218 	rsb	r2, r2, #24
 8000d52:	f1c2 0c20 	rsb	ip, r2, #32
 8000d56:	fa10 f30c 	lsls.w	r3, r0, ip
 8000d5a:	fa20 f002 	lsr.w	r0, r0, r2
 8000d5e:	bf18      	it	ne
 8000d60:	f040 0001 	orrne.w	r0, r0, #1
 8000d64:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000d68:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 8000d6c:	fa03 fc0c 	lsl.w	ip, r3, ip
 8000d70:	ea40 000c 	orr.w	r0, r0, ip
 8000d74:	fa23 f302 	lsr.w	r3, r3, r2
 8000d78:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8000d7c:	e7cc      	b.n	8000d18 <__aeabi_d2f+0x14>
 8000d7e:	ea7f 5362 	mvns.w	r3, r2, asr #21
 8000d82:	d107      	bne.n	8000d94 <__aeabi_d2f+0x90>
 8000d84:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 8000d88:	bf1e      	ittt	ne
 8000d8a:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
 8000d8e:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
 8000d92:	4770      	bxne	lr
 8000d94:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
 8000d98:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8000d9c:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000da0:	4770      	bx	lr
 8000da2:	bf00      	nop

08000da4 <__aeabi_frsub>:
 8000da4:	f080 4000 	eor.w	r0, r0, #2147483648	; 0x80000000
 8000da8:	e002      	b.n	8000db0 <__addsf3>
 8000daa:	bf00      	nop

08000dac <__aeabi_fsub>:
 8000dac:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000

08000db0 <__addsf3>:
 8000db0:	0042      	lsls	r2, r0, #1
 8000db2:	bf1f      	itttt	ne
 8000db4:	ea5f 0341 	movsne.w	r3, r1, lsl #1
 8000db8:	ea92 0f03 	teqne	r2, r3
 8000dbc:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
 8000dc0:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 8000dc4:	d06a      	beq.n	8000e9c <__addsf3+0xec>
 8000dc6:	ea4f 6212 	mov.w	r2, r2, lsr #24
 8000dca:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
 8000dce:	bfc1      	itttt	gt
 8000dd0:	18d2      	addgt	r2, r2, r3
 8000dd2:	4041      	eorgt	r1, r0
 8000dd4:	4048      	eorgt	r0, r1
 8000dd6:	4041      	eorgt	r1, r0
 8000dd8:	bfb8      	it	lt
 8000dda:	425b      	neglt	r3, r3
 8000ddc:	2b19      	cmp	r3, #25
 8000dde:	bf88      	it	hi
 8000de0:	4770      	bxhi	lr
 8000de2:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
 8000de6:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000dea:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
 8000dee:	bf18      	it	ne
 8000df0:	4240      	negne	r0, r0
 8000df2:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000df6:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
 8000dfa:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
 8000dfe:	bf18      	it	ne
 8000e00:	4249      	negne	r1, r1
 8000e02:	ea92 0f03 	teq	r2, r3
 8000e06:	d03f      	beq.n	8000e88 <__addsf3+0xd8>
 8000e08:	f1a2 0201 	sub.w	r2, r2, #1
 8000e0c:	fa41 fc03 	asr.w	ip, r1, r3
 8000e10:	eb10 000c 	adds.w	r0, r0, ip
 8000e14:	f1c3 0320 	rsb	r3, r3, #32
 8000e18:	fa01 f103 	lsl.w	r1, r1, r3
 8000e1c:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 8000e20:	d502      	bpl.n	8000e28 <__addsf3+0x78>
 8000e22:	4249      	negs	r1, r1
 8000e24:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
 8000e28:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
 8000e2c:	d313      	bcc.n	8000e56 <__addsf3+0xa6>
 8000e2e:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 8000e32:	d306      	bcc.n	8000e42 <__addsf3+0x92>
 8000e34:	0840      	lsrs	r0, r0, #1
 8000e36:	ea4f 0131 	mov.w	r1, r1, rrx
 8000e3a:	f102 0201 	add.w	r2, r2, #1
 8000e3e:	2afe      	cmp	r2, #254	; 0xfe
 8000e40:	d251      	bcs.n	8000ee6 <__addsf3+0x136>
 8000e42:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
 8000e46:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 8000e4a:	bf08      	it	eq
 8000e4c:	f020 0001 	biceq.w	r0, r0, #1
 8000e50:	ea40 0003 	orr.w	r0, r0, r3
 8000e54:	4770      	bx	lr
 8000e56:	0049      	lsls	r1, r1, #1
 8000e58:	eb40 0000 	adc.w	r0, r0, r0
 8000e5c:	3a01      	subs	r2, #1
 8000e5e:	bf28      	it	cs
 8000e60:	f5b0 0f00 	cmpcs.w	r0, #8388608	; 0x800000
 8000e64:	d2ed      	bcs.n	8000e42 <__addsf3+0x92>
 8000e66:	fab0 fc80 	clz	ip, r0
 8000e6a:	f1ac 0c08 	sub.w	ip, ip, #8
 8000e6e:	ebb2 020c 	subs.w	r2, r2, ip
 8000e72:	fa00 f00c 	lsl.w	r0, r0, ip
 8000e76:	bfaa      	itet	ge
 8000e78:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
 8000e7c:	4252      	neglt	r2, r2
 8000e7e:	4318      	orrge	r0, r3
 8000e80:	bfbc      	itt	lt
 8000e82:	40d0      	lsrlt	r0, r2
 8000e84:	4318      	orrlt	r0, r3
 8000e86:	4770      	bx	lr
 8000e88:	f092 0f00 	teq	r2, #0
 8000e8c:	f481 0100 	eor.w	r1, r1, #8388608	; 0x800000
 8000e90:	bf06      	itte	eq
 8000e92:	f480 0000 	eoreq.w	r0, r0, #8388608	; 0x800000
 8000e96:	3201      	addeq	r2, #1
 8000e98:	3b01      	subne	r3, #1
 8000e9a:	e7b5      	b.n	8000e08 <__addsf3+0x58>
 8000e9c:	ea4f 0341 	mov.w	r3, r1, lsl #1
 8000ea0:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 8000ea4:	bf18      	it	ne
 8000ea6:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 8000eaa:	d021      	beq.n	8000ef0 <__addsf3+0x140>
 8000eac:	ea92 0f03 	teq	r2, r3
 8000eb0:	d004      	beq.n	8000ebc <__addsf3+0x10c>
 8000eb2:	f092 0f00 	teq	r2, #0
 8000eb6:	bf08      	it	eq
 8000eb8:	4608      	moveq	r0, r1
 8000eba:	4770      	bx	lr
 8000ebc:	ea90 0f01 	teq	r0, r1
 8000ec0:	bf1c      	itt	ne
 8000ec2:	2000      	movne	r0, #0
 8000ec4:	4770      	bxne	lr
 8000ec6:	f012 4f7f 	tst.w	r2, #4278190080	; 0xff000000
 8000eca:	d104      	bne.n	8000ed6 <__addsf3+0x126>
 8000ecc:	0040      	lsls	r0, r0, #1
 8000ece:	bf28      	it	cs
 8000ed0:	f040 4000 	orrcs.w	r0, r0, #2147483648	; 0x80000000
 8000ed4:	4770      	bx	lr
 8000ed6:	f112 7200 	adds.w	r2, r2, #33554432	; 0x2000000
 8000eda:	bf3c      	itt	cc
 8000edc:	f500 0000 	addcc.w	r0, r0, #8388608	; 0x800000
 8000ee0:	4770      	bxcc	lr
 8000ee2:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 8000ee6:	f043 40fe 	orr.w	r0, r3, #2130706432	; 0x7f000000
 8000eea:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000eee:	4770      	bx	lr
 8000ef0:	ea7f 6222 	mvns.w	r2, r2, asr #24
 8000ef4:	bf16      	itet	ne
 8000ef6:	4608      	movne	r0, r1
 8000ef8:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
 8000efc:	4601      	movne	r1, r0
 8000efe:	0242      	lsls	r2, r0, #9
 8000f00:	bf06      	itte	eq
 8000f02:	ea5f 2341 	movseq.w	r3, r1, lsl #9
 8000f06:	ea90 0f01 	teqeq	r0, r1
 8000f0a:	f440 0080 	orrne.w	r0, r0, #4194304	; 0x400000
 8000f0e:	4770      	bx	lr

08000f10 <__aeabi_ui2f>:
 8000f10:	f04f 0300 	mov.w	r3, #0
 8000f14:	e004      	b.n	8000f20 <__aeabi_i2f+0x8>
 8000f16:	bf00      	nop

08000f18 <__aeabi_i2f>:
 8000f18:	f010 4300 	ands.w	r3, r0, #2147483648	; 0x80000000
 8000f1c:	bf48      	it	mi
 8000f1e:	4240      	negmi	r0, r0
 8000f20:	ea5f 0c00 	movs.w	ip, r0
 8000f24:	bf08      	it	eq
 8000f26:	4770      	bxeq	lr
 8000f28:	f043 4396 	orr.w	r3, r3, #1258291200	; 0x4b000000
 8000f2c:	4601      	mov	r1, r0
 8000f2e:	f04f 0000 	mov.w	r0, #0
 8000f32:	e01c      	b.n	8000f6e <__aeabi_l2f+0x2a>

08000f34 <__aeabi_ul2f>:
 8000f34:	ea50 0201 	orrs.w	r2, r0, r1
 8000f38:	bf08      	it	eq
 8000f3a:	4770      	bxeq	lr
 8000f3c:	f04f 0300 	mov.w	r3, #0
 8000f40:	e00a      	b.n	8000f58 <__aeabi_l2f+0x14>
 8000f42:	bf00      	nop

08000f44 <__aeabi_l2f>:
 8000f44:	ea50 0201 	orrs.w	r2, r0, r1
 8000f48:	bf08      	it	eq
 8000f4a:	4770      	bxeq	lr
 8000f4c:	f011 4300 	ands.w	r3, r1, #2147483648	; 0x80000000
 8000f50:	d502      	bpl.n	8000f58 <__aeabi_l2f+0x14>
 8000f52:	4240      	negs	r0, r0
 8000f54:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000f58:	ea5f 0c01 	movs.w	ip, r1
 8000f5c:	bf02      	ittt	eq
 8000f5e:	4684      	moveq	ip, r0
 8000f60:	4601      	moveq	r1, r0
 8000f62:	2000      	moveq	r0, #0
 8000f64:	f043 43b6 	orr.w	r3, r3, #1526726656	; 0x5b000000
 8000f68:	bf08      	it	eq
 8000f6a:	f1a3 5380 	subeq.w	r3, r3, #268435456	; 0x10000000
 8000f6e:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
 8000f72:	fabc f28c 	clz	r2, ip
 8000f76:	3a08      	subs	r2, #8
 8000f78:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
 8000f7c:	db10      	blt.n	8000fa0 <__aeabi_l2f+0x5c>
 8000f7e:	fa01 fc02 	lsl.w	ip, r1, r2
 8000f82:	4463      	add	r3, ip
 8000f84:	fa00 fc02 	lsl.w	ip, r0, r2
 8000f88:	f1c2 0220 	rsb	r2, r2, #32
 8000f8c:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 8000f90:	fa20 f202 	lsr.w	r2, r0, r2
 8000f94:	eb43 0002 	adc.w	r0, r3, r2
 8000f98:	bf08      	it	eq
 8000f9a:	f020 0001 	biceq.w	r0, r0, #1
 8000f9e:	4770      	bx	lr
 8000fa0:	f102 0220 	add.w	r2, r2, #32
 8000fa4:	fa01 fc02 	lsl.w	ip, r1, r2
 8000fa8:	f1c2 0220 	rsb	r2, r2, #32
 8000fac:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
 8000fb0:	fa21 f202 	lsr.w	r2, r1, r2
 8000fb4:	eb43 0002 	adc.w	r0, r3, r2
 8000fb8:	bf08      	it	eq
 8000fba:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 8000fbe:	4770      	bx	lr

08000fc0 <__gesf2>:
 8000fc0:	f04f 3cff 	mov.w	ip, #4294967295
 8000fc4:	e006      	b.n	8000fd4 <__cmpsf2+0x4>
 8000fc6:	bf00      	nop

08000fc8 <__lesf2>:
 8000fc8:	f04f 0c01 	mov.w	ip, #1
 8000fcc:	e002      	b.n	8000fd4 <__cmpsf2+0x4>
 8000fce:	bf00      	nop

08000fd0 <__cmpsf2>:
 8000fd0:	f04f 0c01 	mov.w	ip, #1
 8000fd4:	f84d cd04 	str.w	ip, [sp, #-4]!
 8000fd8:	ea4f 0240 	mov.w	r2, r0, lsl #1
 8000fdc:	ea4f 0341 	mov.w	r3, r1, lsl #1
 8000fe0:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 8000fe4:	bf18      	it	ne
 8000fe6:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 8000fea:	d011      	beq.n	8001010 <__cmpsf2+0x40>
 8000fec:	b001      	add	sp, #4
 8000fee:	ea52 0c53 	orrs.w	ip, r2, r3, lsr #1
 8000ff2:	bf18      	it	ne
 8000ff4:	ea90 0f01 	teqne	r0, r1
 8000ff8:	bf58      	it	pl
 8000ffa:	ebb2 0003 	subspl.w	r0, r2, r3
 8000ffe:	bf88      	it	hi
 8001000:	17c8      	asrhi	r0, r1, #31
 8001002:	bf38      	it	cc
 8001004:	ea6f 70e1 	mvncc.w	r0, r1, asr #31
 8001008:	bf18      	it	ne
 800100a:	f040 0001 	orrne.w	r0, r0, #1
 800100e:	4770      	bx	lr
 8001010:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 8001014:	d102      	bne.n	800101c <__cmpsf2+0x4c>
 8001016:	ea5f 2c40 	movs.w	ip, r0, lsl #9
 800101a:	d105      	bne.n	8001028 <__cmpsf2+0x58>
 800101c:	ea7f 6c23 	mvns.w	ip, r3, asr #24
 8001020:	d1e4      	bne.n	8000fec <__cmpsf2+0x1c>
 8001022:	ea5f 2c41 	movs.w	ip, r1, lsl #9
 8001026:	d0e1      	beq.n	8000fec <__cmpsf2+0x1c>
 8001028:	f85d 0b04 	ldr.w	r0, [sp], #4
 800102c:	4770      	bx	lr
 800102e:	bf00      	nop

08001030 <__aeabi_cfrcmple>:
 8001030:	4684      	mov	ip, r0
 8001032:	4608      	mov	r0, r1
 8001034:	4661      	mov	r1, ip
 8001036:	e7ff      	b.n	8001038 <__aeabi_cfcmpeq>

08001038 <__aeabi_cfcmpeq>:
 8001038:	b50f      	push	{r0, r1, r2, r3, lr}
 800103a:	f7ff ffc9 	bl	8000fd0 <__cmpsf2>
 800103e:	2800      	cmp	r0, #0
 8001040:	bf48      	it	mi
 8001042:	f110 0f00 	cmnmi.w	r0, #0
 8001046:	bd0f      	pop	{r0, r1, r2, r3, pc}

08001048 <__aeabi_fcmpeq>:
 8001048:	f84d ed08 	str.w	lr, [sp, #-8]!
 800104c:	f7ff fff4 	bl	8001038 <__aeabi_cfcmpeq>
 8001050:	bf0c      	ite	eq
 8001052:	2001      	moveq	r0, #1
 8001054:	2000      	movne	r0, #0
 8001056:	f85d fb08 	ldr.w	pc, [sp], #8
 800105a:	bf00      	nop

0800105c <__aeabi_fcmplt>:
 800105c:	f84d ed08 	str.w	lr, [sp, #-8]!
 8001060:	f7ff ffea 	bl	8001038 <__aeabi_cfcmpeq>
 8001064:	bf34      	ite	cc
 8001066:	2001      	movcc	r0, #1
 8001068:	2000      	movcs	r0, #0
 800106a:	f85d fb08 	ldr.w	pc, [sp], #8
 800106e:	bf00      	nop

08001070 <__aeabi_fcmple>:
 8001070:	f84d ed08 	str.w	lr, [sp, #-8]!
 8001074:	f7ff ffe0 	bl	8001038 <__aeabi_cfcmpeq>
 8001078:	bf94      	ite	ls
 800107a:	2001      	movls	r0, #1
 800107c:	2000      	movhi	r0, #0
 800107e:	f85d fb08 	ldr.w	pc, [sp], #8
 8001082:	bf00      	nop

08001084 <__aeabi_fcmpge>:
 8001084:	f84d ed08 	str.w	lr, [sp, #-8]!
 8001088:	f7ff ffd2 	bl	8001030 <__aeabi_cfrcmple>
 800108c:	bf94      	ite	ls
 800108e:	2001      	movls	r0, #1
 8001090:	2000      	movhi	r0, #0
 8001092:	f85d fb08 	ldr.w	pc, [sp], #8
 8001096:	bf00      	nop

08001098 <__aeabi_fcmpgt>:
 8001098:	f84d ed08 	str.w	lr, [sp, #-8]!
 800109c:	f7ff ffc8 	bl	8001030 <__aeabi_cfrcmple>
 80010a0:	bf34      	ite	cc
 80010a2:	2001      	movcc	r0, #1
 80010a4:	2000      	movcs	r0, #0
 80010a6:	f85d fb08 	ldr.w	pc, [sp], #8
 80010aa:	bf00      	nop

080010ac <__aeabi_f2iz>:
 80010ac:	ea4f 0240 	mov.w	r2, r0, lsl #1
 80010b0:	f1b2 4ffe 	cmp.w	r2, #2130706432	; 0x7f000000
 80010b4:	d30f      	bcc.n	80010d6 <__aeabi_f2iz+0x2a>
 80010b6:	f04f 039e 	mov.w	r3, #158	; 0x9e
 80010ba:	ebb3 6212 	subs.w	r2, r3, r2, lsr #24
 80010be:	d90d      	bls.n	80010dc <__aeabi_f2iz+0x30>
 80010c0:	ea4f 2300 	mov.w	r3, r0, lsl #8
 80010c4:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80010c8:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
 80010cc:	fa23 f002 	lsr.w	r0, r3, r2
 80010d0:	bf18      	it	ne
 80010d2:	4240      	negne	r0, r0
 80010d4:	4770      	bx	lr
 80010d6:	f04f 0000 	mov.w	r0, #0
 80010da:	4770      	bx	lr
 80010dc:	f112 0f61 	cmn.w	r2, #97	; 0x61
 80010e0:	d101      	bne.n	80010e6 <__aeabi_f2iz+0x3a>
 80010e2:	0242      	lsls	r2, r0, #9
 80010e4:	d105      	bne.n	80010f2 <__aeabi_f2iz+0x46>
 80010e6:	f010 4000 	ands.w	r0, r0, #2147483648	; 0x80000000
 80010ea:	bf08      	it	eq
 80010ec:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 80010f0:	4770      	bx	lr
 80010f2:	f04f 0000 	mov.w	r0, #0
 80010f6:	4770      	bx	lr

080010f8 <Reset_Handler>:
 * @param  None
 * @retval : None
*/

void Reset_Handler(void)
{
 80010f8:	4668      	mov	r0, sp
 80010fa:	f020 0107 	bic.w	r1, r0, #7
 80010fe:	468d      	mov	sp, r1
 8001100:	b581      	push	{r0, r7, lr}
 8001102:	b083      	sub	sp, #12
 8001104:	af00      	add	r7, sp, #0

#ifdef STARTUP_DELAY
  volatile unsigned long i;
  for (i=0;i<500000;i++) { ; }
 8001106:	2300      	movs	r3, #0
 8001108:	607b      	str	r3, [r7, #4]
 800110a:	e002      	b.n	8001112 <Reset_Handler+0x1a>
 800110c:	687b      	ldr	r3, [r7, #4]
 800110e:	3301      	adds	r3, #1
 8001110:	607b      	str	r3, [r7, #4]
 8001112:	687b      	ldr	r3, [r7, #4]
 8001114:	4a03      	ldr	r2, [pc, #12]	; (8001124 <Reset_Handler+0x2c>)
 8001116:	4293      	cmp	r3, r2
 8001118:	d9f8      	bls.n	800110c <Reset_Handler+0x14>
#endif

  /* Initialize data and bss */
  __Init_Data();
 800111a:	4b03      	ldr	r3, [pc, #12]	; (8001128 <Reset_Handler+0x30>)
 800111c:	4798      	blx	r3

  /* Call the application's entry point.*/
  main();
 800111e:	4b03      	ldr	r3, [pc, #12]	; (800112c <Reset_Handler+0x34>)
 8001120:	4798      	blx	r3

  while(1) { ; }
 8001122:	e7fe      	b.n	8001122 <Reset_Handler+0x2a>
 8001124:	0007a11f 	.word	0x0007a11f
 8001128:	08001131 	.word	0x08001131
 800112c:	08006dfd 	.word	0x08006dfd

08001130 <__Init_Data>:
 * @param  None
 * @retval : None
*/

void __Init_Data(void)
{
 8001130:	b480      	push	{r7}
 8001132:	b083      	sub	sp, #12
 8001134:	af00      	add	r7, sp, #0
  unsigned long *pulSrc, *pulDest;

  /* Copy the data segment initializers from flash to SRAM */
  pulSrc  = &_sidata;
 8001136:	4b13      	ldr	r3, [pc, #76]	; (8001184 <__Init_Data+0x54>)
 8001138:	607b      	str	r3, [r7, #4]
  pulDest = &_sdata;
 800113a:	4b13      	ldr	r3, [pc, #76]	; (8001188 <__Init_Data+0x58>)
 800113c:	603b      	str	r3, [r7, #0]
  if ( pulSrc != pulDest )
 800113e:	687a      	ldr	r2, [r7, #4]
 8001140:	683b      	ldr	r3, [r7, #0]
 8001142:	429a      	cmp	r2, r3
 8001144:	d00c      	beq.n	8001160 <__Init_Data+0x30>
  {
    for(; pulDest < &_edata; )
 8001146:	e007      	b.n	8001158 <__Init_Data+0x28>
    {
      *(pulDest++) = *(pulSrc++);
 8001148:	687a      	ldr	r2, [r7, #4]
 800114a:	1d13      	adds	r3, r2, #4
 800114c:	607b      	str	r3, [r7, #4]
 800114e:	683b      	ldr	r3, [r7, #0]
 8001150:	1d19      	adds	r1, r3, #4
 8001152:	6039      	str	r1, [r7, #0]
 8001154:	6812      	ldr	r2, [r2, #0]
 8001156:	601a      	str	r2, [r3, #0]
    for(; pulDest < &_edata; )
 8001158:	683b      	ldr	r3, [r7, #0]
 800115a:	4a0c      	ldr	r2, [pc, #48]	; (800118c <__Init_Data+0x5c>)
 800115c:	4293      	cmp	r3, r2
 800115e:	d3f3      	bcc.n	8001148 <__Init_Data+0x18>
    }
  }
  /* Zero fill the bss segment. */
  for(pulDest = &_sbss; pulDest < &_ebss; )
 8001160:	4b0b      	ldr	r3, [pc, #44]	; (8001190 <__Init_Data+0x60>)
 8001162:	603b      	str	r3, [r7, #0]
 8001164:	e004      	b.n	8001170 <__Init_Data+0x40>
  {
    *(pulDest++) = 0;
 8001166:	683b      	ldr	r3, [r7, #0]
 8001168:	1d1a      	adds	r2, r3, #4
 800116a:	603a      	str	r2, [r7, #0]
 800116c:	2200      	movs	r2, #0
 800116e:	601a      	str	r2, [r3, #0]
  for(pulDest = &_sbss; pulDest < &_ebss; )
 8001170:	683b      	ldr	r3, [r7, #0]
 8001172:	4a08      	ldr	r2, [pc, #32]	; (8001194 <__Init_Data+0x64>)
 8001174:	4293      	cmp	r3, r2
 8001176:	d3f6      	bcc.n	8001166 <__Init_Data+0x36>
  }
}
 8001178:	bf00      	nop
 800117a:	bf00      	nop
 800117c:	370c      	adds	r7, #12
 800117e:	46bd      	mov	sp, r7
 8001180:	bc80      	pop	{r7}
 8001182:	4770      	bx	lr
 8001184:	08015930 	.word	0x08015930
 8001188:	20000000 	.word	0x20000000
 800118c:	20000658 	.word	0x20000658
 8001190:	20000658 	.word	0x20000658
 8001194:	200096e4 	.word	0x200096e4

08001198 <Default_Handler>:
 * @param  None
 * @retval : None
*/

void Default_Handler(void)
{
 8001198:	b480      	push	{r7}
 800119a:	af00      	add	r7, sp, #0
  /* Go into an infinite loop. */
  while (1)
 800119c:	e7fe      	b.n	800119c <Default_Handler+0x4>
	...

080011a0 <RCC_Configuration>:
 * Description    : Configures the different system clocks.
 * Input          : None
 * Output         : None
 * Return         : None
 *******************************************************************************/
void RCC_Configuration(void) {
 80011a0:	b580      	push	{r7, lr}
 80011a2:	af00      	add	r7, sp, #0
	/* RCC system reset(for debug purpose) */
	RCC_DeInit();
 80011a4:	4b23      	ldr	r3, [pc, #140]	; (8001234 <RCC_Configuration+0x94>)
 80011a6:	4798      	blx	r3

	/* Enable HSE */
	RCC_HSEConfig(RCC_HSE_ON);
 80011a8:	f44f 3080 	mov.w	r0, #65536	; 0x10000
 80011ac:	4b22      	ldr	r3, [pc, #136]	; (8001238 <RCC_Configuration+0x98>)
 80011ae:	4798      	blx	r3
	RCC_LSEConfig(RCC_LSE_OFF); /////    gd
 80011b0:	2000      	movs	r0, #0
 80011b2:	4b22      	ldr	r3, [pc, #136]	; (800123c <RCC_Configuration+0x9c>)
 80011b4:	4798      	blx	r3
	/* Wait till HSE is ready */
	HSEStartUpStatus = RCC_WaitForHSEStartUp();
 80011b6:	4b22      	ldr	r3, [pc, #136]	; (8001240 <RCC_Configuration+0xa0>)
 80011b8:	4798      	blx	r3
 80011ba:	4603      	mov	r3, r0
 80011bc:	461a      	mov	r2, r3
 80011be:	4b21      	ldr	r3, [pc, #132]	; (8001244 <RCC_Configuration+0xa4>)
 80011c0:	701a      	strb	r2, [r3, #0]

	if (HSEStartUpStatus == SUCCESS) {
 80011c2:	4b20      	ldr	r3, [pc, #128]	; (8001244 <RCC_Configuration+0xa4>)
 80011c4:	781b      	ldrb	r3, [r3, #0]
 80011c6:	2b01      	cmp	r3, #1
 80011c8:	d131      	bne.n	800122e <RCC_Configuration+0x8e>
		/* Enable Prefetch Buffer */
		FLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable);
 80011ca:	2010      	movs	r0, #16
 80011cc:	4b1e      	ldr	r3, [pc, #120]	; (8001248 <RCC_Configuration+0xa8>)
 80011ce:	4798      	blx	r3

		/* Flash 2 wait state */
		FLASH_SetLatency(FLASH_Latency_2);
 80011d0:	2002      	movs	r0, #2
 80011d2:	4b1e      	ldr	r3, [pc, #120]	; (800124c <RCC_Configuration+0xac>)
 80011d4:	4798      	blx	r3

		/* HCLK = SYSCLK */

		if (initMK == 1) {
 80011d6:	4b1e      	ldr	r3, [pc, #120]	; (8001250 <RCC_Configuration+0xb0>)
 80011d8:	681b      	ldr	r3, [r3, #0]
 80011da:	2b01      	cmp	r3, #1
 80011dc:	d103      	bne.n	80011e6 <RCC_Configuration+0x46>
			RCC_HCLKConfig(RCC_SYSCLK_Div1);
 80011de:	2000      	movs	r0, #0
 80011e0:	4b1c      	ldr	r3, [pc, #112]	; (8001254 <RCC_Configuration+0xb4>)
 80011e2:	4798      	blx	r3
 80011e4:	e002      	b.n	80011ec <RCC_Configuration+0x4c>
		} else {
			RCC_HCLKConfig(RCC_SYSCLK_Div2);
 80011e6:	2080      	movs	r0, #128	; 0x80
 80011e8:	4b1a      	ldr	r3, [pc, #104]	; (8001254 <RCC_Configuration+0xb4>)
 80011ea:	4798      	blx	r3
		}

		/* PCLK2 = HCLK */
		RCC_PCLK2Config(RCC_HCLK_Div2);
 80011ec:	f44f 6080 	mov.w	r0, #1024	; 0x400
 80011f0:	4b19      	ldr	r3, [pc, #100]	; (8001258 <RCC_Configuration+0xb8>)
 80011f2:	4798      	blx	r3

		/* PCLK1 = HCLK/2 */
		RCC_PCLK1Config(RCC_HCLK_Div2);
 80011f4:	f44f 6080 	mov.w	r0, #1024	; 0x400
 80011f8:	4b18      	ldr	r3, [pc, #96]	; (800125c <RCC_Configuration+0xbc>)
 80011fa:	4798      	blx	r3

		/* PLLCLK = 16MHz * 3 = 48 MHz */
		//RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_3);
		/* PLLCLK = (16MHz * 9) /2= 72 MHz */
		RCC_PLLConfig(RCC_PLLSource_HSE_Div2, RCC_PLLMul_9);
 80011fc:	f44f 11e0 	mov.w	r1, #1835008	; 0x1c0000
 8001200:	f44f 3040 	mov.w	r0, #196608	; 0x30000
 8001204:	4b16      	ldr	r3, [pc, #88]	; (8001260 <RCC_Configuration+0xc0>)
 8001206:	4798      	blx	r3
		//RCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_2);

		/* Enable PLL */
		RCC_PLLCmd(ENABLE);
 8001208:	2001      	movs	r0, #1
 800120a:	4b16      	ldr	r3, [pc, #88]	; (8001264 <RCC_Configuration+0xc4>)
 800120c:	4798      	blx	r3

		/* Wait till PLL is ready */
		while (RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET) {
 800120e:	bf00      	nop
 8001210:	2039      	movs	r0, #57	; 0x39
 8001212:	4b15      	ldr	r3, [pc, #84]	; (8001268 <RCC_Configuration+0xc8>)
 8001214:	4798      	blx	r3
 8001216:	4603      	mov	r3, r0
 8001218:	2b00      	cmp	r3, #0
 800121a:	d0f9      	beq.n	8001210 <RCC_Configuration+0x70>
		}

		/* Select PLL as system clock source */
		RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
 800121c:	2002      	movs	r0, #2
 800121e:	4b13      	ldr	r3, [pc, #76]	; (800126c <RCC_Configuration+0xcc>)
 8001220:	4798      	blx	r3

		/* Wait till PLL is used as system clock source */
		while (RCC_GetSYSCLKSource() != 0x08) {
 8001222:	bf00      	nop
 8001224:	4b12      	ldr	r3, [pc, #72]	; (8001270 <RCC_Configuration+0xd0>)
 8001226:	4798      	blx	r3
 8001228:	4603      	mov	r3, r0
 800122a:	2b08      	cmp	r3, #8
 800122c:	d1fa      	bne.n	8001224 <RCC_Configuration+0x84>
		}



	}
}
 800122e:	bf00      	nop
 8001230:	bd80      	pop	{r7, pc}
 8001232:	bf00      	nop
 8001234:	08003069 	.word	0x08003069
 8001238:	080030c5 	.word	0x080030c5
 800123c:	080032d1 	.word	0x080032d1
 8001240:	08003121 	.word	0x08003121
 8001244:	20000658 	.word	0x20000658
 8001248:	08002b55 	.word	0x08002b55
 800124c:	08002b1d 	.word	0x08002b1d
 8001250:	20007194 	.word	0x20007194
 8001254:	08003229 	.word	0x08003229
 8001258:	08003299 	.word	0x08003299
 800125c:	08003261 	.word	0x08003261
 8001260:	08003179 	.word	0x08003179
 8001264:	080031b5 	.word	0x080031b5
 8001268:	080035ad 	.word	0x080035ad
 800126c:	080031d5 	.word	0x080031d5
 8001270:	0800320d 	.word	0x0800320d

08001274 <NVIC_Configuration>:
 *******************************************************************************/
#ifdef VECT_TAB_RAM
/* vector-offset (TBLOFF) from bottom of SRAM. defined in linker script */
extern uint32_t _isr_vectorsram_offs;
void NVIC_Configuration(void)
{
 8001274:	b580      	push	{r7, lr}
 8001276:	b082      	sub	sp, #8
 8001278:	af00      	add	r7, sp, #0
	/* Set the Vector Table base location at 0x20000000+_isr_vectorsram_offs */
	NVIC_SetVectorTable(NVIC_VectTab_RAM, (uint32_t) &_isr_vectorsram_offs);
 800127a:	4b43      	ldr	r3, [pc, #268]	; (8001388 <NVIC_Configuration+0x114>)
 800127c:	4619      	mov	r1, r3
 800127e:	f04f 5000 	mov.w	r0, #536870912	; 0x20000000
 8001282:	4b42      	ldr	r3, [pc, #264]	; (800138c <NVIC_Configuration+0x118>)
 8001284:	4798      	blx	r3
    NVIC_InitTypeDef NVIC_InitStructure;

    /* Configure one bit for preemption priority */
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4);
 8001286:	f44f 7040 	mov.w	r0, #768	; 0x300
 800128a:	4b41      	ldr	r3, [pc, #260]	; (8001390 <NVIC_Configuration+0x11c>)
 800128c:	4798      	blx	r3

    NVIC_InitStructure.NVIC_IRQChannel = I2C1_EV_IRQn;
 800128e:	231f      	movs	r3, #31
 8001290:	713b      	strb	r3, [r7, #4]
    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = -3;
 8001292:	23fd      	movs	r3, #253	; 0xfd
 8001294:	717b      	strb	r3, [r7, #5]
    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;;
 8001296:	2300      	movs	r3, #0
 8001298:	71bb      	strb	r3, [r7, #6]
    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 800129a:	2301      	movs	r3, #1
 800129c:	71fb      	strb	r3, [r7, #7]
    	NVIC_Init(&NVIC_InitStructure);
 800129e:	1d3b      	adds	r3, r7, #4
 80012a0:	4618      	mov	r0, r3
 80012a2:	4b3c      	ldr	r3, [pc, #240]	; (8001394 <NVIC_Configuration+0x120>)
 80012a4:	4798      	blx	r3

    NVIC_InitStructure.NVIC_IRQChannel = I2C1_ER_IRQn;
 80012a6:	2320      	movs	r3, #32
 80012a8:	713b      	strb	r3, [r7, #4]
    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = -3;
 80012aa:	23fd      	movs	r3, #253	; 0xfd
 80012ac:	717b      	strb	r3, [r7, #5]
    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
 80012ae:	2301      	movs	r3, #1
 80012b0:	71bb      	strb	r3, [r7, #6]
    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 80012b2:	2301      	movs	r3, #1
 80012b4:	71fb      	strb	r3, [r7, #7]
    	NVIC_Init(&NVIC_InitStructure);
 80012b6:	1d3b      	adds	r3, r7, #4
 80012b8:	4618      	mov	r0, r3
 80012ba:	4b36      	ldr	r3, [pc, #216]	; (8001394 <NVIC_Configuration+0x120>)
 80012bc:	4798      	blx	r3


    NVIC_InitStructure.NVIC_IRQChannel = USART3_IRQn;
 80012be:	2327      	movs	r3, #39	; 0x27
 80012c0:	713b      	strb	r3, [r7, #4]
    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;//5//2
 80012c2:	2301      	movs	r3, #1
 80012c4:	717b      	strb	r3, [r7, #5]
    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
 80012c6:	2300      	movs	r3, #0
 80012c8:	71bb      	strb	r3, [r7, #6]
    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 80012ca:	2301      	movs	r3, #1
 80012cc:	71fb      	strb	r3, [r7, #7]
    	NVIC_Init(&NVIC_InitStructure);
 80012ce:	1d3b      	adds	r3, r7, #4
 80012d0:	4618      	mov	r0, r3
 80012d2:	4b30      	ldr	r3, [pc, #192]	; (8001394 <NVIC_Configuration+0x120>)
 80012d4:	4798      	blx	r3

	NVIC_InitStructure.NVIC_IRQChannel = UART4_IRQn;
 80012d6:	2334      	movs	r3, #52	; 0x34
 80012d8:	713b      	strb	r3, [r7, #4]
		NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 5;
 80012da:	2305      	movs	r3, #5
 80012dc:	717b      	strb	r3, [r7, #5]
		NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
 80012de:	2300      	movs	r3, #0
 80012e0:	71bb      	strb	r3, [r7, #6]
		NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 80012e2:	2301      	movs	r3, #1
 80012e4:	71fb      	strb	r3, [r7, #7]
		NVIC_Init(&NVIC_InitStructure);
 80012e6:	1d3b      	adds	r3, r7, #4
 80012e8:	4618      	mov	r0, r3
 80012ea:	4b2a      	ldr	r3, [pc, #168]	; (8001394 <NVIC_Configuration+0x120>)
 80012ec:	4798      	blx	r3

    NVIC_InitStructure.NVIC_IRQChannel = TIM5_IRQn;
 80012ee:	2332      	movs	r3, #50	; 0x32
 80012f0:	713b      	strb	r3, [r7, #4]
        NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
 80012f2:	2302      	movs	r3, #2
 80012f4:	717b      	strb	r3, [r7, #5]
        NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
 80012f6:	2300      	movs	r3, #0
 80012f8:	71bb      	strb	r3, [r7, #6]
        NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 80012fa:	2301      	movs	r3, #1
 80012fc:	71fb      	strb	r3, [r7, #7]
        NVIC_Init(&NVIC_InitStructure);
 80012fe:	1d3b      	adds	r3, r7, #4
 8001300:	4618      	mov	r0, r3
 8001302:	4b24      	ldr	r3, [pc, #144]	; (8001394 <NVIC_Configuration+0x120>)
 8001304:	4798      	blx	r3

    NVIC_InitStructure.NVIC_IRQChannel = DMA1_Channel2_IRQn;
 8001306:	230c      	movs	r3, #12
 8001308:	713b      	strb	r3, [r7, #4]
        NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 7;
 800130a:	2307      	movs	r3, #7
 800130c:	717b      	strb	r3, [r7, #5]
        NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
 800130e:	2300      	movs	r3, #0
 8001310:	71bb      	strb	r3, [r7, #6]
        NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 8001312:	2301      	movs	r3, #1
 8001314:	71fb      	strb	r3, [r7, #7]
        NVIC_Init(&NVIC_InitStructure);
 8001316:	1d3b      	adds	r3, r7, #4
 8001318:	4618      	mov	r0, r3
 800131a:	4b1e      	ldr	r3, [pc, #120]	; (8001394 <NVIC_Configuration+0x120>)
 800131c:	4798      	blx	r3

	NVIC_InitStructure.NVIC_IRQChannel = DMA1_Channel3_IRQn;
 800131e:	230d      	movs	r3, #13
 8001320:	713b      	strb	r3, [r7, #4]
	   NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 4;
 8001322:	2304      	movs	r3, #4
 8001324:	717b      	strb	r3, [r7, #5]
	   NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
 8001326:	2300      	movs	r3, #0
 8001328:	71bb      	strb	r3, [r7, #6]
	   NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 800132a:	2301      	movs	r3, #1
 800132c:	71fb      	strb	r3, [r7, #7]
	   NVIC_Init(&NVIC_InitStructure);
 800132e:	1d3b      	adds	r3, r7, #4
 8001330:	4618      	mov	r0, r3
 8001332:	4b18      	ldr	r3, [pc, #96]	; (8001394 <NVIC_Configuration+0x120>)
 8001334:	4798      	blx	r3

   NVIC_InitStructure.NVIC_IRQChannel = DMA2_Channel5_IRQn;
 8001336:	233b      	movs	r3, #59	; 0x3b
 8001338:	713b      	strb	r3, [r7, #4]
	   NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 6;
 800133a:	2306      	movs	r3, #6
 800133c:	717b      	strb	r3, [r7, #5]
	   NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
 800133e:	2300      	movs	r3, #0
 8001340:	71bb      	strb	r3, [r7, #6]
	   NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 8001342:	2301      	movs	r3, #1
 8001344:	71fb      	strb	r3, [r7, #7]
	   NVIC_Init(&NVIC_InitStructure);
 8001346:	1d3b      	adds	r3, r7, #4
 8001348:	4618      	mov	r0, r3
 800134a:	4b12      	ldr	r3, [pc, #72]	; (8001394 <NVIC_Configuration+0x120>)
 800134c:	4798      	blx	r3

	NVIC_InitStructure.NVIC_IRQChannel = DMA2_Channel3_IRQn;
 800134e:	233a      	movs	r3, #58	; 0x3a
 8001350:	713b      	strb	r3, [r7, #4]
	   NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 3;
 8001352:	2303      	movs	r3, #3
 8001354:	717b      	strb	r3, [r7, #5]
	   NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
 8001356:	2300      	movs	r3, #0
 8001358:	71bb      	strb	r3, [r7, #6]
	   NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 800135a:	2301      	movs	r3, #1
 800135c:	71fb      	strb	r3, [r7, #7]
	   NVIC_Init(&NVIC_InitStructure);
 800135e:	1d3b      	adds	r3, r7, #4
 8001360:	4618      	mov	r0, r3
 8001362:	4b0c      	ldr	r3, [pc, #48]	; (8001394 <NVIC_Configuration+0x120>)
 8001364:	4798      	blx	r3

	NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn;
 8001366:	231d      	movs	r3, #29
 8001368:	713b      	strb	r3, [r7, #4]
	   NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
 800136a:	2301      	movs	r3, #1
 800136c:	717b      	strb	r3, [r7, #5]
	   NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
 800136e:	2300      	movs	r3, #0
 8001370:	71bb      	strb	r3, [r7, #6]
	   NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
 8001372:	2301      	movs	r3, #1
 8001374:	71fb      	strb	r3, [r7, #7]
	   NVIC_Init(&NVIC_InitStructure);
 8001376:	1d3b      	adds	r3, r7, #4
 8001378:	4618      	mov	r0, r3
 800137a:	4b06      	ldr	r3, [pc, #24]	; (8001394 <NVIC_Configuration+0x120>)
 800137c:	4798      	blx	r3
    //----------------------------------------------------
}
 800137e:	bf00      	nop
 8001380:	3708      	adds	r7, #8
 8001382:	46bd      	mov	sp, r7
 8001384:	bd80      	pop	{r7, pc}
 8001386:	bf00      	nop
 8001388:	00000000 	.word	0x00000000
 800138c:	080041c1 	.word	0x080041c1
 8001390:	080040d9 	.word	0x080040d9
 8001394:	080040fd 	.word	0x080040fd

08001398 <hwInit>:
	}
#endif
}
#endif

void hwInit() {
 8001398:	b580      	push	{r7, lr}
 800139a:	af00      	add	r7, sp, #0
	GPIO_SetBits(GPIO_LEDWORK, LEDWORK);
 800139c:	2180      	movs	r1, #128	; 0x80
 800139e:	4804      	ldr	r0, [pc, #16]	; (80013b0 <hwInit+0x18>)
 80013a0:	4b04      	ldr	r3, [pc, #16]	; (80013b4 <hwInit+0x1c>)
 80013a2:	4798      	blx	r3
	/* System Clocks Configuration */
	RCC_Configuration();
 80013a4:	4b04      	ldr	r3, [pc, #16]	; (80013b8 <hwInit+0x20>)
 80013a6:	4798      	blx	r3
	/* NVIC configuration */
	NVIC_Configuration();
 80013a8:	4b04      	ldr	r3, [pc, #16]	; (80013bc <hwInit+0x24>)
 80013aa:	4798      	blx	r3
}
 80013ac:	bf00      	nop
 80013ae:	bd80      	pop	{r7, pc}
 80013b0:	40010800 	.word	0x40010800
 80013b4:	08002f6d 	.word	0x08002f6d
 80013b8:	080011a1 	.word	0x080011a1
 80013bc:	08001275 	.word	0x08001275

080013c0 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
 80013c0:	b590      	push	{r4, r7, lr}
 80013c2:	b08b      	sub	sp, #44	; 0x2c
 80013c4:	af02      	add	r7, sp, #8
 80013c6:	60f8      	str	r0, [r7, #12]
 80013c8:	60b9      	str	r1, [r7, #8]
 80013ca:	603b      	str	r3, [r7, #0]
 80013cc:	4613      	mov	r3, r2
 80013ce:	80fb      	strh	r3, [r7, #6]
signed portBASE_TYPE xReturn;
tskTCB * pxNewTCB;

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
 80013d0:	88fb      	ldrh	r3, [r7, #6]
 80013d2:	6bb9      	ldr	r1, [r7, #56]	; 0x38
 80013d4:	4618      	mov	r0, r3
 80013d6:	4b45      	ldr	r3, [pc, #276]	; (80014ec <xTaskGenericCreate+0x12c>)
 80013d8:	4798      	blx	r3
 80013da:	61b8      	str	r0, [r7, #24]

	if( pxNewTCB != NULL )
 80013dc:	69bb      	ldr	r3, [r7, #24]
 80013de:	2b00      	cmp	r3, #0
 80013e0:	d066      	beq.n	80014b0 <xTaskGenericCreate+0xf0>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
 80013e2:	69bb      	ldr	r3, [r7, #24]
 80013e4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80013e6:	88fb      	ldrh	r3, [r7, #6]
 80013e8:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 80013ec:	3b01      	subs	r3, #1
 80013ee:	009b      	lsls	r3, r3, #2
 80013f0:	4413      	add	r3, r2
 80013f2:	617b      	str	r3, [r7, #20]
			pxTopOfStack = ( portSTACK_TYPE * ) ( ( ( unsigned long ) pxTopOfStack ) & ( ( unsigned long ) ~portBYTE_ALIGNMENT_MASK  ) );
 80013f4:	697b      	ldr	r3, [r7, #20]
 80013f6:	f023 0307 	bic.w	r3, r3, #7
 80013fa:	617b      	str	r3, [r7, #20]
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
 80013fc:	88fb      	ldrh	r3, [r7, #6]
 80013fe:	9300      	str	r3, [sp, #0]
 8001400:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
 8001402:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 8001404:	68b9      	ldr	r1, [r7, #8]
 8001406:	69b8      	ldr	r0, [r7, #24]
 8001408:	4c39      	ldr	r4, [pc, #228]	; (80014f0 <xTaskGenericCreate+0x130>)
 800140a:	47a0      	blx	r4
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 800140c:	683a      	ldr	r2, [r7, #0]
 800140e:	68f9      	ldr	r1, [r7, #12]
 8001410:	6978      	ldr	r0, [r7, #20]
 8001412:	4b38      	ldr	r3, [pc, #224]	; (80014f4 <xTaskGenericCreate+0x134>)
 8001414:	4798      	blx	r3
 8001416:	4602      	mov	r2, r0
 8001418:	69bb      	ldr	r3, [r7, #24]
 800141a:	601a      	str	r2, [r3, #0]
		}
		#endif

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		portENTER_CRITICAL();
 800141c:	4b36      	ldr	r3, [pc, #216]	; (80014f8 <xTaskGenericCreate+0x138>)
 800141e:	4798      	blx	r3
		{
			uxCurrentNumberOfTasks++;
 8001420:	4b36      	ldr	r3, [pc, #216]	; (80014fc <xTaskGenericCreate+0x13c>)
 8001422:	681b      	ldr	r3, [r3, #0]
 8001424:	3301      	adds	r3, #1
 8001426:	4a35      	ldr	r2, [pc, #212]	; (80014fc <xTaskGenericCreate+0x13c>)
 8001428:	6013      	str	r3, [r2, #0]
			if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
 800142a:	4b34      	ldr	r3, [pc, #208]	; (80014fc <xTaskGenericCreate+0x13c>)
 800142c:	681b      	ldr	r3, [r3, #0]
 800142e:	2b01      	cmp	r3, #1
 8001430:	d105      	bne.n	800143e <xTaskGenericCreate+0x7e>
			{
				/* As this is the first task it must also be the current task. */
				pxCurrentTCB =  pxNewTCB;
 8001432:	4a33      	ldr	r2, [pc, #204]	; (8001500 <xTaskGenericCreate+0x140>)
 8001434:	69bb      	ldr	r3, [r7, #24]
 8001436:	6013      	str	r3, [r2, #0]

				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
 8001438:	4b32      	ldr	r3, [pc, #200]	; (8001504 <xTaskGenericCreate+0x144>)
 800143a:	4798      	blx	r3
 800143c:	e00c      	b.n	8001458 <xTaskGenericCreate+0x98>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
 800143e:	4b32      	ldr	r3, [pc, #200]	; (8001508 <xTaskGenericCreate+0x148>)
 8001440:	681b      	ldr	r3, [r3, #0]
 8001442:	2b00      	cmp	r3, #0
 8001444:	d108      	bne.n	8001458 <xTaskGenericCreate+0x98>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
 8001446:	4b2e      	ldr	r3, [pc, #184]	; (8001500 <xTaskGenericCreate+0x140>)
 8001448:	681b      	ldr	r3, [r3, #0]
 800144a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800144c:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 800144e:	429a      	cmp	r2, r3
 8001450:	d302      	bcc.n	8001458 <xTaskGenericCreate+0x98>
					{
						pxCurrentTCB = pxNewTCB;
 8001452:	4a2b      	ldr	r2, [pc, #172]	; (8001500 <xTaskGenericCreate+0x140>)
 8001454:	69bb      	ldr	r3, [r7, #24]
 8001456:	6013      	str	r3, [r2, #0]
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
 8001458:	69bb      	ldr	r3, [r7, #24]
 800145a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800145c:	4b2b      	ldr	r3, [pc, #172]	; (800150c <xTaskGenericCreate+0x14c>)
 800145e:	681b      	ldr	r3, [r3, #0]
 8001460:	429a      	cmp	r2, r3
 8001462:	d903      	bls.n	800146c <xTaskGenericCreate+0xac>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
 8001464:	69bb      	ldr	r3, [r7, #24]
 8001466:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001468:	4a28      	ldr	r2, [pc, #160]	; (800150c <xTaskGenericCreate+0x14c>)
 800146a:	6013      	str	r3, [r2, #0]
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
 800146c:	4b28      	ldr	r3, [pc, #160]	; (8001510 <xTaskGenericCreate+0x150>)
 800146e:	681b      	ldr	r3, [r3, #0]
 8001470:	3301      	adds	r3, #1
 8001472:	4a27      	ldr	r2, [pc, #156]	; (8001510 <xTaskGenericCreate+0x150>)
 8001474:	6013      	str	r3, [r2, #0]

			prvAddTaskToReadyQueue( pxNewTCB );
 8001476:	69bb      	ldr	r3, [r7, #24]
 8001478:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800147a:	4b26      	ldr	r3, [pc, #152]	; (8001514 <xTaskGenericCreate+0x154>)
 800147c:	681b      	ldr	r3, [r3, #0]
 800147e:	429a      	cmp	r2, r3
 8001480:	d903      	bls.n	800148a <xTaskGenericCreate+0xca>
 8001482:	69bb      	ldr	r3, [r7, #24]
 8001484:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001486:	4a23      	ldr	r2, [pc, #140]	; (8001514 <xTaskGenericCreate+0x154>)
 8001488:	6013      	str	r3, [r2, #0]
 800148a:	69bb      	ldr	r3, [r7, #24]
 800148c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 800148e:	4613      	mov	r3, r2
 8001490:	009b      	lsls	r3, r3, #2
 8001492:	4413      	add	r3, r2
 8001494:	009b      	lsls	r3, r3, #2
 8001496:	4a20      	ldr	r2, [pc, #128]	; (8001518 <xTaskGenericCreate+0x158>)
 8001498:	441a      	add	r2, r3
 800149a:	69bb      	ldr	r3, [r7, #24]
 800149c:	3304      	adds	r3, #4
 800149e:	4619      	mov	r1, r3
 80014a0:	4610      	mov	r0, r2
 80014a2:	4b1e      	ldr	r3, [pc, #120]	; (800151c <xTaskGenericCreate+0x15c>)
 80014a4:	4798      	blx	r3

			xReturn = pdPASS;
 80014a6:	2301      	movs	r3, #1
 80014a8:	61fb      	str	r3, [r7, #28]
			traceTASK_CREATE( pxNewTCB );
		}
		portEXIT_CRITICAL();
 80014aa:	4b1d      	ldr	r3, [pc, #116]	; (8001520 <xTaskGenericCreate+0x160>)
 80014ac:	4798      	blx	r3
 80014ae:	e002      	b.n	80014b6 <xTaskGenericCreate+0xf6>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 80014b0:	f04f 33ff 	mov.w	r3, #4294967295
 80014b4:	61fb      	str	r3, [r7, #28]
		traceTASK_CREATE_FAILED( pxNewTCB );
	}

	if( xReturn == pdPASS )
 80014b6:	69fb      	ldr	r3, [r7, #28]
 80014b8:	2b01      	cmp	r3, #1
 80014ba:	d111      	bne.n	80014e0 <xTaskGenericCreate+0x120>
	{
		if( ( void * ) pxCreatedTask != NULL )
 80014bc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80014be:	2b00      	cmp	r3, #0
 80014c0:	d002      	beq.n	80014c8 <xTaskGenericCreate+0x108>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
 80014c2:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80014c4:	69ba      	ldr	r2, [r7, #24]
 80014c6:	601a      	str	r2, [r3, #0]
		}

		if( xSchedulerRunning != pdFALSE )
 80014c8:	4b0f      	ldr	r3, [pc, #60]	; (8001508 <xTaskGenericCreate+0x148>)
 80014ca:	681b      	ldr	r3, [r3, #0]
 80014cc:	2b00      	cmp	r3, #0
 80014ce:	d007      	beq.n	80014e0 <xTaskGenericCreate+0x120>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
 80014d0:	4b0b      	ldr	r3, [pc, #44]	; (8001500 <xTaskGenericCreate+0x140>)
 80014d2:	681b      	ldr	r3, [r3, #0]
 80014d4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80014d6:	6b3a      	ldr	r2, [r7, #48]	; 0x30
 80014d8:	429a      	cmp	r2, r3
 80014da:	d901      	bls.n	80014e0 <xTaskGenericCreate+0x120>
			{
				portYIELD_WITHIN_API();
 80014dc:	4b11      	ldr	r3, [pc, #68]	; (8001524 <xTaskGenericCreate+0x164>)
 80014de:	4798      	blx	r3
			}
		}
	}

	return xReturn;
 80014e0:	69fb      	ldr	r3, [r7, #28]
}
 80014e2:	4618      	mov	r0, r3
 80014e4:	3724      	adds	r7, #36	; 0x24
 80014e6:	46bd      	mov	sp, r7
 80014e8:	bd90      	pop	{r4, r7, pc}
 80014ea:	bf00      	nop
 80014ec:	08001ce5 	.word	0x08001ce5
 80014f0:	08001b51 	.word	0x08001b51
 80014f4:	08002517 	.word	0x08002517
 80014f8:	080025f9 	.word	0x080025f9
 80014fc:	20000798 	.word	0x20000798
 8001500:	2000065c 	.word	0x2000065c
 8001504:	08001bc5 	.word	0x08001bc5
 8001508:	200007a8 	.word	0x200007a8
 800150c:	200007a0 	.word	0x200007a0
 8001510:	200007bc 	.word	0x200007bc
 8001514:	200007a4 	.word	0x200007a4
 8001518:	20000660 	.word	0x20000660
 800151c:	0800240b 	.word	0x0800240b
 8001520:	0800261d 	.word	0x0800261d
 8001524:	080025e1 	.word	0x080025e1

08001528 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
 8001528:	b580      	push	{r7, lr}
 800152a:	b084      	sub	sp, #16
 800152c:	af00      	add	r7, sp, #0
 800152e:	6078      	str	r0, [r7, #4]
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 8001530:	2300      	movs	r3, #0
 8001532:	60fb      	str	r3, [r7, #12]

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0 )
 8001534:	687b      	ldr	r3, [r7, #4]
 8001536:	2b00      	cmp	r3, #0
 8001538:	d02b      	beq.n	8001592 <vTaskDelay+0x6a>
		{
			vTaskSuspendAll();
 800153a:	4b1a      	ldr	r3, [pc, #104]	; (80015a4 <vTaskDelay+0x7c>)
 800153c:	4798      	blx	r3
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
 800153e:	4b1a      	ldr	r3, [pc, #104]	; (80015a8 <vTaskDelay+0x80>)
 8001540:	681b      	ldr	r3, [r3, #0]
 8001542:	687a      	ldr	r2, [r7, #4]
 8001544:	4413      	add	r3, r2
 8001546:	60bb      	str	r3, [r7, #8]

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 8001548:	4b18      	ldr	r3, [pc, #96]	; (80015ac <vTaskDelay+0x84>)
 800154a:	681b      	ldr	r3, [r3, #0]
 800154c:	3304      	adds	r3, #4
 800154e:	4618      	mov	r0, r3
 8001550:	4b17      	ldr	r3, [pc, #92]	; (80015b0 <vTaskDelay+0x88>)
 8001552:	4798      	blx	r3

				/* The list item will be inserted in wake time order. */
				listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 8001554:	4b15      	ldr	r3, [pc, #84]	; (80015ac <vTaskDelay+0x84>)
 8001556:	681b      	ldr	r3, [r3, #0]
 8001558:	68ba      	ldr	r2, [r7, #8]
 800155a:	605a      	str	r2, [r3, #4]

				if( xTimeToWake < xTickCount )
 800155c:	4b12      	ldr	r3, [pc, #72]	; (80015a8 <vTaskDelay+0x80>)
 800155e:	681b      	ldr	r3, [r3, #0]
 8001560:	68ba      	ldr	r2, [r7, #8]
 8001562:	429a      	cmp	r2, r3
 8001564:	d209      	bcs.n	800157a <vTaskDelay+0x52>
				{
					/* Wake time has overflowed.  Place this item in the
					overflow list. */
					vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 8001566:	4b13      	ldr	r3, [pc, #76]	; (80015b4 <vTaskDelay+0x8c>)
 8001568:	681a      	ldr	r2, [r3, #0]
 800156a:	4b10      	ldr	r3, [pc, #64]	; (80015ac <vTaskDelay+0x84>)
 800156c:	681b      	ldr	r3, [r3, #0]
 800156e:	3304      	adds	r3, #4
 8001570:	4619      	mov	r1, r3
 8001572:	4610      	mov	r0, r2
 8001574:	4b10      	ldr	r3, [pc, #64]	; (80015b8 <vTaskDelay+0x90>)
 8001576:	4798      	blx	r3
 8001578:	e008      	b.n	800158c <vTaskDelay+0x64>
				}
				else
				{
					/* The wake time has not overflowed, so we can use the
					current block list. */
					vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 800157a:	4b10      	ldr	r3, [pc, #64]	; (80015bc <vTaskDelay+0x94>)
 800157c:	681a      	ldr	r2, [r3, #0]
 800157e:	4b0b      	ldr	r3, [pc, #44]	; (80015ac <vTaskDelay+0x84>)
 8001580:	681b      	ldr	r3, [r3, #0]
 8001582:	3304      	adds	r3, #4
 8001584:	4619      	mov	r1, r3
 8001586:	4610      	mov	r0, r2
 8001588:	4b0b      	ldr	r3, [pc, #44]	; (80015b8 <vTaskDelay+0x90>)
 800158a:	4798      	blx	r3
				}
			}
			xAlreadyYielded = xTaskResumeAll();
 800158c:	4b0c      	ldr	r3, [pc, #48]	; (80015c0 <vTaskDelay+0x98>)
 800158e:	4798      	blx	r3
 8001590:	60f8      	str	r0, [r7, #12]
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( !xAlreadyYielded )
 8001592:	68fb      	ldr	r3, [r7, #12]
 8001594:	2b00      	cmp	r3, #0
 8001596:	d101      	bne.n	800159c <vTaskDelay+0x74>
		{
			portYIELD_WITHIN_API();
 8001598:	4b0a      	ldr	r3, [pc, #40]	; (80015c4 <vTaskDelay+0x9c>)
 800159a:	4798      	blx	r3
		}
	}
 800159c:	bf00      	nop
 800159e:	3710      	adds	r7, #16
 80015a0:	46bd      	mov	sp, r7
 80015a2:	bd80      	pop	{r7, pc}
 80015a4:	0800162d 	.word	0x0800162d
 80015a8:	2000079c 	.word	0x2000079c
 80015ac:	2000065c 	.word	0x2000065c
 80015b0:	080024c9 	.word	0x080024c9
 80015b4:	20000754 	.word	0x20000754
 80015b8:	08002459 	.word	0x08002459
 80015bc:	20000750 	.word	0x20000750
 80015c0:	08001649 	.word	0x08001649
 80015c4:	080025e1 	.word	0x080025e1

080015c8 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
 80015c8:	b590      	push	{r4, r7, lr}
 80015ca:	b087      	sub	sp, #28
 80015cc:	af04      	add	r7, sp, #16
portBASE_TYPE xReturn;

	/* Add the idle task at the lowest priority. */
	xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), ( xTaskHandle * ) NULL );
 80015ce:	2300      	movs	r3, #0
 80015d0:	9303      	str	r3, [sp, #12]
 80015d2:	2300      	movs	r3, #0
 80015d4:	9302      	str	r3, [sp, #8]
 80015d6:	2300      	movs	r3, #0
 80015d8:	9301      	str	r3, [sp, #4]
 80015da:	2300      	movs	r3, #0
 80015dc:	9300      	str	r3, [sp, #0]
 80015de:	2300      	movs	r3, #0
 80015e0:	2280      	movs	r2, #128	; 0x80
 80015e2:	490c      	ldr	r1, [pc, #48]	; (8001614 <vTaskStartScheduler+0x4c>)
 80015e4:	480c      	ldr	r0, [pc, #48]	; (8001618 <vTaskStartScheduler+0x50>)
 80015e6:	4c0d      	ldr	r4, [pc, #52]	; (800161c <vTaskStartScheduler+0x54>)
 80015e8:	47a0      	blx	r4
 80015ea:	6078      	str	r0, [r7, #4]

	if( xReturn == pdPASS )
 80015ec:	687b      	ldr	r3, [r7, #4]
 80015ee:	2b01      	cmp	r3, #1
 80015f0:	d10b      	bne.n	800160a <vTaskStartScheduler+0x42>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
 80015f2:	f04f 00bf 	mov.w	r0, #191	; 0xbf
 80015f6:	f380 8811 	msr	BASEPRI, r0

		xSchedulerRunning = pdTRUE;
 80015fa:	4b09      	ldr	r3, [pc, #36]	; (8001620 <vTaskStartScheduler+0x58>)
 80015fc:	2201      	movs	r2, #1
 80015fe:	601a      	str	r2, [r3, #0]
		xTickCount = ( portTickType ) 0;
 8001600:	4b08      	ldr	r3, [pc, #32]	; (8001624 <vTaskStartScheduler+0x5c>)
 8001602:	2200      	movs	r2, #0
 8001604:	601a      	str	r2, [r3, #0]
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() )
 8001606:	4b08      	ldr	r3, [pc, #32]	; (8001628 <vTaskStartScheduler+0x60>)
 8001608:	4798      	blx	r3
		else
		{
			/* Should only reach here if a task calls xTaskEndScheduler(). */
		}
	}
}
 800160a:	bf00      	nop
 800160c:	370c      	adds	r7, #12
 800160e:	46bd      	mov	sp, r7
 8001610:	bd90      	pop	{r4, r7, pc}
 8001612:	bf00      	nop
 8001614:	08014940 	.word	0x08014940
 8001618:	08001b21 	.word	0x08001b21
 800161c:	080013c1 	.word	0x080013c1
 8001620:	200007a8 	.word	0x200007a8
 8001624:	2000079c 	.word	0x2000079c
 8001628:	080025a1 	.word	0x080025a1

0800162c <vTaskSuspendAll>:
	vPortEndScheduler();
}
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
 800162c:	b480      	push	{r7}
 800162e:	af00      	add	r7, sp, #0
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
 8001630:	4b04      	ldr	r3, [pc, #16]	; (8001644 <vTaskSuspendAll+0x18>)
 8001632:	681b      	ldr	r3, [r3, #0]
 8001634:	3301      	adds	r3, #1
 8001636:	4a03      	ldr	r2, [pc, #12]	; (8001644 <vTaskSuspendAll+0x18>)
 8001638:	6013      	str	r3, [r2, #0]
}
 800163a:	bf00      	nop
 800163c:	46bd      	mov	sp, r7
 800163e:	bc80      	pop	{r7}
 8001640:	4770      	bx	lr
 8001642:	bf00      	nop
 8001644:	200007ac 	.word	0x200007ac

08001648 <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
 8001648:	b590      	push	{r4, r7, lr}
 800164a:	b083      	sub	sp, #12
 800164c:	af00      	add	r7, sp, #0
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
 800164e:	2300      	movs	r3, #0
 8001650:	607b      	str	r3, [r7, #4]
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	portENTER_CRITICAL();
 8001652:	4b35      	ldr	r3, [pc, #212]	; (8001728 <xTaskResumeAll+0xe0>)
 8001654:	4798      	blx	r3
	{
		--uxSchedulerSuspended;
 8001656:	4b35      	ldr	r3, [pc, #212]	; (800172c <xTaskResumeAll+0xe4>)
 8001658:	681b      	ldr	r3, [r3, #0]
 800165a:	3b01      	subs	r3, #1
 800165c:	4a33      	ldr	r2, [pc, #204]	; (800172c <xTaskResumeAll+0xe4>)
 800165e:	6013      	str	r3, [r2, #0]

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 8001660:	4b32      	ldr	r3, [pc, #200]	; (800172c <xTaskResumeAll+0xe4>)
 8001662:	681b      	ldr	r3, [r3, #0]
 8001664:	2b00      	cmp	r3, #0
 8001666:	d157      	bne.n	8001718 <xTaskResumeAll+0xd0>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
 8001668:	4b31      	ldr	r3, [pc, #196]	; (8001730 <xTaskResumeAll+0xe8>)
 800166a:	681b      	ldr	r3, [r3, #0]
 800166c:	2b00      	cmp	r3, #0
 800166e:	d053      	beq.n	8001718 <xTaskResumeAll+0xd0>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
 8001670:	2300      	movs	r3, #0
 8001672:	603b      	str	r3, [r7, #0]

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
 8001674:	e024      	b.n	80016c0 <xTaskResumeAll+0x78>
				{
					vListRemove( &( pxTCB->xEventListItem ) );
 8001676:	f104 0318 	add.w	r3, r4, #24
 800167a:	4618      	mov	r0, r3
 800167c:	4b2d      	ldr	r3, [pc, #180]	; (8001734 <xTaskResumeAll+0xec>)
 800167e:	4798      	blx	r3
					vListRemove( &( pxTCB->xGenericListItem ) );
 8001680:	1d23      	adds	r3, r4, #4
 8001682:	4618      	mov	r0, r3
 8001684:	4b2b      	ldr	r3, [pc, #172]	; (8001734 <xTaskResumeAll+0xec>)
 8001686:	4798      	blx	r3
					prvAddTaskToReadyQueue( pxTCB );
 8001688:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800168a:	4b2b      	ldr	r3, [pc, #172]	; (8001738 <xTaskResumeAll+0xf0>)
 800168c:	681b      	ldr	r3, [r3, #0]
 800168e:	429a      	cmp	r2, r3
 8001690:	d902      	bls.n	8001698 <xTaskResumeAll+0x50>
 8001692:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8001694:	4a28      	ldr	r2, [pc, #160]	; (8001738 <xTaskResumeAll+0xf0>)
 8001696:	6013      	str	r3, [r2, #0]
 8001698:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800169a:	4613      	mov	r3, r2
 800169c:	009b      	lsls	r3, r3, #2
 800169e:	4413      	add	r3, r2
 80016a0:	009b      	lsls	r3, r3, #2
 80016a2:	4a26      	ldr	r2, [pc, #152]	; (800173c <xTaskResumeAll+0xf4>)
 80016a4:	4413      	add	r3, r2
 80016a6:	1d22      	adds	r2, r4, #4
 80016a8:	4611      	mov	r1, r2
 80016aa:	4618      	mov	r0, r3
 80016ac:	4b24      	ldr	r3, [pc, #144]	; (8001740 <xTaskResumeAll+0xf8>)
 80016ae:	4798      	blx	r3

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 80016b0:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 80016b2:	4b24      	ldr	r3, [pc, #144]	; (8001744 <xTaskResumeAll+0xfc>)
 80016b4:	681b      	ldr	r3, [r3, #0]
 80016b6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80016b8:	429a      	cmp	r2, r3
 80016ba:	d301      	bcc.n	80016c0 <xTaskResumeAll+0x78>
					{
						xYieldRequired = pdTRUE;
 80016bc:	2301      	movs	r3, #1
 80016be:	603b      	str	r3, [r7, #0]
				while( ( pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) ) ) != NULL )
 80016c0:	4b21      	ldr	r3, [pc, #132]	; (8001748 <xTaskResumeAll+0x100>)
 80016c2:	681b      	ldr	r3, [r3, #0]
 80016c4:	2b00      	cmp	r3, #0
 80016c6:	d003      	beq.n	80016d0 <xTaskResumeAll+0x88>
 80016c8:	4b1f      	ldr	r3, [pc, #124]	; (8001748 <xTaskResumeAll+0x100>)
 80016ca:	68db      	ldr	r3, [r3, #12]
 80016cc:	68db      	ldr	r3, [r3, #12]
 80016ce:	e000      	b.n	80016d2 <xTaskResumeAll+0x8a>
 80016d0:	2300      	movs	r3, #0
 80016d2:	461c      	mov	r4, r3
 80016d4:	2c00      	cmp	r4, #0
 80016d6:	d1ce      	bne.n	8001676 <xTaskResumeAll+0x2e>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
 80016d8:	4b1c      	ldr	r3, [pc, #112]	; (800174c <xTaskResumeAll+0x104>)
 80016da:	681b      	ldr	r3, [r3, #0]
 80016dc:	2b00      	cmp	r3, #0
 80016de:	d00d      	beq.n	80016fc <xTaskResumeAll+0xb4>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
 80016e0:	e006      	b.n	80016f0 <xTaskResumeAll+0xa8>
					{
						vTaskIncrementTick();
 80016e2:	4b1b      	ldr	r3, [pc, #108]	; (8001750 <xTaskResumeAll+0x108>)
 80016e4:	4798      	blx	r3
						--uxMissedTicks;
 80016e6:	4b19      	ldr	r3, [pc, #100]	; (800174c <xTaskResumeAll+0x104>)
 80016e8:	681b      	ldr	r3, [r3, #0]
 80016ea:	3b01      	subs	r3, #1
 80016ec:	4a17      	ldr	r2, [pc, #92]	; (800174c <xTaskResumeAll+0x104>)
 80016ee:	6013      	str	r3, [r2, #0]
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
 80016f0:	4b16      	ldr	r3, [pc, #88]	; (800174c <xTaskResumeAll+0x104>)
 80016f2:	681b      	ldr	r3, [r3, #0]
 80016f4:	2b00      	cmp	r3, #0
 80016f6:	d1f4      	bne.n	80016e2 <xTaskResumeAll+0x9a>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
 80016f8:	2301      	movs	r3, #1
 80016fa:	603b      	str	r3, [r7, #0]
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
 80016fc:	683b      	ldr	r3, [r7, #0]
 80016fe:	2b01      	cmp	r3, #1
 8001700:	d003      	beq.n	800170a <xTaskResumeAll+0xc2>
 8001702:	4b14      	ldr	r3, [pc, #80]	; (8001754 <xTaskResumeAll+0x10c>)
 8001704:	681b      	ldr	r3, [r3, #0]
 8001706:	2b01      	cmp	r3, #1
 8001708:	d106      	bne.n	8001718 <xTaskResumeAll+0xd0>
				{
					xAlreadyYielded = pdTRUE;
 800170a:	2301      	movs	r3, #1
 800170c:	607b      	str	r3, [r7, #4]
					xMissedYield = pdFALSE;
 800170e:	4b11      	ldr	r3, [pc, #68]	; (8001754 <xTaskResumeAll+0x10c>)
 8001710:	2200      	movs	r2, #0
 8001712:	601a      	str	r2, [r3, #0]
					portYIELD_WITHIN_API();
 8001714:	4b10      	ldr	r3, [pc, #64]	; (8001758 <xTaskResumeAll+0x110>)
 8001716:	4798      	blx	r3
				}
			}
		}
	}
	portEXIT_CRITICAL();
 8001718:	4b10      	ldr	r3, [pc, #64]	; (800175c <xTaskResumeAll+0x114>)
 800171a:	4798      	blx	r3

	return xAlreadyYielded;
 800171c:	687b      	ldr	r3, [r7, #4]
}
 800171e:	4618      	mov	r0, r3
 8001720:	370c      	adds	r7, #12
 8001722:	46bd      	mov	sp, r7
 8001724:	bd90      	pop	{r4, r7, pc}
 8001726:	bf00      	nop
 8001728:	080025f9 	.word	0x080025f9
 800172c:	200007ac 	.word	0x200007ac
 8001730:	20000798 	.word	0x20000798
 8001734:	080024c9 	.word	0x080024c9
 8001738:	200007a4 	.word	0x200007a4
 800173c:	20000660 	.word	0x20000660
 8001740:	0800240b 	.word	0x0800240b
 8001744:	2000065c 	.word	0x2000065c
 8001748:	20000758 	.word	0x20000758
 800174c:	200007b0 	.word	0x200007b0
 8001750:	08001761 	.word	0x08001761
 8001754:	200007b4 	.word	0x200007b4
 8001758:	080025e1 	.word	0x080025e1
 800175c:	0800261d 	.word	0x0800261d

08001760 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
 8001760:	b590      	push	{r4, r7, lr}
 8001762:	b083      	sub	sp, #12
 8001764:	af00      	add	r7, sp, #0
	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 8001766:	4b32      	ldr	r3, [pc, #200]	; (8001830 <vTaskIncrementTick+0xd0>)
 8001768:	681b      	ldr	r3, [r3, #0]
 800176a:	2b00      	cmp	r3, #0
 800176c:	d14c      	bne.n	8001808 <vTaskIncrementTick+0xa8>
	{
		++xTickCount;
 800176e:	4b31      	ldr	r3, [pc, #196]	; (8001834 <vTaskIncrementTick+0xd4>)
 8001770:	681b      	ldr	r3, [r3, #0]
 8001772:	3301      	adds	r3, #1
 8001774:	4a2f      	ldr	r2, [pc, #188]	; (8001834 <vTaskIncrementTick+0xd4>)
 8001776:	6013      	str	r3, [r2, #0]
		if( xTickCount == ( portTickType ) 0 )
 8001778:	4b2e      	ldr	r3, [pc, #184]	; (8001834 <vTaskIncrementTick+0xd4>)
 800177a:	681b      	ldr	r3, [r3, #0]
 800177c:	2b00      	cmp	r3, #0
 800177e:	d134      	bne.n	80017ea <vTaskIncrementTick+0x8a>
			xList *pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			pxTemp = pxDelayedTaskList;
 8001780:	4b2d      	ldr	r3, [pc, #180]	; (8001838 <vTaskIncrementTick+0xd8>)
 8001782:	681b      	ldr	r3, [r3, #0]
 8001784:	607b      	str	r3, [r7, #4]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
 8001786:	4b2d      	ldr	r3, [pc, #180]	; (800183c <vTaskIncrementTick+0xdc>)
 8001788:	681b      	ldr	r3, [r3, #0]
 800178a:	4a2b      	ldr	r2, [pc, #172]	; (8001838 <vTaskIncrementTick+0xd8>)
 800178c:	6013      	str	r3, [r2, #0]
			pxOverflowDelayedTaskList = pxTemp;
 800178e:	4a2b      	ldr	r2, [pc, #172]	; (800183c <vTaskIncrementTick+0xdc>)
 8001790:	687b      	ldr	r3, [r7, #4]
 8001792:	6013      	str	r3, [r2, #0]
			xNumOfOverflows++;
 8001794:	4b2a      	ldr	r3, [pc, #168]	; (8001840 <vTaskIncrementTick+0xe0>)
 8001796:	681b      	ldr	r3, [r3, #0]
 8001798:	3301      	adds	r3, #1
 800179a:	4a29      	ldr	r2, [pc, #164]	; (8001840 <vTaskIncrementTick+0xe0>)
 800179c:	6013      	str	r3, [r2, #0]
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
 800179e:	e024      	b.n	80017ea <vTaskIncrementTick+0x8a>
 80017a0:	6862      	ldr	r2, [r4, #4]
 80017a2:	4b24      	ldr	r3, [pc, #144]	; (8001834 <vTaskIncrementTick+0xd4>)
 80017a4:	681b      	ldr	r3, [r3, #0]
 80017a6:	429a      	cmp	r2, r3
 80017a8:	d836      	bhi.n	8001818 <vTaskIncrementTick+0xb8>
 80017aa:	1d23      	adds	r3, r4, #4
 80017ac:	4618      	mov	r0, r3
 80017ae:	4b25      	ldr	r3, [pc, #148]	; (8001844 <vTaskIncrementTick+0xe4>)
 80017b0:	4798      	blx	r3
 80017b2:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80017b4:	2b00      	cmp	r3, #0
 80017b6:	d004      	beq.n	80017c2 <vTaskIncrementTick+0x62>
 80017b8:	f104 0318 	add.w	r3, r4, #24
 80017bc:	4618      	mov	r0, r3
 80017be:	4b21      	ldr	r3, [pc, #132]	; (8001844 <vTaskIncrementTick+0xe4>)
 80017c0:	4798      	blx	r3
 80017c2:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 80017c4:	4b20      	ldr	r3, [pc, #128]	; (8001848 <vTaskIncrementTick+0xe8>)
 80017c6:	681b      	ldr	r3, [r3, #0]
 80017c8:	429a      	cmp	r2, r3
 80017ca:	d902      	bls.n	80017d2 <vTaskIncrementTick+0x72>
 80017cc:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80017ce:	4a1e      	ldr	r2, [pc, #120]	; (8001848 <vTaskIncrementTick+0xe8>)
 80017d0:	6013      	str	r3, [r2, #0]
 80017d2:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 80017d4:	4613      	mov	r3, r2
 80017d6:	009b      	lsls	r3, r3, #2
 80017d8:	4413      	add	r3, r2
 80017da:	009b      	lsls	r3, r3, #2
 80017dc:	4a1b      	ldr	r2, [pc, #108]	; (800184c <vTaskIncrementTick+0xec>)
 80017de:	4413      	add	r3, r2
 80017e0:	1d22      	adds	r2, r4, #4
 80017e2:	4611      	mov	r1, r2
 80017e4:	4618      	mov	r0, r3
 80017e6:	4b1a      	ldr	r3, [pc, #104]	; (8001850 <vTaskIncrementTick+0xf0>)
 80017e8:	4798      	blx	r3
 80017ea:	4b13      	ldr	r3, [pc, #76]	; (8001838 <vTaskIncrementTick+0xd8>)
 80017ec:	681b      	ldr	r3, [r3, #0]
 80017ee:	681b      	ldr	r3, [r3, #0]
 80017f0:	2b00      	cmp	r3, #0
 80017f2:	d004      	beq.n	80017fe <vTaskIncrementTick+0x9e>
 80017f4:	4b10      	ldr	r3, [pc, #64]	; (8001838 <vTaskIncrementTick+0xd8>)
 80017f6:	681b      	ldr	r3, [r3, #0]
 80017f8:	68db      	ldr	r3, [r3, #12]
 80017fa:	68db      	ldr	r3, [r3, #12]
 80017fc:	e000      	b.n	8001800 <vTaskIncrementTick+0xa0>
 80017fe:	2300      	movs	r3, #0
 8001800:	461c      	mov	r4, r3
 8001802:	2c00      	cmp	r4, #0
 8001804:	d1cc      	bne.n	80017a0 <vTaskIncrementTick+0x40>
 8001806:	e008      	b.n	800181a <vTaskIncrementTick+0xba>
	}
	else
	{
		++uxMissedTicks;
 8001808:	4b12      	ldr	r3, [pc, #72]	; (8001854 <vTaskIncrementTick+0xf4>)
 800180a:	681b      	ldr	r3, [r3, #0]
 800180c:	3301      	adds	r3, #1
 800180e:	4a11      	ldr	r2, [pc, #68]	; (8001854 <vTaskIncrementTick+0xf4>)
 8001810:	6013      	str	r3, [r2, #0]
		scheduler is locked. */
		#if ( configUSE_TICK_HOOK == 1 )
		{
			extern void vApplicationTickHook( void );

			vApplicationTickHook();
 8001812:	4b11      	ldr	r3, [pc, #68]	; (8001858 <vTaskIncrementTick+0xf8>)
 8001814:	4798      	blx	r3
 8001816:	e000      	b.n	800181a <vTaskIncrementTick+0xba>
		prvCheckDelayedTasks();
 8001818:	bf00      	nop
	{
		extern void vApplicationTickHook( void );

		/* Guard against the tick hook being called when the missed tick
		count is being unwound (when the scheduler is being unlocked. */
		if( uxMissedTicks == 0 )
 800181a:	4b0e      	ldr	r3, [pc, #56]	; (8001854 <vTaskIncrementTick+0xf4>)
 800181c:	681b      	ldr	r3, [r3, #0]
 800181e:	2b00      	cmp	r3, #0
 8001820:	d101      	bne.n	8001826 <vTaskIncrementTick+0xc6>
		{
			vApplicationTickHook();
 8001822:	4b0d      	ldr	r3, [pc, #52]	; (8001858 <vTaskIncrementTick+0xf8>)
 8001824:	4798      	blx	r3
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
 8001826:	bf00      	nop
 8001828:	370c      	adds	r7, #12
 800182a:	46bd      	mov	sp, r7
 800182c:	bd90      	pop	{r4, r7, pc}
 800182e:	bf00      	nop
 8001830:	200007ac 	.word	0x200007ac
 8001834:	2000079c 	.word	0x2000079c
 8001838:	20000750 	.word	0x20000750
 800183c:	20000754 	.word	0x20000754
 8001840:	200007b8 	.word	0x200007b8
 8001844:	080024c9 	.word	0x080024c9
 8001848:	200007a4 	.word	0x200007a4
 800184c:	20000660 	.word	0x20000660
 8001850:	0800240b 	.word	0x0800240b
 8001854:	200007b0 	.word	0x200007b0
 8001858:	08006fa9 	.word	0x08006fa9

0800185c <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
 800185c:	b480      	push	{r7}
 800185e:	b083      	sub	sp, #12
 8001860:	af00      	add	r7, sp, #0
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 8001862:	4b1d      	ldr	r3, [pc, #116]	; (80018d8 <vTaskSwitchContext+0x7c>)
 8001864:	681b      	ldr	r3, [r3, #0]
 8001866:	2b00      	cmp	r3, #0
 8001868:	d008      	beq.n	800187c <vTaskSwitchContext+0x20>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
 800186a:	4b1c      	ldr	r3, [pc, #112]	; (80018dc <vTaskSwitchContext+0x80>)
 800186c:	2201      	movs	r2, #1
 800186e:	601a      	str	r2, [r3, #0]
		return;
 8001870:	e02d      	b.n	80018ce <vTaskSwitchContext+0x72>
	taskSECOND_CHECK_FOR_STACK_OVERFLOW();

	/* Find the highest priority queue that contains ready tasks. */
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
	{
		--uxTopReadyPriority;
 8001872:	4b1b      	ldr	r3, [pc, #108]	; (80018e0 <vTaskSwitchContext+0x84>)
 8001874:	681b      	ldr	r3, [r3, #0]
 8001876:	3b01      	subs	r3, #1
 8001878:	4a19      	ldr	r2, [pc, #100]	; (80018e0 <vTaskSwitchContext+0x84>)
 800187a:	6013      	str	r3, [r2, #0]
	while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 800187c:	4b18      	ldr	r3, [pc, #96]	; (80018e0 <vTaskSwitchContext+0x84>)
 800187e:	681a      	ldr	r2, [r3, #0]
 8001880:	4918      	ldr	r1, [pc, #96]	; (80018e4 <vTaskSwitchContext+0x88>)
 8001882:	4613      	mov	r3, r2
 8001884:	009b      	lsls	r3, r3, #2
 8001886:	4413      	add	r3, r2
 8001888:	009b      	lsls	r3, r3, #2
 800188a:	440b      	add	r3, r1
 800188c:	681b      	ldr	r3, [r3, #0]
 800188e:	2b00      	cmp	r3, #0
 8001890:	d0ef      	beq.n	8001872 <vTaskSwitchContext+0x16>
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
 8001892:	4b13      	ldr	r3, [pc, #76]	; (80018e0 <vTaskSwitchContext+0x84>)
 8001894:	681a      	ldr	r2, [r3, #0]
 8001896:	4613      	mov	r3, r2
 8001898:	009b      	lsls	r3, r3, #2
 800189a:	4413      	add	r3, r2
 800189c:	009b      	lsls	r3, r3, #2
 800189e:	4a11      	ldr	r2, [pc, #68]	; (80018e4 <vTaskSwitchContext+0x88>)
 80018a0:	4413      	add	r3, r2
 80018a2:	607b      	str	r3, [r7, #4]
 80018a4:	687b      	ldr	r3, [r7, #4]
 80018a6:	685b      	ldr	r3, [r3, #4]
 80018a8:	685a      	ldr	r2, [r3, #4]
 80018aa:	687b      	ldr	r3, [r7, #4]
 80018ac:	605a      	str	r2, [r3, #4]
 80018ae:	687b      	ldr	r3, [r7, #4]
 80018b0:	685a      	ldr	r2, [r3, #4]
 80018b2:	687b      	ldr	r3, [r7, #4]
 80018b4:	3308      	adds	r3, #8
 80018b6:	429a      	cmp	r2, r3
 80018b8:	d104      	bne.n	80018c4 <vTaskSwitchContext+0x68>
 80018ba:	687b      	ldr	r3, [r7, #4]
 80018bc:	685b      	ldr	r3, [r3, #4]
 80018be:	685a      	ldr	r2, [r3, #4]
 80018c0:	687b      	ldr	r3, [r7, #4]
 80018c2:	605a      	str	r2, [r3, #4]
 80018c4:	687b      	ldr	r3, [r7, #4]
 80018c6:	685b      	ldr	r3, [r3, #4]
 80018c8:	68db      	ldr	r3, [r3, #12]
 80018ca:	4a07      	ldr	r2, [pc, #28]	; (80018e8 <vTaskSwitchContext+0x8c>)
 80018cc:	6013      	str	r3, [r2, #0]

	traceTASK_SWITCHED_IN();
	vWriteTraceToBuffer();
}
 80018ce:	370c      	adds	r7, #12
 80018d0:	46bd      	mov	sp, r7
 80018d2:	bc80      	pop	{r7}
 80018d4:	4770      	bx	lr
 80018d6:	bf00      	nop
 80018d8:	200007ac 	.word	0x200007ac
 80018dc:	200007b4 	.word	0x200007b4
 80018e0:	200007a4 	.word	0x200007a4
 80018e4:	20000660 	.word	0x20000660
 80018e8:	2000065c 	.word	0x2000065c

080018ec <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
 80018ec:	b580      	push	{r7, lr}
 80018ee:	b084      	sub	sp, #16
 80018f0:	af00      	add	r7, sp, #0
 80018f2:	6078      	str	r0, [r7, #4]
 80018f4:	6039      	str	r1, [r7, #0]
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
 80018f6:	4b1f      	ldr	r3, [pc, #124]	; (8001974 <vTaskPlaceOnEventList+0x88>)
 80018f8:	681b      	ldr	r3, [r3, #0]
 80018fa:	3318      	adds	r3, #24
 80018fc:	4619      	mov	r1, r3
 80018fe:	6878      	ldr	r0, [r7, #4]
 8001900:	4b1d      	ldr	r3, [pc, #116]	; (8001978 <vTaskPlaceOnEventList+0x8c>)
 8001902:	4798      	blx	r3

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 8001904:	4b1b      	ldr	r3, [pc, #108]	; (8001974 <vTaskPlaceOnEventList+0x88>)
 8001906:	681b      	ldr	r3, [r3, #0]
 8001908:	3304      	adds	r3, #4
 800190a:	4618      	mov	r0, r3
 800190c:	4b1b      	ldr	r3, [pc, #108]	; (800197c <vTaskPlaceOnEventList+0x90>)
 800190e:	4798      	blx	r3


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
 8001910:	683b      	ldr	r3, [r7, #0]
 8001912:	f1b3 3fff 	cmp.w	r3, #4294967295
 8001916:	d107      	bne.n	8001928 <vTaskPlaceOnEventList+0x3c>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 8001918:	4b16      	ldr	r3, [pc, #88]	; (8001974 <vTaskPlaceOnEventList+0x88>)
 800191a:	681b      	ldr	r3, [r3, #0]
 800191c:	3304      	adds	r3, #4
 800191e:	4619      	mov	r1, r3
 8001920:	4817      	ldr	r0, [pc, #92]	; (8001980 <vTaskPlaceOnEventList+0x94>)
 8001922:	4b18      	ldr	r3, [pc, #96]	; (8001984 <vTaskPlaceOnEventList+0x98>)
 8001924:	4798      	blx	r3
				/* The wake time has not overflowed, so we can use the current block list. */
				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
			}
	}
	#endif
}
 8001926:	e020      	b.n	800196a <vTaskPlaceOnEventList+0x7e>
			xTimeToWake = xTickCount + xTicksToWait;
 8001928:	4b17      	ldr	r3, [pc, #92]	; (8001988 <vTaskPlaceOnEventList+0x9c>)
 800192a:	681b      	ldr	r3, [r3, #0]
 800192c:	683a      	ldr	r2, [r7, #0]
 800192e:	4413      	add	r3, r2
 8001930:	60fb      	str	r3, [r7, #12]
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 8001932:	4b10      	ldr	r3, [pc, #64]	; (8001974 <vTaskPlaceOnEventList+0x88>)
 8001934:	681b      	ldr	r3, [r3, #0]
 8001936:	68fa      	ldr	r2, [r7, #12]
 8001938:	605a      	str	r2, [r3, #4]
			if( xTimeToWake < xTickCount )
 800193a:	4b13      	ldr	r3, [pc, #76]	; (8001988 <vTaskPlaceOnEventList+0x9c>)
 800193c:	681b      	ldr	r3, [r3, #0]
 800193e:	68fa      	ldr	r2, [r7, #12]
 8001940:	429a      	cmp	r2, r3
 8001942:	d209      	bcs.n	8001958 <vTaskPlaceOnEventList+0x6c>
				vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 8001944:	4b11      	ldr	r3, [pc, #68]	; (800198c <vTaskPlaceOnEventList+0xa0>)
 8001946:	681a      	ldr	r2, [r3, #0]
 8001948:	4b0a      	ldr	r3, [pc, #40]	; (8001974 <vTaskPlaceOnEventList+0x88>)
 800194a:	681b      	ldr	r3, [r3, #0]
 800194c:	3304      	adds	r3, #4
 800194e:	4619      	mov	r1, r3
 8001950:	4610      	mov	r0, r2
 8001952:	4b09      	ldr	r3, [pc, #36]	; (8001978 <vTaskPlaceOnEventList+0x8c>)
 8001954:	4798      	blx	r3
}
 8001956:	e008      	b.n	800196a <vTaskPlaceOnEventList+0x7e>
				vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
 8001958:	4b0d      	ldr	r3, [pc, #52]	; (8001990 <vTaskPlaceOnEventList+0xa4>)
 800195a:	681a      	ldr	r2, [r3, #0]
 800195c:	4b05      	ldr	r3, [pc, #20]	; (8001974 <vTaskPlaceOnEventList+0x88>)
 800195e:	681b      	ldr	r3, [r3, #0]
 8001960:	3304      	adds	r3, #4
 8001962:	4619      	mov	r1, r3
 8001964:	4610      	mov	r0, r2
 8001966:	4b04      	ldr	r3, [pc, #16]	; (8001978 <vTaskPlaceOnEventList+0x8c>)
 8001968:	4798      	blx	r3
}
 800196a:	bf00      	nop
 800196c:	3710      	adds	r7, #16
 800196e:	46bd      	mov	sp, r7
 8001970:	bd80      	pop	{r7, pc}
 8001972:	bf00      	nop
 8001974:	2000065c 	.word	0x2000065c
 8001978:	08002459 	.word	0x08002459
 800197c:	080024c9 	.word	0x080024c9
 8001980:	20000784 	.word	0x20000784
 8001984:	0800240b 	.word	0x0800240b
 8001988:	2000079c 	.word	0x2000079c
 800198c:	20000754 	.word	0x20000754
 8001990:	20000750 	.word	0x20000750

08001994 <xTaskRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
 8001994:	b580      	push	{r7, lr}
 8001996:	b084      	sub	sp, #16
 8001998:	af00      	add	r7, sp, #0
 800199a:	6078      	str	r0, [r7, #4]
	it to the ready list.

	If an event is for a queue that is locked then this function will never
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
 800199c:	687b      	ldr	r3, [r7, #4]
 800199e:	681b      	ldr	r3, [r3, #0]
 80019a0:	2b00      	cmp	r3, #0
 80019a2:	d003      	beq.n	80019ac <xTaskRemoveFromEventList+0x18>
 80019a4:	687b      	ldr	r3, [r7, #4]
 80019a6:	68db      	ldr	r3, [r3, #12]
 80019a8:	68db      	ldr	r3, [r3, #12]
 80019aa:	e000      	b.n	80019ae <xTaskRemoveFromEventList+0x1a>
 80019ac:	2300      	movs	r3, #0
 80019ae:	60bb      	str	r3, [r7, #8]
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
 80019b0:	68bb      	ldr	r3, [r7, #8]
 80019b2:	3318      	adds	r3, #24
 80019b4:	4618      	mov	r0, r3
 80019b6:	4b1d      	ldr	r3, [pc, #116]	; (8001a2c <xTaskRemoveFromEventList+0x98>)
 80019b8:	4798      	blx	r3

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
 80019ba:	4b1d      	ldr	r3, [pc, #116]	; (8001a30 <xTaskRemoveFromEventList+0x9c>)
 80019bc:	681b      	ldr	r3, [r3, #0]
 80019be:	2b00      	cmp	r3, #0
 80019c0:	d11d      	bne.n	80019fe <xTaskRemoveFromEventList+0x6a>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
 80019c2:	68bb      	ldr	r3, [r7, #8]
 80019c4:	3304      	adds	r3, #4
 80019c6:	4618      	mov	r0, r3
 80019c8:	4b18      	ldr	r3, [pc, #96]	; (8001a2c <xTaskRemoveFromEventList+0x98>)
 80019ca:	4798      	blx	r3
		prvAddTaskToReadyQueue( pxUnblockedTCB );
 80019cc:	68bb      	ldr	r3, [r7, #8]
 80019ce:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80019d0:	4b18      	ldr	r3, [pc, #96]	; (8001a34 <xTaskRemoveFromEventList+0xa0>)
 80019d2:	681b      	ldr	r3, [r3, #0]
 80019d4:	429a      	cmp	r2, r3
 80019d6:	d903      	bls.n	80019e0 <xTaskRemoveFromEventList+0x4c>
 80019d8:	68bb      	ldr	r3, [r7, #8]
 80019da:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80019dc:	4a15      	ldr	r2, [pc, #84]	; (8001a34 <xTaskRemoveFromEventList+0xa0>)
 80019de:	6013      	str	r3, [r2, #0]
 80019e0:	68bb      	ldr	r3, [r7, #8]
 80019e2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80019e4:	4613      	mov	r3, r2
 80019e6:	009b      	lsls	r3, r3, #2
 80019e8:	4413      	add	r3, r2
 80019ea:	009b      	lsls	r3, r3, #2
 80019ec:	4a12      	ldr	r2, [pc, #72]	; (8001a38 <xTaskRemoveFromEventList+0xa4>)
 80019ee:	441a      	add	r2, r3
 80019f0:	68bb      	ldr	r3, [r7, #8]
 80019f2:	3304      	adds	r3, #4
 80019f4:	4619      	mov	r1, r3
 80019f6:	4610      	mov	r0, r2
 80019f8:	4b10      	ldr	r3, [pc, #64]	; (8001a3c <xTaskRemoveFromEventList+0xa8>)
 80019fa:	4798      	blx	r3
 80019fc:	e005      	b.n	8001a0a <xTaskRemoveFromEventList+0x76>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 80019fe:	68bb      	ldr	r3, [r7, #8]
 8001a00:	3318      	adds	r3, #24
 8001a02:	4619      	mov	r1, r3
 8001a04:	480e      	ldr	r0, [pc, #56]	; (8001a40 <xTaskRemoveFromEventList+0xac>)
 8001a06:	4b0d      	ldr	r3, [pc, #52]	; (8001a3c <xTaskRemoveFromEventList+0xa8>)
 8001a08:	4798      	blx	r3
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8001a0a:	68bb      	ldr	r3, [r7, #8]
 8001a0c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001a0e:	4b0d      	ldr	r3, [pc, #52]	; (8001a44 <xTaskRemoveFromEventList+0xb0>)
 8001a10:	681b      	ldr	r3, [r3, #0]
 8001a12:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001a14:	429a      	cmp	r2, r3
 8001a16:	d302      	bcc.n	8001a1e <xTaskRemoveFromEventList+0x8a>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
 8001a18:	2301      	movs	r3, #1
 8001a1a:	60fb      	str	r3, [r7, #12]
 8001a1c:	e001      	b.n	8001a22 <xTaskRemoveFromEventList+0x8e>
	}
	else
	{
		xReturn = pdFALSE;
 8001a1e:	2300      	movs	r3, #0
 8001a20:	60fb      	str	r3, [r7, #12]
	}

	return xReturn;
 8001a22:	68fb      	ldr	r3, [r7, #12]
}
 8001a24:	4618      	mov	r0, r3
 8001a26:	3710      	adds	r7, #16
 8001a28:	46bd      	mov	sp, r7
 8001a2a:	bd80      	pop	{r7, pc}
 8001a2c:	080024c9 	.word	0x080024c9
 8001a30:	200007ac 	.word	0x200007ac
 8001a34:	200007a4 	.word	0x200007a4
 8001a38:	20000660 	.word	0x20000660
 8001a3c:	0800240b 	.word	0x0800240b
 8001a40:	20000758 	.word	0x20000758
 8001a44:	2000065c 	.word	0x2000065c

08001a48 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
 8001a48:	b480      	push	{r7}
 8001a4a:	b083      	sub	sp, #12
 8001a4c:	af00      	add	r7, sp, #0
 8001a4e:	6078      	str	r0, [r7, #4]
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 8001a50:	4b06      	ldr	r3, [pc, #24]	; (8001a6c <vTaskSetTimeOutState+0x24>)
 8001a52:	681a      	ldr	r2, [r3, #0]
 8001a54:	687b      	ldr	r3, [r7, #4]
 8001a56:	601a      	str	r2, [r3, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
 8001a58:	4b05      	ldr	r3, [pc, #20]	; (8001a70 <vTaskSetTimeOutState+0x28>)
 8001a5a:	681a      	ldr	r2, [r3, #0]
 8001a5c:	687b      	ldr	r3, [r7, #4]
 8001a5e:	605a      	str	r2, [r3, #4]
}
 8001a60:	bf00      	nop
 8001a62:	370c      	adds	r7, #12
 8001a64:	46bd      	mov	sp, r7
 8001a66:	bc80      	pop	{r7}
 8001a68:	4770      	bx	lr
 8001a6a:	bf00      	nop
 8001a6c:	200007b8 	.word	0x200007b8
 8001a70:	2000079c 	.word	0x2000079c

08001a74 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
 8001a74:	b580      	push	{r7, lr}
 8001a76:	b084      	sub	sp, #16
 8001a78:	af00      	add	r7, sp, #0
 8001a7a:	6078      	str	r0, [r7, #4]
 8001a7c:	6039      	str	r1, [r7, #0]
portBASE_TYPE xReturn;

	portENTER_CRITICAL();
 8001a7e:	4b1d      	ldr	r3, [pc, #116]	; (8001af4 <xTaskCheckForTimeOut+0x80>)
 8001a80:	4798      	blx	r3
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
 8001a82:	683b      	ldr	r3, [r7, #0]
 8001a84:	681b      	ldr	r3, [r3, #0]
 8001a86:	f1b3 3fff 	cmp.w	r3, #4294967295
 8001a8a:	d102      	bne.n	8001a92 <xTaskCheckForTimeOut+0x1e>
			{
				xReturn = pdFALSE;
 8001a8c:	2300      	movs	r3, #0
 8001a8e:	60fb      	str	r3, [r7, #12]
 8001a90:	e029      	b.n	8001ae6 <xTaskCheckForTimeOut+0x72>
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
 8001a92:	687b      	ldr	r3, [r7, #4]
 8001a94:	681a      	ldr	r2, [r3, #0]
 8001a96:	4b18      	ldr	r3, [pc, #96]	; (8001af8 <xTaskCheckForTimeOut+0x84>)
 8001a98:	681b      	ldr	r3, [r3, #0]
 8001a9a:	429a      	cmp	r2, r3
 8001a9c:	d008      	beq.n	8001ab0 <xTaskCheckForTimeOut+0x3c>
 8001a9e:	687b      	ldr	r3, [r7, #4]
 8001aa0:	685a      	ldr	r2, [r3, #4]
 8001aa2:	4b16      	ldr	r3, [pc, #88]	; (8001afc <xTaskCheckForTimeOut+0x88>)
 8001aa4:	681b      	ldr	r3, [r3, #0]
 8001aa6:	429a      	cmp	r2, r3
 8001aa8:	d802      	bhi.n	8001ab0 <xTaskCheckForTimeOut+0x3c>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
 8001aaa:	2301      	movs	r3, #1
 8001aac:	60fb      	str	r3, [r7, #12]
 8001aae:	e01a      	b.n	8001ae6 <xTaskCheckForTimeOut+0x72>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
 8001ab0:	4b12      	ldr	r3, [pc, #72]	; (8001afc <xTaskCheckForTimeOut+0x88>)
 8001ab2:	681a      	ldr	r2, [r3, #0]
 8001ab4:	687b      	ldr	r3, [r7, #4]
 8001ab6:	685b      	ldr	r3, [r3, #4]
 8001ab8:	1ad2      	subs	r2, r2, r3
 8001aba:	683b      	ldr	r3, [r7, #0]
 8001abc:	681b      	ldr	r3, [r3, #0]
 8001abe:	429a      	cmp	r2, r3
 8001ac0:	d20f      	bcs.n	8001ae2 <xTaskCheckForTimeOut+0x6e>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
 8001ac2:	4b0e      	ldr	r3, [pc, #56]	; (8001afc <xTaskCheckForTimeOut+0x88>)
 8001ac4:	681a      	ldr	r2, [r3, #0]
 8001ac6:	687b      	ldr	r3, [r7, #4]
 8001ac8:	685b      	ldr	r3, [r3, #4]
 8001aca:	1ad3      	subs	r3, r2, r3
 8001acc:	683a      	ldr	r2, [r7, #0]
 8001ace:	6812      	ldr	r2, [r2, #0]
 8001ad0:	1ad2      	subs	r2, r2, r3
 8001ad2:	683b      	ldr	r3, [r7, #0]
 8001ad4:	601a      	str	r2, [r3, #0]
			vTaskSetTimeOutState( pxTimeOut );
 8001ad6:	6878      	ldr	r0, [r7, #4]
 8001ad8:	4b09      	ldr	r3, [pc, #36]	; (8001b00 <xTaskCheckForTimeOut+0x8c>)
 8001ada:	4798      	blx	r3
			xReturn = pdFALSE;
 8001adc:	2300      	movs	r3, #0
 8001ade:	60fb      	str	r3, [r7, #12]
 8001ae0:	e001      	b.n	8001ae6 <xTaskCheckForTimeOut+0x72>
		}
		else
		{
			xReturn = pdTRUE;
 8001ae2:	2301      	movs	r3, #1
 8001ae4:	60fb      	str	r3, [r7, #12]
		}
	}
	portEXIT_CRITICAL();
 8001ae6:	4b07      	ldr	r3, [pc, #28]	; (8001b04 <xTaskCheckForTimeOut+0x90>)
 8001ae8:	4798      	blx	r3

	return xReturn;
 8001aea:	68fb      	ldr	r3, [r7, #12]
}
 8001aec:	4618      	mov	r0, r3
 8001aee:	3710      	adds	r7, #16
 8001af0:	46bd      	mov	sp, r7
 8001af2:	bd80      	pop	{r7, pc}
 8001af4:	080025f9 	.word	0x080025f9
 8001af8:	200007b8 	.word	0x200007b8
 8001afc:	2000079c 	.word	0x2000079c
 8001b00:	08001a49 	.word	0x08001a49
 8001b04:	0800261d 	.word	0x0800261d

08001b08 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
 8001b08:	b480      	push	{r7}
 8001b0a:	af00      	add	r7, sp, #0
	xMissedYield = pdTRUE;
 8001b0c:	4b03      	ldr	r3, [pc, #12]	; (8001b1c <vTaskMissedYield+0x14>)
 8001b0e:	2201      	movs	r2, #1
 8001b10:	601a      	str	r2, [r3, #0]
}
 8001b12:	bf00      	nop
 8001b14:	46bd      	mov	sp, r7
 8001b16:	bc80      	pop	{r7}
 8001b18:	4770      	bx	lr
 8001b1a:	bf00      	nop
 8001b1c:	200007b4 	.word	0x200007b4

08001b20 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
 8001b20:	b580      	push	{r7, lr}
 8001b22:	b082      	sub	sp, #8
 8001b24:	af00      	add	r7, sp, #0
 8001b26:	6078      	str	r0, [r7, #4]
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
 8001b28:	4b05      	ldr	r3, [pc, #20]	; (8001b40 <prvIdleTask+0x20>)
 8001b2a:	4798      	blx	r3

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
 8001b2c:	4b05      	ldr	r3, [pc, #20]	; (8001b44 <prvIdleTask+0x24>)
 8001b2e:	681b      	ldr	r3, [r3, #0]
 8001b30:	2b01      	cmp	r3, #1
 8001b32:	d901      	bls.n	8001b38 <prvIdleTask+0x18>
			{
				taskYIELD();
 8001b34:	4b04      	ldr	r3, [pc, #16]	; (8001b48 <prvIdleTask+0x28>)
 8001b36:	4798      	blx	r3
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
 8001b38:	4b04      	ldr	r3, [pc, #16]	; (8001b4c <prvIdleTask+0x2c>)
 8001b3a:	4798      	blx	r3
		prvCheckTasksWaitingTermination();
 8001b3c:	e7f4      	b.n	8001b28 <prvIdleTask+0x8>
 8001b3e:	bf00      	nop
 8001b40:	08001c49 	.word	0x08001c49
 8001b44:	20000660 	.word	0x20000660
 8001b48:	080025e1 	.word	0x080025e1
 8001b4c:	08006f9d 	.word	0x08006f9d

08001b50 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
 8001b50:	b580      	push	{r7, lr}
 8001b52:	b084      	sub	sp, #16
 8001b54:	af00      	add	r7, sp, #0
 8001b56:	60f8      	str	r0, [r7, #12]
 8001b58:	60b9      	str	r1, [r7, #8]
 8001b5a:	607a      	str	r2, [r7, #4]
 8001b5c:	603b      	str	r3, [r7, #0]
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
 8001b5e:	68fb      	ldr	r3, [r7, #12]
 8001b60:	3334      	adds	r3, #52	; 0x34
 8001b62:	2210      	movs	r2, #16
 8001b64:	68b9      	ldr	r1, [r7, #8]
 8001b66:	4618      	mov	r0, r3
 8001b68:	4b14      	ldr	r3, [pc, #80]	; (8001bbc <prvInitialiseTCBVariables+0x6c>)
 8001b6a:	4798      	blx	r3
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = '\0';
 8001b6c:	68fb      	ldr	r3, [r7, #12]
 8001b6e:	2200      	movs	r2, #0
 8001b70:	f883 2043 	strb.w	r2, [r3, #67]	; 0x43

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
 8001b74:	687b      	ldr	r3, [r7, #4]
 8001b76:	2b09      	cmp	r3, #9
 8001b78:	d901      	bls.n	8001b7e <prvInitialiseTCBVariables+0x2e>
	{
		uxPriority = configMAX_PRIORITIES - 1;
 8001b7a:	2309      	movs	r3, #9
 8001b7c:	607b      	str	r3, [r7, #4]
	}

	pxTCB->uxPriority = uxPriority;
 8001b7e:	68fb      	ldr	r3, [r7, #12]
 8001b80:	687a      	ldr	r2, [r7, #4]
 8001b82:	62da      	str	r2, [r3, #44]	; 0x2c
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
 8001b84:	68fb      	ldr	r3, [r7, #12]
 8001b86:	687a      	ldr	r2, [r7, #4]
 8001b88:	645a      	str	r2, [r3, #68]	; 0x44
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 8001b8a:	68fb      	ldr	r3, [r7, #12]
 8001b8c:	3304      	adds	r3, #4
 8001b8e:	4618      	mov	r0, r3
 8001b90:	4b0b      	ldr	r3, [pc, #44]	; (8001bc0 <prvInitialiseTCBVariables+0x70>)
 8001b92:	4798      	blx	r3
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 8001b94:	68fb      	ldr	r3, [r7, #12]
 8001b96:	3318      	adds	r3, #24
 8001b98:	4618      	mov	r0, r3
 8001b9a:	4b09      	ldr	r3, [pc, #36]	; (8001bc0 <prvInitialiseTCBVariables+0x70>)
 8001b9c:	4798      	blx	r3

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 8001b9e:	68fb      	ldr	r3, [r7, #12]
 8001ba0:	68fa      	ldr	r2, [r7, #12]
 8001ba2:	611a      	str	r2, [r3, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
 8001ba4:	687b      	ldr	r3, [r7, #4]
 8001ba6:	f1c3 020a 	rsb	r2, r3, #10
 8001baa:	68fb      	ldr	r3, [r7, #12]
 8001bac:	619a      	str	r2, [r3, #24]
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 8001bae:	68fb      	ldr	r3, [r7, #12]
 8001bb0:	68fa      	ldr	r2, [r7, #12]
 8001bb2:	625a      	str	r2, [r3, #36]	; 0x24
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
 8001bb4:	bf00      	nop
 8001bb6:	3710      	adds	r7, #16
 8001bb8:	46bd      	mov	sp, r7
 8001bba:	bd80      	pop	{r7, pc}
 8001bbc:	0801478d 	.word	0x0801478d
 8001bc0:	080023f3 	.word	0x080023f3

08001bc4 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
 8001bc4:	b580      	push	{r7, lr}
 8001bc6:	b082      	sub	sp, #8
 8001bc8:	af00      	add	r7, sp, #0
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 8001bca:	2300      	movs	r3, #0
 8001bcc:	607b      	str	r3, [r7, #4]
 8001bce:	e00c      	b.n	8001bea <prvInitialiseTaskLists+0x26>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
 8001bd0:	687a      	ldr	r2, [r7, #4]
 8001bd2:	4613      	mov	r3, r2
 8001bd4:	009b      	lsls	r3, r3, #2
 8001bd6:	4413      	add	r3, r2
 8001bd8:	009b      	lsls	r3, r3, #2
 8001bda:	4a12      	ldr	r2, [pc, #72]	; (8001c24 <prvInitialiseTaskLists+0x60>)
 8001bdc:	4413      	add	r3, r2
 8001bde:	4618      	mov	r0, r3
 8001be0:	4b11      	ldr	r3, [pc, #68]	; (8001c28 <prvInitialiseTaskLists+0x64>)
 8001be2:	4798      	blx	r3
	for( uxPriority = 0; uxPriority < configMAX_PRIORITIES; uxPriority++ )
 8001be4:	687b      	ldr	r3, [r7, #4]
 8001be6:	3301      	adds	r3, #1
 8001be8:	607b      	str	r3, [r7, #4]
 8001bea:	687b      	ldr	r3, [r7, #4]
 8001bec:	2b09      	cmp	r3, #9
 8001bee:	d9ef      	bls.n	8001bd0 <prvInitialiseTaskLists+0xc>
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
 8001bf0:	480e      	ldr	r0, [pc, #56]	; (8001c2c <prvInitialiseTaskLists+0x68>)
 8001bf2:	4b0d      	ldr	r3, [pc, #52]	; (8001c28 <prvInitialiseTaskLists+0x64>)
 8001bf4:	4798      	blx	r3
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
 8001bf6:	480e      	ldr	r0, [pc, #56]	; (8001c30 <prvInitialiseTaskLists+0x6c>)
 8001bf8:	4b0b      	ldr	r3, [pc, #44]	; (8001c28 <prvInitialiseTaskLists+0x64>)
 8001bfa:	4798      	blx	r3
	vListInitialise( ( xList * ) &xPendingReadyList );
 8001bfc:	480d      	ldr	r0, [pc, #52]	; (8001c34 <prvInitialiseTaskLists+0x70>)
 8001bfe:	4b0a      	ldr	r3, [pc, #40]	; (8001c28 <prvInitialiseTaskLists+0x64>)
 8001c00:	4798      	blx	r3

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
 8001c02:	480d      	ldr	r0, [pc, #52]	; (8001c38 <prvInitialiseTaskLists+0x74>)
 8001c04:	4b08      	ldr	r3, [pc, #32]	; (8001c28 <prvInitialiseTaskLists+0x64>)
 8001c06:	4798      	blx	r3
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
 8001c08:	480c      	ldr	r0, [pc, #48]	; (8001c3c <prvInitialiseTaskLists+0x78>)
 8001c0a:	4b07      	ldr	r3, [pc, #28]	; (8001c28 <prvInitialiseTaskLists+0x64>)
 8001c0c:	4798      	blx	r3
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
 8001c0e:	4b0c      	ldr	r3, [pc, #48]	; (8001c40 <prvInitialiseTaskLists+0x7c>)
 8001c10:	4a06      	ldr	r2, [pc, #24]	; (8001c2c <prvInitialiseTaskLists+0x68>)
 8001c12:	601a      	str	r2, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 8001c14:	4b0b      	ldr	r3, [pc, #44]	; (8001c44 <prvInitialiseTaskLists+0x80>)
 8001c16:	4a06      	ldr	r2, [pc, #24]	; (8001c30 <prvInitialiseTaskLists+0x6c>)
 8001c18:	601a      	str	r2, [r3, #0]
}
 8001c1a:	bf00      	nop
 8001c1c:	3708      	adds	r7, #8
 8001c1e:	46bd      	mov	sp, r7
 8001c20:	bd80      	pop	{r7, pc}
 8001c22:	bf00      	nop
 8001c24:	20000660 	.word	0x20000660
 8001c28:	080023b5 	.word	0x080023b5
 8001c2c:	20000728 	.word	0x20000728
 8001c30:	2000073c 	.word	0x2000073c
 8001c34:	20000758 	.word	0x20000758
 8001c38:	2000076c 	.word	0x2000076c
 8001c3c:	20000784 	.word	0x20000784
 8001c40:	20000750 	.word	0x20000750
 8001c44:	20000754 	.word	0x20000754

08001c48 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
 8001c48:	b580      	push	{r7, lr}
 8001c4a:	b082      	sub	sp, #8
 8001c4c:	af00      	add	r7, sp, #0
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0 )
 8001c4e:	4b1b      	ldr	r3, [pc, #108]	; (8001cbc <prvCheckTasksWaitingTermination+0x74>)
 8001c50:	681b      	ldr	r3, [r3, #0]
 8001c52:	2b00      	cmp	r3, #0
 8001c54:	d02e      	beq.n	8001cb4 <prvCheckTasksWaitingTermination+0x6c>
		{
			vTaskSuspendAll();
 8001c56:	4b1a      	ldr	r3, [pc, #104]	; (8001cc0 <prvCheckTasksWaitingTermination+0x78>)
 8001c58:	4798      	blx	r3
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 8001c5a:	4b1a      	ldr	r3, [pc, #104]	; (8001cc4 <prvCheckTasksWaitingTermination+0x7c>)
 8001c5c:	681b      	ldr	r3, [r3, #0]
 8001c5e:	2b00      	cmp	r3, #0
 8001c60:	bf0c      	ite	eq
 8001c62:	2301      	moveq	r3, #1
 8001c64:	2300      	movne	r3, #0
 8001c66:	b2db      	uxtb	r3, r3
 8001c68:	607b      	str	r3, [r7, #4]
			xTaskResumeAll();
 8001c6a:	4b17      	ldr	r3, [pc, #92]	; (8001cc8 <prvCheckTasksWaitingTermination+0x80>)
 8001c6c:	4798      	blx	r3

			if( !xListIsEmpty )
 8001c6e:	687b      	ldr	r3, [r7, #4]
 8001c70:	2b00      	cmp	r3, #0
 8001c72:	d11f      	bne.n	8001cb4 <prvCheckTasksWaitingTermination+0x6c>
			{
				tskTCB *pxTCB;

				portENTER_CRITICAL();
 8001c74:	4b15      	ldr	r3, [pc, #84]	; (8001ccc <prvCheckTasksWaitingTermination+0x84>)
 8001c76:	4798      	blx	r3
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
 8001c78:	4b12      	ldr	r3, [pc, #72]	; (8001cc4 <prvCheckTasksWaitingTermination+0x7c>)
 8001c7a:	681b      	ldr	r3, [r3, #0]
 8001c7c:	2b00      	cmp	r3, #0
 8001c7e:	d003      	beq.n	8001c88 <prvCheckTasksWaitingTermination+0x40>
 8001c80:	4b13      	ldr	r3, [pc, #76]	; (8001cd0 <prvCheckTasksWaitingTermination+0x88>)
 8001c82:	685b      	ldr	r3, [r3, #4]
 8001c84:	68db      	ldr	r3, [r3, #12]
 8001c86:	e000      	b.n	8001c8a <prvCheckTasksWaitingTermination+0x42>
 8001c88:	2300      	movs	r3, #0
 8001c8a:	603b      	str	r3, [r7, #0]
					vListRemove( &( pxTCB->xGenericListItem ) );
 8001c8c:	683b      	ldr	r3, [r7, #0]
 8001c8e:	3304      	adds	r3, #4
 8001c90:	4618      	mov	r0, r3
 8001c92:	4b10      	ldr	r3, [pc, #64]	; (8001cd4 <prvCheckTasksWaitingTermination+0x8c>)
 8001c94:	4798      	blx	r3
					--uxCurrentNumberOfTasks;
 8001c96:	4b10      	ldr	r3, [pc, #64]	; (8001cd8 <prvCheckTasksWaitingTermination+0x90>)
 8001c98:	681b      	ldr	r3, [r3, #0]
 8001c9a:	3b01      	subs	r3, #1
 8001c9c:	4a0e      	ldr	r2, [pc, #56]	; (8001cd8 <prvCheckTasksWaitingTermination+0x90>)
 8001c9e:	6013      	str	r3, [r2, #0]
					--uxTasksDeleted;
 8001ca0:	4b06      	ldr	r3, [pc, #24]	; (8001cbc <prvCheckTasksWaitingTermination+0x74>)
 8001ca2:	681b      	ldr	r3, [r3, #0]
 8001ca4:	3b01      	subs	r3, #1
 8001ca6:	4a05      	ldr	r2, [pc, #20]	; (8001cbc <prvCheckTasksWaitingTermination+0x74>)
 8001ca8:	6013      	str	r3, [r2, #0]
				}
				portEXIT_CRITICAL();
 8001caa:	4b0c      	ldr	r3, [pc, #48]	; (8001cdc <prvCheckTasksWaitingTermination+0x94>)
 8001cac:	4798      	blx	r3

				prvDeleteTCB( pxTCB );
 8001cae:	6838      	ldr	r0, [r7, #0]
 8001cb0:	4b0b      	ldr	r3, [pc, #44]	; (8001ce0 <prvCheckTasksWaitingTermination+0x98>)
 8001cb2:	4798      	blx	r3
			}
		}
	}
	#endif
}
 8001cb4:	bf00      	nop
 8001cb6:	3708      	adds	r7, #8
 8001cb8:	46bd      	mov	sp, r7
 8001cba:	bd80      	pop	{r7, pc}
 8001cbc:	20000780 	.word	0x20000780
 8001cc0:	0800162d 	.word	0x0800162d
 8001cc4:	2000076c 	.word	0x2000076c
 8001cc8:	08001649 	.word	0x08001649
 8001ccc:	080025f9 	.word	0x080025f9
 8001cd0:	20000774 	.word	0x20000774
 8001cd4:	080024c9 	.word	0x080024c9
 8001cd8:	20000798 	.word	0x20000798
 8001cdc:	0800261d 	.word	0x0800261d
 8001ce0:	08001d49 	.word	0x08001d49

08001ce4 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
 8001ce4:	b580      	push	{r7, lr}
 8001ce6:	b084      	sub	sp, #16
 8001ce8:	af00      	add	r7, sp, #0
 8001cea:	4603      	mov	r3, r0
 8001cec:	6039      	str	r1, [r7, #0]
 8001cee:	80fb      	strh	r3, [r7, #6]
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
 8001cf0:	2048      	movs	r0, #72	; 0x48
 8001cf2:	4b12      	ldr	r3, [pc, #72]	; (8001d3c <prvAllocateTCBAndStack+0x58>)
 8001cf4:	4798      	blx	r3
 8001cf6:	60f8      	str	r0, [r7, #12]

	if( pxNewTCB != NULL )
 8001cf8:	68fb      	ldr	r3, [r7, #12]
 8001cfa:	2b00      	cmp	r3, #0
 8001cfc:	d019      	beq.n	8001d32 <prvAllocateTCBAndStack+0x4e>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
 8001cfe:	88fb      	ldrh	r3, [r7, #6]
 8001d00:	009b      	lsls	r3, r3, #2
 8001d02:	4618      	mov	r0, r3
 8001d04:	4b0d      	ldr	r3, [pc, #52]	; (8001d3c <prvAllocateTCBAndStack+0x58>)
 8001d06:	4798      	blx	r3
 8001d08:	4602      	mov	r2, r0
 8001d0a:	68fb      	ldr	r3, [r7, #12]
 8001d0c:	631a      	str	r2, [r3, #48]	; 0x30

		if( pxNewTCB->pxStack == NULL )
 8001d0e:	68fb      	ldr	r3, [r7, #12]
 8001d10:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8001d12:	2b00      	cmp	r3, #0
 8001d14:	d105      	bne.n	8001d22 <prvAllocateTCBAndStack+0x3e>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
 8001d16:	68f8      	ldr	r0, [r7, #12]
 8001d18:	4b09      	ldr	r3, [pc, #36]	; (8001d40 <prvAllocateTCBAndStack+0x5c>)
 8001d1a:	4798      	blx	r3
			pxNewTCB = NULL;
 8001d1c:	2300      	movs	r3, #0
 8001d1e:	60fb      	str	r3, [r7, #12]
 8001d20:	e007      	b.n	8001d32 <prvAllocateTCBAndStack+0x4e>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, tskSTACK_FILL_BYTE, usStackDepth * sizeof( portSTACK_TYPE ) );
 8001d22:	68fb      	ldr	r3, [r7, #12]
 8001d24:	6b18      	ldr	r0, [r3, #48]	; 0x30
 8001d26:	88fb      	ldrh	r3, [r7, #6]
 8001d28:	009b      	lsls	r3, r3, #2
 8001d2a:	461a      	mov	r2, r3
 8001d2c:	21a5      	movs	r1, #165	; 0xa5
 8001d2e:	4b05      	ldr	r3, [pc, #20]	; (8001d44 <prvAllocateTCBAndStack+0x60>)
 8001d30:	4798      	blx	r3
		}
	}

	return pxNewTCB;
 8001d32:	68fb      	ldr	r3, [r7, #12]
}
 8001d34:	4618      	mov	r0, r3
 8001d36:	3710      	adds	r7, #16
 8001d38:	46bd      	mov	sp, r7
 8001d3a:	bd80      	pop	{r7, pc}
 8001d3c:	080026e5 	.word	0x080026e5
 8001d40:	08002839 	.word	0x08002839
 8001d44:	08014591 	.word	0x08014591

08001d48 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_vTaskDelete == 1 ) || ( INCLUDE_vTaskCleanUpResources == 1 ) )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
 8001d48:	b580      	push	{r7, lr}
 8001d4a:	b082      	sub	sp, #8
 8001d4c:	af00      	add	r7, sp, #0
 8001d4e:	6078      	str	r0, [r7, #4]
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
 8001d50:	687b      	ldr	r3, [r7, #4]
 8001d52:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8001d54:	4618      	mov	r0, r3
 8001d56:	4b04      	ldr	r3, [pc, #16]	; (8001d68 <prvDeleteTCB+0x20>)
 8001d58:	4798      	blx	r3
		vPortFree( pxTCB );
 8001d5a:	6878      	ldr	r0, [r7, #4]
 8001d5c:	4b02      	ldr	r3, [pc, #8]	; (8001d68 <prvDeleteTCB+0x20>)
 8001d5e:	4798      	blx	r3
	}
 8001d60:	bf00      	nop
 8001d62:	3708      	adds	r7, #8
 8001d64:	46bd      	mov	sp, r7
 8001d66:	bd80      	pop	{r7, pc}
 8001d68:	08002839 	.word	0x08002839

08001d6c <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_xTaskGetCurrentTaskHandle == 1 )

	xTaskHandle xTaskGetCurrentTaskHandle( void )
	{
 8001d6c:	b480      	push	{r7}
 8001d6e:	b083      	sub	sp, #12
 8001d70:	af00      	add	r7, sp, #0
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
 8001d72:	4b04      	ldr	r3, [pc, #16]	; (8001d84 <xTaskGetCurrentTaskHandle+0x18>)
 8001d74:	681b      	ldr	r3, [r3, #0]
 8001d76:	607b      	str	r3, [r7, #4]

		return xReturn;
 8001d78:	687b      	ldr	r3, [r7, #4]
	}
 8001d7a:	4618      	mov	r0, r3
 8001d7c:	370c      	adds	r7, #12
 8001d7e:	46bd      	mov	sp, r7
 8001d80:	bc80      	pop	{r7}
 8001d82:	4770      	bx	lr
 8001d84:	2000065c 	.word	0x2000065c

08001d88 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
 8001d88:	b580      	push	{r7, lr}
 8001d8a:	b084      	sub	sp, #16
 8001d8c:	af00      	add	r7, sp, #0
 8001d8e:	6078      	str	r0, [r7, #4]
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
 8001d90:	687b      	ldr	r3, [r7, #4]
 8001d92:	60fb      	str	r3, [r7, #12]

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
 8001d94:	68fb      	ldr	r3, [r7, #12]
 8001d96:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001d98:	4b21      	ldr	r3, [pc, #132]	; (8001e20 <vTaskPriorityInherit+0x98>)
 8001d9a:	681b      	ldr	r3, [r3, #0]
 8001d9c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001d9e:	429a      	cmp	r2, r3
 8001da0:	d23a      	bcs.n	8001e18 <vTaskPriorityInherit+0x90>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
 8001da2:	4b1f      	ldr	r3, [pc, #124]	; (8001e20 <vTaskPriorityInherit+0x98>)
 8001da4:	681b      	ldr	r3, [r3, #0]
 8001da6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001da8:	f1c3 020a 	rsb	r2, r3, #10
 8001dac:	68fb      	ldr	r3, [r7, #12]
 8001dae:	619a      	str	r2, [r3, #24]

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
 8001db0:	68fb      	ldr	r3, [r7, #12]
 8001db2:	6959      	ldr	r1, [r3, #20]
 8001db4:	68fb      	ldr	r3, [r7, #12]
 8001db6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001db8:	4613      	mov	r3, r2
 8001dba:	009b      	lsls	r3, r3, #2
 8001dbc:	4413      	add	r3, r2
 8001dbe:	009b      	lsls	r3, r3, #2
 8001dc0:	4a18      	ldr	r2, [pc, #96]	; (8001e24 <vTaskPriorityInherit+0x9c>)
 8001dc2:	4413      	add	r3, r2
 8001dc4:	4299      	cmp	r1, r3
 8001dc6:	d122      	bne.n	8001e0e <vTaskPriorityInherit+0x86>
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
 8001dc8:	68fb      	ldr	r3, [r7, #12]
 8001dca:	3304      	adds	r3, #4
 8001dcc:	4618      	mov	r0, r3
 8001dce:	4b16      	ldr	r3, [pc, #88]	; (8001e28 <vTaskPriorityInherit+0xa0>)
 8001dd0:	4798      	blx	r3

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 8001dd2:	4b13      	ldr	r3, [pc, #76]	; (8001e20 <vTaskPriorityInherit+0x98>)
 8001dd4:	681b      	ldr	r3, [r3, #0]
 8001dd6:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001dd8:	68fb      	ldr	r3, [r7, #12]
 8001dda:	62da      	str	r2, [r3, #44]	; 0x2c
				prvAddTaskToReadyQueue( pxTCB );
 8001ddc:	68fb      	ldr	r3, [r7, #12]
 8001dde:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001de0:	4b12      	ldr	r3, [pc, #72]	; (8001e2c <vTaskPriorityInherit+0xa4>)
 8001de2:	681b      	ldr	r3, [r3, #0]
 8001de4:	429a      	cmp	r2, r3
 8001de6:	d903      	bls.n	8001df0 <vTaskPriorityInherit+0x68>
 8001de8:	68fb      	ldr	r3, [r7, #12]
 8001dea:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001dec:	4a0f      	ldr	r2, [pc, #60]	; (8001e2c <vTaskPriorityInherit+0xa4>)
 8001dee:	6013      	str	r3, [r2, #0]
 8001df0:	68fb      	ldr	r3, [r7, #12]
 8001df2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001df4:	4613      	mov	r3, r2
 8001df6:	009b      	lsls	r3, r3, #2
 8001df8:	4413      	add	r3, r2
 8001dfa:	009b      	lsls	r3, r3, #2
 8001dfc:	4a09      	ldr	r2, [pc, #36]	; (8001e24 <vTaskPriorityInherit+0x9c>)
 8001dfe:	441a      	add	r2, r3
 8001e00:	68fb      	ldr	r3, [r7, #12]
 8001e02:	3304      	adds	r3, #4
 8001e04:	4619      	mov	r1, r3
 8001e06:	4610      	mov	r0, r2
 8001e08:	4b09      	ldr	r3, [pc, #36]	; (8001e30 <vTaskPriorityInherit+0xa8>)
 8001e0a:	4798      	blx	r3
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
			}
		}
	}
 8001e0c:	e004      	b.n	8001e18 <vTaskPriorityInherit+0x90>
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
 8001e0e:	4b04      	ldr	r3, [pc, #16]	; (8001e20 <vTaskPriorityInherit+0x98>)
 8001e10:	681b      	ldr	r3, [r3, #0]
 8001e12:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001e14:	68fb      	ldr	r3, [r7, #12]
 8001e16:	62da      	str	r2, [r3, #44]	; 0x2c
	}
 8001e18:	bf00      	nop
 8001e1a:	3710      	adds	r7, #16
 8001e1c:	46bd      	mov	sp, r7
 8001e1e:	bd80      	pop	{r7, pc}
 8001e20:	2000065c 	.word	0x2000065c
 8001e24:	20000660 	.word	0x20000660
 8001e28:	080024c9 	.word	0x080024c9
 8001e2c:	200007a4 	.word	0x200007a4
 8001e30:	0800240b 	.word	0x0800240b

08001e34 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
 8001e34:	b580      	push	{r7, lr}
 8001e36:	b084      	sub	sp, #16
 8001e38:	af00      	add	r7, sp, #0
 8001e3a:	6078      	str	r0, [r7, #4]
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;
 8001e3c:	687b      	ldr	r3, [r7, #4]
 8001e3e:	60fb      	str	r3, [r7, #12]

		if( pxMutexHolder != NULL )
 8001e40:	687b      	ldr	r3, [r7, #4]
 8001e42:	2b00      	cmp	r3, #0
 8001e44:	d02c      	beq.n	8001ea0 <vTaskPriorityDisinherit+0x6c>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 8001e46:	68fb      	ldr	r3, [r7, #12]
 8001e48:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001e4a:	68fb      	ldr	r3, [r7, #12]
 8001e4c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8001e4e:	429a      	cmp	r2, r3
 8001e50:	d026      	beq.n	8001ea0 <vTaskPriorityDisinherit+0x6c>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
 8001e52:	68fb      	ldr	r3, [r7, #12]
 8001e54:	3304      	adds	r3, #4
 8001e56:	4618      	mov	r0, r3
 8001e58:	4b13      	ldr	r3, [pc, #76]	; (8001ea8 <vTaskPriorityDisinherit+0x74>)
 8001e5a:	4798      	blx	r3

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
 8001e5c:	68fb      	ldr	r3, [r7, #12]
 8001e5e:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8001e60:	68fb      	ldr	r3, [r7, #12]
 8001e62:	62da      	str	r2, [r3, #44]	; 0x2c
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
 8001e64:	68fb      	ldr	r3, [r7, #12]
 8001e66:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001e68:	f1c3 020a 	rsb	r2, r3, #10
 8001e6c:	68fb      	ldr	r3, [r7, #12]
 8001e6e:	619a      	str	r2, [r3, #24]
				prvAddTaskToReadyQueue( pxTCB );
 8001e70:	68fb      	ldr	r3, [r7, #12]
 8001e72:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001e74:	4b0d      	ldr	r3, [pc, #52]	; (8001eac <vTaskPriorityDisinherit+0x78>)
 8001e76:	681b      	ldr	r3, [r3, #0]
 8001e78:	429a      	cmp	r2, r3
 8001e7a:	d903      	bls.n	8001e84 <vTaskPriorityDisinherit+0x50>
 8001e7c:	68fb      	ldr	r3, [r7, #12]
 8001e7e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001e80:	4a0a      	ldr	r2, [pc, #40]	; (8001eac <vTaskPriorityDisinherit+0x78>)
 8001e82:	6013      	str	r3, [r2, #0]
 8001e84:	68fb      	ldr	r3, [r7, #12]
 8001e86:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8001e88:	4613      	mov	r3, r2
 8001e8a:	009b      	lsls	r3, r3, #2
 8001e8c:	4413      	add	r3, r2
 8001e8e:	009b      	lsls	r3, r3, #2
 8001e90:	4a07      	ldr	r2, [pc, #28]	; (8001eb0 <vTaskPriorityDisinherit+0x7c>)
 8001e92:	441a      	add	r2, r3
 8001e94:	68fb      	ldr	r3, [r7, #12]
 8001e96:	3304      	adds	r3, #4
 8001e98:	4619      	mov	r1, r3
 8001e9a:	4610      	mov	r0, r2
 8001e9c:	4b05      	ldr	r3, [pc, #20]	; (8001eb4 <vTaskPriorityDisinherit+0x80>)
 8001e9e:	4798      	blx	r3
			}
		}
	}
 8001ea0:	bf00      	nop
 8001ea2:	3710      	adds	r7, #16
 8001ea4:	46bd      	mov	sp, r7
 8001ea6:	bd80      	pop	{r7, pc}
 8001ea8:	080024c9 	.word	0x080024c9
 8001eac:	200007a4 	.word	0x200007a4
 8001eb0:	20000660 	.word	0x20000660
 8001eb4:	0800240b 	.word	0x0800240b

08001eb8 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
 8001eb8:	b580      	push	{r7, lr}
 8001eba:	b088      	sub	sp, #32
 8001ebc:	af00      	add	r7, sp, #0
 8001ebe:	60f8      	str	r0, [r7, #12]
 8001ec0:	60b9      	str	r1, [r7, #8]
 8001ec2:	607a      	str	r2, [r7, #4]
 8001ec4:	603b      	str	r3, [r7, #0]
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 8001ec6:	2300      	movs	r3, #0
 8001ec8:	61fb      	str	r3, [r7, #28]
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
 8001eca:	4b3d      	ldr	r3, [pc, #244]	; (8001fc0 <xQueueGenericSend+0x108>)
 8001ecc:	4798      	blx	r3
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
 8001ece:	68fb      	ldr	r3, [r7, #12]
 8001ed0:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8001ed2:	68fb      	ldr	r3, [r7, #12]
 8001ed4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8001ed6:	429a      	cmp	r2, r3
 8001ed8:	d216      	bcs.n	8001f08 <xQueueGenericSend+0x50>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 8001eda:	683a      	ldr	r2, [r7, #0]
 8001edc:	68b9      	ldr	r1, [r7, #8]
 8001ede:	68f8      	ldr	r0, [r7, #12]
 8001ee0:	4b38      	ldr	r3, [pc, #224]	; (8001fc4 <xQueueGenericSend+0x10c>)
 8001ee2:	4798      	blx	r3

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 8001ee4:	68fb      	ldr	r3, [r7, #12]
 8001ee6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001ee8:	2b00      	cmp	r3, #0
 8001eea:	d009      	beq.n	8001f00 <xQueueGenericSend+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
 8001eec:	68fb      	ldr	r3, [r7, #12]
 8001eee:	3324      	adds	r3, #36	; 0x24
 8001ef0:	4618      	mov	r0, r3
 8001ef2:	4b35      	ldr	r3, [pc, #212]	; (8001fc8 <xQueueGenericSend+0x110>)
 8001ef4:	4798      	blx	r3
 8001ef6:	4603      	mov	r3, r0
 8001ef8:	2b01      	cmp	r3, #1
 8001efa:	d101      	bne.n	8001f00 <xQueueGenericSend+0x48>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
 8001efc:	4b33      	ldr	r3, [pc, #204]	; (8001fcc <xQueueGenericSend+0x114>)
 8001efe:	4798      	blx	r3
					}
				}

				taskEXIT_CRITICAL();
 8001f00:	4b33      	ldr	r3, [pc, #204]	; (8001fd0 <xQueueGenericSend+0x118>)
 8001f02:	4798      	blx	r3

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
 8001f04:	2301      	movs	r3, #1
 8001f06:	e056      	b.n	8001fb6 <xQueueGenericSend+0xfe>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
 8001f08:	687b      	ldr	r3, [r7, #4]
 8001f0a:	2b00      	cmp	r3, #0
 8001f0c:	d103      	bne.n	8001f16 <xQueueGenericSend+0x5e>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 8001f0e:	4b30      	ldr	r3, [pc, #192]	; (8001fd0 <xQueueGenericSend+0x118>)
 8001f10:	4798      	blx	r3

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
 8001f12:	2300      	movs	r3, #0
 8001f14:	e04f      	b.n	8001fb6 <xQueueGenericSend+0xfe>
				}
				else if( xEntryTimeSet == pdFALSE )
 8001f16:	69fb      	ldr	r3, [r7, #28]
 8001f18:	2b00      	cmp	r3, #0
 8001f1a:	d106      	bne.n	8001f2a <xQueueGenericSend+0x72>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
 8001f1c:	f107 0314 	add.w	r3, r7, #20
 8001f20:	4618      	mov	r0, r3
 8001f22:	4b2c      	ldr	r3, [pc, #176]	; (8001fd4 <xQueueGenericSend+0x11c>)
 8001f24:	4798      	blx	r3
					xEntryTimeSet = pdTRUE;
 8001f26:	2301      	movs	r3, #1
 8001f28:	61fb      	str	r3, [r7, #28]
				}
			}
		}
		taskEXIT_CRITICAL();
 8001f2a:	4b29      	ldr	r3, [pc, #164]	; (8001fd0 <xQueueGenericSend+0x118>)
 8001f2c:	4798      	blx	r3

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 8001f2e:	4b2a      	ldr	r3, [pc, #168]	; (8001fd8 <xQueueGenericSend+0x120>)
 8001f30:	4798      	blx	r3
		prvLockQueue( pxQueue );
 8001f32:	4b23      	ldr	r3, [pc, #140]	; (8001fc0 <xQueueGenericSend+0x108>)
 8001f34:	4798      	blx	r3
 8001f36:	68fb      	ldr	r3, [r7, #12]
 8001f38:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8001f3a:	f1b3 3fff 	cmp.w	r3, #4294967295
 8001f3e:	d102      	bne.n	8001f46 <xQueueGenericSend+0x8e>
 8001f40:	68fb      	ldr	r3, [r7, #12]
 8001f42:	2200      	movs	r2, #0
 8001f44:	645a      	str	r2, [r3, #68]	; 0x44
 8001f46:	68fb      	ldr	r3, [r7, #12]
 8001f48:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8001f4a:	f1b3 3fff 	cmp.w	r3, #4294967295
 8001f4e:	d102      	bne.n	8001f56 <xQueueGenericSend+0x9e>
 8001f50:	68fb      	ldr	r3, [r7, #12]
 8001f52:	2200      	movs	r2, #0
 8001f54:	649a      	str	r2, [r3, #72]	; 0x48
 8001f56:	4b1e      	ldr	r3, [pc, #120]	; (8001fd0 <xQueueGenericSend+0x118>)
 8001f58:	4798      	blx	r3

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 8001f5a:	1d3a      	adds	r2, r7, #4
 8001f5c:	f107 0314 	add.w	r3, r7, #20
 8001f60:	4611      	mov	r1, r2
 8001f62:	4618      	mov	r0, r3
 8001f64:	4b1d      	ldr	r3, [pc, #116]	; (8001fdc <xQueueGenericSend+0x124>)
 8001f66:	4798      	blx	r3
 8001f68:	4603      	mov	r3, r0
 8001f6a:	2b00      	cmp	r3, #0
 8001f6c:	d11d      	bne.n	8001faa <xQueueGenericSend+0xf2>
		{
			if( prvIsQueueFull( pxQueue ) )
 8001f6e:	68f8      	ldr	r0, [r7, #12]
 8001f70:	4b1b      	ldr	r3, [pc, #108]	; (8001fe0 <xQueueGenericSend+0x128>)
 8001f72:	4798      	blx	r3
 8001f74:	4603      	mov	r3, r0
 8001f76:	2b00      	cmp	r3, #0
 8001f78:	d011      	beq.n	8001f9e <xQueueGenericSend+0xe6>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 8001f7a:	68fb      	ldr	r3, [r7, #12]
 8001f7c:	3310      	adds	r3, #16
 8001f7e:	687a      	ldr	r2, [r7, #4]
 8001f80:	4611      	mov	r1, r2
 8001f82:	4618      	mov	r0, r3
 8001f84:	4b17      	ldr	r3, [pc, #92]	; (8001fe4 <xQueueGenericSend+0x12c>)
 8001f86:	4798      	blx	r3
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
 8001f88:	68f8      	ldr	r0, [r7, #12]
 8001f8a:	4b17      	ldr	r3, [pc, #92]	; (8001fe8 <xQueueGenericSend+0x130>)
 8001f8c:	4798      	blx	r3
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
 8001f8e:	4b17      	ldr	r3, [pc, #92]	; (8001fec <xQueueGenericSend+0x134>)
 8001f90:	4798      	blx	r3
 8001f92:	4603      	mov	r3, r0
 8001f94:	2b00      	cmp	r3, #0
 8001f96:	d198      	bne.n	8001eca <xQueueGenericSend+0x12>
				{
					portYIELD_WITHIN_API();
 8001f98:	4b0c      	ldr	r3, [pc, #48]	; (8001fcc <xQueueGenericSend+0x114>)
 8001f9a:	4798      	blx	r3
 8001f9c:	e795      	b.n	8001eca <xQueueGenericSend+0x12>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
 8001f9e:	68f8      	ldr	r0, [r7, #12]
 8001fa0:	4b11      	ldr	r3, [pc, #68]	; (8001fe8 <xQueueGenericSend+0x130>)
 8001fa2:	4798      	blx	r3
				( void ) xTaskResumeAll();
 8001fa4:	4b11      	ldr	r3, [pc, #68]	; (8001fec <xQueueGenericSend+0x134>)
 8001fa6:	4798      	blx	r3
 8001fa8:	e78f      	b.n	8001eca <xQueueGenericSend+0x12>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
 8001faa:	68f8      	ldr	r0, [r7, #12]
 8001fac:	4b0e      	ldr	r3, [pc, #56]	; (8001fe8 <xQueueGenericSend+0x130>)
 8001fae:	4798      	blx	r3
			( void ) xTaskResumeAll();
 8001fb0:	4b0e      	ldr	r3, [pc, #56]	; (8001fec <xQueueGenericSend+0x134>)
 8001fb2:	4798      	blx	r3

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
 8001fb4:	2300      	movs	r3, #0
		}
	}
}
 8001fb6:	4618      	mov	r0, r3
 8001fb8:	3720      	adds	r7, #32
 8001fba:	46bd      	mov	sp, r7
 8001fbc:	bd80      	pop	{r7, pc}
 8001fbe:	bf00      	nop
 8001fc0:	080025f9 	.word	0x080025f9
 8001fc4:	08002191 	.word	0x08002191
 8001fc8:	08001995 	.word	0x08001995
 8001fcc:	080025e1 	.word	0x080025e1
 8001fd0:	0800261d 	.word	0x0800261d
 8001fd4:	08001a49 	.word	0x08001a49
 8001fd8:	0800162d 	.word	0x0800162d
 8001fdc:	08001a75 	.word	0x08001a75
 8001fe0:	0800237d 	.word	0x0800237d
 8001fe4:	080018ed 	.word	0x080018ed
 8001fe8:	080022a1 	.word	0x080022a1
 8001fec:	08001649 	.word	0x08001649

08001ff0 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
 8001ff0:	b580      	push	{r7, lr}
 8001ff2:	b088      	sub	sp, #32
 8001ff4:	af00      	add	r7, sp, #0
 8001ff6:	60f8      	str	r0, [r7, #12]
 8001ff8:	60b9      	str	r1, [r7, #8]
 8001ffa:	607a      	str	r2, [r7, #4]
 8001ffc:	603b      	str	r3, [r7, #0]
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
 8001ffe:	2300      	movs	r3, #0
 8002000:	61fb      	str	r3, [r7, #28]
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
 8002002:	4b55      	ldr	r3, [pc, #340]	; (8002158 <xQueueGenericReceive+0x168>)
 8002004:	4798      	blx	r3
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
 8002006:	68fb      	ldr	r3, [r7, #12]
 8002008:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800200a:	2b00      	cmp	r3, #0
 800200c:	d03b      	beq.n	8002086 <xQueueGenericReceive+0x96>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
 800200e:	68fb      	ldr	r3, [r7, #12]
 8002010:	68db      	ldr	r3, [r3, #12]
 8002012:	61bb      	str	r3, [r7, #24]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
 8002014:	68b9      	ldr	r1, [r7, #8]
 8002016:	68f8      	ldr	r0, [r7, #12]
 8002018:	4b50      	ldr	r3, [pc, #320]	; (800215c <xQueueGenericReceive+0x16c>)
 800201a:	4798      	blx	r3

				if( xJustPeeking == pdFALSE )
 800201c:	683b      	ldr	r3, [r7, #0]
 800201e:	2b00      	cmp	r3, #0
 8002020:	d11c      	bne.n	800205c <xQueueGenericReceive+0x6c>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
 8002022:	68fb      	ldr	r3, [r7, #12]
 8002024:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8002026:	1e5a      	subs	r2, r3, #1
 8002028:	68fb      	ldr	r3, [r7, #12]
 800202a:	639a      	str	r2, [r3, #56]	; 0x38

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 800202c:	68fb      	ldr	r3, [r7, #12]
 800202e:	681b      	ldr	r3, [r3, #0]
 8002030:	2b00      	cmp	r3, #0
 8002032:	d104      	bne.n	800203e <xQueueGenericReceive+0x4e>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
 8002034:	4b4a      	ldr	r3, [pc, #296]	; (8002160 <xQueueGenericReceive+0x170>)
 8002036:	4798      	blx	r3
 8002038:	4602      	mov	r2, r0
 800203a:	68fb      	ldr	r3, [r7, #12]
 800203c:	605a      	str	r2, [r3, #4]
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 800203e:	68fb      	ldr	r3, [r7, #12]
 8002040:	691b      	ldr	r3, [r3, #16]
 8002042:	2b00      	cmp	r3, #0
 8002044:	d01b      	beq.n	800207e <xQueueGenericReceive+0x8e>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
 8002046:	68fb      	ldr	r3, [r7, #12]
 8002048:	3310      	adds	r3, #16
 800204a:	4618      	mov	r0, r3
 800204c:	4b45      	ldr	r3, [pc, #276]	; (8002164 <xQueueGenericReceive+0x174>)
 800204e:	4798      	blx	r3
 8002050:	4603      	mov	r3, r0
 8002052:	2b01      	cmp	r3, #1
 8002054:	d113      	bne.n	800207e <xQueueGenericReceive+0x8e>
						{
							portYIELD_WITHIN_API();
 8002056:	4b44      	ldr	r3, [pc, #272]	; (8002168 <xQueueGenericReceive+0x178>)
 8002058:	4798      	blx	r3
 800205a:	e010      	b.n	800207e <xQueueGenericReceive+0x8e>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
 800205c:	68fb      	ldr	r3, [r7, #12]
 800205e:	69ba      	ldr	r2, [r7, #24]
 8002060:	60da      	str	r2, [r3, #12]

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
 8002062:	68fb      	ldr	r3, [r7, #12]
 8002064:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8002066:	2b00      	cmp	r3, #0
 8002068:	d009      	beq.n	800207e <xQueueGenericReceive+0x8e>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 800206a:	68fb      	ldr	r3, [r7, #12]
 800206c:	3324      	adds	r3, #36	; 0x24
 800206e:	4618      	mov	r0, r3
 8002070:	4b3c      	ldr	r3, [pc, #240]	; (8002164 <xQueueGenericReceive+0x174>)
 8002072:	4798      	blx	r3
 8002074:	4603      	mov	r3, r0
 8002076:	2b00      	cmp	r3, #0
 8002078:	d001      	beq.n	800207e <xQueueGenericReceive+0x8e>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
 800207a:	4b3b      	ldr	r3, [pc, #236]	; (8002168 <xQueueGenericReceive+0x178>)
 800207c:	4798      	blx	r3
						}
					}

				}

				taskEXIT_CRITICAL();
 800207e:	4b3b      	ldr	r3, [pc, #236]	; (800216c <xQueueGenericReceive+0x17c>)
 8002080:	4798      	blx	r3
				return pdPASS;
 8002082:	2301      	movs	r3, #1
 8002084:	e064      	b.n	8002150 <xQueueGenericReceive+0x160>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
 8002086:	687b      	ldr	r3, [r7, #4]
 8002088:	2b00      	cmp	r3, #0
 800208a:	d103      	bne.n	8002094 <xQueueGenericReceive+0xa4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 800208c:	4b37      	ldr	r3, [pc, #220]	; (800216c <xQueueGenericReceive+0x17c>)
 800208e:	4798      	blx	r3
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
 8002090:	2300      	movs	r3, #0
 8002092:	e05d      	b.n	8002150 <xQueueGenericReceive+0x160>
				}
				else if( xEntryTimeSet == pdFALSE )
 8002094:	69fb      	ldr	r3, [r7, #28]
 8002096:	2b00      	cmp	r3, #0
 8002098:	d106      	bne.n	80020a8 <xQueueGenericReceive+0xb8>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
 800209a:	f107 0310 	add.w	r3, r7, #16
 800209e:	4618      	mov	r0, r3
 80020a0:	4b33      	ldr	r3, [pc, #204]	; (8002170 <xQueueGenericReceive+0x180>)
 80020a2:	4798      	blx	r3
					xEntryTimeSet = pdTRUE;
 80020a4:	2301      	movs	r3, #1
 80020a6:	61fb      	str	r3, [r7, #28]
				}
			}
		}
		taskEXIT_CRITICAL();
 80020a8:	4b30      	ldr	r3, [pc, #192]	; (800216c <xQueueGenericReceive+0x17c>)
 80020aa:	4798      	blx	r3

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 80020ac:	4b31      	ldr	r3, [pc, #196]	; (8002174 <xQueueGenericReceive+0x184>)
 80020ae:	4798      	blx	r3
		prvLockQueue( pxQueue );
 80020b0:	4b29      	ldr	r3, [pc, #164]	; (8002158 <xQueueGenericReceive+0x168>)
 80020b2:	4798      	blx	r3
 80020b4:	68fb      	ldr	r3, [r7, #12]
 80020b6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80020b8:	f1b3 3fff 	cmp.w	r3, #4294967295
 80020bc:	d102      	bne.n	80020c4 <xQueueGenericReceive+0xd4>
 80020be:	68fb      	ldr	r3, [r7, #12]
 80020c0:	2200      	movs	r2, #0
 80020c2:	645a      	str	r2, [r3, #68]	; 0x44
 80020c4:	68fb      	ldr	r3, [r7, #12]
 80020c6:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80020c8:	f1b3 3fff 	cmp.w	r3, #4294967295
 80020cc:	d102      	bne.n	80020d4 <xQueueGenericReceive+0xe4>
 80020ce:	68fb      	ldr	r3, [r7, #12]
 80020d0:	2200      	movs	r2, #0
 80020d2:	649a      	str	r2, [r3, #72]	; 0x48
 80020d4:	4b25      	ldr	r3, [pc, #148]	; (800216c <xQueueGenericReceive+0x17c>)
 80020d6:	4798      	blx	r3

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 80020d8:	1d3a      	adds	r2, r7, #4
 80020da:	f107 0310 	add.w	r3, r7, #16
 80020de:	4611      	mov	r1, r2
 80020e0:	4618      	mov	r0, r3
 80020e2:	4b25      	ldr	r3, [pc, #148]	; (8002178 <xQueueGenericReceive+0x188>)
 80020e4:	4798      	blx	r3
 80020e6:	4603      	mov	r3, r0
 80020e8:	2b00      	cmp	r3, #0
 80020ea:	d12b      	bne.n	8002144 <xQueueGenericReceive+0x154>
		{
			if( prvIsQueueEmpty( pxQueue ) )
 80020ec:	68f8      	ldr	r0, [r7, #12]
 80020ee:	4b23      	ldr	r3, [pc, #140]	; (800217c <xQueueGenericReceive+0x18c>)
 80020f0:	4798      	blx	r3
 80020f2:	4603      	mov	r3, r0
 80020f4:	2b00      	cmp	r3, #0
 80020f6:	d01f      	beq.n	8002138 <xQueueGenericReceive+0x148>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 80020f8:	68fb      	ldr	r3, [r7, #12]
 80020fa:	681b      	ldr	r3, [r3, #0]
 80020fc:	2b00      	cmp	r3, #0
 80020fe:	d108      	bne.n	8002112 <xQueueGenericReceive+0x122>
					{
						portENTER_CRITICAL();
 8002100:	4b15      	ldr	r3, [pc, #84]	; (8002158 <xQueueGenericReceive+0x168>)
 8002102:	4798      	blx	r3
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
 8002104:	68fb      	ldr	r3, [r7, #12]
 8002106:	685b      	ldr	r3, [r3, #4]
 8002108:	4618      	mov	r0, r3
 800210a:	4b1d      	ldr	r3, [pc, #116]	; (8002180 <xQueueGenericReceive+0x190>)
 800210c:	4798      	blx	r3
						}
						portEXIT_CRITICAL();
 800210e:	4b17      	ldr	r3, [pc, #92]	; (800216c <xQueueGenericReceive+0x17c>)
 8002110:	4798      	blx	r3
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 8002112:	68fb      	ldr	r3, [r7, #12]
 8002114:	3324      	adds	r3, #36	; 0x24
 8002116:	687a      	ldr	r2, [r7, #4]
 8002118:	4611      	mov	r1, r2
 800211a:	4618      	mov	r0, r3
 800211c:	4b19      	ldr	r3, [pc, #100]	; (8002184 <xQueueGenericReceive+0x194>)
 800211e:	4798      	blx	r3
				prvUnlockQueue( pxQueue );
 8002120:	68f8      	ldr	r0, [r7, #12]
 8002122:	4b19      	ldr	r3, [pc, #100]	; (8002188 <xQueueGenericReceive+0x198>)
 8002124:	4798      	blx	r3
				if( !xTaskResumeAll() )
 8002126:	4b19      	ldr	r3, [pc, #100]	; (800218c <xQueueGenericReceive+0x19c>)
 8002128:	4798      	blx	r3
 800212a:	4603      	mov	r3, r0
 800212c:	2b00      	cmp	r3, #0
 800212e:	f47f af68 	bne.w	8002002 <xQueueGenericReceive+0x12>
				{
					portYIELD_WITHIN_API();
 8002132:	4b0d      	ldr	r3, [pc, #52]	; (8002168 <xQueueGenericReceive+0x178>)
 8002134:	4798      	blx	r3
 8002136:	e764      	b.n	8002002 <xQueueGenericReceive+0x12>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
 8002138:	68f8      	ldr	r0, [r7, #12]
 800213a:	4b13      	ldr	r3, [pc, #76]	; (8002188 <xQueueGenericReceive+0x198>)
 800213c:	4798      	blx	r3
				( void ) xTaskResumeAll();
 800213e:	4b13      	ldr	r3, [pc, #76]	; (800218c <xQueueGenericReceive+0x19c>)
 8002140:	4798      	blx	r3
 8002142:	e75e      	b.n	8002002 <xQueueGenericReceive+0x12>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
 8002144:	68f8      	ldr	r0, [r7, #12]
 8002146:	4b10      	ldr	r3, [pc, #64]	; (8002188 <xQueueGenericReceive+0x198>)
 8002148:	4798      	blx	r3
			( void ) xTaskResumeAll();
 800214a:	4b10      	ldr	r3, [pc, #64]	; (800218c <xQueueGenericReceive+0x19c>)
 800214c:	4798      	blx	r3
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
 800214e:	2300      	movs	r3, #0
		}
	}
}
 8002150:	4618      	mov	r0, r3
 8002152:	3720      	adds	r7, #32
 8002154:	46bd      	mov	sp, r7
 8002156:	bd80      	pop	{r7, pc}
 8002158:	080025f9 	.word	0x080025f9
 800215c:	08002251 	.word	0x08002251
 8002160:	08001d6d 	.word	0x08001d6d
 8002164:	08001995 	.word	0x08001995
 8002168:	080025e1 	.word	0x080025e1
 800216c:	0800261d 	.word	0x0800261d
 8002170:	08001a49 	.word	0x08001a49
 8002174:	0800162d 	.word	0x0800162d
 8002178:	08001a75 	.word	0x08001a75
 800217c:	08002349 	.word	0x08002349
 8002180:	08001d89 	.word	0x08001d89
 8002184:	080018ed 	.word	0x080018ed
 8002188:	080022a1 	.word	0x080022a1
 800218c:	08001649 	.word	0x08001649

08002190 <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
 8002190:	b580      	push	{r7, lr}
 8002192:	b084      	sub	sp, #16
 8002194:	af00      	add	r7, sp, #0
 8002196:	60f8      	str	r0, [r7, #12]
 8002198:	60b9      	str	r1, [r7, #8]
 800219a:	607a      	str	r2, [r7, #4]
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
 800219c:	68fb      	ldr	r3, [r7, #12]
 800219e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80021a0:	2b00      	cmp	r3, #0
 80021a2:	d10c      	bne.n	80021be <prvCopyDataToQueue+0x2e>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 80021a4:	68fb      	ldr	r3, [r7, #12]
 80021a6:	681b      	ldr	r3, [r3, #0]
 80021a8:	2b00      	cmp	r3, #0
 80021aa:	d143      	bne.n	8002234 <prvCopyDataToQueue+0xa4>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
 80021ac:	68fb      	ldr	r3, [r7, #12]
 80021ae:	685b      	ldr	r3, [r3, #4]
 80021b0:	4618      	mov	r0, r3
 80021b2:	4b25      	ldr	r3, [pc, #148]	; (8002248 <prvCopyDataToQueue+0xb8>)
 80021b4:	4798      	blx	r3
				pxQueue->pxMutexHolder = NULL;
 80021b6:	68fb      	ldr	r3, [r7, #12]
 80021b8:	2200      	movs	r2, #0
 80021ba:	605a      	str	r2, [r3, #4]
 80021bc:	e03a      	b.n	8002234 <prvCopyDataToQueue+0xa4>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
 80021be:	687b      	ldr	r3, [r7, #4]
 80021c0:	2b00      	cmp	r3, #0
 80021c2:	d119      	bne.n	80021f8 <prvCopyDataToQueue+0x68>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
 80021c4:	68fb      	ldr	r3, [r7, #12]
 80021c6:	6898      	ldr	r0, [r3, #8]
 80021c8:	68fb      	ldr	r3, [r7, #12]
 80021ca:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80021cc:	461a      	mov	r2, r3
 80021ce:	68b9      	ldr	r1, [r7, #8]
 80021d0:	4b1e      	ldr	r3, [pc, #120]	; (800224c <prvCopyDataToQueue+0xbc>)
 80021d2:	4798      	blx	r3
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
 80021d4:	68fb      	ldr	r3, [r7, #12]
 80021d6:	689a      	ldr	r2, [r3, #8]
 80021d8:	68fb      	ldr	r3, [r7, #12]
 80021da:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80021dc:	441a      	add	r2, r3
 80021de:	68fb      	ldr	r3, [r7, #12]
 80021e0:	609a      	str	r2, [r3, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
 80021e2:	68fb      	ldr	r3, [r7, #12]
 80021e4:	689a      	ldr	r2, [r3, #8]
 80021e6:	68fb      	ldr	r3, [r7, #12]
 80021e8:	685b      	ldr	r3, [r3, #4]
 80021ea:	429a      	cmp	r2, r3
 80021ec:	d322      	bcc.n	8002234 <prvCopyDataToQueue+0xa4>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
 80021ee:	68fb      	ldr	r3, [r7, #12]
 80021f0:	681a      	ldr	r2, [r3, #0]
 80021f2:	68fb      	ldr	r3, [r7, #12]
 80021f4:	609a      	str	r2, [r3, #8]
 80021f6:	e01d      	b.n	8002234 <prvCopyDataToQueue+0xa4>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
 80021f8:	68fb      	ldr	r3, [r7, #12]
 80021fa:	68d8      	ldr	r0, [r3, #12]
 80021fc:	68fb      	ldr	r3, [r7, #12]
 80021fe:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8002200:	461a      	mov	r2, r3
 8002202:	68b9      	ldr	r1, [r7, #8]
 8002204:	4b11      	ldr	r3, [pc, #68]	; (800224c <prvCopyDataToQueue+0xbc>)
 8002206:	4798      	blx	r3
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
 8002208:	68fb      	ldr	r3, [r7, #12]
 800220a:	68da      	ldr	r2, [r3, #12]
 800220c:	68fb      	ldr	r3, [r7, #12]
 800220e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8002210:	425b      	negs	r3, r3
 8002212:	441a      	add	r2, r3
 8002214:	68fb      	ldr	r3, [r7, #12]
 8002216:	60da      	str	r2, [r3, #12]
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
 8002218:	68fb      	ldr	r3, [r7, #12]
 800221a:	68da      	ldr	r2, [r3, #12]
 800221c:	68fb      	ldr	r3, [r7, #12]
 800221e:	681b      	ldr	r3, [r3, #0]
 8002220:	429a      	cmp	r2, r3
 8002222:	d207      	bcs.n	8002234 <prvCopyDataToQueue+0xa4>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
 8002224:	68fb      	ldr	r3, [r7, #12]
 8002226:	685a      	ldr	r2, [r3, #4]
 8002228:	68fb      	ldr	r3, [r7, #12]
 800222a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800222c:	425b      	negs	r3, r3
 800222e:	441a      	add	r2, r3
 8002230:	68fb      	ldr	r3, [r7, #12]
 8002232:	60da      	str	r2, [r3, #12]
		}
	}

	++( pxQueue->uxMessagesWaiting );
 8002234:	68fb      	ldr	r3, [r7, #12]
 8002236:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8002238:	1c5a      	adds	r2, r3, #1
 800223a:	68fb      	ldr	r3, [r7, #12]
 800223c:	639a      	str	r2, [r3, #56]	; 0x38
}
 800223e:	bf00      	nop
 8002240:	3710      	adds	r7, #16
 8002242:	46bd      	mov	sp, r7
 8002244:	bd80      	pop	{r7, pc}
 8002246:	bf00      	nop
 8002248:	08001e35 	.word	0x08001e35
 800224c:	08000009 	.word	0x08000009

08002250 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
 8002250:	b580      	push	{r7, lr}
 8002252:	b082      	sub	sp, #8
 8002254:	af00      	add	r7, sp, #0
 8002256:	6078      	str	r0, [r7, #4]
 8002258:	6039      	str	r1, [r7, #0]
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
 800225a:	687b      	ldr	r3, [r7, #4]
 800225c:	681b      	ldr	r3, [r3, #0]
 800225e:	2b00      	cmp	r3, #0
 8002260:	d018      	beq.n	8002294 <prvCopyDataFromQueue+0x44>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
 8002262:	687b      	ldr	r3, [r7, #4]
 8002264:	68da      	ldr	r2, [r3, #12]
 8002266:	687b      	ldr	r3, [r7, #4]
 8002268:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800226a:	441a      	add	r2, r3
 800226c:	687b      	ldr	r3, [r7, #4]
 800226e:	60da      	str	r2, [r3, #12]
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
 8002270:	687b      	ldr	r3, [r7, #4]
 8002272:	68da      	ldr	r2, [r3, #12]
 8002274:	687b      	ldr	r3, [r7, #4]
 8002276:	685b      	ldr	r3, [r3, #4]
 8002278:	429a      	cmp	r2, r3
 800227a:	d303      	bcc.n	8002284 <prvCopyDataFromQueue+0x34>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
 800227c:	687b      	ldr	r3, [r7, #4]
 800227e:	681a      	ldr	r2, [r3, #0]
 8002280:	687b      	ldr	r3, [r7, #4]
 8002282:	60da      	str	r2, [r3, #12]
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
 8002284:	687b      	ldr	r3, [r7, #4]
 8002286:	68d9      	ldr	r1, [r3, #12]
 8002288:	687b      	ldr	r3, [r7, #4]
 800228a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800228c:	461a      	mov	r2, r3
 800228e:	6838      	ldr	r0, [r7, #0]
 8002290:	4b02      	ldr	r3, [pc, #8]	; (800229c <prvCopyDataFromQueue+0x4c>)
 8002292:	4798      	blx	r3
	}
}
 8002294:	bf00      	nop
 8002296:	3708      	adds	r7, #8
 8002298:	46bd      	mov	sp, r7
 800229a:	bd80      	pop	{r7, pc}
 800229c:	08000009 	.word	0x08000009

080022a0 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
 80022a0:	b580      	push	{r7, lr}
 80022a2:	b082      	sub	sp, #8
 80022a4:	af00      	add	r7, sp, #0
 80022a6:	6078      	str	r0, [r7, #4]

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
 80022a8:	4b23      	ldr	r3, [pc, #140]	; (8002338 <prvUnlockQueue+0x98>)
 80022aa:	4798      	blx	r3
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 80022ac:	e012      	b.n	80022d4 <prvUnlockQueue+0x34>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) )
 80022ae:	687b      	ldr	r3, [r7, #4]
 80022b0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80022b2:	2b00      	cmp	r3, #0
 80022b4:	d013      	beq.n	80022de <prvUnlockQueue+0x3e>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 80022b6:	687b      	ldr	r3, [r7, #4]
 80022b8:	3324      	adds	r3, #36	; 0x24
 80022ba:	4618      	mov	r0, r3
 80022bc:	4b1f      	ldr	r3, [pc, #124]	; (800233c <prvUnlockQueue+0x9c>)
 80022be:	4798      	blx	r3
 80022c0:	4603      	mov	r3, r0
 80022c2:	2b00      	cmp	r3, #0
 80022c4:	d001      	beq.n	80022ca <prvUnlockQueue+0x2a>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
 80022c6:	4b1e      	ldr	r3, [pc, #120]	; (8002340 <prvUnlockQueue+0xa0>)
 80022c8:	4798      	blx	r3
				}

				--( pxQueue->xTxLock );
 80022ca:	687b      	ldr	r3, [r7, #4]
 80022cc:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80022ce:	1e5a      	subs	r2, r3, #1
 80022d0:	687b      	ldr	r3, [r7, #4]
 80022d2:	649a      	str	r2, [r3, #72]	; 0x48
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
 80022d4:	687b      	ldr	r3, [r7, #4]
 80022d6:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80022d8:	2b00      	cmp	r3, #0
 80022da:	dce8      	bgt.n	80022ae <prvUnlockQueue+0xe>
 80022dc:	e000      	b.n	80022e0 <prvUnlockQueue+0x40>
			}
			else
			{
				break;
 80022de:	bf00      	nop
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
 80022e0:	687b      	ldr	r3, [r7, #4]
 80022e2:	f04f 32ff 	mov.w	r2, #4294967295
 80022e6:	649a      	str	r2, [r3, #72]	; 0x48
	}
	taskEXIT_CRITICAL();
 80022e8:	4b16      	ldr	r3, [pc, #88]	; (8002344 <prvUnlockQueue+0xa4>)
 80022ea:	4798      	blx	r3

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
 80022ec:	4b12      	ldr	r3, [pc, #72]	; (8002338 <prvUnlockQueue+0x98>)
 80022ee:	4798      	blx	r3
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 80022f0:	e012      	b.n	8002318 <prvUnlockQueue+0x78>
		{
			if( !listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) )
 80022f2:	687b      	ldr	r3, [r7, #4]
 80022f4:	691b      	ldr	r3, [r3, #16]
 80022f6:	2b00      	cmp	r3, #0
 80022f8:	d013      	beq.n	8002322 <prvUnlockQueue+0x82>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 80022fa:	687b      	ldr	r3, [r7, #4]
 80022fc:	3310      	adds	r3, #16
 80022fe:	4618      	mov	r0, r3
 8002300:	4b0e      	ldr	r3, [pc, #56]	; (800233c <prvUnlockQueue+0x9c>)
 8002302:	4798      	blx	r3
 8002304:	4603      	mov	r3, r0
 8002306:	2b00      	cmp	r3, #0
 8002308:	d001      	beq.n	800230e <prvUnlockQueue+0x6e>
				{
					vTaskMissedYield();
 800230a:	4b0d      	ldr	r3, [pc, #52]	; (8002340 <prvUnlockQueue+0xa0>)
 800230c:	4798      	blx	r3
				}

				--( pxQueue->xRxLock );
 800230e:	687b      	ldr	r3, [r7, #4]
 8002310:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8002312:	1e5a      	subs	r2, r3, #1
 8002314:	687b      	ldr	r3, [r7, #4]
 8002316:	645a      	str	r2, [r3, #68]	; 0x44
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
 8002318:	687b      	ldr	r3, [r7, #4]
 800231a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800231c:	2b00      	cmp	r3, #0
 800231e:	dce8      	bgt.n	80022f2 <prvUnlockQueue+0x52>
 8002320:	e000      	b.n	8002324 <prvUnlockQueue+0x84>
			}
			else
			{
				break;
 8002322:	bf00      	nop
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
 8002324:	687b      	ldr	r3, [r7, #4]
 8002326:	f04f 32ff 	mov.w	r2, #4294967295
 800232a:	645a      	str	r2, [r3, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
 800232c:	4b05      	ldr	r3, [pc, #20]	; (8002344 <prvUnlockQueue+0xa4>)
 800232e:	4798      	blx	r3
}
 8002330:	bf00      	nop
 8002332:	3708      	adds	r7, #8
 8002334:	46bd      	mov	sp, r7
 8002336:	bd80      	pop	{r7, pc}
 8002338:	080025f9 	.word	0x080025f9
 800233c:	08001995 	.word	0x08001995
 8002340:	08001b09 	.word	0x08001b09
 8002344:	0800261d 	.word	0x0800261d

08002348 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
 8002348:	b580      	push	{r7, lr}
 800234a:	b084      	sub	sp, #16
 800234c:	af00      	add	r7, sp, #0
 800234e:	6078      	str	r0, [r7, #4]
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
 8002350:	4b08      	ldr	r3, [pc, #32]	; (8002374 <prvIsQueueEmpty+0x2c>)
 8002352:	4798      	blx	r3
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
 8002354:	687b      	ldr	r3, [r7, #4]
 8002356:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8002358:	2b00      	cmp	r3, #0
 800235a:	bf0c      	ite	eq
 800235c:	2301      	moveq	r3, #1
 800235e:	2300      	movne	r3, #0
 8002360:	b2db      	uxtb	r3, r3
 8002362:	60fb      	str	r3, [r7, #12]
	taskEXIT_CRITICAL();
 8002364:	4b04      	ldr	r3, [pc, #16]	; (8002378 <prvIsQueueEmpty+0x30>)
 8002366:	4798      	blx	r3

	return xReturn;
 8002368:	68fb      	ldr	r3, [r7, #12]
}
 800236a:	4618      	mov	r0, r3
 800236c:	3710      	adds	r7, #16
 800236e:	46bd      	mov	sp, r7
 8002370:	bd80      	pop	{r7, pc}
 8002372:	bf00      	nop
 8002374:	080025f9 	.word	0x080025f9
 8002378:	0800261d 	.word	0x0800261d

0800237c <prvIsQueueFull>:
	return xReturn;
}
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
 800237c:	b580      	push	{r7, lr}
 800237e:	b084      	sub	sp, #16
 8002380:	af00      	add	r7, sp, #0
 8002382:	6078      	str	r0, [r7, #4]
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
 8002384:	4b09      	ldr	r3, [pc, #36]	; (80023ac <prvIsQueueFull+0x30>)
 8002386:	4798      	blx	r3
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
 8002388:	687b      	ldr	r3, [r7, #4]
 800238a:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800238c:	687b      	ldr	r3, [r7, #4]
 800238e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8002390:	429a      	cmp	r2, r3
 8002392:	bf0c      	ite	eq
 8002394:	2301      	moveq	r3, #1
 8002396:	2300      	movne	r3, #0
 8002398:	b2db      	uxtb	r3, r3
 800239a:	60fb      	str	r3, [r7, #12]
	taskEXIT_CRITICAL();
 800239c:	4b04      	ldr	r3, [pc, #16]	; (80023b0 <prvIsQueueFull+0x34>)
 800239e:	4798      	blx	r3

	return xReturn;
 80023a0:	68fb      	ldr	r3, [r7, #12]
}
 80023a2:	4618      	mov	r0, r3
 80023a4:	3710      	adds	r7, #16
 80023a6:	46bd      	mov	sp, r7
 80023a8:	bd80      	pop	{r7, pc}
 80023aa:	bf00      	nop
 80023ac:	080025f9 	.word	0x080025f9
 80023b0:	0800261d 	.word	0x0800261d

080023b4 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
 80023b4:	b480      	push	{r7}
 80023b6:	b083      	sub	sp, #12
 80023b8:	af00      	add	r7, sp, #0
 80023ba:	6078      	str	r0, [r7, #4]
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
 80023bc:	687b      	ldr	r3, [r7, #4]
 80023be:	f103 0208 	add.w	r2, r3, #8
 80023c2:	687b      	ldr	r3, [r7, #4]
 80023c4:	605a      	str	r2, [r3, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 80023c6:	687b      	ldr	r3, [r7, #4]
 80023c8:	f04f 32ff 	mov.w	r2, #4294967295
 80023cc:	609a      	str	r2, [r3, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
 80023ce:	687b      	ldr	r3, [r7, #4]
 80023d0:	f103 0208 	add.w	r2, r3, #8
 80023d4:	687b      	ldr	r3, [r7, #4]
 80023d6:	60da      	str	r2, [r3, #12]
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
 80023d8:	687b      	ldr	r3, [r7, #4]
 80023da:	f103 0208 	add.w	r2, r3, #8
 80023de:	687b      	ldr	r3, [r7, #4]
 80023e0:	611a      	str	r2, [r3, #16]

	pxList->uxNumberOfItems = 0;
 80023e2:	687b      	ldr	r3, [r7, #4]
 80023e4:	2200      	movs	r2, #0
 80023e6:	601a      	str	r2, [r3, #0]
}
 80023e8:	bf00      	nop
 80023ea:	370c      	adds	r7, #12
 80023ec:	46bd      	mov	sp, r7
 80023ee:	bc80      	pop	{r7}
 80023f0:	4770      	bx	lr

080023f2 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
 80023f2:	b480      	push	{r7}
 80023f4:	b083      	sub	sp, #12
 80023f6:	af00      	add	r7, sp, #0
 80023f8:	6078      	str	r0, [r7, #4]
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 80023fa:	687b      	ldr	r3, [r7, #4]
 80023fc:	2200      	movs	r2, #0
 80023fe:	611a      	str	r2, [r3, #16]
}
 8002400:	bf00      	nop
 8002402:	370c      	adds	r7, #12
 8002404:	46bd      	mov	sp, r7
 8002406:	bc80      	pop	{r7}
 8002408:	4770      	bx	lr

0800240a <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
 800240a:	b480      	push	{r7}
 800240c:	b085      	sub	sp, #20
 800240e:	af00      	add	r7, sp, #0
 8002410:	6078      	str	r0, [r7, #4]
 8002412:	6039      	str	r1, [r7, #0]

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
 8002414:	687b      	ldr	r3, [r7, #4]
 8002416:	685b      	ldr	r3, [r3, #4]
 8002418:	60fb      	str	r3, [r7, #12]

	pxNewListItem->pxNext = pxIndex->pxNext;
 800241a:	68fb      	ldr	r3, [r7, #12]
 800241c:	685a      	ldr	r2, [r3, #4]
 800241e:	683b      	ldr	r3, [r7, #0]
 8002420:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxList->pxIndex;
 8002422:	687b      	ldr	r3, [r7, #4]
 8002424:	685a      	ldr	r2, [r3, #4]
 8002426:	683b      	ldr	r3, [r7, #0]
 8002428:	609a      	str	r2, [r3, #8]
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
 800242a:	68fb      	ldr	r3, [r7, #12]
 800242c:	685b      	ldr	r3, [r3, #4]
 800242e:	683a      	ldr	r2, [r7, #0]
 8002430:	609a      	str	r2, [r3, #8]
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
 8002432:	68fb      	ldr	r3, [r7, #12]
 8002434:	683a      	ldr	r2, [r7, #0]
 8002436:	605a      	str	r2, [r3, #4]
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
 8002438:	687b      	ldr	r3, [r7, #4]
 800243a:	683a      	ldr	r2, [r7, #0]
 800243c:	605a      	str	r2, [r3, #4]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 800243e:	683b      	ldr	r3, [r7, #0]
 8002440:	687a      	ldr	r2, [r7, #4]
 8002442:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
 8002444:	687b      	ldr	r3, [r7, #4]
 8002446:	681b      	ldr	r3, [r3, #0]
 8002448:	1c5a      	adds	r2, r3, #1
 800244a:	687b      	ldr	r3, [r7, #4]
 800244c:	601a      	str	r2, [r3, #0]
}
 800244e:	bf00      	nop
 8002450:	3714      	adds	r7, #20
 8002452:	46bd      	mov	sp, r7
 8002454:	bc80      	pop	{r7}
 8002456:	4770      	bx	lr

08002458 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
 8002458:	b480      	push	{r7}
 800245a:	b085      	sub	sp, #20
 800245c:	af00      	add	r7, sp, #0
 800245e:	6078      	str	r0, [r7, #4]
 8002460:	6039      	str	r1, [r7, #0]
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
 8002462:	683b      	ldr	r3, [r7, #0]
 8002464:	681b      	ldr	r3, [r3, #0]
 8002466:	60bb      	str	r3, [r7, #8]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as 
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the 
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 8002468:	68bb      	ldr	r3, [r7, #8]
 800246a:	f1b3 3fff 	cmp.w	r3, #4294967295
 800246e:	d103      	bne.n	8002478 <vListInsert+0x20>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 8002470:	687b      	ldr	r3, [r7, #4]
 8002472:	691b      	ldr	r3, [r3, #16]
 8002474:	60fb      	str	r3, [r7, #12]
 8002476:	e00c      	b.n	8002492 <vListInsert+0x3a>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips. 
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
 8002478:	687b      	ldr	r3, [r7, #4]
 800247a:	3308      	adds	r3, #8
 800247c:	60fb      	str	r3, [r7, #12]
 800247e:	e002      	b.n	8002486 <vListInsert+0x2e>
 8002480:	68fb      	ldr	r3, [r7, #12]
 8002482:	685b      	ldr	r3, [r3, #4]
 8002484:	60fb      	str	r3, [r7, #12]
 8002486:	68fb      	ldr	r3, [r7, #12]
 8002488:	685b      	ldr	r3, [r3, #4]
 800248a:	681b      	ldr	r3, [r3, #0]
 800248c:	68ba      	ldr	r2, [r7, #8]
 800248e:	429a      	cmp	r2, r3
 8002490:	d2f6      	bcs.n	8002480 <vListInsert+0x28>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 8002492:	68fb      	ldr	r3, [r7, #12]
 8002494:	685a      	ldr	r2, [r3, #4]
 8002496:	683b      	ldr	r3, [r7, #0]
 8002498:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
 800249a:	683b      	ldr	r3, [r7, #0]
 800249c:	685b      	ldr	r3, [r3, #4]
 800249e:	683a      	ldr	r2, [r7, #0]
 80024a0:	609a      	str	r2, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
 80024a2:	683b      	ldr	r3, [r7, #0]
 80024a4:	68fa      	ldr	r2, [r7, #12]
 80024a6:	609a      	str	r2, [r3, #8]
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
 80024a8:	68fb      	ldr	r3, [r7, #12]
 80024aa:	683a      	ldr	r2, [r7, #0]
 80024ac:	605a      	str	r2, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 80024ae:	683b      	ldr	r3, [r7, #0]
 80024b0:	687a      	ldr	r2, [r7, #4]
 80024b2:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
 80024b4:	687b      	ldr	r3, [r7, #4]
 80024b6:	681b      	ldr	r3, [r3, #0]
 80024b8:	1c5a      	adds	r2, r3, #1
 80024ba:	687b      	ldr	r3, [r7, #4]
 80024bc:	601a      	str	r2, [r3, #0]
}
 80024be:	bf00      	nop
 80024c0:	3714      	adds	r7, #20
 80024c2:	46bd      	mov	sp, r7
 80024c4:	bc80      	pop	{r7}
 80024c6:	4770      	bx	lr

080024c8 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
 80024c8:	b480      	push	{r7}
 80024ca:	b085      	sub	sp, #20
 80024cc:	af00      	add	r7, sp, #0
 80024ce:	6078      	str	r0, [r7, #4]
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 80024d0:	687b      	ldr	r3, [r7, #4]
 80024d2:	685b      	ldr	r3, [r3, #4]
 80024d4:	687a      	ldr	r2, [r7, #4]
 80024d6:	6892      	ldr	r2, [r2, #8]
 80024d8:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 80024da:	687b      	ldr	r3, [r7, #4]
 80024dc:	689b      	ldr	r3, [r3, #8]
 80024de:	687a      	ldr	r2, [r7, #4]
 80024e0:	6852      	ldr	r2, [r2, #4]
 80024e2:	605a      	str	r2, [r3, #4]
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
 80024e4:	687b      	ldr	r3, [r7, #4]
 80024e6:	691b      	ldr	r3, [r3, #16]
 80024e8:	60fb      	str	r3, [r7, #12]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 80024ea:	68fb      	ldr	r3, [r7, #12]
 80024ec:	685b      	ldr	r3, [r3, #4]
 80024ee:	687a      	ldr	r2, [r7, #4]
 80024f0:	429a      	cmp	r2, r3
 80024f2:	d103      	bne.n	80024fc <vListRemove+0x34>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 80024f4:	687b      	ldr	r3, [r7, #4]
 80024f6:	689a      	ldr	r2, [r3, #8]
 80024f8:	68fb      	ldr	r3, [r7, #12]
 80024fa:	605a      	str	r2, [r3, #4]
	}

	pxItemToRemove->pvContainer = NULL;
 80024fc:	687b      	ldr	r3, [r7, #4]
 80024fe:	2200      	movs	r2, #0
 8002500:	611a      	str	r2, [r3, #16]
	( pxList->uxNumberOfItems )--;
 8002502:	68fb      	ldr	r3, [r7, #12]
 8002504:	681b      	ldr	r3, [r3, #0]
 8002506:	1e5a      	subs	r2, r3, #1
 8002508:	68fb      	ldr	r3, [r7, #12]
 800250a:	601a      	str	r2, [r3, #0]
}
 800250c:	bf00      	nop
 800250e:	3714      	adds	r7, #20
 8002510:	46bd      	mov	sp, r7
 8002512:	bc80      	pop	{r7}
 8002514:	4770      	bx	lr

08002516 <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
 8002516:	b480      	push	{r7}
 8002518:	b085      	sub	sp, #20
 800251a:	af00      	add	r7, sp, #0
 800251c:	60f8      	str	r0, [r7, #12]
 800251e:	60b9      	str	r1, [r7, #8]
 8002520:	607a      	str	r2, [r7, #4]
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */
	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
 8002522:	68fb      	ldr	r3, [r7, #12]
 8002524:	3b04      	subs	r3, #4
 8002526:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 8002528:	68fb      	ldr	r3, [r7, #12]
 800252a:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 800252e:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
 8002530:	68fb      	ldr	r3, [r7, #12]
 8002532:	3b04      	subs	r3, #4
 8002534:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( portSTACK_TYPE ) pxCode;	/* PC */
 8002536:	68ba      	ldr	r2, [r7, #8]
 8002538:	68fb      	ldr	r3, [r7, #12]
 800253a:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
 800253c:	68fb      	ldr	r3, [r7, #12]
 800253e:	3b04      	subs	r3, #4
 8002540:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = 0;	/* LR */
 8002542:	68fb      	ldr	r3, [r7, #12]
 8002544:	2200      	movs	r2, #0
 8002546:	601a      	str	r2, [r3, #0]
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
 8002548:	68fb      	ldr	r3, [r7, #12]
 800254a:	3b14      	subs	r3, #20
 800254c:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( portSTACK_TYPE ) pvParameters;	/* R0 */
 800254e:	687a      	ldr	r2, [r7, #4]
 8002550:	68fb      	ldr	r3, [r7, #12]
 8002552:	601a      	str	r2, [r3, #0]
	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
 8002554:	68fb      	ldr	r3, [r7, #12]
 8002556:	3b20      	subs	r3, #32
 8002558:	60fb      	str	r3, [r7, #12]

	return pxTopOfStack;
 800255a:	68fb      	ldr	r3, [r7, #12]
}
 800255c:	4618      	mov	r0, r3
 800255e:	3714      	adds	r7, #20
 8002560:	46bd      	mov	sp, r7
 8002562:	bc80      	pop	{r7}
 8002564:	4770      	bx	lr
	...

08002568 <vPortSVCHandler>:
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
 8002568:	4b06      	ldr	r3, [pc, #24]	; (8002584 <pxCurrentTCBConst2>)
 800256a:	6819      	ldr	r1, [r3, #0]
 800256c:	6808      	ldr	r0, [r1, #0]
 800256e:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8002572:	f380 8809 	msr	PSP, r0
 8002576:	f04f 0000 	mov.w	r0, #0
 800257a:	f380 8811 	msr	BASEPRI, r0
 800257e:	f04e 0e0d 	orr.w	lr, lr, #13
 8002582:	4770      	bx	lr

08002584 <pxCurrentTCBConst2>:
 8002584:	2000065c 	.word	0x2000065c
					"	bx r14							\n"
					"									\n"
					"	.align 2						\n"
					"pxCurrentTCBConst2: .word pxCurrentTCB				\n"
				);
}
 8002588:	bf00      	nop
 800258a:	bf00      	nop

0800258c <vPortStartFirstTask>:
/*-----------------------------------------------------------*/

void vPortStartFirstTask( void )
{
	__asm volatile(
 800258c:	4803      	ldr	r0, [pc, #12]	; (800259c <vPortStartFirstTask+0x10>)
 800258e:	6800      	ldr	r0, [r0, #0]
 8002590:	6800      	ldr	r0, [r0, #0]
 8002592:	f380 8808 	msr	MSP, r0
 8002596:	df00      	svc	0
					" ldr r0, [r0] 			\n"
					" ldr r0, [r0] 			\n"
					" msr msp, r0			\n" /* Set the msp back to the start of the stack. */
					" svc 0					\n" /* System call to start first task. */
				);
}
 8002598:	bf00      	nop
 800259a:	0000      	.short	0x0000
 800259c:	e000ed08 	.word	0xe000ed08

080025a0 <xPortStartScheduler>:

/*
 * See header file for description.
 */
portBASE_TYPE xPortStartScheduler( void )
{
 80025a0:	b580      	push	{r7, lr}
 80025a2:	af00      	add	r7, sp, #0
	/* Make PendSV, CallSV and SysTick the same priroity as the kernel. */
	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
 80025a4:	4b0a      	ldr	r3, [pc, #40]	; (80025d0 <xPortStartScheduler+0x30>)
 80025a6:	681b      	ldr	r3, [r3, #0]
 80025a8:	4a09      	ldr	r2, [pc, #36]	; (80025d0 <xPortStartScheduler+0x30>)
 80025aa:	f443 037f 	orr.w	r3, r3, #16711680	; 0xff0000
 80025ae:	6013      	str	r3, [r2, #0]
	*(portNVIC_SYSPRI2) |= portNVIC_SYSTICK_PRI;
 80025b0:	4b07      	ldr	r3, [pc, #28]	; (80025d0 <xPortStartScheduler+0x30>)
 80025b2:	681b      	ldr	r3, [r3, #0]
 80025b4:	4a06      	ldr	r2, [pc, #24]	; (80025d0 <xPortStartScheduler+0x30>)
 80025b6:	f043 437f 	orr.w	r3, r3, #4278190080	; 0xff000000
 80025ba:	6013      	str	r3, [r2, #0]

	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	prvSetupTimerInterrupt();
 80025bc:	4b05      	ldr	r3, [pc, #20]	; (80025d4 <xPortStartScheduler+0x34>)
 80025be:	4798      	blx	r3

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
 80025c0:	4b05      	ldr	r3, [pc, #20]	; (80025d8 <xPortStartScheduler+0x38>)
 80025c2:	2200      	movs	r2, #0
 80025c4:	601a      	str	r2, [r3, #0]

	/* Start the first task. */
	vPortStartFirstTask();
 80025c6:	4b05      	ldr	r3, [pc, #20]	; (80025dc <xPortStartScheduler+0x3c>)
 80025c8:	4798      	blx	r3

	/* Should not get here! */
	return 0;
 80025ca:	2300      	movs	r3, #0
}
 80025cc:	4618      	mov	r0, r3
 80025ce:	bd80      	pop	{r7, pc}
 80025d0:	e000ed20 	.word	0xe000ed20
 80025d4:	080026c1 	.word	0x080026c1
 80025d8:	20000130 	.word	0x20000130
 80025dc:	0800258d 	.word	0x0800258d

080025e0 <vPortYieldFromISR>:
	is nothing to return to.  */
}
/*-----------------------------------------------------------*/

void vPortYieldFromISR( void )
{
 80025e0:	b480      	push	{r7}
 80025e2:	af00      	add	r7, sp, #0
	/* Set a PendSV to request a context switch. */
	*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
 80025e4:	4b03      	ldr	r3, [pc, #12]	; (80025f4 <vPortYieldFromISR+0x14>)
 80025e6:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80025ea:	601a      	str	r2, [r3, #0]
}
 80025ec:	bf00      	nop
 80025ee:	46bd      	mov	sp, r7
 80025f0:	bc80      	pop	{r7}
 80025f2:	4770      	bx	lr
 80025f4:	e000ed04 	.word	0xe000ed04

080025f8 <vPortEnterCritical>:
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
 80025f8:	b480      	push	{r7}
 80025fa:	af00      	add	r7, sp, #0
	portDISABLE_INTERRUPTS();
 80025fc:	f04f 00bf 	mov.w	r0, #191	; 0xbf
 8002600:	f380 8811 	msr	BASEPRI, r0
	uxCriticalNesting++;
 8002604:	4b04      	ldr	r3, [pc, #16]	; (8002618 <vPortEnterCritical+0x20>)
 8002606:	681b      	ldr	r3, [r3, #0]
 8002608:	3301      	adds	r3, #1
 800260a:	4a03      	ldr	r2, [pc, #12]	; (8002618 <vPortEnterCritical+0x20>)
 800260c:	6013      	str	r3, [r2, #0]
}
 800260e:	bf00      	nop
 8002610:	46bd      	mov	sp, r7
 8002612:	bc80      	pop	{r7}
 8002614:	4770      	bx	lr
 8002616:	bf00      	nop
 8002618:	20000130 	.word	0x20000130

0800261c <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
 800261c:	b480      	push	{r7}
 800261e:	af00      	add	r7, sp, #0
	uxCriticalNesting--;
 8002620:	4b08      	ldr	r3, [pc, #32]	; (8002644 <vPortExitCritical+0x28>)
 8002622:	681b      	ldr	r3, [r3, #0]
 8002624:	3b01      	subs	r3, #1
 8002626:	4a07      	ldr	r2, [pc, #28]	; (8002644 <vPortExitCritical+0x28>)
 8002628:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
 800262a:	4b06      	ldr	r3, [pc, #24]	; (8002644 <vPortExitCritical+0x28>)
 800262c:	681b      	ldr	r3, [r3, #0]
 800262e:	2b00      	cmp	r3, #0
 8002630:	d103      	bne.n	800263a <vPortExitCritical+0x1e>
	{
		portENABLE_INTERRUPTS();
 8002632:	f04f 0000 	mov.w	r0, #0
 8002636:	f380 8811 	msr	BASEPRI, r0
	}
}
 800263a:	bf00      	nop
 800263c:	46bd      	mov	sp, r7
 800263e:	bc80      	pop	{r7}
 8002640:	4770      	bx	lr
 8002642:	bf00      	nop
 8002644:	20000130 	.word	0x20000130

08002648 <xPortPendSVHandler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
 8002648:	f3ef 8009 	mrs	r0, PSP
 800264c:	4b0c      	ldr	r3, [pc, #48]	; (8002680 <pxCurrentTCBConst>)
 800264e:	681a      	ldr	r2, [r3, #0]
 8002650:	e920 0ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8002654:	6010      	str	r0, [r2, #0]
 8002656:	e92d 4008 	stmdb	sp!, {r3, lr}
 800265a:	f04f 00bf 	mov.w	r0, #191	; 0xbf
 800265e:	f380 8811 	msr	BASEPRI, r0
 8002662:	f7ff f8fb 	bl	800185c <vTaskSwitchContext>
 8002666:	f04f 0000 	mov.w	r0, #0
 800266a:	f380 8811 	msr	BASEPRI, r0
 800266e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8002672:	6819      	ldr	r1, [r3, #0]
 8002674:	6808      	ldr	r0, [r1, #0]
 8002676:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
 800267a:	f380 8809 	msr	PSP, r0
 800267e:	4770      	bx	lr

08002680 <pxCurrentTCBConst>:
 8002680:	2000065c 	.word	0x2000065c
	"										\n"
	"	.align 2							\n"
	"pxCurrentTCBConst: .word pxCurrentTCB	\n"
	::"i"(configMAX_SYSCALL_INTERRUPT_PRIORITY)
	);
}
 8002684:	bf00      	nop
 8002686:	bf00      	nop

08002688 <xPortSysTickHandler>:
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
 8002688:	b580      	push	{r7, lr}
 800268a:	b082      	sub	sp, #8
 800268c:	af00      	add	r7, sp, #0
unsigned long ulDummy;

	/* If using preemption, also force a context switch. */
	#if configUSE_PREEMPTION == 1
		*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
 800268e:	4b0a      	ldr	r3, [pc, #40]	; (80026b8 <xPortSysTickHandler+0x30>)
 8002690:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8002694:	601a      	str	r2, [r3, #0]
	#endif

	ulDummy = portSET_INTERRUPT_MASK_FROM_ISR();
 8002696:	2300      	movs	r3, #0
 8002698:	607b      	str	r3, [r7, #4]
 800269a:	f04f 00bf 	mov.w	r0, #191	; 0xbf
 800269e:	f380 8811 	msr	BASEPRI, r0
	{
		vTaskIncrementTick();
 80026a2:	4b06      	ldr	r3, [pc, #24]	; (80026bc <xPortSysTickHandler+0x34>)
 80026a4:	4798      	blx	r3
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( ulDummy );
 80026a6:	f04f 0000 	mov.w	r0, #0
 80026aa:	f380 8811 	msr	BASEPRI, r0
}
 80026ae:	bf00      	nop
 80026b0:	3708      	adds	r7, #8
 80026b2:	46bd      	mov	sp, r7
 80026b4:	bd80      	pop	{r7, pc}
 80026b6:	bf00      	nop
 80026b8:	e000ed04 	.word	0xe000ed04
 80026bc:	08001761 	.word	0x08001761

080026c0 <prvSetupTimerInterrupt>:
/*
 * Setup the systick timer to generate the tick interrupts at the required
 * frequency.
 */
void prvSetupTimerInterrupt( void )
{
 80026c0:	b480      	push	{r7}
 80026c2:	af00      	add	r7, sp, #0
	/* Configure SysTick to interrupt at the requested rate. */
	*(portNVIC_SYSTICK_LOAD) = ( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 80026c4:	4b05      	ldr	r3, [pc, #20]	; (80026dc <prvSetupTimerInterrupt+0x1c>)
 80026c6:	f64b 327f 	movw	r2, #47999	; 0xbb7f
 80026ca:	601a      	str	r2, [r3, #0]
	*(portNVIC_SYSTICK_CTRL) = portNVIC_SYSTICK_CLK | portNVIC_SYSTICK_INT | portNVIC_SYSTICK_ENABLE;
 80026cc:	4b04      	ldr	r3, [pc, #16]	; (80026e0 <prvSetupTimerInterrupt+0x20>)
 80026ce:	2207      	movs	r2, #7
 80026d0:	601a      	str	r2, [r3, #0]
}
 80026d2:	bf00      	nop
 80026d4:	46bd      	mov	sp, r7
 80026d6:	bc80      	pop	{r7}
 80026d8:	4770      	bx	lr
 80026da:	bf00      	nop
 80026dc:	e000e014 	.word	0xe000e014
 80026e0:	e000e010 	.word	0xe000e010

080026e4 <pvPortMalloc>:
	xFreeBytesRemaining = configTOTAL_HEAP_SIZE;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 80026e4:	b580      	push	{r7, lr}
 80026e6:	b08a      	sub	sp, #40	; 0x28
 80026e8:	af00      	add	r7, sp, #0
 80026ea:	6078      	str	r0, [r7, #4]
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
 80026ec:	2300      	movs	r3, #0
 80026ee:	61fb      	str	r3, [r7, #28]

	vTaskSuspendAll();
 80026f0:	4b4a      	ldr	r3, [pc, #296]	; (800281c <pvPortMalloc+0x138>)
 80026f2:	4798      	blx	r3
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
 80026f4:	4b4a      	ldr	r3, [pc, #296]	; (8002820 <pvPortMalloc+0x13c>)
 80026f6:	681b      	ldr	r3, [r3, #0]
 80026f8:	2b00      	cmp	r3, #0
 80026fa:	d11c      	bne.n	8002736 <pvPortMalloc+0x52>
		{
			prvHeapInit();
 80026fc:	4b49      	ldr	r3, [pc, #292]	; (8002824 <pvPortMalloc+0x140>)
 80026fe:	4a4a      	ldr	r2, [pc, #296]	; (8002828 <pvPortMalloc+0x144>)
 8002700:	601a      	str	r2, [r3, #0]
 8002702:	4b48      	ldr	r3, [pc, #288]	; (8002824 <pvPortMalloc+0x140>)
 8002704:	2200      	movs	r2, #0
 8002706:	605a      	str	r2, [r3, #4]
 8002708:	4b48      	ldr	r3, [pc, #288]	; (800282c <pvPortMalloc+0x148>)
 800270a:	f44f 42a0 	mov.w	r2, #20480	; 0x5000
 800270e:	605a      	str	r2, [r3, #4]
 8002710:	4b46      	ldr	r3, [pc, #280]	; (800282c <pvPortMalloc+0x148>)
 8002712:	2200      	movs	r2, #0
 8002714:	601a      	str	r2, [r3, #0]
 8002716:	4b44      	ldr	r3, [pc, #272]	; (8002828 <pvPortMalloc+0x144>)
 8002718:	617b      	str	r3, [r7, #20]
 800271a:	697b      	ldr	r3, [r7, #20]
 800271c:	f44f 42a0 	mov.w	r2, #20480	; 0x5000
 8002720:	605a      	str	r2, [r3, #4]
 8002722:	697b      	ldr	r3, [r7, #20]
 8002724:	4a41      	ldr	r2, [pc, #260]	; (800282c <pvPortMalloc+0x148>)
 8002726:	601a      	str	r2, [r3, #0]
 8002728:	4b41      	ldr	r3, [pc, #260]	; (8002830 <pvPortMalloc+0x14c>)
 800272a:	f44f 42a0 	mov.w	r2, #20480	; 0x5000
 800272e:	601a      	str	r2, [r3, #0]
			xHeapHasBeenInitialised = pdTRUE;
 8002730:	4b3b      	ldr	r3, [pc, #236]	; (8002820 <pvPortMalloc+0x13c>)
 8002732:	2201      	movs	r2, #1
 8002734:	601a      	str	r2, [r3, #0]
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
 8002736:	687b      	ldr	r3, [r7, #4]
 8002738:	2b00      	cmp	r3, #0
 800273a:	d00e      	beq.n	800275a <pvPortMalloc+0x76>
		{
			xWantedSize += heapSTRUCT_SIZE;
 800273c:	2310      	movs	r3, #16
 800273e:	461a      	mov	r2, r3
 8002740:	687b      	ldr	r3, [r7, #4]
 8002742:	4413      	add	r3, r2
 8002744:	607b      	str	r3, [r7, #4]

			/* Ensure that blocks are always aligned to the required number of bytes. */
			if( xWantedSize & portBYTE_ALIGNMENT_MASK )
 8002746:	687b      	ldr	r3, [r7, #4]
 8002748:	f003 0307 	and.w	r3, r3, #7
 800274c:	2b00      	cmp	r3, #0
 800274e:	d004      	beq.n	800275a <pvPortMalloc+0x76>
			{
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 8002750:	687b      	ldr	r3, [r7, #4]
 8002752:	f023 0307 	bic.w	r3, r3, #7
 8002756:	3308      	adds	r3, #8
 8002758:	607b      	str	r3, [r7, #4]
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
 800275a:	687b      	ldr	r3, [r7, #4]
 800275c:	2b00      	cmp	r3, #0
 800275e:	d055      	beq.n	800280c <pvPortMalloc+0x128>
 8002760:	687b      	ldr	r3, [r7, #4]
 8002762:	f5b3 4fa0 	cmp.w	r3, #20480	; 0x5000
 8002766:	d251      	bcs.n	800280c <pvPortMalloc+0x128>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
 8002768:	4b2e      	ldr	r3, [pc, #184]	; (8002824 <pvPortMalloc+0x140>)
 800276a:	623b      	str	r3, [r7, #32]
			pxBlock = xStart.pxNextFreeBlock;
 800276c:	4b2d      	ldr	r3, [pc, #180]	; (8002824 <pvPortMalloc+0x140>)
 800276e:	681b      	ldr	r3, [r3, #0]
 8002770:	627b      	str	r3, [r7, #36]	; 0x24
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
 8002772:	e004      	b.n	800277e <pvPortMalloc+0x9a>
			{
				pxPreviousBlock = pxBlock;
 8002774:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002776:	623b      	str	r3, [r7, #32]
				pxBlock = pxBlock->pxNextFreeBlock;
 8002778:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800277a:	681b      	ldr	r3, [r3, #0]
 800277c:	627b      	str	r3, [r7, #36]	; 0x24
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
 800277e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002780:	685b      	ldr	r3, [r3, #4]
 8002782:	687a      	ldr	r2, [r7, #4]
 8002784:	429a      	cmp	r2, r3
 8002786:	d903      	bls.n	8002790 <pvPortMalloc+0xac>
 8002788:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800278a:	681b      	ldr	r3, [r3, #0]
 800278c:	2b00      	cmp	r3, #0
 800278e:	d1f1      	bne.n	8002774 <pvPortMalloc+0x90>
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
 8002790:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002792:	4a26      	ldr	r2, [pc, #152]	; (800282c <pvPortMalloc+0x148>)
 8002794:	4293      	cmp	r3, r2
 8002796:	d039      	beq.n	800280c <pvPortMalloc+0x128>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
 8002798:	6a3b      	ldr	r3, [r7, #32]
 800279a:	681b      	ldr	r3, [r3, #0]
 800279c:	2210      	movs	r2, #16
 800279e:	4413      	add	r3, r2
 80027a0:	61fb      	str	r3, [r7, #28]

				/* This block is being returned for use so must be taken our of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 80027a2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80027a4:	681a      	ldr	r2, [r3, #0]
 80027a6:	6a3b      	ldr	r3, [r7, #32]
 80027a8:	601a      	str	r2, [r3, #0]

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 80027aa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80027ac:	685a      	ldr	r2, [r3, #4]
 80027ae:	687b      	ldr	r3, [r7, #4]
 80027b0:	1ad3      	subs	r3, r2, r3
 80027b2:	2210      	movs	r2, #16
 80027b4:	0052      	lsls	r2, r2, #1
 80027b6:	4293      	cmp	r3, r2
 80027b8:	d922      	bls.n	8002800 <pvPortMalloc+0x11c>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
 80027ba:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80027bc:	687b      	ldr	r3, [r7, #4]
 80027be:	4413      	add	r3, r2
 80027c0:	613b      	str	r3, [r7, #16]

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 80027c2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80027c4:	685a      	ldr	r2, [r3, #4]
 80027c6:	687b      	ldr	r3, [r7, #4]
 80027c8:	1ad2      	subs	r2, r2, r3
 80027ca:	693b      	ldr	r3, [r7, #16]
 80027cc:	605a      	str	r2, [r3, #4]
					pxBlock->xBlockSize = xWantedSize;
 80027ce:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80027d0:	687a      	ldr	r2, [r7, #4]
 80027d2:	605a      	str	r2, [r3, #4]

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
 80027d4:	693b      	ldr	r3, [r7, #16]
 80027d6:	685b      	ldr	r3, [r3, #4]
 80027d8:	60fb      	str	r3, [r7, #12]
 80027da:	4b12      	ldr	r3, [pc, #72]	; (8002824 <pvPortMalloc+0x140>)
 80027dc:	61bb      	str	r3, [r7, #24]
 80027de:	e002      	b.n	80027e6 <pvPortMalloc+0x102>
 80027e0:	69bb      	ldr	r3, [r7, #24]
 80027e2:	681b      	ldr	r3, [r3, #0]
 80027e4:	61bb      	str	r3, [r7, #24]
 80027e6:	69bb      	ldr	r3, [r7, #24]
 80027e8:	681b      	ldr	r3, [r3, #0]
 80027ea:	685b      	ldr	r3, [r3, #4]
 80027ec:	68fa      	ldr	r2, [r7, #12]
 80027ee:	429a      	cmp	r2, r3
 80027f0:	d8f6      	bhi.n	80027e0 <pvPortMalloc+0xfc>
 80027f2:	69bb      	ldr	r3, [r7, #24]
 80027f4:	681a      	ldr	r2, [r3, #0]
 80027f6:	693b      	ldr	r3, [r7, #16]
 80027f8:	601a      	str	r2, [r3, #0]
 80027fa:	69bb      	ldr	r3, [r7, #24]
 80027fc:	693a      	ldr	r2, [r7, #16]
 80027fe:	601a      	str	r2, [r3, #0]
				}
				
				xFreeBytesRemaining -= xWantedSize;
 8002800:	4b0b      	ldr	r3, [pc, #44]	; (8002830 <pvPortMalloc+0x14c>)
 8002802:	681a      	ldr	r2, [r3, #0]
 8002804:	687b      	ldr	r3, [r7, #4]
 8002806:	1ad3      	subs	r3, r2, r3
 8002808:	4a09      	ldr	r2, [pc, #36]	; (8002830 <pvPortMalloc+0x14c>)
 800280a:	6013      	str	r3, [r2, #0]
			}
		}
	}
	xTaskResumeAll();
 800280c:	4b09      	ldr	r3, [pc, #36]	; (8002834 <pvPortMalloc+0x150>)
 800280e:	4798      	blx	r3
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
 8002810:	69fb      	ldr	r3, [r7, #28]
}
 8002812:	4618      	mov	r0, r3
 8002814:	3728      	adds	r7, #40	; 0x28
 8002816:	46bd      	mov	sp, r7
 8002818:	bd80      	pop	{r7, pc}
 800281a:	bf00      	nop
 800281c:	0800162d 	.word	0x0800162d
 8002820:	200057d4 	.word	0x200057d4
 8002824:	200057c0 	.word	0x200057c0
 8002828:	200007c0 	.word	0x200007c0
 800282c:	200057c8 	.word	0x200057c8
 8002830:	200057d0 	.word	0x200057d0
 8002834:	08001649 	.word	0x08001649

08002838 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 8002838:	b580      	push	{r7, lr}
 800283a:	b086      	sub	sp, #24
 800283c:	af00      	add	r7, sp, #0
 800283e:	6078      	str	r0, [r7, #4]
unsigned char *puc = ( unsigned char * ) pv;
 8002840:	687b      	ldr	r3, [r7, #4]
 8002842:	613b      	str	r3, [r7, #16]
xBlockLink *pxLink;

	if( pv )
 8002844:	687b      	ldr	r3, [r7, #4]
 8002846:	2b00      	cmp	r3, #0
 8002848:	d027      	beq.n	800289a <vPortFree+0x62>
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
 800284a:	2310      	movs	r3, #16
 800284c:	425b      	negs	r3, r3
 800284e:	693a      	ldr	r2, [r7, #16]
 8002850:	4413      	add	r3, r2
 8002852:	613b      	str	r3, [r7, #16]

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;
 8002854:	693b      	ldr	r3, [r7, #16]
 8002856:	60fb      	str	r3, [r7, #12]

		vTaskSuspendAll();
 8002858:	4b12      	ldr	r3, [pc, #72]	; (80028a4 <vPortFree+0x6c>)
 800285a:	4798      	blx	r3
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
 800285c:	68fb      	ldr	r3, [r7, #12]
 800285e:	685b      	ldr	r3, [r3, #4]
 8002860:	60bb      	str	r3, [r7, #8]
 8002862:	4b11      	ldr	r3, [pc, #68]	; (80028a8 <vPortFree+0x70>)
 8002864:	617b      	str	r3, [r7, #20]
 8002866:	e002      	b.n	800286e <vPortFree+0x36>
 8002868:	697b      	ldr	r3, [r7, #20]
 800286a:	681b      	ldr	r3, [r3, #0]
 800286c:	617b      	str	r3, [r7, #20]
 800286e:	697b      	ldr	r3, [r7, #20]
 8002870:	681b      	ldr	r3, [r3, #0]
 8002872:	685b      	ldr	r3, [r3, #4]
 8002874:	68ba      	ldr	r2, [r7, #8]
 8002876:	429a      	cmp	r2, r3
 8002878:	d8f6      	bhi.n	8002868 <vPortFree+0x30>
 800287a:	697b      	ldr	r3, [r7, #20]
 800287c:	681a      	ldr	r2, [r3, #0]
 800287e:	68fb      	ldr	r3, [r7, #12]
 8002880:	601a      	str	r2, [r3, #0]
 8002882:	697b      	ldr	r3, [r7, #20]
 8002884:	68fa      	ldr	r2, [r7, #12]
 8002886:	601a      	str	r2, [r3, #0]
			xFreeBytesRemaining += pxLink->xBlockSize;
 8002888:	68fb      	ldr	r3, [r7, #12]
 800288a:	685a      	ldr	r2, [r3, #4]
 800288c:	4b07      	ldr	r3, [pc, #28]	; (80028ac <vPortFree+0x74>)
 800288e:	681b      	ldr	r3, [r3, #0]
 8002890:	4413      	add	r3, r2
 8002892:	4a06      	ldr	r2, [pc, #24]	; (80028ac <vPortFree+0x74>)
 8002894:	6013      	str	r3, [r2, #0]
		}
		xTaskResumeAll();
 8002896:	4b06      	ldr	r3, [pc, #24]	; (80028b0 <vPortFree+0x78>)
 8002898:	4798      	blx	r3
	}
}
 800289a:	bf00      	nop
 800289c:	3718      	adds	r7, #24
 800289e:	46bd      	mov	sp, r7
 80028a0:	bd80      	pop	{r7, pc}
 80028a2:	bf00      	nop
 80028a4:	0800162d 	.word	0x0800162d
 80028a8:	200057c0 	.word	0x200057c0
 80028ac:	200057d0 	.word	0x200057d0
 80028b0:	08001649 	.word	0x08001649

080028b4 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
 80028b4:	b480      	push	{r7}
 80028b6:	af00      	add	r7, sp, #0
	return xFreeBytesRemaining;
 80028b8:	4b02      	ldr	r3, [pc, #8]	; (80028c4 <xPortGetFreeHeapSize+0x10>)
 80028ba:	681b      	ldr	r3, [r3, #0]
}
 80028bc:	4618      	mov	r0, r3
 80028be:	46bd      	mov	sp, r7
 80028c0:	bc80      	pop	{r7}
 80028c2:	4770      	bx	lr
 80028c4:	200057d0 	.word	0x200057d0

080028c8 <USART_DeInit>:
  * @param  USARTx: Select the USART or the UART peripheral. 
  *   This parameter can be one of the following values: USART1, USART2, USART3, UART4 or UART5.
  * @retval None
  */
void USART_DeInit(USART_TypeDef* USARTx)
{
 80028c8:	b580      	push	{r7, lr}
 80028ca:	b082      	sub	sp, #8
 80028cc:	af00      	add	r7, sp, #0
 80028ce:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));

  if (USARTx == USART1)
 80028d0:	687b      	ldr	r3, [r7, #4]
 80028d2:	4a26      	ldr	r2, [pc, #152]	; (800296c <USART_DeInit+0xa4>)
 80028d4:	4293      	cmp	r3, r2
 80028d6:	d10a      	bne.n	80028ee <USART_DeInit+0x26>
  {
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
 80028d8:	2101      	movs	r1, #1
 80028da:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 80028de:	4b24      	ldr	r3, [pc, #144]	; (8002970 <USART_DeInit+0xa8>)
 80028e0:	4798      	blx	r3
    RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
 80028e2:	2100      	movs	r1, #0
 80028e4:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 80028e8:	4b21      	ldr	r3, [pc, #132]	; (8002970 <USART_DeInit+0xa8>)
 80028ea:	4798      	blx	r3
    { 
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
    }
  }
}
 80028ec:	e03a      	b.n	8002964 <USART_DeInit+0x9c>
  else if (USARTx == USART2)
 80028ee:	687b      	ldr	r3, [r7, #4]
 80028f0:	4a20      	ldr	r2, [pc, #128]	; (8002974 <USART_DeInit+0xac>)
 80028f2:	4293      	cmp	r3, r2
 80028f4:	d10a      	bne.n	800290c <USART_DeInit+0x44>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
 80028f6:	2101      	movs	r1, #1
 80028f8:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 80028fc:	4b1e      	ldr	r3, [pc, #120]	; (8002978 <USART_DeInit+0xb0>)
 80028fe:	4798      	blx	r3
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
 8002900:	2100      	movs	r1, #0
 8002902:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 8002906:	4b1c      	ldr	r3, [pc, #112]	; (8002978 <USART_DeInit+0xb0>)
 8002908:	4798      	blx	r3
}
 800290a:	e02b      	b.n	8002964 <USART_DeInit+0x9c>
  else if (USARTx == USART3)
 800290c:	687b      	ldr	r3, [r7, #4]
 800290e:	4a1b      	ldr	r2, [pc, #108]	; (800297c <USART_DeInit+0xb4>)
 8002910:	4293      	cmp	r3, r2
 8002912:	d10a      	bne.n	800292a <USART_DeInit+0x62>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
 8002914:	2101      	movs	r1, #1
 8002916:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 800291a:	4b17      	ldr	r3, [pc, #92]	; (8002978 <USART_DeInit+0xb0>)
 800291c:	4798      	blx	r3
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
 800291e:	2100      	movs	r1, #0
 8002920:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 8002924:	4b14      	ldr	r3, [pc, #80]	; (8002978 <USART_DeInit+0xb0>)
 8002926:	4798      	blx	r3
}
 8002928:	e01c      	b.n	8002964 <USART_DeInit+0x9c>
  else if (USARTx == UART4)
 800292a:	687b      	ldr	r3, [r7, #4]
 800292c:	4a14      	ldr	r2, [pc, #80]	; (8002980 <USART_DeInit+0xb8>)
 800292e:	4293      	cmp	r3, r2
 8002930:	d10a      	bne.n	8002948 <USART_DeInit+0x80>
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
 8002932:	2101      	movs	r1, #1
 8002934:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 8002938:	4b0f      	ldr	r3, [pc, #60]	; (8002978 <USART_DeInit+0xb0>)
 800293a:	4798      	blx	r3
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
 800293c:	2100      	movs	r1, #0
 800293e:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 8002942:	4b0d      	ldr	r3, [pc, #52]	; (8002978 <USART_DeInit+0xb0>)
 8002944:	4798      	blx	r3
}
 8002946:	e00d      	b.n	8002964 <USART_DeInit+0x9c>
    if (USARTx == UART5)
 8002948:	687b      	ldr	r3, [r7, #4]
 800294a:	4a0e      	ldr	r2, [pc, #56]	; (8002984 <USART_DeInit+0xbc>)
 800294c:	4293      	cmp	r3, r2
 800294e:	d109      	bne.n	8002964 <USART_DeInit+0x9c>
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
 8002950:	2101      	movs	r1, #1
 8002952:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 8002956:	4b08      	ldr	r3, [pc, #32]	; (8002978 <USART_DeInit+0xb0>)
 8002958:	4798      	blx	r3
      RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
 800295a:	2100      	movs	r1, #0
 800295c:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 8002960:	4b05      	ldr	r3, [pc, #20]	; (8002978 <USART_DeInit+0xb0>)
 8002962:	4798      	blx	r3
}
 8002964:	bf00      	nop
 8002966:	3708      	adds	r7, #8
 8002968:	46bd      	mov	sp, r7
 800296a:	bd80      	pop	{r7, pc}
 800296c:	40013800 	.word	0x40013800
 8002970:	08003535 	.word	0x08003535
 8002974:	40004400 	.word	0x40004400
 8002978:	08003571 	.word	0x08003571
 800297c:	40004800 	.word	0x40004800
 8002980:	40004c00 	.word	0x40004c00
 8002984:	40005000 	.word	0x40005000

08002988 <USART_Init>:
  * @param  USART_InitStruct: pointer to a USART_InitTypeDef structure
  *   that contains the configuration information for the specified USART peripheral.
  * @retval None
  */
void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
{
 8002988:	b580      	push	{r7, lr}
 800298a:	b08c      	sub	sp, #48	; 0x30
 800298c:	af00      	add	r7, sp, #0
 800298e:	6078      	str	r0, [r7, #4]
 8002990:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0x00, apbclock = 0x00;
 8002992:	2300      	movs	r3, #0
 8002994:	62bb      	str	r3, [r7, #40]	; 0x28
 8002996:	2300      	movs	r3, #0
 8002998:	62fb      	str	r3, [r7, #44]	; 0x2c
  uint32_t integerdivider = 0x00;
 800299a:	2300      	movs	r3, #0
 800299c:	627b      	str	r3, [r7, #36]	; 0x24
  uint32_t fractionaldivider = 0x00;
 800299e:	2300      	movs	r3, #0
 80029a0:	623b      	str	r3, [r7, #32]
  uint32_t usartxbase = 0;
 80029a2:	2300      	movs	r3, #0
 80029a4:	61fb      	str	r3, [r7, #28]
  if (USART_InitStruct->USART_HardwareFlowControl != USART_HardwareFlowControl_None)
  {
    assert_param(IS_USART_123_PERIPH(USARTx));
  }

  usartxbase = (uint32_t)USARTx;
 80029a6:	687b      	ldr	r3, [r7, #4]
 80029a8:	61fb      	str	r3, [r7, #28]

/*---------------------------- USART CR2 Configuration -----------------------*/
  tmpreg = USARTx->CR2;
 80029aa:	687b      	ldr	r3, [r7, #4]
 80029ac:	8a1b      	ldrh	r3, [r3, #16]
 80029ae:	b29b      	uxth	r3, r3
 80029b0:	62bb      	str	r3, [r7, #40]	; 0x28
  /* Clear STOP[13:12] bits */
  tmpreg &= CR2_STOP_CLEAR_Mask;
 80029b2:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80029b4:	f64c 73ff 	movw	r3, #53247	; 0xcfff
 80029b8:	4013      	ands	r3, r2
 80029ba:	62bb      	str	r3, [r7, #40]	; 0x28
  /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
  /* Set STOP[13:12] bits according to USART_StopBits value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
 80029bc:	683b      	ldr	r3, [r7, #0]
 80029be:	88db      	ldrh	r3, [r3, #6]
 80029c0:	461a      	mov	r2, r3
 80029c2:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80029c4:	4313      	orrs	r3, r2
 80029c6:	62bb      	str	r3, [r7, #40]	; 0x28
  
  /* Write to USART CR2 */
  USARTx->CR2 = (uint16_t)tmpreg;
 80029c8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80029ca:	b29a      	uxth	r2, r3
 80029cc:	687b      	ldr	r3, [r7, #4]
 80029ce:	821a      	strh	r2, [r3, #16]

/*---------------------------- USART CR1 Configuration -----------------------*/
  tmpreg = USARTx->CR1;
 80029d0:	687b      	ldr	r3, [r7, #4]
 80029d2:	899b      	ldrh	r3, [r3, #12]
 80029d4:	b29b      	uxth	r3, r3
 80029d6:	62bb      	str	r3, [r7, #40]	; 0x28
  /* Clear M, PCE, PS, TE and RE bits */
  tmpreg &= CR1_CLEAR_Mask;
 80029d8:	6aba      	ldr	r2, [r7, #40]	; 0x28
 80029da:	f64e 13f3 	movw	r3, #59891	; 0xe9f3
 80029de:	4013      	ands	r3, r2
 80029e0:	62bb      	str	r3, [r7, #40]	; 0x28
  /* Configure the USART Word Length, Parity and mode ----------------------- */
  /* Set the M bits according to USART_WordLength value */
  /* Set PCE and PS bits according to USART_Parity value */
  /* Set TE and RE bits according to USART_Mode value */
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 80029e2:	683b      	ldr	r3, [r7, #0]
 80029e4:	889a      	ldrh	r2, [r3, #4]
 80029e6:	683b      	ldr	r3, [r7, #0]
 80029e8:	891b      	ldrh	r3, [r3, #8]
 80029ea:	4313      	orrs	r3, r2
 80029ec:	b29a      	uxth	r2, r3
            USART_InitStruct->USART_Mode;
 80029ee:	683b      	ldr	r3, [r7, #0]
 80029f0:	895b      	ldrh	r3, [r3, #10]
  tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 80029f2:	4313      	orrs	r3, r2
 80029f4:	b29b      	uxth	r3, r3
 80029f6:	461a      	mov	r2, r3
 80029f8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80029fa:	4313      	orrs	r3, r2
 80029fc:	62bb      	str	r3, [r7, #40]	; 0x28
  /* Write to USART CR1 */
  USARTx->CR1 = (uint16_t)tmpreg;
 80029fe:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002a00:	b29a      	uxth	r2, r3
 8002a02:	687b      	ldr	r3, [r7, #4]
 8002a04:	819a      	strh	r2, [r3, #12]

/*---------------------------- USART CR3 Configuration -----------------------*/  
  tmpreg = USARTx->CR3;
 8002a06:	687b      	ldr	r3, [r7, #4]
 8002a08:	8a9b      	ldrh	r3, [r3, #20]
 8002a0a:	b29b      	uxth	r3, r3
 8002a0c:	62bb      	str	r3, [r7, #40]	; 0x28
  /* Clear CTSE and RTSE bits */
  tmpreg &= CR3_CLEAR_Mask;
 8002a0e:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8002a10:	f64f 43ff 	movw	r3, #64767	; 0xfcff
 8002a14:	4013      	ands	r3, r2
 8002a16:	62bb      	str	r3, [r7, #40]	; 0x28
  /* Configure the USART HFC -------------------------------------------------*/
  /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
  tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
 8002a18:	683b      	ldr	r3, [r7, #0]
 8002a1a:	899b      	ldrh	r3, [r3, #12]
 8002a1c:	461a      	mov	r2, r3
 8002a1e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002a20:	4313      	orrs	r3, r2
 8002a22:	62bb      	str	r3, [r7, #40]	; 0x28
  /* Write to USART CR3 */
  USARTx->CR3 = (uint16_t)tmpreg;
 8002a24:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002a26:	b29a      	uxth	r2, r3
 8002a28:	687b      	ldr	r3, [r7, #4]
 8002a2a:	829a      	strh	r2, [r3, #20]

/*---------------------------- USART BRR Configuration -----------------------*/
  /* Configure the USART Baud Rate -------------------------------------------*/
  RCC_GetClocksFreq(&RCC_ClocksStatus);
 8002a2c:	f107 0308 	add.w	r3, r7, #8
 8002a30:	4618      	mov	r0, r3
 8002a32:	4b0f      	ldr	r3, [pc, #60]	; (8002a70 <USART_Init+0xe8>)
 8002a34:	4798      	blx	r3
  if (usartxbase == USART1_BASE)
 8002a36:	69fb      	ldr	r3, [r7, #28]
 8002a38:	4a0e      	ldr	r2, [pc, #56]	; (8002a74 <USART_Init+0xec>)
 8002a3a:	4293      	cmp	r3, r2
 8002a3c:	d102      	bne.n	8002a44 <USART_Init+0xbc>
  {
    apbclock = RCC_ClocksStatus.PCLK2_Frequency;
 8002a3e:	697b      	ldr	r3, [r7, #20]
 8002a40:	62fb      	str	r3, [r7, #44]	; 0x2c
 8002a42:	e001      	b.n	8002a48 <USART_Init+0xc0>
  }
  else
  {
    apbclock = RCC_ClocksStatus.PCLK1_Frequency;
 8002a44:	693b      	ldr	r3, [r7, #16]
 8002a46:	62fb      	str	r3, [r7, #44]	; 0x2c
  }
#ifdef MOD_MTHOMAS_STMLIB
  /* proposed by "A.K." in the mikrocontroller.net forum: */
  USARTx->BRR = ((2 * apbclock) / (USART_InitStruct->USART_BaudRate) + 1) / 2;
 8002a48:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8002a4a:	005a      	lsls	r2, r3, #1
 8002a4c:	683b      	ldr	r3, [r7, #0]
 8002a4e:	681b      	ldr	r3, [r3, #0]
 8002a50:	fbb2 f3f3 	udiv	r3, r2, r3
 8002a54:	3301      	adds	r3, #1
 8002a56:	085b      	lsrs	r3, r3, #1
 8002a58:	b29a      	uxth	r2, r3
 8002a5a:	687b      	ldr	r3, [r7, #4]
 8002a5c:	811a      	strh	r2, [r3, #8]
  /* avoid "unused" warning: */
  fractionaldivider = integerdivider = 0x00;
 8002a5e:	2300      	movs	r3, #0
 8002a60:	627b      	str	r3, [r7, #36]	; 0x24
 8002a62:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002a64:	623b      	str	r3, [r7, #32]
  fractionaldivider = integerdivider - (0x64 * (tmpreg >> 0x04));
  tmpreg |= ((((fractionaldivider * 0x10) + 0x32) / 0x64)) & ((uint8_t)0x0F);
  /* Write to USART BRR */
  USARTx->BRR = (uint16_t)tmpreg;
#endif
}
 8002a66:	bf00      	nop
 8002a68:	3730      	adds	r7, #48	; 0x30
 8002a6a:	46bd      	mov	sp, r7
 8002a6c:	bd80      	pop	{r7, pc}
 8002a6e:	bf00      	nop
 8002a70:	08003311 	.word	0x08003311
 8002a74:	40013800 	.word	0x40013800

08002a78 <USART_Cmd>:
  * @param  NewState: new state of the USARTx peripheral.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
{
 8002a78:	b480      	push	{r7}
 8002a7a:	b083      	sub	sp, #12
 8002a7c:	af00      	add	r7, sp, #0
 8002a7e:	6078      	str	r0, [r7, #4]
 8002a80:	460b      	mov	r3, r1
 8002a82:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_USART_ALL_PERIPH(USARTx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8002a84:	78fb      	ldrb	r3, [r7, #3]
 8002a86:	2b00      	cmp	r3, #0
 8002a88:	d008      	beq.n	8002a9c <USART_Cmd+0x24>
  {
    /* Enable the selected USART by setting the UE bit in the CR1 register */
    USARTx->CR1 |= CR1_UE_Set;
 8002a8a:	687b      	ldr	r3, [r7, #4]
 8002a8c:	899b      	ldrh	r3, [r3, #12]
 8002a8e:	b29b      	uxth	r3, r3
 8002a90:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8002a94:	b29a      	uxth	r2, r3
 8002a96:	687b      	ldr	r3, [r7, #4]
 8002a98:	819a      	strh	r2, [r3, #12]
  else
  {
    /* Disable the selected USART by clearing the UE bit in the CR1 register */
    USARTx->CR1 &= CR1_UE_Reset;
  }
}
 8002a9a:	e007      	b.n	8002aac <USART_Cmd+0x34>
    USARTx->CR1 &= CR1_UE_Reset;
 8002a9c:	687b      	ldr	r3, [r7, #4]
 8002a9e:	899b      	ldrh	r3, [r3, #12]
 8002aa0:	b29b      	uxth	r3, r3
 8002aa2:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8002aa6:	b29a      	uxth	r2, r3
 8002aa8:	687b      	ldr	r3, [r7, #4]
 8002aaa:	819a      	strh	r2, [r3, #12]
}
 8002aac:	bf00      	nop
 8002aae:	370c      	adds	r7, #12
 8002ab0:	46bd      	mov	sp, r7
 8002ab2:	bc80      	pop	{r7}
 8002ab4:	4770      	bx	lr

08002ab6 <USART_DMACmd>:
  *   This parameter can be: ENABLE or DISABLE.
  * @note The DMA mode is not available for UART5.  
  * @retval None
  */
void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState)
{
 8002ab6:	b480      	push	{r7}
 8002ab8:	b083      	sub	sp, #12
 8002aba:	af00      	add	r7, sp, #0
 8002abc:	6078      	str	r0, [r7, #4]
 8002abe:	460b      	mov	r3, r1
 8002ac0:	807b      	strh	r3, [r7, #2]
 8002ac2:	4613      	mov	r3, r2
 8002ac4:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_USART_1234_PERIPH(USARTx));
  assert_param(IS_USART_DMAREQ(USART_DMAReq));  
  assert_param(IS_FUNCTIONAL_STATE(NewState)); 
  if (NewState != DISABLE)
 8002ac6:	787b      	ldrb	r3, [r7, #1]
 8002ac8:	2b00      	cmp	r3, #0
 8002aca:	d008      	beq.n	8002ade <USART_DMACmd+0x28>
  {
    /* Enable the DMA transfer for selected requests by setting the DMAT and/or
       DMAR bits in the USART CR3 register */
    USARTx->CR3 |= USART_DMAReq;
 8002acc:	687b      	ldr	r3, [r7, #4]
 8002ace:	8a9b      	ldrh	r3, [r3, #20]
 8002ad0:	b29a      	uxth	r2, r3
 8002ad2:	887b      	ldrh	r3, [r7, #2]
 8002ad4:	4313      	orrs	r3, r2
 8002ad6:	b29a      	uxth	r2, r3
 8002ad8:	687b      	ldr	r3, [r7, #4]
 8002ada:	829a      	strh	r2, [r3, #20]
  {
    /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
       DMAR bits in the USART CR3 register */
    USARTx->CR3 &= (uint16_t)~USART_DMAReq;
  }
}
 8002adc:	e009      	b.n	8002af2 <USART_DMACmd+0x3c>
    USARTx->CR3 &= (uint16_t)~USART_DMAReq;
 8002ade:	687b      	ldr	r3, [r7, #4]
 8002ae0:	8a9b      	ldrh	r3, [r3, #20]
 8002ae2:	b29a      	uxth	r2, r3
 8002ae4:	887b      	ldrh	r3, [r7, #2]
 8002ae6:	43db      	mvns	r3, r3
 8002ae8:	b29b      	uxth	r3, r3
 8002aea:	4013      	ands	r3, r2
 8002aec:	b29a      	uxth	r2, r3
 8002aee:	687b      	ldr	r3, [r7, #4]
 8002af0:	829a      	strh	r2, [r3, #20]
}
 8002af2:	bf00      	nop
 8002af4:	370c      	adds	r7, #12
 8002af6:	46bd      	mov	sp, r7
 8002af8:	bc80      	pop	{r7}
 8002afa:	4770      	bx	lr

08002afc <USART_ClearFlag>:
  *   - TXE flag is cleared only by a write to the USART_DR register 
  *     (USART_SendData()).
  * @retval None
  */
void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG)
{
 8002afc:	b480      	push	{r7}
 8002afe:	b083      	sub	sp, #12
 8002b00:	af00      	add	r7, sp, #0
 8002b02:	6078      	str	r0, [r7, #4]
 8002b04:	460b      	mov	r3, r1
 8002b06:	807b      	strh	r3, [r7, #2]
  if ((USART_FLAG & USART_FLAG_CTS) == USART_FLAG_CTS)
  {
    assert_param(IS_USART_123_PERIPH(USARTx));
  } 
   
  USARTx->SR = (uint16_t)~USART_FLAG;
 8002b08:	887b      	ldrh	r3, [r7, #2]
 8002b0a:	43db      	mvns	r3, r3
 8002b0c:	b29a      	uxth	r2, r3
 8002b0e:	687b      	ldr	r3, [r7, #4]
 8002b10:	801a      	strh	r2, [r3, #0]
}
 8002b12:	bf00      	nop
 8002b14:	370c      	adds	r7, #12
 8002b16:	46bd      	mov	sp, r7
 8002b18:	bc80      	pop	{r7}
 8002b1a:	4770      	bx	lr

08002b1c <FLASH_SetLatency>:
  *     @arg FLASH_Latency_1: FLASH One Latency cycle
  *     @arg FLASH_Latency_2: FLASH Two Latency cycles
  * @retval None
  */
void FLASH_SetLatency(uint32_t FLASH_Latency)
{
 8002b1c:	b480      	push	{r7}
 8002b1e:	b085      	sub	sp, #20
 8002b20:	af00      	add	r7, sp, #0
 8002b22:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 8002b24:	2300      	movs	r3, #0
 8002b26:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_FLASH_LATENCY(FLASH_Latency));

  /* Read the ACR register */
  tmpreg = FLASH->ACR;
 8002b28:	4b09      	ldr	r3, [pc, #36]	; (8002b50 <FLASH_SetLatency+0x34>)
 8002b2a:	681b      	ldr	r3, [r3, #0]
 8002b2c:	60fb      	str	r3, [r7, #12]

  /* Sets the Latency value */
  tmpreg &= ACR_LATENCY_Mask;
 8002b2e:	68fb      	ldr	r3, [r7, #12]
 8002b30:	f003 0338 	and.w	r3, r3, #56	; 0x38
 8002b34:	60fb      	str	r3, [r7, #12]
  tmpreg |= FLASH_Latency;
 8002b36:	68fa      	ldr	r2, [r7, #12]
 8002b38:	687b      	ldr	r3, [r7, #4]
 8002b3a:	4313      	orrs	r3, r2
 8002b3c:	60fb      	str	r3, [r7, #12]

  /* Write the ACR register */
  FLASH->ACR = tmpreg;
 8002b3e:	4a04      	ldr	r2, [pc, #16]	; (8002b50 <FLASH_SetLatency+0x34>)
 8002b40:	68fb      	ldr	r3, [r7, #12]
 8002b42:	6013      	str	r3, [r2, #0]
}
 8002b44:	bf00      	nop
 8002b46:	3714      	adds	r7, #20
 8002b48:	46bd      	mov	sp, r7
 8002b4a:	bc80      	pop	{r7}
 8002b4c:	4770      	bx	lr
 8002b4e:	bf00      	nop
 8002b50:	40022000 	.word	0x40022000

08002b54 <FLASH_PrefetchBufferCmd>:
  *     @arg FLASH_PrefetchBuffer_Enable: FLASH Prefetch Buffer Enable
  *     @arg FLASH_PrefetchBuffer_Disable: FLASH Prefetch Buffer Disable
  * @retval None
  */
void FLASH_PrefetchBufferCmd(uint32_t FLASH_PrefetchBuffer)
{
 8002b54:	b480      	push	{r7}
 8002b56:	b083      	sub	sp, #12
 8002b58:	af00      	add	r7, sp, #0
 8002b5a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_FLASH_PREFETCHBUFFER_STATE(FLASH_PrefetchBuffer));

  /* Enable or disable the Prefetch Buffer */
  FLASH->ACR &= ACR_PRFTBE_Mask;
 8002b5c:	4b08      	ldr	r3, [pc, #32]	; (8002b80 <FLASH_PrefetchBufferCmd+0x2c>)
 8002b5e:	681b      	ldr	r3, [r3, #0]
 8002b60:	4a07      	ldr	r2, [pc, #28]	; (8002b80 <FLASH_PrefetchBufferCmd+0x2c>)
 8002b62:	f023 0310 	bic.w	r3, r3, #16
 8002b66:	6013      	str	r3, [r2, #0]
  FLASH->ACR |= FLASH_PrefetchBuffer;
 8002b68:	4b05      	ldr	r3, [pc, #20]	; (8002b80 <FLASH_PrefetchBufferCmd+0x2c>)
 8002b6a:	681a      	ldr	r2, [r3, #0]
 8002b6c:	4904      	ldr	r1, [pc, #16]	; (8002b80 <FLASH_PrefetchBufferCmd+0x2c>)
 8002b6e:	687b      	ldr	r3, [r7, #4]
 8002b70:	4313      	orrs	r3, r2
 8002b72:	600b      	str	r3, [r1, #0]
}
 8002b74:	bf00      	nop
 8002b76:	370c      	adds	r7, #12
 8002b78:	46bd      	mov	sp, r7
 8002b7a:	bc80      	pop	{r7}
 8002b7c:	4770      	bx	lr
 8002b7e:	bf00      	nop
 8002b80:	40022000 	.word	0x40022000

08002b84 <FLASH_Unlock>:
  * @brief  Unlocks the FLASH Program Erase Controller.
  * @param  None
  * @retval None
  */
void FLASH_Unlock(void)
{
 8002b84:	b480      	push	{r7}
 8002b86:	af00      	add	r7, sp, #0
  /* Authorize the FPEC Access */
  FLASH->KEYR = FLASH_KEY1;
 8002b88:	4b04      	ldr	r3, [pc, #16]	; (8002b9c <FLASH_Unlock+0x18>)
 8002b8a:	4a05      	ldr	r2, [pc, #20]	; (8002ba0 <FLASH_Unlock+0x1c>)
 8002b8c:	605a      	str	r2, [r3, #4]
  FLASH->KEYR = FLASH_KEY2;
 8002b8e:	4b03      	ldr	r3, [pc, #12]	; (8002b9c <FLASH_Unlock+0x18>)
 8002b90:	4a04      	ldr	r2, [pc, #16]	; (8002ba4 <FLASH_Unlock+0x20>)
 8002b92:	605a      	str	r2, [r3, #4]
}
 8002b94:	bf00      	nop
 8002b96:	46bd      	mov	sp, r7
 8002b98:	bc80      	pop	{r7}
 8002b9a:	4770      	bx	lr
 8002b9c:	40022000 	.word	0x40022000
 8002ba0:	45670123 	.word	0x45670123
 8002ba4:	cdef89ab 	.word	0xcdef89ab

08002ba8 <FLASH_Lock>:
  * @brief  Locks the FLASH Program Erase Controller.
  * @param  None
  * @retval None
  */
void FLASH_Lock(void)
{
 8002ba8:	b480      	push	{r7}
 8002baa:	af00      	add	r7, sp, #0
  /* Set the Lock Bit to lock the FPEC and the FCR */
  FLASH->CR |= CR_LOCK_Set;
 8002bac:	4b04      	ldr	r3, [pc, #16]	; (8002bc0 <FLASH_Lock+0x18>)
 8002bae:	691b      	ldr	r3, [r3, #16]
 8002bb0:	4a03      	ldr	r2, [pc, #12]	; (8002bc0 <FLASH_Lock+0x18>)
 8002bb2:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8002bb6:	6113      	str	r3, [r2, #16]
}
 8002bb8:	bf00      	nop
 8002bba:	46bd      	mov	sp, r7
 8002bbc:	bc80      	pop	{r7}
 8002bbe:	4770      	bx	lr
 8002bc0:	40022000 	.word	0x40022000

08002bc4 <FLASH_ErasePage>:
  * @param  Page_Address: The page address to be erased.
  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PG,
  *   FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
  */
FLASH_Status FLASH_ErasePage(uint32_t Page_Address)
{
 8002bc4:	b580      	push	{r7, lr}
 8002bc6:	b084      	sub	sp, #16
 8002bc8:	af00      	add	r7, sp, #0
 8002bca:	6078      	str	r0, [r7, #4]
  FLASH_Status status = FLASH_COMPLETE;
 8002bcc:	2304      	movs	r3, #4
 8002bce:	73fb      	strb	r3, [r7, #15]
  /* Check the parameters */
  assert_param(IS_FLASH_ADDRESS(Page_Address));
  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation(EraseTimeout);
 8002bd0:	f640 70ff 	movw	r0, #4095	; 0xfff
 8002bd4:	4b15      	ldr	r3, [pc, #84]	; (8002c2c <FLASH_ErasePage+0x68>)
 8002bd6:	4798      	blx	r3
 8002bd8:	4603      	mov	r3, r0
 8002bda:	73fb      	strb	r3, [r7, #15]

  if(status == FLASH_COMPLETE)
 8002bdc:	7bfb      	ldrb	r3, [r7, #15]
 8002bde:	2b04      	cmp	r3, #4
 8002be0:	d11e      	bne.n	8002c20 <FLASH_ErasePage+0x5c>
  {
    /* if the previous operation is completed, proceed to erase the page */
    FLASH->CR|= CR_PER_Set;
 8002be2:	4b13      	ldr	r3, [pc, #76]	; (8002c30 <FLASH_ErasePage+0x6c>)
 8002be4:	691b      	ldr	r3, [r3, #16]
 8002be6:	4a12      	ldr	r2, [pc, #72]	; (8002c30 <FLASH_ErasePage+0x6c>)
 8002be8:	f043 0302 	orr.w	r3, r3, #2
 8002bec:	6113      	str	r3, [r2, #16]
    FLASH->AR = Page_Address;
 8002bee:	4a10      	ldr	r2, [pc, #64]	; (8002c30 <FLASH_ErasePage+0x6c>)
 8002bf0:	687b      	ldr	r3, [r7, #4]
 8002bf2:	6153      	str	r3, [r2, #20]
    FLASH->CR|= CR_STRT_Set;
 8002bf4:	4b0e      	ldr	r3, [pc, #56]	; (8002c30 <FLASH_ErasePage+0x6c>)
 8002bf6:	691b      	ldr	r3, [r3, #16]
 8002bf8:	4a0d      	ldr	r2, [pc, #52]	; (8002c30 <FLASH_ErasePage+0x6c>)
 8002bfa:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8002bfe:	6113      	str	r3, [r2, #16]
#ifdef MOD_MTHOMAS_STMLIB
	for (volatile int i=0;i<1000;i++);
#endif
#endif

    status = FLASH_WaitForLastOperation(EraseTimeout);
 8002c00:	f640 70ff 	movw	r0, #4095	; 0xfff
 8002c04:	4b09      	ldr	r3, [pc, #36]	; (8002c2c <FLASH_ErasePage+0x68>)
 8002c06:	4798      	blx	r3
 8002c08:	4603      	mov	r3, r0
 8002c0a:	73fb      	strb	r3, [r7, #15]
    if(status != FLASH_TIMEOUT)
 8002c0c:	7bfb      	ldrb	r3, [r7, #15]
 8002c0e:	2b05      	cmp	r3, #5
 8002c10:	d006      	beq.n	8002c20 <FLASH_ErasePage+0x5c>
    {
      /* if the erase operation is completed, disable the PER Bit */
      FLASH->CR &= CR_PER_Reset;
 8002c12:	4b07      	ldr	r3, [pc, #28]	; (8002c30 <FLASH_ErasePage+0x6c>)
 8002c14:	691a      	ldr	r2, [r3, #16]
 8002c16:	4906      	ldr	r1, [pc, #24]	; (8002c30 <FLASH_ErasePage+0x6c>)
 8002c18:	f641 73fd 	movw	r3, #8189	; 0x1ffd
 8002c1c:	4013      	ands	r3, r2
 8002c1e:	610b      	str	r3, [r1, #16]
    }
  }
  /* Return the Erase Status */
  return status;
 8002c20:	7bfb      	ldrb	r3, [r7, #15]
}
 8002c22:	4618      	mov	r0, r3
 8002c24:	3710      	adds	r7, #16
 8002c26:	46bd      	mov	sp, r7
 8002c28:	bd80      	pop	{r7, pc}
 8002c2a:	bf00      	nop
 8002c2c:	08002ca9 	.word	0x08002ca9
 8002c30:	40022000 	.word	0x40022000

08002c34 <FLASH_ClearFlag>:
  *     @arg FLASH_FLAG_WRPRTERR: FLASH Write protected error flag
  *     @arg FLASH_FLAG_EOP: FLASH End of Operation flag
  * @retval None
  */
void FLASH_ClearFlag(uint16_t FLASH_FLAG)
{
 8002c34:	b480      	push	{r7}
 8002c36:	b083      	sub	sp, #12
 8002c38:	af00      	add	r7, sp, #0
 8002c3a:	4603      	mov	r3, r0
 8002c3c:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG)) ;

  /* Clear the flags */
  FLASH->SR = FLASH_FLAG;
 8002c3e:	4a04      	ldr	r2, [pc, #16]	; (8002c50 <FLASH_ClearFlag+0x1c>)
 8002c40:	88fb      	ldrh	r3, [r7, #6]
 8002c42:	60d3      	str	r3, [r2, #12]
}
 8002c44:	bf00      	nop
 8002c46:	370c      	adds	r7, #12
 8002c48:	46bd      	mov	sp, r7
 8002c4a:	bc80      	pop	{r7}
 8002c4c:	4770      	bx	lr
 8002c4e:	bf00      	nop
 8002c50:	40022000 	.word	0x40022000

08002c54 <FLASH_GetStatus>:
  * @param  None
  * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PG,
  *   FLASH_ERROR_WRP or FLASH_COMPLETE
  */
FLASH_Status FLASH_GetStatus(void)
{
 8002c54:	b480      	push	{r7}
 8002c56:	b083      	sub	sp, #12
 8002c58:	af00      	add	r7, sp, #0
  FLASH_Status flashstatus = FLASH_COMPLETE;
 8002c5a:	2304      	movs	r3, #4
 8002c5c:	71fb      	strb	r3, [r7, #7]

  if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY)
 8002c5e:	4b11      	ldr	r3, [pc, #68]	; (8002ca4 <FLASH_GetStatus+0x50>)
 8002c60:	68db      	ldr	r3, [r3, #12]
 8002c62:	f003 0301 	and.w	r3, r3, #1
 8002c66:	2b01      	cmp	r3, #1
 8002c68:	d102      	bne.n	8002c70 <FLASH_GetStatus+0x1c>
  {
    flashstatus = FLASH_BUSY;
 8002c6a:	2301      	movs	r3, #1
 8002c6c:	71fb      	strb	r3, [r7, #7]
 8002c6e:	e013      	b.n	8002c98 <FLASH_GetStatus+0x44>
  }
  else
  {
    if((FLASH->SR & FLASH_FLAG_PGERR) != 0)
 8002c70:	4b0c      	ldr	r3, [pc, #48]	; (8002ca4 <FLASH_GetStatus+0x50>)
 8002c72:	68db      	ldr	r3, [r3, #12]
 8002c74:	f003 0304 	and.w	r3, r3, #4
 8002c78:	2b00      	cmp	r3, #0
 8002c7a:	d002      	beq.n	8002c82 <FLASH_GetStatus+0x2e>
    {
      flashstatus = FLASH_ERROR_PG;
 8002c7c:	2302      	movs	r3, #2
 8002c7e:	71fb      	strb	r3, [r7, #7]
 8002c80:	e00a      	b.n	8002c98 <FLASH_GetStatus+0x44>
    }
    else
    {
      if((FLASH->SR & FLASH_FLAG_WRPRTERR) != 0 )
 8002c82:	4b08      	ldr	r3, [pc, #32]	; (8002ca4 <FLASH_GetStatus+0x50>)
 8002c84:	68db      	ldr	r3, [r3, #12]
 8002c86:	f003 0310 	and.w	r3, r3, #16
 8002c8a:	2b00      	cmp	r3, #0
 8002c8c:	d002      	beq.n	8002c94 <FLASH_GetStatus+0x40>
      {
        flashstatus = FLASH_ERROR_WRP;
 8002c8e:	2303      	movs	r3, #3
 8002c90:	71fb      	strb	r3, [r7, #7]
 8002c92:	e001      	b.n	8002c98 <FLASH_GetStatus+0x44>
      }
      else
      {
        flashstatus = FLASH_COMPLETE;
 8002c94:	2304      	movs	r3, #4
 8002c96:	71fb      	strb	r3, [r7, #7]
      }
    }
  }
  /* Return the Flash Status */
  return flashstatus;
 8002c98:	79fb      	ldrb	r3, [r7, #7]
}
 8002c9a:	4618      	mov	r0, r3
 8002c9c:	370c      	adds	r7, #12
 8002c9e:	46bd      	mov	sp, r7
 8002ca0:	bc80      	pop	{r7}
 8002ca2:	4770      	bx	lr
 8002ca4:	40022000 	.word	0x40022000

08002ca8 <FLASH_WaitForLastOperation>:
  * @param  Timeout: FLASH progamming Timeout
  * @retval FLASH Status: The returned value can be: FLASH_ERROR_PG,
  *   FLASH_ERROR_WRP, FLASH_COMPLETE or FLASH_TIMEOUT.
  */
FLASH_Status FLASH_WaitForLastOperation(uint32_t Timeout)
{
 8002ca8:	b580      	push	{r7, lr}
 8002caa:	b084      	sub	sp, #16
 8002cac:	af00      	add	r7, sp, #0
 8002cae:	6078      	str	r0, [r7, #4]
  FLASH_Status status = FLASH_COMPLETE;
 8002cb0:	2304      	movs	r3, #4
 8002cb2:	73fb      	strb	r3, [r7, #15]

  /* Check for the Flash Status */
  status = FLASH_GetStatus();
 8002cb4:	4b0e      	ldr	r3, [pc, #56]	; (8002cf0 <FLASH_WaitForLastOperation+0x48>)
 8002cb6:	4798      	blx	r3
 8002cb8:	4603      	mov	r3, r0
 8002cba:	73fb      	strb	r3, [r7, #15]
  /* Wait for a Flash operation to complete or a TIMEOUT to occur */
  while((status == FLASH_BUSY) && (Timeout != 0x00))
 8002cbc:	e008      	b.n	8002cd0 <FLASH_WaitForLastOperation+0x28>
  {
    delay();
 8002cbe:	4b0d      	ldr	r3, [pc, #52]	; (8002cf4 <FLASH_WaitForLastOperation+0x4c>)
 8002cc0:	4798      	blx	r3
    status = FLASH_GetStatus();
 8002cc2:	4b0b      	ldr	r3, [pc, #44]	; (8002cf0 <FLASH_WaitForLastOperation+0x48>)
 8002cc4:	4798      	blx	r3
 8002cc6:	4603      	mov	r3, r0
 8002cc8:	73fb      	strb	r3, [r7, #15]
    Timeout--;
 8002cca:	687b      	ldr	r3, [r7, #4]
 8002ccc:	3b01      	subs	r3, #1
 8002cce:	607b      	str	r3, [r7, #4]
  while((status == FLASH_BUSY) && (Timeout != 0x00))
 8002cd0:	7bfb      	ldrb	r3, [r7, #15]
 8002cd2:	2b01      	cmp	r3, #1
 8002cd4:	d102      	bne.n	8002cdc <FLASH_WaitForLastOperation+0x34>
 8002cd6:	687b      	ldr	r3, [r7, #4]
 8002cd8:	2b00      	cmp	r3, #0
 8002cda:	d1f0      	bne.n	8002cbe <FLASH_WaitForLastOperation+0x16>
  }
  if(Timeout == 0x00 )
 8002cdc:	687b      	ldr	r3, [r7, #4]
 8002cde:	2b00      	cmp	r3, #0
 8002ce0:	d101      	bne.n	8002ce6 <FLASH_WaitForLastOperation+0x3e>
  {
    status = FLASH_TIMEOUT;
 8002ce2:	2305      	movs	r3, #5
 8002ce4:	73fb      	strb	r3, [r7, #15]
  }
  /* Return the operation status */
  return status;
 8002ce6:	7bfb      	ldrb	r3, [r7, #15]
}
 8002ce8:	4618      	mov	r0, r3
 8002cea:	3710      	adds	r7, #16
 8002cec:	46bd      	mov	sp, r7
 8002cee:	bd80      	pop	{r7, pc}
 8002cf0:	08002c55 	.word	0x08002c55
 8002cf4:	08002cf9 	.word	0x08002cf9

08002cf8 <delay>:
  * @brief  Inserts a time delay.
  * @param  None
  * @retval None
  */
static void delay(void)
{
 8002cf8:	b480      	push	{r7}
 8002cfa:	b083      	sub	sp, #12
 8002cfc:	af00      	add	r7, sp, #0
  __IO uint32_t i = 0;
 8002cfe:	2300      	movs	r3, #0
 8002d00:	607b      	str	r3, [r7, #4]
  for(i = 0xFF; i != 0; i--)
 8002d02:	23ff      	movs	r3, #255	; 0xff
 8002d04:	607b      	str	r3, [r7, #4]
 8002d06:	e002      	b.n	8002d0e <delay+0x16>
 8002d08:	687b      	ldr	r3, [r7, #4]
 8002d0a:	3b01      	subs	r3, #1
 8002d0c:	607b      	str	r3, [r7, #4]
 8002d0e:	687b      	ldr	r3, [r7, #4]
 8002d10:	2b00      	cmp	r3, #0
 8002d12:	d1f9      	bne.n	8002d08 <delay+0x10>
  {
  }
}
 8002d14:	bf00      	nop
 8002d16:	bf00      	nop
 8002d18:	370c      	adds	r7, #12
 8002d1a:	46bd      	mov	sp, r7
 8002d1c:	bc80      	pop	{r7}
 8002d1e:	4770      	bx	lr

08002d20 <WriteFlash>:

void WriteFlash(void* Src, void* Dst, int Len)
{
 8002d20:	b480      	push	{r7}
 8002d22:	b087      	sub	sp, #28
 8002d24:	af00      	add	r7, sp, #0
 8002d26:	60f8      	str	r0, [r7, #12]
 8002d28:	60b9      	str	r1, [r7, #8]
 8002d2a:	607a      	str	r2, [r7, #4]
  uint16_t* SrcW = (uint16_t*)Src;
 8002d2c:	68fb      	ldr	r3, [r7, #12]
 8002d2e:	617b      	str	r3, [r7, #20]
  uint16_t* DstW = (uint16_t*)Dst;
 8002d30:	68bb      	ldr	r3, [r7, #8]
 8002d32:	613b      	str	r3, [r7, #16]

  FLASH->CR |= FLASH_CR_PG; /* Programm the flash */
 8002d34:	4b18      	ldr	r3, [pc, #96]	; (8002d98 <WriteFlash+0x78>)
 8002d36:	691b      	ldr	r3, [r3, #16]
 8002d38:	4a17      	ldr	r2, [pc, #92]	; (8002d98 <WriteFlash+0x78>)
 8002d3a:	f043 0301 	orr.w	r3, r3, #1
 8002d3e:	6113      	str	r3, [r2, #16]
  while (Len)
 8002d40:	e019      	b.n	8002d76 <WriteFlash+0x56>
  {
    *DstW = *SrcW;
 8002d42:	697b      	ldr	r3, [r7, #20]
 8002d44:	881a      	ldrh	r2, [r3, #0]
 8002d46:	693b      	ldr	r3, [r7, #16]
 8002d48:	801a      	strh	r2, [r3, #0]
    while ((FLASH->SR & FLASH_SR_BSY) != 0 )
 8002d4a:	bf00      	nop
 8002d4c:	4b12      	ldr	r3, [pc, #72]	; (8002d98 <WriteFlash+0x78>)
 8002d4e:	68db      	ldr	r3, [r3, #12]
 8002d50:	f003 0301 	and.w	r3, r3, #1
 8002d54:	2b00      	cmp	r3, #0
 8002d56:	d1f9      	bne.n	8002d4c <WriteFlash+0x2c>
      ;
    if (*DstW != *SrcW )
 8002d58:	693b      	ldr	r3, [r7, #16]
 8002d5a:	881a      	ldrh	r2, [r3, #0]
 8002d5c:	697b      	ldr	r3, [r7, #20]
 8002d5e:	881b      	ldrh	r3, [r3, #0]
 8002d60:	429a      	cmp	r2, r3
 8002d62:	d10c      	bne.n	8002d7e <WriteFlash+0x5e>
    {
      goto EndPrg;
    }
    DstW++;
 8002d64:	693b      	ldr	r3, [r7, #16]
 8002d66:	3302      	adds	r3, #2
 8002d68:	613b      	str	r3, [r7, #16]
    SrcW++;
 8002d6a:	697b      	ldr	r3, [r7, #20]
 8002d6c:	3302      	adds	r3, #2
 8002d6e:	617b      	str	r3, [r7, #20]
    Len = Len - sizeof(uint16_t);
 8002d70:	687b      	ldr	r3, [r7, #4]
 8002d72:	3b02      	subs	r3, #2
 8002d74:	607b      	str	r3, [r7, #4]
  while (Len)
 8002d76:	687b      	ldr	r3, [r7, #4]
 8002d78:	2b00      	cmp	r3, #0
 8002d7a:	d1e2      	bne.n	8002d42 <WriteFlash+0x22>
  }
EndPrg:
 8002d7c:	e000      	b.n	8002d80 <WriteFlash+0x60>
      goto EndPrg;
 8002d7e:	bf00      	nop
  FLASH->CR &= ~FLASH_CR_PG; /* Reset the flag back !!!! */
 8002d80:	4b05      	ldr	r3, [pc, #20]	; (8002d98 <WriteFlash+0x78>)
 8002d82:	691b      	ldr	r3, [r3, #16]
 8002d84:	4a04      	ldr	r2, [pc, #16]	; (8002d98 <WriteFlash+0x78>)
 8002d86:	f023 0301 	bic.w	r3, r3, #1
 8002d8a:	6113      	str	r3, [r2, #16]
}
 8002d8c:	bf00      	nop
 8002d8e:	371c      	adds	r7, #28
 8002d90:	46bd      	mov	sp, r7
 8002d92:	bc80      	pop	{r7}
 8002d94:	4770      	bx	lr
 8002d96:	bf00      	nop
 8002d98:	40022000 	.word	0x40022000

08002d9c <GPIO_Init>:
  * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that
  *   contains the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
{
 8002d9c:	b480      	push	{r7}
 8002d9e:	b089      	sub	sp, #36	; 0x24
 8002da0:	af00      	add	r7, sp, #0
 8002da2:	6078      	str	r0, [r7, #4]
 8002da4:	6039      	str	r1, [r7, #0]
  uint32_t currentmode = 0x00, currentpin = 0x00, pinpos = 0x00, pos = 0x00;
 8002da6:	2300      	movs	r3, #0
 8002da8:	61fb      	str	r3, [r7, #28]
 8002daa:	2300      	movs	r3, #0
 8002dac:	613b      	str	r3, [r7, #16]
 8002dae:	2300      	movs	r3, #0
 8002db0:	61bb      	str	r3, [r7, #24]
 8002db2:	2300      	movs	r3, #0
 8002db4:	60fb      	str	r3, [r7, #12]
  uint32_t tmpreg = 0x00, pinmask = 0x00;
 8002db6:	2300      	movs	r3, #0
 8002db8:	617b      	str	r3, [r7, #20]
 8002dba:	2300      	movs	r3, #0
 8002dbc:	60bb      	str	r3, [r7, #8]
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
  assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));  
  
/*---------------------------- GPIO Mode Configuration -----------------------*/
  currentmode = ((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x0F);
 8002dbe:	683b      	ldr	r3, [r7, #0]
 8002dc0:	78db      	ldrb	r3, [r3, #3]
 8002dc2:	f003 030f 	and.w	r3, r3, #15
 8002dc6:	61fb      	str	r3, [r7, #28]
  if ((((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x10)) != 0x00)
 8002dc8:	683b      	ldr	r3, [r7, #0]
 8002dca:	78db      	ldrb	r3, [r3, #3]
 8002dcc:	f003 0310 	and.w	r3, r3, #16
 8002dd0:	2b00      	cmp	r3, #0
 8002dd2:	d005      	beq.n	8002de0 <GPIO_Init+0x44>
  { 
    /* Check the parameters */
    assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));
    /* Output mode */
    currentmode |= (uint32_t)GPIO_InitStruct->GPIO_Speed;
 8002dd4:	683b      	ldr	r3, [r7, #0]
 8002dd6:	789b      	ldrb	r3, [r3, #2]
 8002dd8:	461a      	mov	r2, r3
 8002dda:	69fb      	ldr	r3, [r7, #28]
 8002ddc:	4313      	orrs	r3, r2
 8002dde:	61fb      	str	r3, [r7, #28]
  }
/*---------------------------- GPIO CRL Configuration ------------------------*/
  /* Configure the eight low port pins */
  if (((uint32_t)GPIO_InitStruct->GPIO_Pin & ((uint32_t)0x00FF)) != 0x00)
 8002de0:	683b      	ldr	r3, [r7, #0]
 8002de2:	881b      	ldrh	r3, [r3, #0]
 8002de4:	b2db      	uxtb	r3, r3
 8002de6:	2b00      	cmp	r3, #0
 8002de8:	d044      	beq.n	8002e74 <GPIO_Init+0xd8>
  {
    tmpreg = GPIOx->CRL;
 8002dea:	687b      	ldr	r3, [r7, #4]
 8002dec:	681b      	ldr	r3, [r3, #0]
 8002dee:	617b      	str	r3, [r7, #20]
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 8002df0:	2300      	movs	r3, #0
 8002df2:	61bb      	str	r3, [r7, #24]
 8002df4:	e038      	b.n	8002e68 <GPIO_Init+0xcc>
    {
      pos = ((uint32_t)0x01) << pinpos;
 8002df6:	2201      	movs	r2, #1
 8002df8:	69bb      	ldr	r3, [r7, #24]
 8002dfa:	fa02 f303 	lsl.w	r3, r2, r3
 8002dfe:	60fb      	str	r3, [r7, #12]
      /* Get the port pins position */
      currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
 8002e00:	683b      	ldr	r3, [r7, #0]
 8002e02:	881b      	ldrh	r3, [r3, #0]
 8002e04:	461a      	mov	r2, r3
 8002e06:	68fb      	ldr	r3, [r7, #12]
 8002e08:	4013      	ands	r3, r2
 8002e0a:	613b      	str	r3, [r7, #16]
      if (currentpin == pos)
 8002e0c:	693a      	ldr	r2, [r7, #16]
 8002e0e:	68fb      	ldr	r3, [r7, #12]
 8002e10:	429a      	cmp	r2, r3
 8002e12:	d126      	bne.n	8002e62 <GPIO_Init+0xc6>
      {
        pos = pinpos << 2;
 8002e14:	69bb      	ldr	r3, [r7, #24]
 8002e16:	009b      	lsls	r3, r3, #2
 8002e18:	60fb      	str	r3, [r7, #12]
        /* Clear the corresponding low control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
 8002e1a:	220f      	movs	r2, #15
 8002e1c:	68fb      	ldr	r3, [r7, #12]
 8002e1e:	fa02 f303 	lsl.w	r3, r2, r3
 8002e22:	60bb      	str	r3, [r7, #8]
        tmpreg &= ~pinmask;
 8002e24:	68bb      	ldr	r3, [r7, #8]
 8002e26:	43db      	mvns	r3, r3
 8002e28:	697a      	ldr	r2, [r7, #20]
 8002e2a:	4013      	ands	r3, r2
 8002e2c:	617b      	str	r3, [r7, #20]
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 8002e2e:	69fa      	ldr	r2, [r7, #28]
 8002e30:	68fb      	ldr	r3, [r7, #12]
 8002e32:	fa02 f303 	lsl.w	r3, r2, r3
 8002e36:	697a      	ldr	r2, [r7, #20]
 8002e38:	4313      	orrs	r3, r2
 8002e3a:	617b      	str	r3, [r7, #20]
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
 8002e3c:	683b      	ldr	r3, [r7, #0]
 8002e3e:	78db      	ldrb	r3, [r3, #3]
 8002e40:	2b28      	cmp	r3, #40	; 0x28
 8002e42:	d105      	bne.n	8002e50 <GPIO_Init+0xb4>
        {
          GPIOx->BRR = (((uint32_t)0x01) << pinpos);
 8002e44:	2201      	movs	r2, #1
 8002e46:	69bb      	ldr	r3, [r7, #24]
 8002e48:	409a      	lsls	r2, r3
 8002e4a:	687b      	ldr	r3, [r7, #4]
 8002e4c:	615a      	str	r2, [r3, #20]
 8002e4e:	e008      	b.n	8002e62 <GPIO_Init+0xc6>
        }
        else
        {
          /* Set the corresponding ODR bit */
          if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
 8002e50:	683b      	ldr	r3, [r7, #0]
 8002e52:	78db      	ldrb	r3, [r3, #3]
 8002e54:	2b48      	cmp	r3, #72	; 0x48
 8002e56:	d104      	bne.n	8002e62 <GPIO_Init+0xc6>
          {
            GPIOx->BSRR = (((uint32_t)0x01) << pinpos);
 8002e58:	2201      	movs	r2, #1
 8002e5a:	69bb      	ldr	r3, [r7, #24]
 8002e5c:	409a      	lsls	r2, r3
 8002e5e:	687b      	ldr	r3, [r7, #4]
 8002e60:	611a      	str	r2, [r3, #16]
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 8002e62:	69bb      	ldr	r3, [r7, #24]
 8002e64:	3301      	adds	r3, #1
 8002e66:	61bb      	str	r3, [r7, #24]
 8002e68:	69bb      	ldr	r3, [r7, #24]
 8002e6a:	2b07      	cmp	r3, #7
 8002e6c:	d9c3      	bls.n	8002df6 <GPIO_Init+0x5a>
          }
        }
      }
    }
    GPIOx->CRL = tmpreg;
 8002e6e:	687b      	ldr	r3, [r7, #4]
 8002e70:	697a      	ldr	r2, [r7, #20]
 8002e72:	601a      	str	r2, [r3, #0]
  }
/*---------------------------- GPIO CRH Configuration ------------------------*/
  /* Configure the eight high port pins */
  if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
 8002e74:	683b      	ldr	r3, [r7, #0]
 8002e76:	881b      	ldrh	r3, [r3, #0]
 8002e78:	2bff      	cmp	r3, #255	; 0xff
 8002e7a:	d946      	bls.n	8002f0a <GPIO_Init+0x16e>
  {
    tmpreg = GPIOx->CRH;
 8002e7c:	687b      	ldr	r3, [r7, #4]
 8002e7e:	685b      	ldr	r3, [r3, #4]
 8002e80:	617b      	str	r3, [r7, #20]
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 8002e82:	2300      	movs	r3, #0
 8002e84:	61bb      	str	r3, [r7, #24]
 8002e86:	e03a      	b.n	8002efe <GPIO_Init+0x162>
    {
      pos = (((uint32_t)0x01) << (pinpos + 0x08));
 8002e88:	69bb      	ldr	r3, [r7, #24]
 8002e8a:	3308      	adds	r3, #8
 8002e8c:	2201      	movs	r2, #1
 8002e8e:	fa02 f303 	lsl.w	r3, r2, r3
 8002e92:	60fb      	str	r3, [r7, #12]
      /* Get the port pins position */
      currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
 8002e94:	683b      	ldr	r3, [r7, #0]
 8002e96:	881b      	ldrh	r3, [r3, #0]
 8002e98:	461a      	mov	r2, r3
 8002e9a:	68fb      	ldr	r3, [r7, #12]
 8002e9c:	4013      	ands	r3, r2
 8002e9e:	613b      	str	r3, [r7, #16]
      if (currentpin == pos)
 8002ea0:	693a      	ldr	r2, [r7, #16]
 8002ea2:	68fb      	ldr	r3, [r7, #12]
 8002ea4:	429a      	cmp	r2, r3
 8002ea6:	d127      	bne.n	8002ef8 <GPIO_Init+0x15c>
      {
        pos = pinpos << 2;
 8002ea8:	69bb      	ldr	r3, [r7, #24]
 8002eaa:	009b      	lsls	r3, r3, #2
 8002eac:	60fb      	str	r3, [r7, #12]
        /* Clear the corresponding high control register bits */
        pinmask = ((uint32_t)0x0F) << pos;
 8002eae:	220f      	movs	r2, #15
 8002eb0:	68fb      	ldr	r3, [r7, #12]
 8002eb2:	fa02 f303 	lsl.w	r3, r2, r3
 8002eb6:	60bb      	str	r3, [r7, #8]
        tmpreg &= ~pinmask;
 8002eb8:	68bb      	ldr	r3, [r7, #8]
 8002eba:	43db      	mvns	r3, r3
 8002ebc:	697a      	ldr	r2, [r7, #20]
 8002ebe:	4013      	ands	r3, r2
 8002ec0:	617b      	str	r3, [r7, #20]
        /* Write the mode configuration in the corresponding bits */
        tmpreg |= (currentmode << pos);
 8002ec2:	69fa      	ldr	r2, [r7, #28]
 8002ec4:	68fb      	ldr	r3, [r7, #12]
 8002ec6:	fa02 f303 	lsl.w	r3, r2, r3
 8002eca:	697a      	ldr	r2, [r7, #20]
 8002ecc:	4313      	orrs	r3, r2
 8002ece:	617b      	str	r3, [r7, #20]
        /* Reset the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
 8002ed0:	683b      	ldr	r3, [r7, #0]
 8002ed2:	78db      	ldrb	r3, [r3, #3]
 8002ed4:	2b28      	cmp	r3, #40	; 0x28
 8002ed6:	d105      	bne.n	8002ee4 <GPIO_Init+0x148>
        {
          GPIOx->BRR = (((uint32_t)0x01) << (pinpos + 0x08));
 8002ed8:	69bb      	ldr	r3, [r7, #24]
 8002eda:	3308      	adds	r3, #8
 8002edc:	2201      	movs	r2, #1
 8002ede:	409a      	lsls	r2, r3
 8002ee0:	687b      	ldr	r3, [r7, #4]
 8002ee2:	615a      	str	r2, [r3, #20]
        }
        /* Set the corresponding ODR bit */
        if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
 8002ee4:	683b      	ldr	r3, [r7, #0]
 8002ee6:	78db      	ldrb	r3, [r3, #3]
 8002ee8:	2b48      	cmp	r3, #72	; 0x48
 8002eea:	d105      	bne.n	8002ef8 <GPIO_Init+0x15c>
        {
          GPIOx->BSRR = (((uint32_t)0x01) << (pinpos + 0x08));
 8002eec:	69bb      	ldr	r3, [r7, #24]
 8002eee:	3308      	adds	r3, #8
 8002ef0:	2201      	movs	r2, #1
 8002ef2:	409a      	lsls	r2, r3
 8002ef4:	687b      	ldr	r3, [r7, #4]
 8002ef6:	611a      	str	r2, [r3, #16]
    for (pinpos = 0x00; pinpos < 0x08; pinpos++)
 8002ef8:	69bb      	ldr	r3, [r7, #24]
 8002efa:	3301      	adds	r3, #1
 8002efc:	61bb      	str	r3, [r7, #24]
 8002efe:	69bb      	ldr	r3, [r7, #24]
 8002f00:	2b07      	cmp	r3, #7
 8002f02:	d9c1      	bls.n	8002e88 <GPIO_Init+0xec>
        }
      }
    }
    GPIOx->CRH = tmpreg;
 8002f04:	687b      	ldr	r3, [r7, #4]
 8002f06:	697a      	ldr	r2, [r7, #20]
 8002f08:	605a      	str	r2, [r3, #4]
  }
}
 8002f0a:	bf00      	nop
 8002f0c:	3724      	adds	r7, #36	; 0x24
 8002f0e:	46bd      	mov	sp, r7
 8002f10:	bc80      	pop	{r7}
 8002f12:	4770      	bx	lr

08002f14 <GPIO_StructInit>:
  * @param  GPIO_InitStruct : pointer to a GPIO_InitTypeDef structure which will
  *   be initialized.
  * @retval None
  */
void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
{
 8002f14:	b480      	push	{r7}
 8002f16:	b083      	sub	sp, #12
 8002f18:	af00      	add	r7, sp, #0
 8002f1a:	6078      	str	r0, [r7, #4]
  /* Reset GPIO init structure parameters values */
  GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
 8002f1c:	687b      	ldr	r3, [r7, #4]
 8002f1e:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8002f22:	801a      	strh	r2, [r3, #0]
  GPIO_InitStruct->GPIO_Speed = GPIO_Speed_2MHz;
 8002f24:	687b      	ldr	r3, [r7, #4]
 8002f26:	2202      	movs	r2, #2
 8002f28:	709a      	strb	r2, [r3, #2]
  GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN_FLOATING;
 8002f2a:	687b      	ldr	r3, [r7, #4]
 8002f2c:	2204      	movs	r2, #4
 8002f2e:	70da      	strb	r2, [r3, #3]
}
 8002f30:	bf00      	nop
 8002f32:	370c      	adds	r7, #12
 8002f34:	46bd      	mov	sp, r7
 8002f36:	bc80      	pop	{r7}
 8002f38:	4770      	bx	lr

08002f3a <GPIO_ReadInputDataBit>:
  * @param  GPIO_Pin:  specifies the port bit to read.
  *   This parameter can be GPIO_Pin_x where x can be (0..15).
  * @retval The input port pin value.
  */
uint8_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 8002f3a:	b480      	push	{r7}
 8002f3c:	b085      	sub	sp, #20
 8002f3e:	af00      	add	r7, sp, #0
 8002f40:	6078      	str	r0, [r7, #4]
 8002f42:	460b      	mov	r3, r1
 8002f44:	807b      	strh	r3, [r7, #2]
  uint8_t bitstatus = 0x00;
 8002f46:	2300      	movs	r3, #0
 8002f48:	73fb      	strb	r3, [r7, #15]
  
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GET_GPIO_PIN(GPIO_Pin)); 
  
  if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)Bit_RESET)
 8002f4a:	687b      	ldr	r3, [r7, #4]
 8002f4c:	689a      	ldr	r2, [r3, #8]
 8002f4e:	887b      	ldrh	r3, [r7, #2]
 8002f50:	4013      	ands	r3, r2
 8002f52:	2b00      	cmp	r3, #0
 8002f54:	d002      	beq.n	8002f5c <GPIO_ReadInputDataBit+0x22>
  {
    bitstatus = (uint8_t)Bit_SET;
 8002f56:	2301      	movs	r3, #1
 8002f58:	73fb      	strb	r3, [r7, #15]
 8002f5a:	e001      	b.n	8002f60 <GPIO_ReadInputDataBit+0x26>
  }
  else
  {
    bitstatus = (uint8_t)Bit_RESET;
 8002f5c:	2300      	movs	r3, #0
 8002f5e:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
 8002f60:	7bfb      	ldrb	r3, [r7, #15]
}
 8002f62:	4618      	mov	r0, r3
 8002f64:	3714      	adds	r7, #20
 8002f66:	46bd      	mov	sp, r7
 8002f68:	bc80      	pop	{r7}
 8002f6a:	4770      	bx	lr

08002f6c <GPIO_SetBits>:
  * @param  GPIO_Pin: specifies the port bits to be written.
  *   This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 8002f6c:	b480      	push	{r7}
 8002f6e:	b083      	sub	sp, #12
 8002f70:	af00      	add	r7, sp, #0
 8002f72:	6078      	str	r0, [r7, #4]
 8002f74:	460b      	mov	r3, r1
 8002f76:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  
  GPIOx->BSRR = GPIO_Pin;
 8002f78:	887a      	ldrh	r2, [r7, #2]
 8002f7a:	687b      	ldr	r3, [r7, #4]
 8002f7c:	611a      	str	r2, [r3, #16]
}
 8002f7e:	bf00      	nop
 8002f80:	370c      	adds	r7, #12
 8002f82:	46bd      	mov	sp, r7
 8002f84:	bc80      	pop	{r7}
 8002f86:	4770      	bx	lr

08002f88 <GPIO_ResetBits>:
  * @param  GPIO_Pin: specifies the port bits to be written.
  *   This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
 8002f88:	b480      	push	{r7}
 8002f8a:	b083      	sub	sp, #12
 8002f8c:	af00      	add	r7, sp, #0
 8002f8e:	6078      	str	r0, [r7, #4]
 8002f90:	460b      	mov	r3, r1
 8002f92:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  
  GPIOx->BRR = GPIO_Pin;
 8002f94:	887a      	ldrh	r2, [r7, #2]
 8002f96:	687b      	ldr	r3, [r7, #4]
 8002f98:	615a      	str	r2, [r3, #20]
}
 8002f9a:	bf00      	nop
 8002f9c:	370c      	adds	r7, #12
 8002f9e:	46bd      	mov	sp, r7
 8002fa0:	bc80      	pop	{r7}
 8002fa2:	4770      	bx	lr

08002fa4 <GPIO_PinRemapConfig>:
  * @param  NewState: new state of the port pin remapping.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void GPIO_PinRemapConfig(uint32_t GPIO_Remap, FunctionalState NewState)
{
 8002fa4:	b480      	push	{r7}
 8002fa6:	b087      	sub	sp, #28
 8002fa8:	af00      	add	r7, sp, #0
 8002faa:	6078      	str	r0, [r7, #4]
 8002fac:	460b      	mov	r3, r1
 8002fae:	70fb      	strb	r3, [r7, #3]
  uint32_t tmp = 0x00, tmp1 = 0x00, tmpreg = 0x00, tmpmask = 0x00;
 8002fb0:	2300      	movs	r3, #0
 8002fb2:	613b      	str	r3, [r7, #16]
 8002fb4:	2300      	movs	r3, #0
 8002fb6:	60fb      	str	r3, [r7, #12]
 8002fb8:	2300      	movs	r3, #0
 8002fba:	617b      	str	r3, [r7, #20]
 8002fbc:	2300      	movs	r3, #0
 8002fbe:	60bb      	str	r3, [r7, #8]

  /* Check the parameters */
  assert_param(IS_GPIO_REMAP(GPIO_Remap));
  assert_param(IS_FUNCTIONAL_STATE(NewState));  
  
  tmpreg = AFIO->MAPR;
 8002fc0:	4b28      	ldr	r3, [pc, #160]	; (8003064 <GPIO_PinRemapConfig+0xc0>)
 8002fc2:	685b      	ldr	r3, [r3, #4]
 8002fc4:	617b      	str	r3, [r7, #20]

  tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
 8002fc6:	687b      	ldr	r3, [r7, #4]
 8002fc8:	0c1b      	lsrs	r3, r3, #16
 8002fca:	f003 030f 	and.w	r3, r3, #15
 8002fce:	60bb      	str	r3, [r7, #8]
  tmp = GPIO_Remap & LSB_MASK;
 8002fd0:	687b      	ldr	r3, [r7, #4]
 8002fd2:	b29b      	uxth	r3, r3
 8002fd4:	613b      	str	r3, [r7, #16]

  if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
 8002fd6:	687b      	ldr	r3, [r7, #4]
 8002fd8:	f403 1340 	and.w	r3, r3, #3145728	; 0x300000
 8002fdc:	f5b3 1f40 	cmp.w	r3, #3145728	; 0x300000
 8002fe0:	d10a      	bne.n	8002ff8 <GPIO_PinRemapConfig+0x54>
  {
    tmpreg &= DBGAFR_SWJCFG_MASK;
 8002fe2:	697b      	ldr	r3, [r7, #20]
 8002fe4:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
 8002fe8:	617b      	str	r3, [r7, #20]
    AFIO->MAPR &= DBGAFR_SWJCFG_MASK;
 8002fea:	4b1e      	ldr	r3, [pc, #120]	; (8003064 <GPIO_PinRemapConfig+0xc0>)
 8002fec:	685b      	ldr	r3, [r3, #4]
 8002fee:	4a1d      	ldr	r2, [pc, #116]	; (8003064 <GPIO_PinRemapConfig+0xc0>)
 8002ff0:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
 8002ff4:	6053      	str	r3, [r2, #4]
 8002ff6:	e021      	b.n	800303c <GPIO_PinRemapConfig+0x98>
  }
  else if ((GPIO_Remap & DBGAFR_NUMBITS_MASK) == DBGAFR_NUMBITS_MASK)
 8002ff8:	687b      	ldr	r3, [r7, #4]
 8002ffa:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8002ffe:	2b00      	cmp	r3, #0
 8003000:	d00e      	beq.n	8003020 <GPIO_PinRemapConfig+0x7c>
  {
    tmp1 = ((uint32_t)0x03) << tmpmask;
 8003002:	2203      	movs	r2, #3
 8003004:	68bb      	ldr	r3, [r7, #8]
 8003006:	fa02 f303 	lsl.w	r3, r2, r3
 800300a:	60fb      	str	r3, [r7, #12]
    tmpreg &= ~tmp1;
 800300c:	68fb      	ldr	r3, [r7, #12]
 800300e:	43db      	mvns	r3, r3
 8003010:	697a      	ldr	r2, [r7, #20]
 8003012:	4013      	ands	r3, r2
 8003014:	617b      	str	r3, [r7, #20]
    tmpreg |= ~DBGAFR_SWJCFG_MASK;
 8003016:	697b      	ldr	r3, [r7, #20]
 8003018:	f043 6370 	orr.w	r3, r3, #251658240	; 0xf000000
 800301c:	617b      	str	r3, [r7, #20]
 800301e:	e00d      	b.n	800303c <GPIO_PinRemapConfig+0x98>
  }
  else
  {
    tmpreg &= ~(tmp << ((GPIO_Remap >> 0x15)*0x10));
 8003020:	687b      	ldr	r3, [r7, #4]
 8003022:	0d5b      	lsrs	r3, r3, #21
 8003024:	011b      	lsls	r3, r3, #4
 8003026:	693a      	ldr	r2, [r7, #16]
 8003028:	fa02 f303 	lsl.w	r3, r2, r3
 800302c:	43db      	mvns	r3, r3
 800302e:	697a      	ldr	r2, [r7, #20]
 8003030:	4013      	ands	r3, r2
 8003032:	617b      	str	r3, [r7, #20]
    tmpreg |= ~DBGAFR_SWJCFG_MASK;
 8003034:	697b      	ldr	r3, [r7, #20]
 8003036:	f043 6370 	orr.w	r3, r3, #251658240	; 0xf000000
 800303a:	617b      	str	r3, [r7, #20]
  }

  if (NewState != DISABLE)
 800303c:	78fb      	ldrb	r3, [r7, #3]
 800303e:	2b00      	cmp	r3, #0
 8003040:	d008      	beq.n	8003054 <GPIO_PinRemapConfig+0xb0>
  {
    tmpreg |= (tmp << ((GPIO_Remap >> 0x15)*0x10));
 8003042:	687b      	ldr	r3, [r7, #4]
 8003044:	0d5b      	lsrs	r3, r3, #21
 8003046:	011b      	lsls	r3, r3, #4
 8003048:	693a      	ldr	r2, [r7, #16]
 800304a:	fa02 f303 	lsl.w	r3, r2, r3
 800304e:	697a      	ldr	r2, [r7, #20]
 8003050:	4313      	orrs	r3, r2
 8003052:	617b      	str	r3, [r7, #20]
  }

  AFIO->MAPR = tmpreg;
 8003054:	4a03      	ldr	r2, [pc, #12]	; (8003064 <GPIO_PinRemapConfig+0xc0>)
 8003056:	697b      	ldr	r3, [r7, #20]
 8003058:	6053      	str	r3, [r2, #4]
}
 800305a:	bf00      	nop
 800305c:	371c      	adds	r7, #28
 800305e:	46bd      	mov	sp, r7
 8003060:	bc80      	pop	{r7}
 8003062:	4770      	bx	lr
 8003064:	40010000 	.word	0x40010000

08003068 <RCC_DeInit>:
  * @brief  Resets the RCC clock configuration to the default reset state.
  * @param  None
  * @retval None
  */
void RCC_DeInit(void)
{
 8003068:	b480      	push	{r7}
 800306a:	af00      	add	r7, sp, #0
  /* Set HSION bit */
  RCC->CR |= (uint32_t)0x00000001;
 800306c:	4b13      	ldr	r3, [pc, #76]	; (80030bc <RCC_DeInit+0x54>)
 800306e:	681b      	ldr	r3, [r3, #0]
 8003070:	4a12      	ldr	r2, [pc, #72]	; (80030bc <RCC_DeInit+0x54>)
 8003072:	f043 0301 	orr.w	r3, r3, #1
 8003076:	6013      	str	r3, [r2, #0]

  /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
#ifndef STM32F10X_CL
  RCC->CFGR &= (uint32_t)0xF8FF0000;
 8003078:	4b10      	ldr	r3, [pc, #64]	; (80030bc <RCC_DeInit+0x54>)
 800307a:	685a      	ldr	r2, [r3, #4]
 800307c:	490f      	ldr	r1, [pc, #60]	; (80030bc <RCC_DeInit+0x54>)
 800307e:	4b10      	ldr	r3, [pc, #64]	; (80030c0 <RCC_DeInit+0x58>)
 8003080:	4013      	ands	r3, r2
 8003082:	604b      	str	r3, [r1, #4]
#else
  RCC->CFGR &= (uint32_t)0xF0FF0000;
#endif /* STM32F10X_CL */   
  
  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= (uint32_t)0xFEF6FFFF;
 8003084:	4b0d      	ldr	r3, [pc, #52]	; (80030bc <RCC_DeInit+0x54>)
 8003086:	681b      	ldr	r3, [r3, #0]
 8003088:	4a0c      	ldr	r2, [pc, #48]	; (80030bc <RCC_DeInit+0x54>)
 800308a:	f023 7384 	bic.w	r3, r3, #17301504	; 0x1080000
 800308e:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8003092:	6013      	str	r3, [r2, #0]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 8003094:	4b09      	ldr	r3, [pc, #36]	; (80030bc <RCC_DeInit+0x54>)
 8003096:	681b      	ldr	r3, [r3, #0]
 8003098:	4a08      	ldr	r2, [pc, #32]	; (80030bc <RCC_DeInit+0x54>)
 800309a:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 800309e:	6013      	str	r3, [r2, #0]

  /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
  RCC->CFGR &= (uint32_t)0xFF80FFFF;
 80030a0:	4b06      	ldr	r3, [pc, #24]	; (80030bc <RCC_DeInit+0x54>)
 80030a2:	685b      	ldr	r3, [r3, #4]
 80030a4:	4a05      	ldr	r2, [pc, #20]	; (80030bc <RCC_DeInit+0x54>)
 80030a6:	f423 03fe 	bic.w	r3, r3, #8323072	; 0x7f0000
 80030aa:	6053      	str	r3, [r2, #4]

#ifndef STM32F10X_CL
  /* Disable all interrupts and clear pending bits  */
  RCC->CIR = 0x009F0000;
 80030ac:	4b03      	ldr	r3, [pc, #12]	; (80030bc <RCC_DeInit+0x54>)
 80030ae:	f44f 021f 	mov.w	r2, #10420224	; 0x9f0000
 80030b2:	609a      	str	r2, [r3, #8]
  RCC->CIR = 0x00FF0000;

  /* Reset CFGR2 register */
  RCC->CFGR2 = 0x00000000;
#endif /* STM32F10X_CL */
}
 80030b4:	bf00      	nop
 80030b6:	46bd      	mov	sp, r7
 80030b8:	bc80      	pop	{r7}
 80030ba:	4770      	bx	lr
 80030bc:	40021000 	.word	0x40021000
 80030c0:	f8ff0000 	.word	0xf8ff0000

080030c4 <RCC_HSEConfig>:
  *     @arg RCC_HSE_ON: HSE oscillator ON
  *     @arg RCC_HSE_Bypass: HSE oscillator bypassed with external clock
  * @retval None
  */
void RCC_HSEConfig(uint32_t RCC_HSE)
{
 80030c4:	b480      	push	{r7}
 80030c6:	b083      	sub	sp, #12
 80030c8:	af00      	add	r7, sp, #0
 80030ca:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_RCC_HSE(RCC_HSE));
  /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
  /* Reset HSEON bit */
  RCC->CR &= CR_HSEON_Reset;
 80030cc:	4b13      	ldr	r3, [pc, #76]	; (800311c <RCC_HSEConfig+0x58>)
 80030ce:	681b      	ldr	r3, [r3, #0]
 80030d0:	4a12      	ldr	r2, [pc, #72]	; (800311c <RCC_HSEConfig+0x58>)
 80030d2:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 80030d6:	6013      	str	r3, [r2, #0]
  /* Reset HSEBYP bit */
  RCC->CR &= CR_HSEBYP_Reset;
 80030d8:	4b10      	ldr	r3, [pc, #64]	; (800311c <RCC_HSEConfig+0x58>)
 80030da:	681b      	ldr	r3, [r3, #0]
 80030dc:	4a0f      	ldr	r2, [pc, #60]	; (800311c <RCC_HSEConfig+0x58>)
 80030de:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 80030e2:	6013      	str	r3, [r2, #0]
  /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
  switch(RCC_HSE)
 80030e4:	687b      	ldr	r3, [r7, #4]
 80030e6:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 80030ea:	d004      	beq.n	80030f6 <RCC_HSEConfig+0x32>
 80030ec:	687b      	ldr	r3, [r7, #4]
 80030ee:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 80030f2:	d007      	beq.n	8003104 <RCC_HSEConfig+0x40>
      /* Set HSEBYP and HSEON bits */
      RCC->CR |= CR_HSEBYP_Set | CR_HSEON_Set;
      break;
      
    default:
      break;
 80030f4:	e00d      	b.n	8003112 <RCC_HSEConfig+0x4e>
      RCC->CR |= CR_HSEON_Set;
 80030f6:	4b09      	ldr	r3, [pc, #36]	; (800311c <RCC_HSEConfig+0x58>)
 80030f8:	681b      	ldr	r3, [r3, #0]
 80030fa:	4a08      	ldr	r2, [pc, #32]	; (800311c <RCC_HSEConfig+0x58>)
 80030fc:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8003100:	6013      	str	r3, [r2, #0]
      break;
 8003102:	e006      	b.n	8003112 <RCC_HSEConfig+0x4e>
      RCC->CR |= CR_HSEBYP_Set | CR_HSEON_Set;
 8003104:	4b05      	ldr	r3, [pc, #20]	; (800311c <RCC_HSEConfig+0x58>)
 8003106:	681b      	ldr	r3, [r3, #0]
 8003108:	4a04      	ldr	r2, [pc, #16]	; (800311c <RCC_HSEConfig+0x58>)
 800310a:	f443 23a0 	orr.w	r3, r3, #327680	; 0x50000
 800310e:	6013      	str	r3, [r2, #0]
      break;
 8003110:	bf00      	nop
  }
}
 8003112:	bf00      	nop
 8003114:	370c      	adds	r7, #12
 8003116:	46bd      	mov	sp, r7
 8003118:	bc80      	pop	{r7}
 800311a:	4770      	bx	lr
 800311c:	40021000 	.word	0x40021000

08003120 <RCC_WaitForHSEStartUp>:
  * @retval An ErrorStatus enumuration value:
  * - SUCCESS: HSE oscillator is stable and ready to use
  * - ERROR: HSE oscillator not yet ready
  */
ErrorStatus RCC_WaitForHSEStartUp(void)
{
 8003120:	b580      	push	{r7, lr}
 8003122:	b082      	sub	sp, #8
 8003124:	af00      	add	r7, sp, #0
  __IO uint32_t StartUpCounter = 0;
 8003126:	2300      	movs	r3, #0
 8003128:	603b      	str	r3, [r7, #0]
  ErrorStatus status = ERROR;
 800312a:	2300      	movs	r3, #0
 800312c:	71fb      	strb	r3, [r7, #7]
  FlagStatus HSEStatus = RESET;
 800312e:	2300      	movs	r3, #0
 8003130:	71bb      	strb	r3, [r7, #6]
  
  /* Wait till HSE is ready and if Time out is reached exit */
  do
  {
    HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
 8003132:	2031      	movs	r0, #49	; 0x31
 8003134:	4b0f      	ldr	r3, [pc, #60]	; (8003174 <RCC_WaitForHSEStartUp+0x54>)
 8003136:	4798      	blx	r3
 8003138:	4603      	mov	r3, r0
 800313a:	71bb      	strb	r3, [r7, #6]
    StartUpCounter++;  
 800313c:	683b      	ldr	r3, [r7, #0]
 800313e:	3301      	adds	r3, #1
 8003140:	603b      	str	r3, [r7, #0]
  } while((StartUpCounter != HSEStartUp_TimeOut) && (HSEStatus == RESET));
 8003142:	683b      	ldr	r3, [r7, #0]
 8003144:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8003148:	4293      	cmp	r3, r2
 800314a:	d002      	beq.n	8003152 <RCC_WaitForHSEStartUp+0x32>
 800314c:	79bb      	ldrb	r3, [r7, #6]
 800314e:	2b00      	cmp	r3, #0
 8003150:	d0ef      	beq.n	8003132 <RCC_WaitForHSEStartUp+0x12>
  
  if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
 8003152:	2031      	movs	r0, #49	; 0x31
 8003154:	4b07      	ldr	r3, [pc, #28]	; (8003174 <RCC_WaitForHSEStartUp+0x54>)
 8003156:	4798      	blx	r3
 8003158:	4603      	mov	r3, r0
 800315a:	2b00      	cmp	r3, #0
 800315c:	d002      	beq.n	8003164 <RCC_WaitForHSEStartUp+0x44>
  {
    status = SUCCESS;
 800315e:	2301      	movs	r3, #1
 8003160:	71fb      	strb	r3, [r7, #7]
 8003162:	e001      	b.n	8003168 <RCC_WaitForHSEStartUp+0x48>
  }
  else
  {
    status = ERROR;
 8003164:	2300      	movs	r3, #0
 8003166:	71fb      	strb	r3, [r7, #7]
  }  
  return (status);
 8003168:	79fb      	ldrb	r3, [r7, #7]
}
 800316a:	4618      	mov	r0, r3
 800316c:	3708      	adds	r7, #8
 800316e:	46bd      	mov	sp, r7
 8003170:	bd80      	pop	{r7, pc}
 8003172:	bf00      	nop
 8003174:	080035ad 	.word	0x080035ad

08003178 <RCC_PLLConfig>:
  *   For @b STM32_Connectivity_line_devices, this parameter can be RCC_PLLMul_x where x:{[4,9], 6_5}
  *   For @b other_STM32_devices, this parameter can be RCC_PLLMul_x where x:[2,16]  
  * @retval None
  */
void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t RCC_PLLMul)
{
 8003178:	b480      	push	{r7}
 800317a:	b085      	sub	sp, #20
 800317c:	af00      	add	r7, sp, #0
 800317e:	6078      	str	r0, [r7, #4]
 8003180:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0;
 8003182:	2300      	movs	r3, #0
 8003184:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
  assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));

  tmpreg = RCC->CFGR;
 8003186:	4b0a      	ldr	r3, [pc, #40]	; (80031b0 <RCC_PLLConfig+0x38>)
 8003188:	685b      	ldr	r3, [r3, #4]
 800318a:	60fb      	str	r3, [r7, #12]
  /* Clear PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */
  tmpreg &= CFGR_PLL_Mask;
 800318c:	68fb      	ldr	r3, [r7, #12]
 800318e:	f423 137c 	bic.w	r3, r3, #4128768	; 0x3f0000
 8003192:	60fb      	str	r3, [r7, #12]
  /* Set the PLL configuration bits */
  tmpreg |= RCC_PLLSource | RCC_PLLMul;
 8003194:	687a      	ldr	r2, [r7, #4]
 8003196:	683b      	ldr	r3, [r7, #0]
 8003198:	4313      	orrs	r3, r2
 800319a:	68fa      	ldr	r2, [r7, #12]
 800319c:	4313      	orrs	r3, r2
 800319e:	60fb      	str	r3, [r7, #12]
  /* Store the new value */
  RCC->CFGR = tmpreg;
 80031a0:	4a03      	ldr	r2, [pc, #12]	; (80031b0 <RCC_PLLConfig+0x38>)
 80031a2:	68fb      	ldr	r3, [r7, #12]
 80031a4:	6053      	str	r3, [r2, #4]
}
 80031a6:	bf00      	nop
 80031a8:	3714      	adds	r7, #20
 80031aa:	46bd      	mov	sp, r7
 80031ac:	bc80      	pop	{r7}
 80031ae:	4770      	bx	lr
 80031b0:	40021000 	.word	0x40021000

080031b4 <RCC_PLLCmd>:
  * @note   The PLL can not be disabled if it is used as system clock.
  * @param  NewState: new state of the PLL. This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_PLLCmd(FunctionalState NewState)
{
 80031b4:	b480      	push	{r7}
 80031b6:	b083      	sub	sp, #12
 80031b8:	af00      	add	r7, sp, #0
 80031ba:	4603      	mov	r3, r0
 80031bc:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
 80031be:	4a04      	ldr	r2, [pc, #16]	; (80031d0 <RCC_PLLCmd+0x1c>)
 80031c0:	79fb      	ldrb	r3, [r7, #7]
 80031c2:	6013      	str	r3, [r2, #0]
}
 80031c4:	bf00      	nop
 80031c6:	370c      	adds	r7, #12
 80031c8:	46bd      	mov	sp, r7
 80031ca:	bc80      	pop	{r7}
 80031cc:	4770      	bx	lr
 80031ce:	bf00      	nop
 80031d0:	42420060 	.word	0x42420060

080031d4 <RCC_SYSCLKConfig>:
  *     @arg RCC_SYSCLKSource_HSE: HSE selected as system clock
  *     @arg RCC_SYSCLKSource_PLLCLK: PLL selected as system clock
  * @retval None
  */
void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
{
 80031d4:	b480      	push	{r7}
 80031d6:	b085      	sub	sp, #20
 80031d8:	af00      	add	r7, sp, #0
 80031da:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 80031dc:	2300      	movs	r3, #0
 80031de:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
  tmpreg = RCC->CFGR;
 80031e0:	4b09      	ldr	r3, [pc, #36]	; (8003208 <RCC_SYSCLKConfig+0x34>)
 80031e2:	685b      	ldr	r3, [r3, #4]
 80031e4:	60fb      	str	r3, [r7, #12]
  /* Clear SW[1:0] bits */
  tmpreg &= CFGR_SW_Mask;
 80031e6:	68fb      	ldr	r3, [r7, #12]
 80031e8:	f023 0303 	bic.w	r3, r3, #3
 80031ec:	60fb      	str	r3, [r7, #12]
  /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
  tmpreg |= RCC_SYSCLKSource;
 80031ee:	68fa      	ldr	r2, [r7, #12]
 80031f0:	687b      	ldr	r3, [r7, #4]
 80031f2:	4313      	orrs	r3, r2
 80031f4:	60fb      	str	r3, [r7, #12]
  /* Store the new value */
  RCC->CFGR = tmpreg;
 80031f6:	4a04      	ldr	r2, [pc, #16]	; (8003208 <RCC_SYSCLKConfig+0x34>)
 80031f8:	68fb      	ldr	r3, [r7, #12]
 80031fa:	6053      	str	r3, [r2, #4]
}
 80031fc:	bf00      	nop
 80031fe:	3714      	adds	r7, #20
 8003200:	46bd      	mov	sp, r7
 8003202:	bc80      	pop	{r7}
 8003204:	4770      	bx	lr
 8003206:	bf00      	nop
 8003208:	40021000 	.word	0x40021000

0800320c <RCC_GetSYSCLKSource>:
  *     - 0x00: HSI used as system clock
  *     - 0x04: HSE used as system clock
  *     - 0x08: PLL used as system clock
  */
uint8_t RCC_GetSYSCLKSource(void)
{
 800320c:	b480      	push	{r7}
 800320e:	af00      	add	r7, sp, #0
  return ((uint8_t)(RCC->CFGR & CFGR_SWS_Mask));
 8003210:	4b04      	ldr	r3, [pc, #16]	; (8003224 <RCC_GetSYSCLKSource+0x18>)
 8003212:	685b      	ldr	r3, [r3, #4]
 8003214:	b2db      	uxtb	r3, r3
 8003216:	f003 030c 	and.w	r3, r3, #12
 800321a:	b2db      	uxtb	r3, r3
}
 800321c:	4618      	mov	r0, r3
 800321e:	46bd      	mov	sp, r7
 8003220:	bc80      	pop	{r7}
 8003222:	4770      	bx	lr
 8003224:	40021000 	.word	0x40021000

08003228 <RCC_HCLKConfig>:
  *     @arg RCC_SYSCLK_Div256: AHB clock = SYSCLK/256
  *     @arg RCC_SYSCLK_Div512: AHB clock = SYSCLK/512
  * @retval None
  */
void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
{
 8003228:	b480      	push	{r7}
 800322a:	b085      	sub	sp, #20
 800322c:	af00      	add	r7, sp, #0
 800322e:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 8003230:	2300      	movs	r3, #0
 8003232:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_RCC_HCLK(RCC_SYSCLK));
  tmpreg = RCC->CFGR;
 8003234:	4b09      	ldr	r3, [pc, #36]	; (800325c <RCC_HCLKConfig+0x34>)
 8003236:	685b      	ldr	r3, [r3, #4]
 8003238:	60fb      	str	r3, [r7, #12]
  /* Clear HPRE[3:0] bits */
  tmpreg &= CFGR_HPRE_Reset_Mask;
 800323a:	68fb      	ldr	r3, [r7, #12]
 800323c:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8003240:	60fb      	str	r3, [r7, #12]
  /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
  tmpreg |= RCC_SYSCLK;
 8003242:	68fa      	ldr	r2, [r7, #12]
 8003244:	687b      	ldr	r3, [r7, #4]
 8003246:	4313      	orrs	r3, r2
 8003248:	60fb      	str	r3, [r7, #12]
  /* Store the new value */
  RCC->CFGR = tmpreg;
 800324a:	4a04      	ldr	r2, [pc, #16]	; (800325c <RCC_HCLKConfig+0x34>)
 800324c:	68fb      	ldr	r3, [r7, #12]
 800324e:	6053      	str	r3, [r2, #4]
}
 8003250:	bf00      	nop
 8003252:	3714      	adds	r7, #20
 8003254:	46bd      	mov	sp, r7
 8003256:	bc80      	pop	{r7}
 8003258:	4770      	bx	lr
 800325a:	bf00      	nop
 800325c:	40021000 	.word	0x40021000

08003260 <RCC_PCLK1Config>:
  *     @arg RCC_HCLK_Div8: APB1 clock = HCLK/8
  *     @arg RCC_HCLK_Div16: APB1 clock = HCLK/16
  * @retval None
  */
void RCC_PCLK1Config(uint32_t RCC_HCLK)
{
 8003260:	b480      	push	{r7}
 8003262:	b085      	sub	sp, #20
 8003264:	af00      	add	r7, sp, #0
 8003266:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 8003268:	2300      	movs	r3, #0
 800326a:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));
  tmpreg = RCC->CFGR;
 800326c:	4b09      	ldr	r3, [pc, #36]	; (8003294 <RCC_PCLK1Config+0x34>)
 800326e:	685b      	ldr	r3, [r3, #4]
 8003270:	60fb      	str	r3, [r7, #12]
  /* Clear PPRE1[2:0] bits */
  tmpreg &= CFGR_PPRE1_Reset_Mask;
 8003272:	68fb      	ldr	r3, [r7, #12]
 8003274:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8003278:	60fb      	str	r3, [r7, #12]
  /* Set PPRE1[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK;
 800327a:	68fa      	ldr	r2, [r7, #12]
 800327c:	687b      	ldr	r3, [r7, #4]
 800327e:	4313      	orrs	r3, r2
 8003280:	60fb      	str	r3, [r7, #12]
  /* Store the new value */
  RCC->CFGR = tmpreg;
 8003282:	4a04      	ldr	r2, [pc, #16]	; (8003294 <RCC_PCLK1Config+0x34>)
 8003284:	68fb      	ldr	r3, [r7, #12]
 8003286:	6053      	str	r3, [r2, #4]
}
 8003288:	bf00      	nop
 800328a:	3714      	adds	r7, #20
 800328c:	46bd      	mov	sp, r7
 800328e:	bc80      	pop	{r7}
 8003290:	4770      	bx	lr
 8003292:	bf00      	nop
 8003294:	40021000 	.word	0x40021000

08003298 <RCC_PCLK2Config>:
  *     @arg RCC_HCLK_Div8: APB2 clock = HCLK/8
  *     @arg RCC_HCLK_Div16: APB2 clock = HCLK/16
  * @retval None
  */
void RCC_PCLK2Config(uint32_t RCC_HCLK)
{
 8003298:	b480      	push	{r7}
 800329a:	b085      	sub	sp, #20
 800329c:	af00      	add	r7, sp, #0
 800329e:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg = 0;
 80032a0:	2300      	movs	r3, #0
 80032a2:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_RCC_PCLK(RCC_HCLK));
  tmpreg = RCC->CFGR;
 80032a4:	4b09      	ldr	r3, [pc, #36]	; (80032cc <RCC_PCLK2Config+0x34>)
 80032a6:	685b      	ldr	r3, [r3, #4]
 80032a8:	60fb      	str	r3, [r7, #12]
  /* Clear PPRE2[2:0] bits */
  tmpreg &= CFGR_PPRE2_Reset_Mask;
 80032aa:	68fb      	ldr	r3, [r7, #12]
 80032ac:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
 80032b0:	60fb      	str	r3, [r7, #12]
  /* Set PPRE2[2:0] bits according to RCC_HCLK value */
  tmpreg |= RCC_HCLK << 3;
 80032b2:	687b      	ldr	r3, [r7, #4]
 80032b4:	00db      	lsls	r3, r3, #3
 80032b6:	68fa      	ldr	r2, [r7, #12]
 80032b8:	4313      	orrs	r3, r2
 80032ba:	60fb      	str	r3, [r7, #12]
  /* Store the new value */
  RCC->CFGR = tmpreg;
 80032bc:	4a03      	ldr	r2, [pc, #12]	; (80032cc <RCC_PCLK2Config+0x34>)
 80032be:	68fb      	ldr	r3, [r7, #12]
 80032c0:	6053      	str	r3, [r2, #4]
}
 80032c2:	bf00      	nop
 80032c4:	3714      	adds	r7, #20
 80032c6:	46bd      	mov	sp, r7
 80032c8:	bc80      	pop	{r7}
 80032ca:	4770      	bx	lr
 80032cc:	40021000 	.word	0x40021000

080032d0 <RCC_LSEConfig>:
  *     @arg RCC_LSE_ON: LSE oscillator ON
  *     @arg RCC_LSE_Bypass: LSE oscillator bypassed with external clock
  * @retval None
  */
void RCC_LSEConfig(uint8_t RCC_LSE)
{
 80032d0:	b480      	push	{r7}
 80032d2:	b083      	sub	sp, #12
 80032d4:	af00      	add	r7, sp, #0
 80032d6:	4603      	mov	r3, r0
 80032d8:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_RCC_LSE(RCC_LSE));
  /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
  /* Reset LSEON bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
 80032da:	4b0c      	ldr	r3, [pc, #48]	; (800330c <RCC_LSEConfig+0x3c>)
 80032dc:	2200      	movs	r2, #0
 80032de:	701a      	strb	r2, [r3, #0]
  /* Reset LSEBYP bit */
  *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
 80032e0:	4b0a      	ldr	r3, [pc, #40]	; (800330c <RCC_LSEConfig+0x3c>)
 80032e2:	2200      	movs	r2, #0
 80032e4:	701a      	strb	r2, [r3, #0]
  /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
  switch(RCC_LSE)
 80032e6:	79fb      	ldrb	r3, [r7, #7]
 80032e8:	2b01      	cmp	r3, #1
 80032ea:	d002      	beq.n	80032f2 <RCC_LSEConfig+0x22>
 80032ec:	2b04      	cmp	r3, #4
 80032ee:	d004      	beq.n	80032fa <RCC_LSEConfig+0x2a>
      /* Set LSEBYP and LSEON bits */
      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
      break;            
      
    default:
      break;      
 80032f0:	e007      	b.n	8003302 <RCC_LSEConfig+0x32>
      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
 80032f2:	4b06      	ldr	r3, [pc, #24]	; (800330c <RCC_LSEConfig+0x3c>)
 80032f4:	2201      	movs	r2, #1
 80032f6:	701a      	strb	r2, [r3, #0]
      break;
 80032f8:	e003      	b.n	8003302 <RCC_LSEConfig+0x32>
      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
 80032fa:	4b04      	ldr	r3, [pc, #16]	; (800330c <RCC_LSEConfig+0x3c>)
 80032fc:	2205      	movs	r2, #5
 80032fe:	701a      	strb	r2, [r3, #0]
      break;            
 8003300:	bf00      	nop
  }
}
 8003302:	bf00      	nop
 8003304:	370c      	adds	r7, #12
 8003306:	46bd      	mov	sp, r7
 8003308:	bc80      	pop	{r7}
 800330a:	4770      	bx	lr
 800330c:	40021020 	.word	0x40021020

08003310 <RCC_GetClocksFreq>:
  * @param  RCC_Clocks: pointer to a RCC_ClocksTypeDef structure which will hold
  *   the clocks frequencies.
  * @retval None
  */
void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
{
 8003310:	b480      	push	{r7}
 8003312:	b087      	sub	sp, #28
 8003314:	af00      	add	r7, sp, #0
 8003316:	6078      	str	r0, [r7, #4]
  uint32_t tmp = 0, pllmull = 0, pllsource = 0, presc = 0;
 8003318:	2300      	movs	r3, #0
 800331a:	617b      	str	r3, [r7, #20]
 800331c:	2300      	movs	r3, #0
 800331e:	613b      	str	r3, [r7, #16]
 8003320:	2300      	movs	r3, #0
 8003322:	60fb      	str	r3, [r7, #12]
 8003324:	2300      	movs	r3, #0
 8003326:	60bb      	str	r3, [r7, #8]
#ifdef  STM32F10X_CL
  uint32_t prediv1source = 0, prediv1factor = 0, prediv2factor = 0, pll2mull = 0;
#endif /* STM32F10X_CL */
    
  /* Get SYSCLK source -------------------------------------------------------*/
  tmp = RCC->CFGR & CFGR_SWS_Mask;
 8003328:	4b4f      	ldr	r3, [pc, #316]	; (8003468 <RCC_GetClocksFreq+0x158>)
 800332a:	685b      	ldr	r3, [r3, #4]
 800332c:	f003 030c 	and.w	r3, r3, #12
 8003330:	617b      	str	r3, [r7, #20]
  
  switch (tmp)
 8003332:	697b      	ldr	r3, [r7, #20]
 8003334:	2b08      	cmp	r3, #8
 8003336:	d011      	beq.n	800335c <RCC_GetClocksFreq+0x4c>
 8003338:	697b      	ldr	r3, [r7, #20]
 800333a:	2b08      	cmp	r3, #8
 800333c:	d83a      	bhi.n	80033b4 <RCC_GetClocksFreq+0xa4>
 800333e:	697b      	ldr	r3, [r7, #20]
 8003340:	2b00      	cmp	r3, #0
 8003342:	d003      	beq.n	800334c <RCC_GetClocksFreq+0x3c>
 8003344:	697b      	ldr	r3, [r7, #20]
 8003346:	2b04      	cmp	r3, #4
 8003348:	d004      	beq.n	8003354 <RCC_GetClocksFreq+0x44>
 800334a:	e033      	b.n	80033b4 <RCC_GetClocksFreq+0xa4>
  {
    case 0x00:  /* HSI used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSI_Value;
 800334c:	687b      	ldr	r3, [r7, #4]
 800334e:	4a47      	ldr	r2, [pc, #284]	; (800346c <RCC_GetClocksFreq+0x15c>)
 8003350:	601a      	str	r2, [r3, #0]
      break;
 8003352:	e033      	b.n	80033bc <RCC_GetClocksFreq+0xac>
    case 0x04:  /* HSE used as system clock */
      RCC_Clocks->SYSCLK_Frequency = HSE_Value;
 8003354:	687b      	ldr	r3, [r7, #4]
 8003356:	4a46      	ldr	r2, [pc, #280]	; (8003470 <RCC_GetClocksFreq+0x160>)
 8003358:	601a      	str	r2, [r3, #0]
      break;
 800335a:	e02f      	b.n	80033bc <RCC_GetClocksFreq+0xac>
    case 0x08:  /* PLL used as system clock */

      /* Get PLL clock source and multiplication factor ----------------------*/
      pllmull = RCC->CFGR & CFGR_PLLMull_Mask;
 800335c:	4b42      	ldr	r3, [pc, #264]	; (8003468 <RCC_GetClocksFreq+0x158>)
 800335e:	685b      	ldr	r3, [r3, #4]
 8003360:	f403 1370 	and.w	r3, r3, #3932160	; 0x3c0000
 8003364:	613b      	str	r3, [r7, #16]
      pllsource = RCC->CFGR & CFGR_PLLSRC_Mask;
 8003366:	4b40      	ldr	r3, [pc, #256]	; (8003468 <RCC_GetClocksFreq+0x158>)
 8003368:	685b      	ldr	r3, [r3, #4]
 800336a:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 800336e:	60fb      	str	r3, [r7, #12]
      
#ifndef STM32F10X_CL      
      pllmull = ( pllmull >> 18) + 2;
 8003370:	693b      	ldr	r3, [r7, #16]
 8003372:	0c9b      	lsrs	r3, r3, #18
 8003374:	3302      	adds	r3, #2
 8003376:	613b      	str	r3, [r7, #16]
      
      if (pllsource == 0x00)
 8003378:	68fb      	ldr	r3, [r7, #12]
 800337a:	2b00      	cmp	r3, #0
 800337c:	d106      	bne.n	800338c <RCC_GetClocksFreq+0x7c>
      {/* HSI oscillator clock divided by 2 selected as PLL clock entry */
        RCC_Clocks->SYSCLK_Frequency = (HSI_Value >> 1) * pllmull;
 800337e:	693b      	ldr	r3, [r7, #16]
 8003380:	4a3c      	ldr	r2, [pc, #240]	; (8003474 <RCC_GetClocksFreq+0x164>)
 8003382:	fb03 f202 	mul.w	r2, r3, r2
 8003386:	687b      	ldr	r3, [r7, #4]
 8003388:	601a      	str	r2, [r3, #0]
          pll2mull = ((RCC->CFGR2 & CFGR2_PLL2MUL) >> 8 ) + 2; 
          RCC_Clocks->SYSCLK_Frequency = (((HSE_Value / prediv2factor) * pll2mull) / prediv1factor) * pllmull;                         
        }
      }
#endif /* STM32F10X_CL */ 
      break;
 800338a:	e017      	b.n	80033bc <RCC_GetClocksFreq+0xac>
        if ((RCC->CFGR & CFGR_PLLXTPRE_Mask) != (uint32_t)RESET)
 800338c:	4b36      	ldr	r3, [pc, #216]	; (8003468 <RCC_GetClocksFreq+0x158>)
 800338e:	685b      	ldr	r3, [r3, #4]
 8003390:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8003394:	2b00      	cmp	r3, #0
 8003396:	d006      	beq.n	80033a6 <RCC_GetClocksFreq+0x96>
          RCC_Clocks->SYSCLK_Frequency = (HSE_Value >> 1) * pllmull;
 8003398:	693b      	ldr	r3, [r7, #16]
 800339a:	4a34      	ldr	r2, [pc, #208]	; (800346c <RCC_GetClocksFreq+0x15c>)
 800339c:	fb03 f202 	mul.w	r2, r3, r2
 80033a0:	687b      	ldr	r3, [r7, #4]
 80033a2:	601a      	str	r2, [r3, #0]
      break;
 80033a4:	e00a      	b.n	80033bc <RCC_GetClocksFreq+0xac>
          RCC_Clocks->SYSCLK_Frequency = HSE_Value * pllmull;
 80033a6:	693b      	ldr	r3, [r7, #16]
 80033a8:	4a31      	ldr	r2, [pc, #196]	; (8003470 <RCC_GetClocksFreq+0x160>)
 80033aa:	fb03 f202 	mul.w	r2, r3, r2
 80033ae:	687b      	ldr	r3, [r7, #4]
 80033b0:	601a      	str	r2, [r3, #0]
      break;
 80033b2:	e003      	b.n	80033bc <RCC_GetClocksFreq+0xac>

    default:
      RCC_Clocks->SYSCLK_Frequency = HSI_Value;
 80033b4:	687b      	ldr	r3, [r7, #4]
 80033b6:	4a2d      	ldr	r2, [pc, #180]	; (800346c <RCC_GetClocksFreq+0x15c>)
 80033b8:	601a      	str	r2, [r3, #0]
      break;
 80033ba:	bf00      	nop
  }

  /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
  /* Get HCLK prescaler */
  tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;
 80033bc:	4b2a      	ldr	r3, [pc, #168]	; (8003468 <RCC_GetClocksFreq+0x158>)
 80033be:	685b      	ldr	r3, [r3, #4]
 80033c0:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 80033c4:	617b      	str	r3, [r7, #20]
  tmp = tmp >> 4;
 80033c6:	697b      	ldr	r3, [r7, #20]
 80033c8:	091b      	lsrs	r3, r3, #4
 80033ca:	617b      	str	r3, [r7, #20]
  presc = APBAHBPrescTable[tmp];
 80033cc:	4a2a      	ldr	r2, [pc, #168]	; (8003478 <RCC_GetClocksFreq+0x168>)
 80033ce:	697b      	ldr	r3, [r7, #20]
 80033d0:	4413      	add	r3, r2
 80033d2:	781b      	ldrb	r3, [r3, #0]
 80033d4:	b2db      	uxtb	r3, r3
 80033d6:	60bb      	str	r3, [r7, #8]
  /* HCLK clock frequency */
  RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
 80033d8:	687b      	ldr	r3, [r7, #4]
 80033da:	681a      	ldr	r2, [r3, #0]
 80033dc:	68bb      	ldr	r3, [r7, #8]
 80033de:	40da      	lsrs	r2, r3
 80033e0:	687b      	ldr	r3, [r7, #4]
 80033e2:	605a      	str	r2, [r3, #4]
  /* Get PCLK1 prescaler */
  tmp = RCC->CFGR & CFGR_PPRE1_Set_Mask;
 80033e4:	4b20      	ldr	r3, [pc, #128]	; (8003468 <RCC_GetClocksFreq+0x158>)
 80033e6:	685b      	ldr	r3, [r3, #4]
 80033e8:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 80033ec:	617b      	str	r3, [r7, #20]
  tmp = tmp >> 8;
 80033ee:	697b      	ldr	r3, [r7, #20]
 80033f0:	0a1b      	lsrs	r3, r3, #8
 80033f2:	617b      	str	r3, [r7, #20]
  presc = APBAHBPrescTable[tmp];
 80033f4:	4a20      	ldr	r2, [pc, #128]	; (8003478 <RCC_GetClocksFreq+0x168>)
 80033f6:	697b      	ldr	r3, [r7, #20]
 80033f8:	4413      	add	r3, r2
 80033fa:	781b      	ldrb	r3, [r3, #0]
 80033fc:	b2db      	uxtb	r3, r3
 80033fe:	60bb      	str	r3, [r7, #8]
  /* PCLK1 clock frequency */
  RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 8003400:	687b      	ldr	r3, [r7, #4]
 8003402:	685a      	ldr	r2, [r3, #4]
 8003404:	68bb      	ldr	r3, [r7, #8]
 8003406:	40da      	lsrs	r2, r3
 8003408:	687b      	ldr	r3, [r7, #4]
 800340a:	609a      	str	r2, [r3, #8]
  /* Get PCLK2 prescaler */
  tmp = RCC->CFGR & CFGR_PPRE2_Set_Mask;
 800340c:	4b16      	ldr	r3, [pc, #88]	; (8003468 <RCC_GetClocksFreq+0x158>)
 800340e:	685b      	ldr	r3, [r3, #4]
 8003410:	f403 5360 	and.w	r3, r3, #14336	; 0x3800
 8003414:	617b      	str	r3, [r7, #20]
  tmp = tmp >> 11;
 8003416:	697b      	ldr	r3, [r7, #20]
 8003418:	0adb      	lsrs	r3, r3, #11
 800341a:	617b      	str	r3, [r7, #20]
  presc = APBAHBPrescTable[tmp];
 800341c:	4a16      	ldr	r2, [pc, #88]	; (8003478 <RCC_GetClocksFreq+0x168>)
 800341e:	697b      	ldr	r3, [r7, #20]
 8003420:	4413      	add	r3, r2
 8003422:	781b      	ldrb	r3, [r3, #0]
 8003424:	b2db      	uxtb	r3, r3
 8003426:	60bb      	str	r3, [r7, #8]
  /* PCLK2 clock frequency */
  RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
 8003428:	687b      	ldr	r3, [r7, #4]
 800342a:	685a      	ldr	r2, [r3, #4]
 800342c:	68bb      	ldr	r3, [r7, #8]
 800342e:	40da      	lsrs	r2, r3
 8003430:	687b      	ldr	r3, [r7, #4]
 8003432:	60da      	str	r2, [r3, #12]
  /* Get ADCCLK prescaler */
  tmp = RCC->CFGR & CFGR_ADCPRE_Set_Mask;
 8003434:	4b0c      	ldr	r3, [pc, #48]	; (8003468 <RCC_GetClocksFreq+0x158>)
 8003436:	685b      	ldr	r3, [r3, #4]
 8003438:	f403 4340 	and.w	r3, r3, #49152	; 0xc000
 800343c:	617b      	str	r3, [r7, #20]
  tmp = tmp >> 14;
 800343e:	697b      	ldr	r3, [r7, #20]
 8003440:	0b9b      	lsrs	r3, r3, #14
 8003442:	617b      	str	r3, [r7, #20]
  presc = ADCPrescTable[tmp];
 8003444:	4a0d      	ldr	r2, [pc, #52]	; (800347c <RCC_GetClocksFreq+0x16c>)
 8003446:	697b      	ldr	r3, [r7, #20]
 8003448:	4413      	add	r3, r2
 800344a:	781b      	ldrb	r3, [r3, #0]
 800344c:	b2db      	uxtb	r3, r3
 800344e:	60bb      	str	r3, [r7, #8]
  /* ADCCLK clock frequency */
  RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK2_Frequency / presc;
 8003450:	687b      	ldr	r3, [r7, #4]
 8003452:	68da      	ldr	r2, [r3, #12]
 8003454:	68bb      	ldr	r3, [r7, #8]
 8003456:	fbb2 f2f3 	udiv	r2, r2, r3
 800345a:	687b      	ldr	r3, [r7, #4]
 800345c:	611a      	str	r2, [r3, #16]
}
 800345e:	bf00      	nop
 8003460:	371c      	adds	r7, #28
 8003462:	46bd      	mov	sp, r7
 8003464:	bc80      	pop	{r7}
 8003466:	4770      	bx	lr
 8003468:	40021000 	.word	0x40021000
 800346c:	007a1200 	.word	0x007a1200
 8003470:	00f42400 	.word	0x00f42400
 8003474:	003d0900 	.word	0x003d0900
 8003478:	20000134 	.word	0x20000134
 800347c:	20000144 	.word	0x20000144

08003480 <RCC_AHBPeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
{
 8003480:	b480      	push	{r7}
 8003482:	b083      	sub	sp, #12
 8003484:	af00      	add	r7, sp, #0
 8003486:	6078      	str	r0, [r7, #4]
 8003488:	460b      	mov	r3, r1
 800348a:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 800348c:	78fb      	ldrb	r3, [r7, #3]
 800348e:	2b00      	cmp	r3, #0
 8003490:	d006      	beq.n	80034a0 <RCC_AHBPeriphClockCmd+0x20>
  {
    RCC->AHBENR |= RCC_AHBPeriph;
 8003492:	4b09      	ldr	r3, [pc, #36]	; (80034b8 <RCC_AHBPeriphClockCmd+0x38>)
 8003494:	695a      	ldr	r2, [r3, #20]
 8003496:	4908      	ldr	r1, [pc, #32]	; (80034b8 <RCC_AHBPeriphClockCmd+0x38>)
 8003498:	687b      	ldr	r3, [r7, #4]
 800349a:	4313      	orrs	r3, r2
 800349c:	614b      	str	r3, [r1, #20]
  }
  else
  {
    RCC->AHBENR &= ~RCC_AHBPeriph;
  }
}
 800349e:	e006      	b.n	80034ae <RCC_AHBPeriphClockCmd+0x2e>
    RCC->AHBENR &= ~RCC_AHBPeriph;
 80034a0:	4b05      	ldr	r3, [pc, #20]	; (80034b8 <RCC_AHBPeriphClockCmd+0x38>)
 80034a2:	695a      	ldr	r2, [r3, #20]
 80034a4:	687b      	ldr	r3, [r7, #4]
 80034a6:	43db      	mvns	r3, r3
 80034a8:	4903      	ldr	r1, [pc, #12]	; (80034b8 <RCC_AHBPeriphClockCmd+0x38>)
 80034aa:	4013      	ands	r3, r2
 80034ac:	614b      	str	r3, [r1, #20]
}
 80034ae:	bf00      	nop
 80034b0:	370c      	adds	r7, #12
 80034b2:	46bd      	mov	sp, r7
 80034b4:	bc80      	pop	{r7}
 80034b6:	4770      	bx	lr
 80034b8:	40021000 	.word	0x40021000

080034bc <RCC_APB2PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
 80034bc:	b480      	push	{r7}
 80034be:	b083      	sub	sp, #12
 80034c0:	af00      	add	r7, sp, #0
 80034c2:	6078      	str	r0, [r7, #4]
 80034c4:	460b      	mov	r3, r1
 80034c6:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 80034c8:	78fb      	ldrb	r3, [r7, #3]
 80034ca:	2b00      	cmp	r3, #0
 80034cc:	d006      	beq.n	80034dc <RCC_APB2PeriphClockCmd+0x20>
  {
    RCC->APB2ENR |= RCC_APB2Periph;
 80034ce:	4b09      	ldr	r3, [pc, #36]	; (80034f4 <RCC_APB2PeriphClockCmd+0x38>)
 80034d0:	699a      	ldr	r2, [r3, #24]
 80034d2:	4908      	ldr	r1, [pc, #32]	; (80034f4 <RCC_APB2PeriphClockCmd+0x38>)
 80034d4:	687b      	ldr	r3, [r7, #4]
 80034d6:	4313      	orrs	r3, r2
 80034d8:	618b      	str	r3, [r1, #24]
  }
  else
  {
    RCC->APB2ENR &= ~RCC_APB2Periph;
  }
}
 80034da:	e006      	b.n	80034ea <RCC_APB2PeriphClockCmd+0x2e>
    RCC->APB2ENR &= ~RCC_APB2Periph;
 80034dc:	4b05      	ldr	r3, [pc, #20]	; (80034f4 <RCC_APB2PeriphClockCmd+0x38>)
 80034de:	699a      	ldr	r2, [r3, #24]
 80034e0:	687b      	ldr	r3, [r7, #4]
 80034e2:	43db      	mvns	r3, r3
 80034e4:	4903      	ldr	r1, [pc, #12]	; (80034f4 <RCC_APB2PeriphClockCmd+0x38>)
 80034e6:	4013      	ands	r3, r2
 80034e8:	618b      	str	r3, [r1, #24]
}
 80034ea:	bf00      	nop
 80034ec:	370c      	adds	r7, #12
 80034ee:	46bd      	mov	sp, r7
 80034f0:	bc80      	pop	{r7}
 80034f2:	4770      	bx	lr
 80034f4:	40021000 	.word	0x40021000

080034f8 <RCC_APB1PeriphClockCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
 80034f8:	b480      	push	{r7}
 80034fa:	b083      	sub	sp, #12
 80034fc:	af00      	add	r7, sp, #0
 80034fe:	6078      	str	r0, [r7, #4]
 8003500:	460b      	mov	r3, r1
 8003502:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8003504:	78fb      	ldrb	r3, [r7, #3]
 8003506:	2b00      	cmp	r3, #0
 8003508:	d006      	beq.n	8003518 <RCC_APB1PeriphClockCmd+0x20>
  {
    RCC->APB1ENR |= RCC_APB1Periph;
 800350a:	4b09      	ldr	r3, [pc, #36]	; (8003530 <RCC_APB1PeriphClockCmd+0x38>)
 800350c:	69da      	ldr	r2, [r3, #28]
 800350e:	4908      	ldr	r1, [pc, #32]	; (8003530 <RCC_APB1PeriphClockCmd+0x38>)
 8003510:	687b      	ldr	r3, [r7, #4]
 8003512:	4313      	orrs	r3, r2
 8003514:	61cb      	str	r3, [r1, #28]
  }
  else
  {
    RCC->APB1ENR &= ~RCC_APB1Periph;
  }
}
 8003516:	e006      	b.n	8003526 <RCC_APB1PeriphClockCmd+0x2e>
    RCC->APB1ENR &= ~RCC_APB1Periph;
 8003518:	4b05      	ldr	r3, [pc, #20]	; (8003530 <RCC_APB1PeriphClockCmd+0x38>)
 800351a:	69da      	ldr	r2, [r3, #28]
 800351c:	687b      	ldr	r3, [r7, #4]
 800351e:	43db      	mvns	r3, r3
 8003520:	4903      	ldr	r1, [pc, #12]	; (8003530 <RCC_APB1PeriphClockCmd+0x38>)
 8003522:	4013      	ands	r3, r2
 8003524:	61cb      	str	r3, [r1, #28]
}
 8003526:	bf00      	nop
 8003528:	370c      	adds	r7, #12
 800352a:	46bd      	mov	sp, r7
 800352c:	bc80      	pop	{r7}
 800352e:	4770      	bx	lr
 8003530:	40021000 	.word	0x40021000

08003534 <RCC_APB2PeriphResetCmd>:
  * @param  NewState: new state of the specified peripheral reset.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
{
 8003534:	b480      	push	{r7}
 8003536:	b083      	sub	sp, #12
 8003538:	af00      	add	r7, sp, #0
 800353a:	6078      	str	r0, [r7, #4]
 800353c:	460b      	mov	r3, r1
 800353e:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8003540:	78fb      	ldrb	r3, [r7, #3]
 8003542:	2b00      	cmp	r3, #0
 8003544:	d006      	beq.n	8003554 <RCC_APB2PeriphResetCmd+0x20>
  {
    RCC->APB2RSTR |= RCC_APB2Periph;
 8003546:	4b09      	ldr	r3, [pc, #36]	; (800356c <RCC_APB2PeriphResetCmd+0x38>)
 8003548:	68da      	ldr	r2, [r3, #12]
 800354a:	4908      	ldr	r1, [pc, #32]	; (800356c <RCC_APB2PeriphResetCmd+0x38>)
 800354c:	687b      	ldr	r3, [r7, #4]
 800354e:	4313      	orrs	r3, r2
 8003550:	60cb      	str	r3, [r1, #12]
  }
  else
  {
    RCC->APB2RSTR &= ~RCC_APB2Periph;
  }
}
 8003552:	e006      	b.n	8003562 <RCC_APB2PeriphResetCmd+0x2e>
    RCC->APB2RSTR &= ~RCC_APB2Periph;
 8003554:	4b05      	ldr	r3, [pc, #20]	; (800356c <RCC_APB2PeriphResetCmd+0x38>)
 8003556:	68da      	ldr	r2, [r3, #12]
 8003558:	687b      	ldr	r3, [r7, #4]
 800355a:	43db      	mvns	r3, r3
 800355c:	4903      	ldr	r1, [pc, #12]	; (800356c <RCC_APB2PeriphResetCmd+0x38>)
 800355e:	4013      	ands	r3, r2
 8003560:	60cb      	str	r3, [r1, #12]
}
 8003562:	bf00      	nop
 8003564:	370c      	adds	r7, #12
 8003566:	46bd      	mov	sp, r7
 8003568:	bc80      	pop	{r7}
 800356a:	4770      	bx	lr
 800356c:	40021000 	.word	0x40021000

08003570 <RCC_APB1PeriphResetCmd>:
  * @param  NewState: new state of the specified peripheral clock.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
{
 8003570:	b480      	push	{r7}
 8003572:	b083      	sub	sp, #12
 8003574:	af00      	add	r7, sp, #0
 8003576:	6078      	str	r0, [r7, #4]
 8003578:	460b      	mov	r3, r1
 800357a:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800357c:	78fb      	ldrb	r3, [r7, #3]
 800357e:	2b00      	cmp	r3, #0
 8003580:	d006      	beq.n	8003590 <RCC_APB1PeriphResetCmd+0x20>
  {
    RCC->APB1RSTR |= RCC_APB1Periph;
 8003582:	4b09      	ldr	r3, [pc, #36]	; (80035a8 <RCC_APB1PeriphResetCmd+0x38>)
 8003584:	691a      	ldr	r2, [r3, #16]
 8003586:	4908      	ldr	r1, [pc, #32]	; (80035a8 <RCC_APB1PeriphResetCmd+0x38>)
 8003588:	687b      	ldr	r3, [r7, #4]
 800358a:	4313      	orrs	r3, r2
 800358c:	610b      	str	r3, [r1, #16]
  }
  else
  {
    RCC->APB1RSTR &= ~RCC_APB1Periph;
  }
}
 800358e:	e006      	b.n	800359e <RCC_APB1PeriphResetCmd+0x2e>
    RCC->APB1RSTR &= ~RCC_APB1Periph;
 8003590:	4b05      	ldr	r3, [pc, #20]	; (80035a8 <RCC_APB1PeriphResetCmd+0x38>)
 8003592:	691a      	ldr	r2, [r3, #16]
 8003594:	687b      	ldr	r3, [r7, #4]
 8003596:	43db      	mvns	r3, r3
 8003598:	4903      	ldr	r1, [pc, #12]	; (80035a8 <RCC_APB1PeriphResetCmd+0x38>)
 800359a:	4013      	ands	r3, r2
 800359c:	610b      	str	r3, [r1, #16]
}
 800359e:	bf00      	nop
 80035a0:	370c      	adds	r7, #12
 80035a2:	46bd      	mov	sp, r7
 80035a4:	bc80      	pop	{r7}
 80035a6:	4770      	bx	lr
 80035a8:	40021000 	.word	0x40021000

080035ac <RCC_GetFlagStatus>:
  *     @arg RCC_FLAG_LPWRRST: Low Power reset
  *   
  * @retval The new state of RCC_FLAG (SET or RESET).
  */
FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)
{
 80035ac:	b480      	push	{r7}
 80035ae:	b087      	sub	sp, #28
 80035b0:	af00      	add	r7, sp, #0
 80035b2:	4603      	mov	r3, r0
 80035b4:	71fb      	strb	r3, [r7, #7]
  uint32_t tmp = 0;
 80035b6:	2300      	movs	r3, #0
 80035b8:	60fb      	str	r3, [r7, #12]
  uint32_t statusreg = 0;
 80035ba:	2300      	movs	r3, #0
 80035bc:	617b      	str	r3, [r7, #20]
  FlagStatus bitstatus = RESET;
 80035be:	2300      	movs	r3, #0
 80035c0:	74fb      	strb	r3, [r7, #19]
  /* Check the parameters */
  assert_param(IS_RCC_FLAG(RCC_FLAG));

  /* Get the RCC register index */
  tmp = RCC_FLAG >> 5;
 80035c2:	79fb      	ldrb	r3, [r7, #7]
 80035c4:	095b      	lsrs	r3, r3, #5
 80035c6:	b2db      	uxtb	r3, r3
 80035c8:	60fb      	str	r3, [r7, #12]
  if (tmp == 1)               /* The flag to check is in CR register */
 80035ca:	68fb      	ldr	r3, [r7, #12]
 80035cc:	2b01      	cmp	r3, #1
 80035ce:	d103      	bne.n	80035d8 <RCC_GetFlagStatus+0x2c>
  {
    statusreg = RCC->CR;
 80035d0:	4b12      	ldr	r3, [pc, #72]	; (800361c <RCC_GetFlagStatus+0x70>)
 80035d2:	681b      	ldr	r3, [r3, #0]
 80035d4:	617b      	str	r3, [r7, #20]
 80035d6:	e009      	b.n	80035ec <RCC_GetFlagStatus+0x40>
  }
  else if (tmp == 2)          /* The flag to check is in BDCR register */
 80035d8:	68fb      	ldr	r3, [r7, #12]
 80035da:	2b02      	cmp	r3, #2
 80035dc:	d103      	bne.n	80035e6 <RCC_GetFlagStatus+0x3a>
  {
    statusreg = RCC->BDCR;
 80035de:	4b0f      	ldr	r3, [pc, #60]	; (800361c <RCC_GetFlagStatus+0x70>)
 80035e0:	6a1b      	ldr	r3, [r3, #32]
 80035e2:	617b      	str	r3, [r7, #20]
 80035e4:	e002      	b.n	80035ec <RCC_GetFlagStatus+0x40>
  }
  else                       /* The flag to check is in CSR register */
  {
    statusreg = RCC->CSR;
 80035e6:	4b0d      	ldr	r3, [pc, #52]	; (800361c <RCC_GetFlagStatus+0x70>)
 80035e8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80035ea:	617b      	str	r3, [r7, #20]
  }

  /* Get the flag position */
  tmp = RCC_FLAG & FLAG_Mask;
 80035ec:	79fb      	ldrb	r3, [r7, #7]
 80035ee:	f003 031f 	and.w	r3, r3, #31
 80035f2:	60fb      	str	r3, [r7, #12]
  if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
 80035f4:	697a      	ldr	r2, [r7, #20]
 80035f6:	68fb      	ldr	r3, [r7, #12]
 80035f8:	fa22 f303 	lsr.w	r3, r2, r3
 80035fc:	f003 0301 	and.w	r3, r3, #1
 8003600:	2b00      	cmp	r3, #0
 8003602:	d002      	beq.n	800360a <RCC_GetFlagStatus+0x5e>
  {
    bitstatus = SET;
 8003604:	2301      	movs	r3, #1
 8003606:	74fb      	strb	r3, [r7, #19]
 8003608:	e001      	b.n	800360e <RCC_GetFlagStatus+0x62>
  }
  else
  {
    bitstatus = RESET;
 800360a:	2300      	movs	r3, #0
 800360c:	74fb      	strb	r3, [r7, #19]
  }

  /* Return the flag status */
  return bitstatus;
 800360e:	7cfb      	ldrb	r3, [r7, #19]
}
 8003610:	4618      	mov	r0, r3
 8003612:	371c      	adds	r7, #28
 8003614:	46bd      	mov	sp, r7
 8003616:	bc80      	pop	{r7}
 8003618:	4770      	bx	lr
 800361a:	bf00      	nop
 800361c:	40021000 	.word	0x40021000

08003620 <BKP_WriteBackupRegister>:
  *   This parameter can be BKP_DRx where x:[1, 42]
  * @param  Data: data to write
  * @retval None
  */
void BKP_WriteBackupRegister(uint16_t BKP_DR, uint16_t Data)
{
 8003620:	b480      	push	{r7}
 8003622:	b085      	sub	sp, #20
 8003624:	af00      	add	r7, sp, #0
 8003626:	4603      	mov	r3, r0
 8003628:	460a      	mov	r2, r1
 800362a:	80fb      	strh	r3, [r7, #6]
 800362c:	4613      	mov	r3, r2
 800362e:	80bb      	strh	r3, [r7, #4]
  __IO uint32_t tmp = 0;
 8003630:	2300      	movs	r3, #0
 8003632:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_BKP_DR(BKP_DR));

  tmp = (uint32_t)BKP_BASE; 
 8003634:	4b07      	ldr	r3, [pc, #28]	; (8003654 <BKP_WriteBackupRegister+0x34>)
 8003636:	60fb      	str	r3, [r7, #12]
  tmp += BKP_DR;
 8003638:	88fa      	ldrh	r2, [r7, #6]
 800363a:	68fb      	ldr	r3, [r7, #12]
 800363c:	4413      	add	r3, r2
 800363e:	60fb      	str	r3, [r7, #12]

  *(__IO uint32_t *) tmp = Data;
 8003640:	68fb      	ldr	r3, [r7, #12]
 8003642:	461a      	mov	r2, r3
 8003644:	88bb      	ldrh	r3, [r7, #4]
 8003646:	6013      	str	r3, [r2, #0]
}
 8003648:	bf00      	nop
 800364a:	3714      	adds	r7, #20
 800364c:	46bd      	mov	sp, r7
 800364e:	bc80      	pop	{r7}
 8003650:	4770      	bx	lr
 8003652:	bf00      	nop
 8003654:	40006c00 	.word	0x40006c00

08003658 <BKP_ReadBackupRegister>:
  * @param  BKP_DR: specifies the Data Backup Register.
  *   This parameter can be BKP_DRx where x:[1, 42]
  * @retval The content of the specified Data Backup Register
  */
uint16_t BKP_ReadBackupRegister(uint16_t BKP_DR)
{
 8003658:	b480      	push	{r7}
 800365a:	b085      	sub	sp, #20
 800365c:	af00      	add	r7, sp, #0
 800365e:	4603      	mov	r3, r0
 8003660:	80fb      	strh	r3, [r7, #6]
  __IO uint32_t tmp = 0;
 8003662:	2300      	movs	r3, #0
 8003664:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_BKP_DR(BKP_DR));

  tmp = (uint32_t)BKP_BASE; 
 8003666:	4b07      	ldr	r3, [pc, #28]	; (8003684 <BKP_ReadBackupRegister+0x2c>)
 8003668:	60fb      	str	r3, [r7, #12]
  tmp += BKP_DR;
 800366a:	88fa      	ldrh	r2, [r7, #6]
 800366c:	68fb      	ldr	r3, [r7, #12]
 800366e:	4413      	add	r3, r2
 8003670:	60fb      	str	r3, [r7, #12]

  return (*(__IO uint16_t *) tmp);
 8003672:	68fb      	ldr	r3, [r7, #12]
 8003674:	881b      	ldrh	r3, [r3, #0]
 8003676:	b29b      	uxth	r3, r3
}
 8003678:	4618      	mov	r0, r3
 800367a:	3714      	adds	r7, #20
 800367c:	46bd      	mov	sp, r7
 800367e:	bc80      	pop	{r7}
 8003680:	4770      	bx	lr
 8003682:	bf00      	nop
 8003684:	40006c00 	.word	0x40006c00

08003688 <PWR_BackupAccessCmd>:
  * @param  NewState: new state of the access to the RTC and backup registers.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void PWR_BackupAccessCmd(FunctionalState NewState)
{
 8003688:	b480      	push	{r7}
 800368a:	b083      	sub	sp, #12
 800368c:	af00      	add	r7, sp, #0
 800368e:	4603      	mov	r3, r0
 8003690:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  *(__IO uint32_t *) CR_DBP_BB = (uint32_t)NewState;
 8003692:	4a04      	ldr	r2, [pc, #16]	; (80036a4 <PWR_BackupAccessCmd+0x1c>)
 8003694:	79fb      	ldrb	r3, [r7, #7]
 8003696:	6013      	str	r3, [r2, #0]
}
 8003698:	bf00      	nop
 800369a:	370c      	adds	r7, #12
 800369c:	46bd      	mov	sp, r7
 800369e:	bc80      	pop	{r7}
 80036a0:	4770      	bx	lr
 80036a2:	bf00      	nop
 80036a4:	420e0020 	.word	0x420e0020

080036a8 <IWDG_WriteAccessCmd>:
  *     @arg IWDG_WriteAccess_Enable: Enable write access to IWDG_PR and IWDG_RLR registers
  *     @arg IWDG_WriteAccess_Disable: Disable write access to IWDG_PR and IWDG_RLR registers
  * @retval None
  */
void IWDG_WriteAccessCmd(uint16_t IWDG_WriteAccess)
{
 80036a8:	b480      	push	{r7}
 80036aa:	b083      	sub	sp, #12
 80036ac:	af00      	add	r7, sp, #0
 80036ae:	4603      	mov	r3, r0
 80036b0:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_IWDG_WRITE_ACCESS(IWDG_WriteAccess));
  IWDG->KR = IWDG_WriteAccess;
 80036b2:	4a04      	ldr	r2, [pc, #16]	; (80036c4 <IWDG_WriteAccessCmd+0x1c>)
 80036b4:	88fb      	ldrh	r3, [r7, #6]
 80036b6:	6013      	str	r3, [r2, #0]
}
 80036b8:	bf00      	nop
 80036ba:	370c      	adds	r7, #12
 80036bc:	46bd      	mov	sp, r7
 80036be:	bc80      	pop	{r7}
 80036c0:	4770      	bx	lr
 80036c2:	bf00      	nop
 80036c4:	40003000 	.word	0x40003000

080036c8 <IWDG_SetPrescaler>:
  *     @arg IWDG_Prescaler_128: IWDG prescaler set to 128
  *     @arg IWDG_Prescaler_256: IWDG prescaler set to 256
  * @retval None
  */
void IWDG_SetPrescaler(uint8_t IWDG_Prescaler)
{
 80036c8:	b480      	push	{r7}
 80036ca:	b083      	sub	sp, #12
 80036cc:	af00      	add	r7, sp, #0
 80036ce:	4603      	mov	r3, r0
 80036d0:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_IWDG_PRESCALER(IWDG_Prescaler));
  IWDG->PR = IWDG_Prescaler;
 80036d2:	4a04      	ldr	r2, [pc, #16]	; (80036e4 <IWDG_SetPrescaler+0x1c>)
 80036d4:	79fb      	ldrb	r3, [r7, #7]
 80036d6:	6053      	str	r3, [r2, #4]
}
 80036d8:	bf00      	nop
 80036da:	370c      	adds	r7, #12
 80036dc:	46bd      	mov	sp, r7
 80036de:	bc80      	pop	{r7}
 80036e0:	4770      	bx	lr
 80036e2:	bf00      	nop
 80036e4:	40003000 	.word	0x40003000

080036e8 <IWDG_SetReload>:
  * @param  Reload: specifies the IWDG Reload value.
  *   This parameter must be a number between 0 and 0x0FFF.
  * @retval None
  */
void IWDG_SetReload(uint16_t Reload)
{
 80036e8:	b480      	push	{r7}
 80036ea:	b083      	sub	sp, #12
 80036ec:	af00      	add	r7, sp, #0
 80036ee:	4603      	mov	r3, r0
 80036f0:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_IWDG_RELOAD(Reload));
  IWDG->RLR = Reload;
 80036f2:	4a04      	ldr	r2, [pc, #16]	; (8003704 <IWDG_SetReload+0x1c>)
 80036f4:	88fb      	ldrh	r3, [r7, #6]
 80036f6:	6093      	str	r3, [r2, #8]
}
 80036f8:	bf00      	nop
 80036fa:	370c      	adds	r7, #12
 80036fc:	46bd      	mov	sp, r7
 80036fe:	bc80      	pop	{r7}
 8003700:	4770      	bx	lr
 8003702:	bf00      	nop
 8003704:	40003000 	.word	0x40003000

08003708 <IWDG_ReloadCounter>:
  *   (write access to IWDG_PR and IWDG_RLR registers disabled).
  * @param  None
  * @retval None
  */
void IWDG_ReloadCounter(void)
{
 8003708:	b480      	push	{r7}
 800370a:	af00      	add	r7, sp, #0
  IWDG->KR = KR_KEY_Reload;
 800370c:	4b03      	ldr	r3, [pc, #12]	; (800371c <IWDG_ReloadCounter+0x14>)
 800370e:	f64a 22aa 	movw	r2, #43690	; 0xaaaa
 8003712:	601a      	str	r2, [r3, #0]
}
 8003714:	bf00      	nop
 8003716:	46bd      	mov	sp, r7
 8003718:	bc80      	pop	{r7}
 800371a:	4770      	bx	lr
 800371c:	40003000 	.word	0x40003000

08003720 <IWDG_Enable>:
  * @brief  Enables IWDG (write access to IWDG_PR and IWDG_RLR registers disabled).
  * @param  None
  * @retval None
  */
void IWDG_Enable(void)
{
 8003720:	b480      	push	{r7}
 8003722:	af00      	add	r7, sp, #0
  IWDG->KR = KR_KEY_Enable;
 8003724:	4b03      	ldr	r3, [pc, #12]	; (8003734 <IWDG_Enable+0x14>)
 8003726:	f64c 42cc 	movw	r2, #52428	; 0xcccc
 800372a:	601a      	str	r2, [r3, #0]
}
 800372c:	bf00      	nop
 800372e:	46bd      	mov	sp, r7
 8003730:	bc80      	pop	{r7}
 8003732:	4770      	bx	lr
 8003734:	40003000 	.word	0x40003000

08003738 <DMA_DeInit>:
  * @param  DMAy_Channelx: where y can be 1 or 2 to select the DMA and
  *   x can be 1 to 7 for DMA1 and 1 to 5 for DMA2 to select the DMA Channel.
  * @retval None
  */
void DMA_DeInit(DMA_Channel_TypeDef* DMAy_Channelx)
{
 8003738:	b480      	push	{r7}
 800373a:	b083      	sub	sp, #12
 800373c:	af00      	add	r7, sp, #0
 800373e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
  /* Disable the selected DMAy Channelx */
  DMAy_Channelx->CCR &= CCR_ENABLE_Reset;
 8003740:	687b      	ldr	r3, [r7, #4]
 8003742:	681b      	ldr	r3, [r3, #0]
 8003744:	f023 0201 	bic.w	r2, r3, #1
 8003748:	687b      	ldr	r3, [r7, #4]
 800374a:	601a      	str	r2, [r3, #0]
  /* Reset DMAy Channelx control register */
  DMAy_Channelx->CCR  = 0;
 800374c:	687b      	ldr	r3, [r7, #4]
 800374e:	2200      	movs	r2, #0
 8003750:	601a      	str	r2, [r3, #0]
  
  /* Reset DMAy Channelx remaining bytes register */
  DMAy_Channelx->CNDTR = 0;
 8003752:	687b      	ldr	r3, [r7, #4]
 8003754:	2200      	movs	r2, #0
 8003756:	605a      	str	r2, [r3, #4]
  
  /* Reset DMAy Channelx peripheral address register */
  DMAy_Channelx->CPAR  = 0;
 8003758:	687b      	ldr	r3, [r7, #4]
 800375a:	2200      	movs	r2, #0
 800375c:	609a      	str	r2, [r3, #8]
  
  /* Reset DMAy Channelx memory address register */
  DMAy_Channelx->CMAR = 0;
 800375e:	687b      	ldr	r3, [r7, #4]
 8003760:	2200      	movs	r2, #0
 8003762:	60da      	str	r2, [r3, #12]
  
  if (DMAy_Channelx == DMA1_Channel1)
 8003764:	687b      	ldr	r3, [r7, #4]
 8003766:	4a43      	ldr	r2, [pc, #268]	; (8003874 <DMA_DeInit+0x13c>)
 8003768:	4293      	cmp	r3, r2
 800376a:	d106      	bne.n	800377a <DMA_DeInit+0x42>
  {
    /* Reset interrupt pending bits for DMA1 Channel1 */
    DMA1->IFCR |= DMA1_Channel1_IT_Mask;
 800376c:	4b42      	ldr	r3, [pc, #264]	; (8003878 <DMA_DeInit+0x140>)
 800376e:	685b      	ldr	r3, [r3, #4]
 8003770:	4a41      	ldr	r2, [pc, #260]	; (8003878 <DMA_DeInit+0x140>)
 8003772:	f043 030f 	orr.w	r3, r3, #15
 8003776:	6053      	str	r3, [r2, #4]
    {
      /* Reset interrupt pending bits for DMA2 Channel5 */
      DMA2->IFCR |= DMA2_Channel5_IT_Mask;
    }
  }
}
 8003778:	e077      	b.n	800386a <DMA_DeInit+0x132>
  else if (DMAy_Channelx == DMA1_Channel2)
 800377a:	687b      	ldr	r3, [r7, #4]
 800377c:	4a3f      	ldr	r2, [pc, #252]	; (800387c <DMA_DeInit+0x144>)
 800377e:	4293      	cmp	r3, r2
 8003780:	d106      	bne.n	8003790 <DMA_DeInit+0x58>
    DMA1->IFCR |= DMA1_Channel2_IT_Mask;
 8003782:	4b3d      	ldr	r3, [pc, #244]	; (8003878 <DMA_DeInit+0x140>)
 8003784:	685b      	ldr	r3, [r3, #4]
 8003786:	4a3c      	ldr	r2, [pc, #240]	; (8003878 <DMA_DeInit+0x140>)
 8003788:	f043 03f0 	orr.w	r3, r3, #240	; 0xf0
 800378c:	6053      	str	r3, [r2, #4]
}
 800378e:	e06c      	b.n	800386a <DMA_DeInit+0x132>
  else if (DMAy_Channelx == DMA1_Channel3)
 8003790:	687b      	ldr	r3, [r7, #4]
 8003792:	4a3b      	ldr	r2, [pc, #236]	; (8003880 <DMA_DeInit+0x148>)
 8003794:	4293      	cmp	r3, r2
 8003796:	d106      	bne.n	80037a6 <DMA_DeInit+0x6e>
    DMA1->IFCR |= DMA1_Channel3_IT_Mask;
 8003798:	4b37      	ldr	r3, [pc, #220]	; (8003878 <DMA_DeInit+0x140>)
 800379a:	685b      	ldr	r3, [r3, #4]
 800379c:	4a36      	ldr	r2, [pc, #216]	; (8003878 <DMA_DeInit+0x140>)
 800379e:	f443 6370 	orr.w	r3, r3, #3840	; 0xf00
 80037a2:	6053      	str	r3, [r2, #4]
}
 80037a4:	e061      	b.n	800386a <DMA_DeInit+0x132>
  else if (DMAy_Channelx == DMA1_Channel4)
 80037a6:	687b      	ldr	r3, [r7, #4]
 80037a8:	4a36      	ldr	r2, [pc, #216]	; (8003884 <DMA_DeInit+0x14c>)
 80037aa:	4293      	cmp	r3, r2
 80037ac:	d106      	bne.n	80037bc <DMA_DeInit+0x84>
    DMA1->IFCR |= DMA1_Channel4_IT_Mask;
 80037ae:	4b32      	ldr	r3, [pc, #200]	; (8003878 <DMA_DeInit+0x140>)
 80037b0:	685b      	ldr	r3, [r3, #4]
 80037b2:	4a31      	ldr	r2, [pc, #196]	; (8003878 <DMA_DeInit+0x140>)
 80037b4:	f443 4370 	orr.w	r3, r3, #61440	; 0xf000
 80037b8:	6053      	str	r3, [r2, #4]
}
 80037ba:	e056      	b.n	800386a <DMA_DeInit+0x132>
  else if (DMAy_Channelx == DMA1_Channel5)
 80037bc:	687b      	ldr	r3, [r7, #4]
 80037be:	4a32      	ldr	r2, [pc, #200]	; (8003888 <DMA_DeInit+0x150>)
 80037c0:	4293      	cmp	r3, r2
 80037c2:	d106      	bne.n	80037d2 <DMA_DeInit+0x9a>
    DMA1->IFCR |= DMA1_Channel5_IT_Mask;
 80037c4:	4b2c      	ldr	r3, [pc, #176]	; (8003878 <DMA_DeInit+0x140>)
 80037c6:	685b      	ldr	r3, [r3, #4]
 80037c8:	4a2b      	ldr	r2, [pc, #172]	; (8003878 <DMA_DeInit+0x140>)
 80037ca:	f443 2370 	orr.w	r3, r3, #983040	; 0xf0000
 80037ce:	6053      	str	r3, [r2, #4]
}
 80037d0:	e04b      	b.n	800386a <DMA_DeInit+0x132>
  else if (DMAy_Channelx == DMA1_Channel6)
 80037d2:	687b      	ldr	r3, [r7, #4]
 80037d4:	4a2d      	ldr	r2, [pc, #180]	; (800388c <DMA_DeInit+0x154>)
 80037d6:	4293      	cmp	r3, r2
 80037d8:	d106      	bne.n	80037e8 <DMA_DeInit+0xb0>
    DMA1->IFCR |= DMA1_Channel6_IT_Mask;
 80037da:	4b27      	ldr	r3, [pc, #156]	; (8003878 <DMA_DeInit+0x140>)
 80037dc:	685b      	ldr	r3, [r3, #4]
 80037de:	4a26      	ldr	r2, [pc, #152]	; (8003878 <DMA_DeInit+0x140>)
 80037e0:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 80037e4:	6053      	str	r3, [r2, #4]
}
 80037e6:	e040      	b.n	800386a <DMA_DeInit+0x132>
  else if (DMAy_Channelx == DMA1_Channel7)
 80037e8:	687b      	ldr	r3, [r7, #4]
 80037ea:	4a29      	ldr	r2, [pc, #164]	; (8003890 <DMA_DeInit+0x158>)
 80037ec:	4293      	cmp	r3, r2
 80037ee:	d106      	bne.n	80037fe <DMA_DeInit+0xc6>
    DMA1->IFCR |= DMA1_Channel7_IT_Mask;
 80037f0:	4b21      	ldr	r3, [pc, #132]	; (8003878 <DMA_DeInit+0x140>)
 80037f2:	685b      	ldr	r3, [r3, #4]
 80037f4:	4a20      	ldr	r2, [pc, #128]	; (8003878 <DMA_DeInit+0x140>)
 80037f6:	f043 6370 	orr.w	r3, r3, #251658240	; 0xf000000
 80037fa:	6053      	str	r3, [r2, #4]
}
 80037fc:	e035      	b.n	800386a <DMA_DeInit+0x132>
  else if (DMAy_Channelx == DMA2_Channel1)
 80037fe:	687b      	ldr	r3, [r7, #4]
 8003800:	4a24      	ldr	r2, [pc, #144]	; (8003894 <DMA_DeInit+0x15c>)
 8003802:	4293      	cmp	r3, r2
 8003804:	d106      	bne.n	8003814 <DMA_DeInit+0xdc>
    DMA2->IFCR |= DMA2_Channel1_IT_Mask;
 8003806:	4b24      	ldr	r3, [pc, #144]	; (8003898 <DMA_DeInit+0x160>)
 8003808:	685b      	ldr	r3, [r3, #4]
 800380a:	4a23      	ldr	r2, [pc, #140]	; (8003898 <DMA_DeInit+0x160>)
 800380c:	f043 030f 	orr.w	r3, r3, #15
 8003810:	6053      	str	r3, [r2, #4]
}
 8003812:	e02a      	b.n	800386a <DMA_DeInit+0x132>
  else if (DMAy_Channelx == DMA2_Channel2)
 8003814:	687b      	ldr	r3, [r7, #4]
 8003816:	4a21      	ldr	r2, [pc, #132]	; (800389c <DMA_DeInit+0x164>)
 8003818:	4293      	cmp	r3, r2
 800381a:	d106      	bne.n	800382a <DMA_DeInit+0xf2>
    DMA2->IFCR |= DMA2_Channel2_IT_Mask;
 800381c:	4b1e      	ldr	r3, [pc, #120]	; (8003898 <DMA_DeInit+0x160>)
 800381e:	685b      	ldr	r3, [r3, #4]
 8003820:	4a1d      	ldr	r2, [pc, #116]	; (8003898 <DMA_DeInit+0x160>)
 8003822:	f043 03f0 	orr.w	r3, r3, #240	; 0xf0
 8003826:	6053      	str	r3, [r2, #4]
}
 8003828:	e01f      	b.n	800386a <DMA_DeInit+0x132>
  else if (DMAy_Channelx == DMA2_Channel3)
 800382a:	687b      	ldr	r3, [r7, #4]
 800382c:	4a1c      	ldr	r2, [pc, #112]	; (80038a0 <DMA_DeInit+0x168>)
 800382e:	4293      	cmp	r3, r2
 8003830:	d106      	bne.n	8003840 <DMA_DeInit+0x108>
    DMA2->IFCR |= DMA2_Channel3_IT_Mask;
 8003832:	4b19      	ldr	r3, [pc, #100]	; (8003898 <DMA_DeInit+0x160>)
 8003834:	685b      	ldr	r3, [r3, #4]
 8003836:	4a18      	ldr	r2, [pc, #96]	; (8003898 <DMA_DeInit+0x160>)
 8003838:	f443 6370 	orr.w	r3, r3, #3840	; 0xf00
 800383c:	6053      	str	r3, [r2, #4]
}
 800383e:	e014      	b.n	800386a <DMA_DeInit+0x132>
  else if (DMAy_Channelx == DMA2_Channel4)
 8003840:	687b      	ldr	r3, [r7, #4]
 8003842:	4a18      	ldr	r2, [pc, #96]	; (80038a4 <DMA_DeInit+0x16c>)
 8003844:	4293      	cmp	r3, r2
 8003846:	d106      	bne.n	8003856 <DMA_DeInit+0x11e>
    DMA2->IFCR |= DMA2_Channel4_IT_Mask;
 8003848:	4b13      	ldr	r3, [pc, #76]	; (8003898 <DMA_DeInit+0x160>)
 800384a:	685b      	ldr	r3, [r3, #4]
 800384c:	4a12      	ldr	r2, [pc, #72]	; (8003898 <DMA_DeInit+0x160>)
 800384e:	f443 4370 	orr.w	r3, r3, #61440	; 0xf000
 8003852:	6053      	str	r3, [r2, #4]
}
 8003854:	e009      	b.n	800386a <DMA_DeInit+0x132>
    if (DMAy_Channelx == DMA2_Channel5)
 8003856:	687b      	ldr	r3, [r7, #4]
 8003858:	4a13      	ldr	r2, [pc, #76]	; (80038a8 <DMA_DeInit+0x170>)
 800385a:	4293      	cmp	r3, r2
 800385c:	d105      	bne.n	800386a <DMA_DeInit+0x132>
      DMA2->IFCR |= DMA2_Channel5_IT_Mask;
 800385e:	4b0e      	ldr	r3, [pc, #56]	; (8003898 <DMA_DeInit+0x160>)
 8003860:	685b      	ldr	r3, [r3, #4]
 8003862:	4a0d      	ldr	r2, [pc, #52]	; (8003898 <DMA_DeInit+0x160>)
 8003864:	f443 2370 	orr.w	r3, r3, #983040	; 0xf0000
 8003868:	6053      	str	r3, [r2, #4]
}
 800386a:	bf00      	nop
 800386c:	370c      	adds	r7, #12
 800386e:	46bd      	mov	sp, r7
 8003870:	bc80      	pop	{r7}
 8003872:	4770      	bx	lr
 8003874:	40020008 	.word	0x40020008
 8003878:	40020000 	.word	0x40020000
 800387c:	4002001c 	.word	0x4002001c
 8003880:	40020030 	.word	0x40020030
 8003884:	40020044 	.word	0x40020044
 8003888:	40020058 	.word	0x40020058
 800388c:	4002006c 	.word	0x4002006c
 8003890:	40020080 	.word	0x40020080
 8003894:	40020408 	.word	0x40020408
 8003898:	40020400 	.word	0x40020400
 800389c:	4002041c 	.word	0x4002041c
 80038a0:	40020430 	.word	0x40020430
 80038a4:	40020444 	.word	0x40020444
 80038a8:	40020458 	.word	0x40020458

080038ac <DMA_Init>:
  * @param  DMA_InitStruct: pointer to a DMA_InitTypeDef structure that
  *   contains the configuration information for the specified DMA Channel.
  * @retval None
  */
void DMA_Init(DMA_Channel_TypeDef* DMAy_Channelx, DMA_InitTypeDef* DMA_InitStruct)
{
 80038ac:	b480      	push	{r7}
 80038ae:	b085      	sub	sp, #20
 80038b0:	af00      	add	r7, sp, #0
 80038b2:	6078      	str	r0, [r7, #4]
 80038b4:	6039      	str	r1, [r7, #0]
  uint32_t tmpreg = 0;
 80038b6:	2300      	movs	r3, #0
 80038b8:	60fb      	str	r3, [r7, #12]
  assert_param(IS_DMA_PRIORITY(DMA_InitStruct->DMA_Priority));
  assert_param(IS_DMA_M2M_STATE(DMA_InitStruct->DMA_M2M));

/*--------------------------- DMAy Channelx CCR Configuration -----------------*/
  /* Get the DMAy_Channelx CCR value */
  tmpreg = DMAy_Channelx->CCR;
 80038ba:	687b      	ldr	r3, [r7, #4]
 80038bc:	681b      	ldr	r3, [r3, #0]
 80038be:	60fb      	str	r3, [r7, #12]
  /* Clear MEM2MEM, PL, MSIZE, PSIZE, MINC, PINC, CIRC and DIR bits */
  tmpreg &= CCR_CLEAR_Mask;
 80038c0:	68fb      	ldr	r3, [r7, #12]
 80038c2:	f423 43ff 	bic.w	r3, r3, #32640	; 0x7f80
 80038c6:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80038ca:	60fb      	str	r3, [r7, #12]
  /* Set MINC bit according to DMA_MemoryInc value */
  /* Set PSIZE bits according to DMA_PeripheralDataSize value */
  /* Set MSIZE bits according to DMA_MemoryDataSize value */
  /* Set PL bits according to DMA_Priority value */
  /* Set the MEM2MEM bit according to DMA_M2M value */
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
 80038cc:	683b      	ldr	r3, [r7, #0]
 80038ce:	689a      	ldr	r2, [r3, #8]
 80038d0:	683b      	ldr	r3, [r7, #0]
 80038d2:	6a1b      	ldr	r3, [r3, #32]
 80038d4:	431a      	orrs	r2, r3
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
 80038d6:	683b      	ldr	r3, [r7, #0]
 80038d8:	691b      	ldr	r3, [r3, #16]
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
 80038da:	431a      	orrs	r2, r3
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
 80038dc:	683b      	ldr	r3, [r7, #0]
 80038de:	695b      	ldr	r3, [r3, #20]
 80038e0:	431a      	orrs	r2, r3
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
 80038e2:	683b      	ldr	r3, [r7, #0]
 80038e4:	699b      	ldr	r3, [r3, #24]
            DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
 80038e6:	431a      	orrs	r2, r3
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
 80038e8:	683b      	ldr	r3, [r7, #0]
 80038ea:	69db      	ldr	r3, [r3, #28]
 80038ec:	431a      	orrs	r2, r3
            DMA_InitStruct->DMA_Priority | DMA_InitStruct->DMA_M2M;
 80038ee:	683b      	ldr	r3, [r7, #0]
 80038f0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
            DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
 80038f2:	431a      	orrs	r2, r3
            DMA_InitStruct->DMA_Priority | DMA_InitStruct->DMA_M2M;
 80038f4:	683b      	ldr	r3, [r7, #0]
 80038f6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80038f8:	4313      	orrs	r3, r2
  tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
 80038fa:	68fa      	ldr	r2, [r7, #12]
 80038fc:	4313      	orrs	r3, r2
 80038fe:	60fb      	str	r3, [r7, #12]

  /* Write to DMAy Channelx CCR */
  DMAy_Channelx->CCR = tmpreg;
 8003900:	687b      	ldr	r3, [r7, #4]
 8003902:	68fa      	ldr	r2, [r7, #12]
 8003904:	601a      	str	r2, [r3, #0]

/*--------------------------- DMAy Channelx CNDTR Configuration ---------------*/
  /* Write to DMAy Channelx CNDTR */
  DMAy_Channelx->CNDTR = DMA_InitStruct->DMA_BufferSize;
 8003906:	683b      	ldr	r3, [r7, #0]
 8003908:	68da      	ldr	r2, [r3, #12]
 800390a:	687b      	ldr	r3, [r7, #4]
 800390c:	605a      	str	r2, [r3, #4]

/*--------------------------- DMAy Channelx CPAR Configuration ----------------*/
  /* Write to DMAy Channelx CPAR */
  DMAy_Channelx->CPAR = DMA_InitStruct->DMA_PeripheralBaseAddr;
 800390e:	683b      	ldr	r3, [r7, #0]
 8003910:	681a      	ldr	r2, [r3, #0]
 8003912:	687b      	ldr	r3, [r7, #4]
 8003914:	609a      	str	r2, [r3, #8]

/*--------------------------- DMAy Channelx CMAR Configuration ----------------*/
  /* Write to DMAy Channelx CMAR */
  DMAy_Channelx->CMAR = DMA_InitStruct->DMA_MemoryBaseAddr;
 8003916:	683b      	ldr	r3, [r7, #0]
 8003918:	685a      	ldr	r2, [r3, #4]
 800391a:	687b      	ldr	r3, [r7, #4]
 800391c:	60da      	str	r2, [r3, #12]
}
 800391e:	bf00      	nop
 8003920:	3714      	adds	r7, #20
 8003922:	46bd      	mov	sp, r7
 8003924:	bc80      	pop	{r7}
 8003926:	4770      	bx	lr

08003928 <DMA_Cmd>:
  * @param  NewState: new state of the DMAy Channelx. 
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void DMA_Cmd(DMA_Channel_TypeDef* DMAy_Channelx, FunctionalState NewState)
{
 8003928:	b480      	push	{r7}
 800392a:	b083      	sub	sp, #12
 800392c:	af00      	add	r7, sp, #0
 800392e:	6078      	str	r0, [r7, #4]
 8003930:	460b      	mov	r3, r1
 8003932:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));

  if (NewState != DISABLE)
 8003934:	78fb      	ldrb	r3, [r7, #3]
 8003936:	2b00      	cmp	r3, #0
 8003938:	d006      	beq.n	8003948 <DMA_Cmd+0x20>
  {
    /* Enable the selected DMAy Channelx */
    DMAy_Channelx->CCR |= CCR_ENABLE_Set;
 800393a:	687b      	ldr	r3, [r7, #4]
 800393c:	681b      	ldr	r3, [r3, #0]
 800393e:	f043 0201 	orr.w	r2, r3, #1
 8003942:	687b      	ldr	r3, [r7, #4]
 8003944:	601a      	str	r2, [r3, #0]
  else
  {
    /* Disable the selected DMAy Channelx */
    DMAy_Channelx->CCR &= CCR_ENABLE_Reset;
  }
}
 8003946:	e005      	b.n	8003954 <DMA_Cmd+0x2c>
    DMAy_Channelx->CCR &= CCR_ENABLE_Reset;
 8003948:	687b      	ldr	r3, [r7, #4]
 800394a:	681b      	ldr	r3, [r3, #0]
 800394c:	f023 0201 	bic.w	r2, r3, #1
 8003950:	687b      	ldr	r3, [r7, #4]
 8003952:	601a      	str	r2, [r3, #0]
}
 8003954:	bf00      	nop
 8003956:	370c      	adds	r7, #12
 8003958:	46bd      	mov	sp, r7
 800395a:	bc80      	pop	{r7}
 800395c:	4770      	bx	lr

0800395e <DMA_ITConfig>:
  * @param  NewState: new state of the specified DMA interrupts.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void DMA_ITConfig(DMA_Channel_TypeDef* DMAy_Channelx, uint32_t DMA_IT, FunctionalState NewState)
{
 800395e:	b480      	push	{r7}
 8003960:	b085      	sub	sp, #20
 8003962:	af00      	add	r7, sp, #0
 8003964:	60f8      	str	r0, [r7, #12]
 8003966:	60b9      	str	r1, [r7, #8]
 8003968:	4613      	mov	r3, r2
 800396a:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
  assert_param(IS_DMA_CONFIG_IT(DMA_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 800396c:	79fb      	ldrb	r3, [r7, #7]
 800396e:	2b00      	cmp	r3, #0
 8003970:	d006      	beq.n	8003980 <DMA_ITConfig+0x22>
  {
    /* Enable the selected DMA interrupts */
    DMAy_Channelx->CCR |= DMA_IT;
 8003972:	68fb      	ldr	r3, [r7, #12]
 8003974:	681a      	ldr	r2, [r3, #0]
 8003976:	68bb      	ldr	r3, [r7, #8]
 8003978:	431a      	orrs	r2, r3
 800397a:	68fb      	ldr	r3, [r7, #12]
 800397c:	601a      	str	r2, [r3, #0]
  else
  {
    /* Disable the selected DMA interrupts */
    DMAy_Channelx->CCR &= ~DMA_IT;
  }
}
 800397e:	e006      	b.n	800398e <DMA_ITConfig+0x30>
    DMAy_Channelx->CCR &= ~DMA_IT;
 8003980:	68fb      	ldr	r3, [r7, #12]
 8003982:	681a      	ldr	r2, [r3, #0]
 8003984:	68bb      	ldr	r3, [r7, #8]
 8003986:	43db      	mvns	r3, r3
 8003988:	401a      	ands	r2, r3
 800398a:	68fb      	ldr	r3, [r7, #12]
 800398c:	601a      	str	r2, [r3, #0]
}
 800398e:	bf00      	nop
 8003990:	3714      	adds	r7, #20
 8003992:	46bd      	mov	sp, r7
 8003994:	bc80      	pop	{r7}
 8003996:	4770      	bx	lr

08003998 <DMA_GetCurrDataCounter>:
  *   x can be 1 to 7 for DMA1 and 1 to 5 for DMA2 to select the DMA Channel.
  * @retval The number of remaining data units in the current DMAy Channelx
  *   transfer.
  */
uint16_t DMA_GetCurrDataCounter(DMA_Channel_TypeDef* DMAy_Channelx)
{
 8003998:	b480      	push	{r7}
 800399a:	b083      	sub	sp, #12
 800399c:	af00      	add	r7, sp, #0
 800399e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
  /* Return the number of remaining data units for DMAy Channelx */
  return ((uint16_t)(DMAy_Channelx->CNDTR));
 80039a0:	687b      	ldr	r3, [r7, #4]
 80039a2:	685b      	ldr	r3, [r3, #4]
 80039a4:	b29b      	uxth	r3, r3
}
 80039a6:	4618      	mov	r0, r3
 80039a8:	370c      	adds	r7, #12
 80039aa:	46bd      	mov	sp, r7
 80039ac:	bc80      	pop	{r7}
 80039ae:	4770      	bx	lr

080039b0 <DMA_ClearFlag>:
  *     @arg DMA2_FLAG_HT5: DMA2 Channel5 half transfer flag.
  *     @arg DMA2_FLAG_TE5: DMA2 Channel5 transfer error flag.
  * @retval None
  */
void DMA_ClearFlag(uint32_t DMA_FLAG)
{
 80039b0:	b480      	push	{r7}
 80039b2:	b083      	sub	sp, #12
 80039b4:	af00      	add	r7, sp, #0
 80039b6:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_DMA_CLEAR_FLAG(DMA_FLAG));
  /* Calculate the used DMA */

  if ((DMA_FLAG & FLAG_Mask) != (uint32_t)RESET)
 80039b8:	687b      	ldr	r3, [r7, #4]
 80039ba:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80039be:	2b00      	cmp	r3, #0
 80039c0:	d003      	beq.n	80039ca <DMA_ClearFlag+0x1a>
  {
    /* Clear the selected DMA flags */
    DMA2->IFCR = DMA_FLAG;
 80039c2:	4a06      	ldr	r2, [pc, #24]	; (80039dc <DMA_ClearFlag+0x2c>)
 80039c4:	687b      	ldr	r3, [r7, #4]
 80039c6:	6053      	str	r3, [r2, #4]
  else
  {
    /* Clear the selected DMA flags */
    DMA1->IFCR = DMA_FLAG;
  }
}
 80039c8:	e002      	b.n	80039d0 <DMA_ClearFlag+0x20>
    DMA1->IFCR = DMA_FLAG;
 80039ca:	4a05      	ldr	r2, [pc, #20]	; (80039e0 <DMA_ClearFlag+0x30>)
 80039cc:	687b      	ldr	r3, [r7, #4]
 80039ce:	6053      	str	r3, [r2, #4]
}
 80039d0:	bf00      	nop
 80039d2:	370c      	adds	r7, #12
 80039d4:	46bd      	mov	sp, r7
 80039d6:	bc80      	pop	{r7}
 80039d8:	4770      	bx	lr
 80039da:	bf00      	nop
 80039dc:	40020400 	.word	0x40020400
 80039e0:	40020000 	.word	0x40020000

080039e4 <DMA_ClearITPendingBit>:
  *     @arg DMA2_IT_HT5: DMA2 Channel5 half transfer interrupt.
  *     @arg DMA2_IT_TE5: DMA2 Channel5 transfer error interrupt.
  * @retval None
  */
void DMA_ClearITPendingBit(uint32_t DMA_IT)
{
 80039e4:	b480      	push	{r7}
 80039e6:	b083      	sub	sp, #12
 80039e8:	af00      	add	r7, sp, #0
 80039ea:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_DMA_CLEAR_IT(DMA_IT));

  /* Calculate the used DMA */
  if ((DMA_IT & FLAG_Mask) != (uint32_t)RESET)
 80039ec:	687b      	ldr	r3, [r7, #4]
 80039ee:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80039f2:	2b00      	cmp	r3, #0
 80039f4:	d003      	beq.n	80039fe <DMA_ClearITPendingBit+0x1a>
  {
    /* Clear the selected DMA interrupt pending bits */
    DMA2->IFCR = DMA_IT;
 80039f6:	4a06      	ldr	r2, [pc, #24]	; (8003a10 <DMA_ClearITPendingBit+0x2c>)
 80039f8:	687b      	ldr	r3, [r7, #4]
 80039fa:	6053      	str	r3, [r2, #4]
  else
  {
    /* Clear the selected DMA interrupt pending bits */
    DMA1->IFCR = DMA_IT;
  }
}
 80039fc:	e002      	b.n	8003a04 <DMA_ClearITPendingBit+0x20>
    DMA1->IFCR = DMA_IT;
 80039fe:	4a05      	ldr	r2, [pc, #20]	; (8003a14 <DMA_ClearITPendingBit+0x30>)
 8003a00:	687b      	ldr	r3, [r7, #4]
 8003a02:	6053      	str	r3, [r2, #4]
}
 8003a04:	bf00      	nop
 8003a06:	370c      	adds	r7, #12
 8003a08:	46bd      	mov	sp, r7
 8003a0a:	bc80      	pop	{r7}
 8003a0c:	4770      	bx	lr
 8003a0e:	bf00      	nop
 8003a10:	40020400 	.word	0x40020400
 8003a14:	40020000 	.word	0x40020000

08003a18 <TIM_TimeBaseInit>:
  * @param  TIM_TimeBaseInitStruct: pointer to a TIM_TimeBaseInitTypeDef
  *   structure that contains the configuration information for the specified TIM peripheral.
  * @retval None
  */
void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
{
 8003a18:	b480      	push	{r7}
 8003a1a:	b083      	sub	sp, #12
 8003a1c:	af00      	add	r7, sp, #0
 8003a1e:	6078      	str	r0, [r7, #4]
 8003a20:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_TIM_123458_PERIPH(TIMx)); 
  assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
  assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));
  /* Select the Counter Mode and set the clock division */
  TIMx->CR1 &= CR1_CKD_Mask & CR1_CounterMode_Mask;
 8003a22:	687b      	ldr	r3, [r7, #4]
 8003a24:	881b      	ldrh	r3, [r3, #0]
 8003a26:	b29b      	uxth	r3, r3
 8003a28:	f003 038f 	and.w	r3, r3, #143	; 0x8f
 8003a2c:	b29a      	uxth	r2, r3
 8003a2e:	687b      	ldr	r3, [r7, #4]
 8003a30:	801a      	strh	r2, [r3, #0]
  TIMx->CR1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision |
 8003a32:	687b      	ldr	r3, [r7, #4]
 8003a34:	881b      	ldrh	r3, [r3, #0]
 8003a36:	b29a      	uxth	r2, r3
 8003a38:	683b      	ldr	r3, [r7, #0]
 8003a3a:	88d9      	ldrh	r1, [r3, #6]
                TIM_TimeBaseInitStruct->TIM_CounterMode;
 8003a3c:	683b      	ldr	r3, [r7, #0]
 8003a3e:	885b      	ldrh	r3, [r3, #2]
  TIMx->CR1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision |
 8003a40:	430b      	orrs	r3, r1
 8003a42:	b29b      	uxth	r3, r3
 8003a44:	4313      	orrs	r3, r2
 8003a46:	b29a      	uxth	r2, r3
 8003a48:	687b      	ldr	r3, [r7, #4]
 8003a4a:	801a      	strh	r2, [r3, #0]
  
  /* Set the Autoreload value */
  TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
 8003a4c:	683b      	ldr	r3, [r7, #0]
 8003a4e:	889a      	ldrh	r2, [r3, #4]
 8003a50:	687b      	ldr	r3, [r7, #4]
 8003a52:	859a      	strh	r2, [r3, #44]	; 0x2c
 
  /* Set the Prescaler value */
  TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
 8003a54:	683b      	ldr	r3, [r7, #0]
 8003a56:	881a      	ldrh	r2, [r3, #0]
 8003a58:	687b      	ldr	r3, [r7, #4]
 8003a5a:	851a      	strh	r2, [r3, #40]	; 0x28
    
  if ((((uint32_t) TIMx) == TIM1_BASE) || (((uint32_t) TIMx) == TIM8_BASE))  
 8003a5c:	687b      	ldr	r3, [r7, #4]
 8003a5e:	4a0a      	ldr	r2, [pc, #40]	; (8003a88 <TIM_TimeBaseInit+0x70>)
 8003a60:	4293      	cmp	r3, r2
 8003a62:	d003      	beq.n	8003a6c <TIM_TimeBaseInit+0x54>
 8003a64:	687b      	ldr	r3, [r7, #4]
 8003a66:	4a09      	ldr	r2, [pc, #36]	; (8003a8c <TIM_TimeBaseInit+0x74>)
 8003a68:	4293      	cmp	r3, r2
 8003a6a:	d104      	bne.n	8003a76 <TIM_TimeBaseInit+0x5e>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
 8003a6c:	683b      	ldr	r3, [r7, #0]
 8003a6e:	7a1b      	ldrb	r3, [r3, #8]
 8003a70:	b29a      	uxth	r2, r3
 8003a72:	687b      	ldr	r3, [r7, #4]
 8003a74:	861a      	strh	r2, [r3, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler value immediatly */
  TIMx->EGR = TIM_PSCReloadMode_Immediate;          
 8003a76:	687b      	ldr	r3, [r7, #4]
 8003a78:	2201      	movs	r2, #1
 8003a7a:	829a      	strh	r2, [r3, #20]
}
 8003a7c:	bf00      	nop
 8003a7e:	370c      	adds	r7, #12
 8003a80:	46bd      	mov	sp, r7
 8003a82:	bc80      	pop	{r7}
 8003a84:	4770      	bx	lr
 8003a86:	bf00      	nop
 8003a88:	40012c00 	.word	0x40012c00
 8003a8c:	40013400 	.word	0x40013400

08003a90 <TIM_Cmd>:
  * @param  NewState: new state of the TIMx peripheral.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
{
 8003a90:	b480      	push	{r7}
 8003a92:	b083      	sub	sp, #12
 8003a94:	af00      	add	r7, sp, #0
 8003a96:	6078      	str	r0, [r7, #4]
 8003a98:	460b      	mov	r3, r1
 8003a9a:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003a9c:	78fb      	ldrb	r3, [r7, #3]
 8003a9e:	2b00      	cmp	r3, #0
 8003aa0:	d008      	beq.n	8003ab4 <TIM_Cmd+0x24>
  {
    /* Enable the TIM Counter */
    TIMx->CR1 |= CR1_CEN_Set;
 8003aa2:	687b      	ldr	r3, [r7, #4]
 8003aa4:	881b      	ldrh	r3, [r3, #0]
 8003aa6:	b29b      	uxth	r3, r3
 8003aa8:	f043 0301 	orr.w	r3, r3, #1
 8003aac:	b29a      	uxth	r2, r3
 8003aae:	687b      	ldr	r3, [r7, #4]
 8003ab0:	801a      	strh	r2, [r3, #0]
  else
  {
    /* Disable the TIM Counter */
    TIMx->CR1 &= CR1_CEN_Reset;
  }
}
 8003ab2:	e008      	b.n	8003ac6 <TIM_Cmd+0x36>
    TIMx->CR1 &= CR1_CEN_Reset;
 8003ab4:	687b      	ldr	r3, [r7, #4]
 8003ab6:	881b      	ldrh	r3, [r3, #0]
 8003ab8:	b29a      	uxth	r2, r3
 8003aba:	f240 33fe 	movw	r3, #1022	; 0x3fe
 8003abe:	4013      	ands	r3, r2
 8003ac0:	b29a      	uxth	r2, r3
 8003ac2:	687b      	ldr	r3, [r7, #4]
 8003ac4:	801a      	strh	r2, [r3, #0]
}
 8003ac6:	bf00      	nop
 8003ac8:	370c      	adds	r7, #12
 8003aca:	46bd      	mov	sp, r7
 8003acc:	bc80      	pop	{r7}
 8003ace:	4770      	bx	lr

08003ad0 <TIM_ITConfig>:
  * @param  NewState: new state of the TIM interrupts.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState)
{  
 8003ad0:	b480      	push	{r7}
 8003ad2:	b083      	sub	sp, #12
 8003ad4:	af00      	add	r7, sp, #0
 8003ad6:	6078      	str	r0, [r7, #4]
 8003ad8:	460b      	mov	r3, r1
 8003ada:	807b      	strh	r3, [r7, #2]
 8003adc:	4613      	mov	r3, r2
 8003ade:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_IT(TIM_IT));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  
  if (NewState != DISABLE)
 8003ae0:	787b      	ldrb	r3, [r7, #1]
 8003ae2:	2b00      	cmp	r3, #0
 8003ae4:	d008      	beq.n	8003af8 <TIM_ITConfig+0x28>
  {
    /* Enable the Interrupt sources */
    TIMx->DIER |= TIM_IT;
 8003ae6:	687b      	ldr	r3, [r7, #4]
 8003ae8:	899b      	ldrh	r3, [r3, #12]
 8003aea:	b29a      	uxth	r2, r3
 8003aec:	887b      	ldrh	r3, [r7, #2]
 8003aee:	4313      	orrs	r3, r2
 8003af0:	b29a      	uxth	r2, r3
 8003af2:	687b      	ldr	r3, [r7, #4]
 8003af4:	819a      	strh	r2, [r3, #12]
  else
  {
    /* Disable the Interrupt sources */
    TIMx->DIER &= (uint16_t)~TIM_IT;
  }
}
 8003af6:	e009      	b.n	8003b0c <TIM_ITConfig+0x3c>
    TIMx->DIER &= (uint16_t)~TIM_IT;
 8003af8:	687b      	ldr	r3, [r7, #4]
 8003afa:	899b      	ldrh	r3, [r3, #12]
 8003afc:	b29a      	uxth	r2, r3
 8003afe:	887b      	ldrh	r3, [r7, #2]
 8003b00:	43db      	mvns	r3, r3
 8003b02:	b29b      	uxth	r3, r3
 8003b04:	4013      	ands	r3, r2
 8003b06:	b29a      	uxth	r2, r3
 8003b08:	687b      	ldr	r3, [r7, #4]
 8003b0a:	819a      	strh	r2, [r3, #12]
}
 8003b0c:	bf00      	nop
 8003b0e:	370c      	adds	r7, #12
 8003b10:	46bd      	mov	sp, r7
 8003b12:	bc80      	pop	{r7}
 8003b14:	4770      	bx	lr

08003b16 <TIM_ARRPreloadConfig>:
  * @param  NewState: new state of the TIMx peripheral Preload register
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
{
 8003b16:	b480      	push	{r7}
 8003b18:	b083      	sub	sp, #12
 8003b1a:	af00      	add	r7, sp, #0
 8003b1c:	6078      	str	r0, [r7, #4]
 8003b1e:	460b      	mov	r3, r1
 8003b20:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8003b22:	78fb      	ldrb	r3, [r7, #3]
 8003b24:	2b00      	cmp	r3, #0
 8003b26:	d008      	beq.n	8003b3a <TIM_ARRPreloadConfig+0x24>
  {
    /* Set the ARR Preload Bit */
    TIMx->CR1 |= CR1_ARPE_Set;
 8003b28:	687b      	ldr	r3, [r7, #4]
 8003b2a:	881b      	ldrh	r3, [r3, #0]
 8003b2c:	b29b      	uxth	r3, r3
 8003b2e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8003b32:	b29a      	uxth	r2, r3
 8003b34:	687b      	ldr	r3, [r7, #4]
 8003b36:	801a      	strh	r2, [r3, #0]
  else
  {
    /* Reset the ARR Preload Bit */
    TIMx->CR1 &= CR1_ARPE_Reset;
  }
}
 8003b38:	e008      	b.n	8003b4c <TIM_ARRPreloadConfig+0x36>
    TIMx->CR1 &= CR1_ARPE_Reset;
 8003b3a:	687b      	ldr	r3, [r7, #4]
 8003b3c:	881b      	ldrh	r3, [r3, #0]
 8003b3e:	b29a      	uxth	r2, r3
 8003b40:	f240 337f 	movw	r3, #895	; 0x37f
 8003b44:	4013      	ands	r3, r2
 8003b46:	b29a      	uxth	r2, r3
 8003b48:	687b      	ldr	r3, [r7, #4]
 8003b4a:	801a      	strh	r2, [r3, #0]
}
 8003b4c:	bf00      	nop
 8003b4e:	370c      	adds	r7, #12
 8003b50:	46bd      	mov	sp, r7
 8003b52:	bc80      	pop	{r7}
 8003b54:	4770      	bx	lr

08003b56 <TIM_GetCapture3>:
  * @brief  Gets the TIMx Input Capture 3 value.
  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
  * @retval Capture Compare 3 Register value.
  */
uint16_t TIM_GetCapture3(TIM_TypeDef* TIMx)
{
 8003b56:	b480      	push	{r7}
 8003b58:	b083      	sub	sp, #12
 8003b5a:	af00      	add	r7, sp, #0
 8003b5c:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_123458_PERIPH(TIMx)); 
  /* Get the Capture 3 Register value */
  return TIMx->CCR3;
 8003b5e:	687b      	ldr	r3, [r7, #4]
 8003b60:	8f9b      	ldrh	r3, [r3, #60]	; 0x3c
 8003b62:	b29b      	uxth	r3, r3
}
 8003b64:	4618      	mov	r0, r3
 8003b66:	370c      	adds	r7, #12
 8003b68:	46bd      	mov	sp, r7
 8003b6a:	bc80      	pop	{r7}
 8003b6c:	4770      	bx	lr

08003b6e <TIM_GetCapture4>:
  * @brief  Gets the TIMx Input Capture 4 value.
  * @param  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
  * @retval Capture Compare 4 Register value.
  */
uint16_t TIM_GetCapture4(TIM_TypeDef* TIMx)
{
 8003b6e:	b480      	push	{r7}
 8003b70:	b083      	sub	sp, #12
 8003b72:	af00      	add	r7, sp, #0
 8003b74:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_TIM_123458_PERIPH(TIMx));
  /* Get the Capture 4 Register value */
  return TIMx->CCR4;
 8003b76:	687b      	ldr	r3, [r7, #4]
 8003b78:	f8b3 3040 	ldrh.w	r3, [r3, #64]	; 0x40
 8003b7c:	b29b      	uxth	r3, r3
}
 8003b7e:	4618      	mov	r0, r3
 8003b80:	370c      	adds	r7, #12
 8003b82:	46bd      	mov	sp, r7
 8003b84:	bc80      	pop	{r7}
 8003b86:	4770      	bx	lr

08003b88 <TIM_ClearFlag>:
  *   - TIM6 and TIM7 can have only one update flag. 
  *   - TIM_FLAG_COM and TIM_FLAG_Break are used only with TIM1 and TIM8.  
  * @retval None
  */
void TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
{  
 8003b88:	b480      	push	{r7}
 8003b8a:	b083      	sub	sp, #12
 8003b8c:	af00      	add	r7, sp, #0
 8003b8e:	6078      	str	r0, [r7, #4]
 8003b90:	460b      	mov	r3, r1
 8003b92:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_CLEAR_FLAG(TIM_FLAG));
   
  /* Clear the flags */
  TIMx->SR = (uint16_t)~TIM_FLAG;
 8003b94:	887b      	ldrh	r3, [r7, #2]
 8003b96:	43db      	mvns	r3, r3
 8003b98:	b29a      	uxth	r2, r3
 8003b9a:	687b      	ldr	r3, [r7, #4]
 8003b9c:	821a      	strh	r2, [r3, #16]
}
 8003b9e:	bf00      	nop
 8003ba0:	370c      	adds	r7, #12
 8003ba2:	46bd      	mov	sp, r7
 8003ba4:	bc80      	pop	{r7}
 8003ba6:	4770      	bx	lr

08003ba8 <TIM_GetITStatus>:
  *   - TIM6 and TIM7 can generate only an update interrupt.
  *   - TIM_IT_COM and TIM_IT_Break are used only with TIM1 and TIM8.  
  * @retval The new state of the TIM_IT(SET or RESET).
  */
ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT)
{
 8003ba8:	b480      	push	{r7}
 8003baa:	b085      	sub	sp, #20
 8003bac:	af00      	add	r7, sp, #0
 8003bae:	6078      	str	r0, [r7, #4]
 8003bb0:	460b      	mov	r3, r1
 8003bb2:	807b      	strh	r3, [r7, #2]
  ITStatus bitstatus = RESET;  
 8003bb4:	2300      	movs	r3, #0
 8003bb6:	73fb      	strb	r3, [r7, #15]
  uint16_t itstatus = 0x0, itenable = 0x0;
 8003bb8:	2300      	movs	r3, #0
 8003bba:	81bb      	strh	r3, [r7, #12]
 8003bbc:	2300      	movs	r3, #0
 8003bbe:	817b      	strh	r3, [r7, #10]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_GET_IT(TIM_IT));
   
  itstatus = TIMx->SR & TIM_IT;
 8003bc0:	687b      	ldr	r3, [r7, #4]
 8003bc2:	8a1b      	ldrh	r3, [r3, #16]
 8003bc4:	b29a      	uxth	r2, r3
 8003bc6:	887b      	ldrh	r3, [r7, #2]
 8003bc8:	4013      	ands	r3, r2
 8003bca:	81bb      	strh	r3, [r7, #12]
  
  itenable = TIMx->DIER & TIM_IT;
 8003bcc:	687b      	ldr	r3, [r7, #4]
 8003bce:	899b      	ldrh	r3, [r3, #12]
 8003bd0:	b29a      	uxth	r2, r3
 8003bd2:	887b      	ldrh	r3, [r7, #2]
 8003bd4:	4013      	ands	r3, r2
 8003bd6:	817b      	strh	r3, [r7, #10]
  if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
 8003bd8:	89bb      	ldrh	r3, [r7, #12]
 8003bda:	2b00      	cmp	r3, #0
 8003bdc:	d005      	beq.n	8003bea <TIM_GetITStatus+0x42>
 8003bde:	897b      	ldrh	r3, [r7, #10]
 8003be0:	2b00      	cmp	r3, #0
 8003be2:	d002      	beq.n	8003bea <TIM_GetITStatus+0x42>
  {
    bitstatus = SET;
 8003be4:	2301      	movs	r3, #1
 8003be6:	73fb      	strb	r3, [r7, #15]
 8003be8:	e001      	b.n	8003bee <TIM_GetITStatus+0x46>
  }
  else
  {
    bitstatus = RESET;
 8003bea:	2300      	movs	r3, #0
 8003bec:	73fb      	strb	r3, [r7, #15]
  }
  return bitstatus;
 8003bee:	7bfb      	ldrb	r3, [r7, #15]
}
 8003bf0:	4618      	mov	r0, r3
 8003bf2:	3714      	adds	r7, #20
 8003bf4:	46bd      	mov	sp, r7
 8003bf6:	bc80      	pop	{r7}
 8003bf8:	4770      	bx	lr

08003bfa <TIM_ClearITPendingBit>:
  *   - TIM6 and TIM7 can generate only an update interrupt.
  *   - TIM_IT_COM and TIM_IT_Break are used only with TIM1 and TIM8.    
  * @retval None
  */
void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT)
{
 8003bfa:	b480      	push	{r7}
 8003bfc:	b083      	sub	sp, #12
 8003bfe:	af00      	add	r7, sp, #0
 8003c00:	6078      	str	r0, [r7, #4]
 8003c02:	460b      	mov	r3, r1
 8003c04:	807b      	strh	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_TIM_ALL_PERIPH(TIMx));
  assert_param(IS_TIM_IT(TIM_IT));
  /* Clear the IT pending Bit */
  TIMx->SR = (uint16_t)~TIM_IT;
 8003c06:	887b      	ldrh	r3, [r7, #2]
 8003c08:	43db      	mvns	r3, r3
 8003c0a:	b29a      	uxth	r2, r3
 8003c0c:	687b      	ldr	r3, [r7, #4]
 8003c0e:	821a      	strh	r2, [r3, #16]
}
 8003c10:	bf00      	nop
 8003c12:	370c      	adds	r7, #12
 8003c14:	46bd      	mov	sp, r7
 8003c16:	bc80      	pop	{r7}
 8003c18:	4770      	bx	lr
	...

08003c1c <I2C_Init>:
  * @param  I2C_InitStruct: pointer to a I2C_InitTypeDef structure that
  *   contains the configuration information for the specified I2C peripheral.
  * @retval None
  */
void I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct)
{
 8003c1c:	b580      	push	{r7, lr}
 8003c1e:	b08a      	sub	sp, #40	; 0x28
 8003c20:	af00      	add	r7, sp, #0
 8003c22:	6078      	str	r0, [r7, #4]
 8003c24:	6039      	str	r1, [r7, #0]
  uint16_t tmpreg = 0, freqrange = 0;
 8003c26:	2300      	movs	r3, #0
 8003c28:	84fb      	strh	r3, [r7, #38]	; 0x26
 8003c2a:	2300      	movs	r3, #0
 8003c2c:	847b      	strh	r3, [r7, #34]	; 0x22
  uint16_t result = 0x04;
 8003c2e:	2304      	movs	r3, #4
 8003c30:	84bb      	strh	r3, [r7, #36]	; 0x24
  uint32_t pclk1 = 8000000;
 8003c32:	4b57      	ldr	r3, [pc, #348]	; (8003d90 <I2C_Init+0x174>)
 8003c34:	61fb      	str	r3, [r7, #28]
  assert_param(IS_I2C_ACK_STATE(I2C_InitStruct->I2C_Ack));
  assert_param(IS_I2C_ACKNOWLEDGE_ADDRESS(I2C_InitStruct->I2C_AcknowledgedAddress));

/*---------------------------- I2Cx CR2 Configuration ------------------------*/
  /* Get the I2Cx CR2 value */
  tmpreg = I2Cx->CR2;
 8003c36:	687b      	ldr	r3, [r7, #4]
 8003c38:	889b      	ldrh	r3, [r3, #4]
 8003c3a:	84fb      	strh	r3, [r7, #38]	; 0x26
  /* Clear frequency FREQ[5:0] bits */
  tmpreg &= CR2_FREQ_Reset;
 8003c3c:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8003c3e:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 8003c42:	84fb      	strh	r3, [r7, #38]	; 0x26
  /* Get pclk1 frequency value */
  RCC_GetClocksFreq(&rcc_clocks);
 8003c44:	f107 0308 	add.w	r3, r7, #8
 8003c48:	4618      	mov	r0, r3
 8003c4a:	4b52      	ldr	r3, [pc, #328]	; (8003d94 <I2C_Init+0x178>)
 8003c4c:	4798      	blx	r3
  pclk1 = rcc_clocks.PCLK1_Frequency;
 8003c4e:	693b      	ldr	r3, [r7, #16]
 8003c50:	61fb      	str	r3, [r7, #28]
  /* Set frequency bits depending on pclk1 value */
  freqrange = (uint16_t)(pclk1 / 1000000);
 8003c52:	69fb      	ldr	r3, [r7, #28]
 8003c54:	4a50      	ldr	r2, [pc, #320]	; (8003d98 <I2C_Init+0x17c>)
 8003c56:	fba2 2303 	umull	r2, r3, r2, r3
 8003c5a:	0c9b      	lsrs	r3, r3, #18
 8003c5c:	847b      	strh	r3, [r7, #34]	; 0x22
  tmpreg |= freqrange;
 8003c5e:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 8003c60:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8003c62:	4313      	orrs	r3, r2
 8003c64:	84fb      	strh	r3, [r7, #38]	; 0x26
  /* Write to I2Cx CR2 */
  I2Cx->CR2 = tmpreg;
 8003c66:	687b      	ldr	r3, [r7, #4]
 8003c68:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 8003c6a:	809a      	strh	r2, [r3, #4]

/*---------------------------- I2Cx CCR Configuration ------------------------*/
  /* Disable the selected I2C peripheral to configure TRISE */
  I2Cx->CR1 &= CR1_PE_Reset;
 8003c6c:	687b      	ldr	r3, [r7, #4]
 8003c6e:	881b      	ldrh	r3, [r3, #0]
 8003c70:	b29b      	uxth	r3, r3
 8003c72:	f023 0301 	bic.w	r3, r3, #1
 8003c76:	b29a      	uxth	r2, r3
 8003c78:	687b      	ldr	r3, [r7, #4]
 8003c7a:	801a      	strh	r2, [r3, #0]
  /* Reset tmpreg value */
  /* Clear F/S, DUTY and CCR[11:0] bits */
  tmpreg = 0;
 8003c7c:	2300      	movs	r3, #0
 8003c7e:	84fb      	strh	r3, [r7, #38]	; 0x26

  /* Configure speed in standard mode */
  if (I2C_InitStruct->I2C_ClockSpeed <= 100000)
 8003c80:	683b      	ldr	r3, [r7, #0]
 8003c82:	681b      	ldr	r3, [r3, #0]
 8003c84:	4a45      	ldr	r2, [pc, #276]	; (8003d9c <I2C_Init+0x180>)
 8003c86:	4293      	cmp	r3, r2
 8003c88:	d815      	bhi.n	8003cb6 <I2C_Init+0x9a>
  {
    /* Standard mode speed calculate */
    result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed << 1));
 8003c8a:	683b      	ldr	r3, [r7, #0]
 8003c8c:	681b      	ldr	r3, [r3, #0]
 8003c8e:	005b      	lsls	r3, r3, #1
 8003c90:	69fa      	ldr	r2, [r7, #28]
 8003c92:	fbb2 f3f3 	udiv	r3, r2, r3
 8003c96:	84bb      	strh	r3, [r7, #36]	; 0x24
    /* Test if CCR value is under 0x4*/
    if (result < 0x04)
 8003c98:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8003c9a:	2b03      	cmp	r3, #3
 8003c9c:	d801      	bhi.n	8003ca2 <I2C_Init+0x86>
    {
      /* Set minimum allowed value */
      result = 0x04;  
 8003c9e:	2304      	movs	r3, #4
 8003ca0:	84bb      	strh	r3, [r7, #36]	; 0x24
    }
    /* Set speed value for standard mode */
    tmpreg |= result;	  
 8003ca2:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 8003ca4:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8003ca6:	4313      	orrs	r3, r2
 8003ca8:	84fb      	strh	r3, [r7, #38]	; 0x26
    /* Set Maximum Rise Time for standard mode */
    I2Cx->TRISE = freqrange + 1; 
 8003caa:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8003cac:	3301      	adds	r3, #1
 8003cae:	b29a      	uxth	r2, r3
 8003cb0:	687b      	ldr	r3, [r7, #4]
 8003cb2:	841a      	strh	r2, [r3, #32]
 8003cb4:	e040      	b.n	8003d38 <I2C_Init+0x11c>
  }
  /* Configure speed in fast mode */
  else /*(I2C_InitStruct->I2C_ClockSpeed <= 400000)*/
  {
    if (I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_2)
 8003cb6:	683b      	ldr	r3, [r7, #0]
 8003cb8:	88db      	ldrh	r3, [r3, #6]
 8003cba:	f64b 72ff 	movw	r2, #49151	; 0xbfff
 8003cbe:	4293      	cmp	r3, r2
 8003cc0:	d109      	bne.n	8003cd6 <I2C_Init+0xba>
    {
      /* Fast mode speed calculate: Tlow/Thigh = 2 */
      result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 3));
 8003cc2:	683b      	ldr	r3, [r7, #0]
 8003cc4:	681a      	ldr	r2, [r3, #0]
 8003cc6:	4613      	mov	r3, r2
 8003cc8:	005b      	lsls	r3, r3, #1
 8003cca:	4413      	add	r3, r2
 8003ccc:	69fa      	ldr	r2, [r7, #28]
 8003cce:	fbb2 f3f3 	udiv	r3, r2, r3
 8003cd2:	84bb      	strh	r3, [r7, #36]	; 0x24
 8003cd4:	e00e      	b.n	8003cf4 <I2C_Init+0xd8>
    }
    else /*I2C_InitStruct->I2C_DutyCycle == I2C_DutyCycle_16_9*/
    {
      /* Fast mode speed calculate: Tlow/Thigh = 16/9 */
      result = (uint16_t)(pclk1 / (I2C_InitStruct->I2C_ClockSpeed * 25));
 8003cd6:	683b      	ldr	r3, [r7, #0]
 8003cd8:	681a      	ldr	r2, [r3, #0]
 8003cda:	4613      	mov	r3, r2
 8003cdc:	009b      	lsls	r3, r3, #2
 8003cde:	4413      	add	r3, r2
 8003ce0:	009a      	lsls	r2, r3, #2
 8003ce2:	4413      	add	r3, r2
 8003ce4:	69fa      	ldr	r2, [r7, #28]
 8003ce6:	fbb2 f3f3 	udiv	r3, r2, r3
 8003cea:	84bb      	strh	r3, [r7, #36]	; 0x24
      /* Set DUTY bit */
      result |= I2C_DutyCycle_16_9;
 8003cec:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8003cee:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8003cf2:	84bb      	strh	r3, [r7, #36]	; 0x24
    }

    /* Test if CCR value is under 0x1*/
    if ((result & CCR_CCR_Set) == 0)
 8003cf4:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8003cf6:	f3c3 030b 	ubfx	r3, r3, #0, #12
 8003cfa:	2b00      	cmp	r3, #0
 8003cfc:	d103      	bne.n	8003d06 <I2C_Init+0xea>
    {
      /* Set minimum allowed value */
      result |= (uint16_t)0x0001;  
 8003cfe:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 8003d00:	f043 0301 	orr.w	r3, r3, #1
 8003d04:	84bb      	strh	r3, [r7, #36]	; 0x24
    }
    /* Set speed value and set F/S bit for fast mode */
    tmpreg |= (uint16_t)(result | CCR_FS_Set);
 8003d06:	8cba      	ldrh	r2, [r7, #36]	; 0x24
 8003d08:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8003d0a:	4313      	orrs	r3, r2
 8003d0c:	b29b      	uxth	r3, r3
 8003d0e:	ea6f 4343 	mvn.w	r3, r3, lsl #17
 8003d12:	ea6f 4353 	mvn.w	r3, r3, lsr #17
 8003d16:	84fb      	strh	r3, [r7, #38]	; 0x26
    /* Set Maximum Rise Time for fast mode */
    I2Cx->TRISE = (uint16_t)(((freqrange * (uint16_t)300) / (uint16_t)1000) + (uint16_t)1);  
 8003d18:	8c7b      	ldrh	r3, [r7, #34]	; 0x22
 8003d1a:	f44f 7296 	mov.w	r2, #300	; 0x12c
 8003d1e:	fb02 f303 	mul.w	r3, r2, r3
 8003d22:	4a1f      	ldr	r2, [pc, #124]	; (8003da0 <I2C_Init+0x184>)
 8003d24:	fb82 1203 	smull	r1, r2, r2, r3
 8003d28:	1192      	asrs	r2, r2, #6
 8003d2a:	17db      	asrs	r3, r3, #31
 8003d2c:	1ad3      	subs	r3, r2, r3
 8003d2e:	b29b      	uxth	r3, r3
 8003d30:	3301      	adds	r3, #1
 8003d32:	b29a      	uxth	r2, r3
 8003d34:	687b      	ldr	r3, [r7, #4]
 8003d36:	841a      	strh	r2, [r3, #32]
  }

  /* Write to I2Cx CCR */
  I2Cx->CCR = tmpreg;
 8003d38:	687b      	ldr	r3, [r7, #4]
 8003d3a:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 8003d3c:	839a      	strh	r2, [r3, #28]
  /* Enable the selected I2C peripheral */
  I2Cx->CR1 |= CR1_PE_Set;
 8003d3e:	687b      	ldr	r3, [r7, #4]
 8003d40:	881b      	ldrh	r3, [r3, #0]
 8003d42:	b29b      	uxth	r3, r3
 8003d44:	f043 0301 	orr.w	r3, r3, #1
 8003d48:	b29a      	uxth	r2, r3
 8003d4a:	687b      	ldr	r3, [r7, #4]
 8003d4c:	801a      	strh	r2, [r3, #0]

/*---------------------------- I2Cx CR1 Configuration ------------------------*/
  /* Get the I2Cx CR1 value */
  tmpreg = I2Cx->CR1;
 8003d4e:	687b      	ldr	r3, [r7, #4]
 8003d50:	881b      	ldrh	r3, [r3, #0]
 8003d52:	84fb      	strh	r3, [r7, #38]	; 0x26
  /* Clear ACK, SMBTYPE and  SMBUS bits */
  tmpreg &= CR1_CLEAR_Mask;
 8003d54:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8003d56:	f423 6381 	bic.w	r3, r3, #1032	; 0x408
 8003d5a:	f023 0302 	bic.w	r3, r3, #2
 8003d5e:	84fb      	strh	r3, [r7, #38]	; 0x26
  /* Configure I2Cx: mode and acknowledgement */
  /* Set SMBTYPE and SMBUS bits according to I2C_Mode value */
  /* Set ACK bit according to I2C_Ack value */
  tmpreg |= (uint16_t)((uint32_t)I2C_InitStruct->I2C_Mode | I2C_InitStruct->I2C_Ack);
 8003d60:	683b      	ldr	r3, [r7, #0]
 8003d62:	889a      	ldrh	r2, [r3, #4]
 8003d64:	683b      	ldr	r3, [r7, #0]
 8003d66:	895b      	ldrh	r3, [r3, #10]
 8003d68:	4313      	orrs	r3, r2
 8003d6a:	b29a      	uxth	r2, r3
 8003d6c:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 8003d6e:	4313      	orrs	r3, r2
 8003d70:	84fb      	strh	r3, [r7, #38]	; 0x26
  /* Write to I2Cx CR1 */
  I2Cx->CR1 = tmpreg;
 8003d72:	687b      	ldr	r3, [r7, #4]
 8003d74:	8cfa      	ldrh	r2, [r7, #38]	; 0x26
 8003d76:	801a      	strh	r2, [r3, #0]

/*---------------------------- I2Cx OAR1 Configuration -----------------------*/
  /* Set I2Cx Own Address1 and acknowledged address */
  I2Cx->OAR1 = (I2C_InitStruct->I2C_AcknowledgedAddress | I2C_InitStruct->I2C_OwnAddress1);
 8003d78:	683b      	ldr	r3, [r7, #0]
 8003d7a:	899a      	ldrh	r2, [r3, #12]
 8003d7c:	683b      	ldr	r3, [r7, #0]
 8003d7e:	891b      	ldrh	r3, [r3, #8]
 8003d80:	4313      	orrs	r3, r2
 8003d82:	b29a      	uxth	r2, r3
 8003d84:	687b      	ldr	r3, [r7, #4]
 8003d86:	811a      	strh	r2, [r3, #8]
}
 8003d88:	bf00      	nop
 8003d8a:	3728      	adds	r7, #40	; 0x28
 8003d8c:	46bd      	mov	sp, r7
 8003d8e:	bd80      	pop	{r7, pc}
 8003d90:	007a1200 	.word	0x007a1200
 8003d94:	08003311 	.word	0x08003311
 8003d98:	431bde83 	.word	0x431bde83
 8003d9c:	000186a0 	.word	0x000186a0
 8003da0:	10624dd3 	.word	0x10624dd3

08003da4 <I2C_Cmd>:
  * @param  NewState: new state of the I2Cx peripheral. 
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
 8003da4:	b480      	push	{r7}
 8003da6:	b083      	sub	sp, #12
 8003da8:	af00      	add	r7, sp, #0
 8003daa:	6078      	str	r0, [r7, #4]
 8003dac:	460b      	mov	r3, r1
 8003dae:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8003db0:	78fb      	ldrb	r3, [r7, #3]
 8003db2:	2b00      	cmp	r3, #0
 8003db4:	d008      	beq.n	8003dc8 <I2C_Cmd+0x24>
  {
    /* Enable the selected I2C peripheral */
    I2Cx->CR1 |= CR1_PE_Set;
 8003db6:	687b      	ldr	r3, [r7, #4]
 8003db8:	881b      	ldrh	r3, [r3, #0]
 8003dba:	b29b      	uxth	r3, r3
 8003dbc:	f043 0301 	orr.w	r3, r3, #1
 8003dc0:	b29a      	uxth	r2, r3
 8003dc2:	687b      	ldr	r3, [r7, #4]
 8003dc4:	801a      	strh	r2, [r3, #0]
  else
  {
    /* Disable the selected I2C peripheral */
    I2Cx->CR1 &= CR1_PE_Reset;
  }
}
 8003dc6:	e007      	b.n	8003dd8 <I2C_Cmd+0x34>
    I2Cx->CR1 &= CR1_PE_Reset;
 8003dc8:	687b      	ldr	r3, [r7, #4]
 8003dca:	881b      	ldrh	r3, [r3, #0]
 8003dcc:	b29b      	uxth	r3, r3
 8003dce:	f023 0301 	bic.w	r3, r3, #1
 8003dd2:	b29a      	uxth	r2, r3
 8003dd4:	687b      	ldr	r3, [r7, #4]
 8003dd6:	801a      	strh	r2, [r3, #0]
}
 8003dd8:	bf00      	nop
 8003dda:	370c      	adds	r7, #12
 8003ddc:	46bd      	mov	sp, r7
 8003dde:	bc80      	pop	{r7}
 8003de0:	4770      	bx	lr

08003de2 <I2C_GenerateSTART>:
  * @param  NewState: new state of the I2C START condition generation.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None.
  */
void I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
 8003de2:	b480      	push	{r7}
 8003de4:	b083      	sub	sp, #12
 8003de6:	af00      	add	r7, sp, #0
 8003de8:	6078      	str	r0, [r7, #4]
 8003dea:	460b      	mov	r3, r1
 8003dec:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8003dee:	78fb      	ldrb	r3, [r7, #3]
 8003df0:	2b00      	cmp	r3, #0
 8003df2:	d008      	beq.n	8003e06 <I2C_GenerateSTART+0x24>
  {
    /* Generate a START condition */
    I2Cx->CR1 |= CR1_START_Set;
 8003df4:	687b      	ldr	r3, [r7, #4]
 8003df6:	881b      	ldrh	r3, [r3, #0]
 8003df8:	b29b      	uxth	r3, r3
 8003dfa:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8003dfe:	b29a      	uxth	r2, r3
 8003e00:	687b      	ldr	r3, [r7, #4]
 8003e02:	801a      	strh	r2, [r3, #0]
  else
  {
    /* Disable the START condition generation */
    I2Cx->CR1 &= CR1_START_Reset;
  }
}
 8003e04:	e007      	b.n	8003e16 <I2C_GenerateSTART+0x34>
    I2Cx->CR1 &= CR1_START_Reset;
 8003e06:	687b      	ldr	r3, [r7, #4]
 8003e08:	881b      	ldrh	r3, [r3, #0]
 8003e0a:	b29b      	uxth	r3, r3
 8003e0c:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8003e10:	b29a      	uxth	r2, r3
 8003e12:	687b      	ldr	r3, [r7, #4]
 8003e14:	801a      	strh	r2, [r3, #0]
}
 8003e16:	bf00      	nop
 8003e18:	370c      	adds	r7, #12
 8003e1a:	46bd      	mov	sp, r7
 8003e1c:	bc80      	pop	{r7}
 8003e1e:	4770      	bx	lr

08003e20 <I2C_GenerateSTOP>:
  * @param  NewState: new state of the I2C STOP condition generation.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None.
  */
void I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
 8003e20:	b480      	push	{r7}
 8003e22:	b083      	sub	sp, #12
 8003e24:	af00      	add	r7, sp, #0
 8003e26:	6078      	str	r0, [r7, #4]
 8003e28:	460b      	mov	r3, r1
 8003e2a:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8003e2c:	78fb      	ldrb	r3, [r7, #3]
 8003e2e:	2b00      	cmp	r3, #0
 8003e30:	d008      	beq.n	8003e44 <I2C_GenerateSTOP+0x24>
  {
    /* Generate a STOP condition */
    I2Cx->CR1 |= CR1_STOP_Set;
 8003e32:	687b      	ldr	r3, [r7, #4]
 8003e34:	881b      	ldrh	r3, [r3, #0]
 8003e36:	b29b      	uxth	r3, r3
 8003e38:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8003e3c:	b29a      	uxth	r2, r3
 8003e3e:	687b      	ldr	r3, [r7, #4]
 8003e40:	801a      	strh	r2, [r3, #0]
  else
  {
    /* Disable the STOP condition generation */
    I2Cx->CR1 &= CR1_STOP_Reset;
  }
}
 8003e42:	e007      	b.n	8003e54 <I2C_GenerateSTOP+0x34>
    I2Cx->CR1 &= CR1_STOP_Reset;
 8003e44:	687b      	ldr	r3, [r7, #4]
 8003e46:	881b      	ldrh	r3, [r3, #0]
 8003e48:	b29b      	uxth	r3, r3
 8003e4a:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8003e4e:	b29a      	uxth	r2, r3
 8003e50:	687b      	ldr	r3, [r7, #4]
 8003e52:	801a      	strh	r2, [r3, #0]
}
 8003e54:	bf00      	nop
 8003e56:	370c      	adds	r7, #12
 8003e58:	46bd      	mov	sp, r7
 8003e5a:	bc80      	pop	{r7}
 8003e5c:	4770      	bx	lr

08003e5e <I2C_AcknowledgeConfig>:
  * @param  NewState: new state of the I2C Acknowledgement.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None.
  */
void I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState)
{
 8003e5e:	b480      	push	{r7}
 8003e60:	b083      	sub	sp, #12
 8003e62:	af00      	add	r7, sp, #0
 8003e64:	6078      	str	r0, [r7, #4]
 8003e66:	460b      	mov	r3, r1
 8003e68:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  if (NewState != DISABLE)
 8003e6a:	78fb      	ldrb	r3, [r7, #3]
 8003e6c:	2b00      	cmp	r3, #0
 8003e6e:	d008      	beq.n	8003e82 <I2C_AcknowledgeConfig+0x24>
  {
    /* Enable the acknowledgement */
    I2Cx->CR1 |= CR1_ACK_Set;
 8003e70:	687b      	ldr	r3, [r7, #4]
 8003e72:	881b      	ldrh	r3, [r3, #0]
 8003e74:	b29b      	uxth	r3, r3
 8003e76:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8003e7a:	b29a      	uxth	r2, r3
 8003e7c:	687b      	ldr	r3, [r7, #4]
 8003e7e:	801a      	strh	r2, [r3, #0]
  else
  {
    /* Disable the acknowledgement */
    I2Cx->CR1 &= CR1_ACK_Reset;
  }
}
 8003e80:	e007      	b.n	8003e92 <I2C_AcknowledgeConfig+0x34>
    I2Cx->CR1 &= CR1_ACK_Reset;
 8003e82:	687b      	ldr	r3, [r7, #4]
 8003e84:	881b      	ldrh	r3, [r3, #0]
 8003e86:	b29b      	uxth	r3, r3
 8003e88:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8003e8c:	b29a      	uxth	r2, r3
 8003e8e:	687b      	ldr	r3, [r7, #4]
 8003e90:	801a      	strh	r2, [r3, #0]
}
 8003e92:	bf00      	nop
 8003e94:	370c      	adds	r7, #12
 8003e96:	46bd      	mov	sp, r7
 8003e98:	bc80      	pop	{r7}
 8003e9a:	4770      	bx	lr

08003e9c <I2C_ITConfig>:
  * @param  NewState: new state of the specified I2C interrupts.
  *   This parameter can be: ENABLE or DISABLE.
  * @retval None
  */
void I2C_ITConfig(I2C_TypeDef* I2Cx, uint16_t I2C_IT, FunctionalState NewState)
{
 8003e9c:	b480      	push	{r7}
 8003e9e:	b083      	sub	sp, #12
 8003ea0:	af00      	add	r7, sp, #0
 8003ea2:	6078      	str	r0, [r7, #4]
 8003ea4:	460b      	mov	r3, r1
 8003ea6:	807b      	strh	r3, [r7, #2]
 8003ea8:	4613      	mov	r3, r2
 8003eaa:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_FUNCTIONAL_STATE(NewState));
  assert_param(IS_I2C_CONFIG_IT(I2C_IT));
  
  if (NewState != DISABLE)
 8003eac:	787b      	ldrb	r3, [r7, #1]
 8003eae:	2b00      	cmp	r3, #0
 8003eb0:	d008      	beq.n	8003ec4 <I2C_ITConfig+0x28>
  {
    /* Enable the selected I2C interrupts */
    I2Cx->CR2 |= I2C_IT;
 8003eb2:	687b      	ldr	r3, [r7, #4]
 8003eb4:	889b      	ldrh	r3, [r3, #4]
 8003eb6:	b29a      	uxth	r2, r3
 8003eb8:	887b      	ldrh	r3, [r7, #2]
 8003eba:	4313      	orrs	r3, r2
 8003ebc:	b29a      	uxth	r2, r3
 8003ebe:	687b      	ldr	r3, [r7, #4]
 8003ec0:	809a      	strh	r2, [r3, #4]
  else
  {
    /* Disable the selected I2C interrupts */
    I2Cx->CR2 &= (uint16_t)~I2C_IT;
  }
}
 8003ec2:	e009      	b.n	8003ed8 <I2C_ITConfig+0x3c>
    I2Cx->CR2 &= (uint16_t)~I2C_IT;
 8003ec4:	687b      	ldr	r3, [r7, #4]
 8003ec6:	889b      	ldrh	r3, [r3, #4]
 8003ec8:	b29a      	uxth	r2, r3
 8003eca:	887b      	ldrh	r3, [r7, #2]
 8003ecc:	43db      	mvns	r3, r3
 8003ece:	b29b      	uxth	r3, r3
 8003ed0:	4013      	ands	r3, r2
 8003ed2:	b29a      	uxth	r2, r3
 8003ed4:	687b      	ldr	r3, [r7, #4]
 8003ed6:	809a      	strh	r2, [r3, #4]
}
 8003ed8:	bf00      	nop
 8003eda:	370c      	adds	r7, #12
 8003edc:	46bd      	mov	sp, r7
 8003ede:	bc80      	pop	{r7}
 8003ee0:	4770      	bx	lr

08003ee2 <I2C_SendData>:
  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
  * @param  Data: Byte to be transmitted..
  * @retval None
  */
void I2C_SendData(I2C_TypeDef* I2Cx, uint8_t Data)
{
 8003ee2:	b480      	push	{r7}
 8003ee4:	b083      	sub	sp, #12
 8003ee6:	af00      	add	r7, sp, #0
 8003ee8:	6078      	str	r0, [r7, #4]
 8003eea:	460b      	mov	r3, r1
 8003eec:	70fb      	strb	r3, [r7, #3]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  /* Write in the DR register the data to be sent */
  I2Cx->DR = Data;
 8003eee:	78fb      	ldrb	r3, [r7, #3]
 8003ef0:	b29a      	uxth	r2, r3
 8003ef2:	687b      	ldr	r3, [r7, #4]
 8003ef4:	821a      	strh	r2, [r3, #16]
}
 8003ef6:	bf00      	nop
 8003ef8:	370c      	adds	r7, #12
 8003efa:	46bd      	mov	sp, r7
 8003efc:	bc80      	pop	{r7}
 8003efe:	4770      	bx	lr

08003f00 <I2C_ReceiveData>:
  * @brief  Returns the most recent received data by the I2Cx peripheral.
  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
  * @retval The value of the received data.
  */
uint8_t I2C_ReceiveData(I2C_TypeDef* I2Cx)
{
 8003f00:	b480      	push	{r7}
 8003f02:	b083      	sub	sp, #12
 8003f04:	af00      	add	r7, sp, #0
 8003f06:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  /* Return the data in the DR register */
  return (uint8_t)I2Cx->DR;
 8003f08:	687b      	ldr	r3, [r7, #4]
 8003f0a:	8a1b      	ldrh	r3, [r3, #16]
 8003f0c:	b29b      	uxth	r3, r3
 8003f0e:	b2db      	uxtb	r3, r3
}
 8003f10:	4618      	mov	r0, r3
 8003f12:	370c      	adds	r7, #12
 8003f14:	46bd      	mov	sp, r7
 8003f16:	bc80      	pop	{r7}
 8003f18:	4770      	bx	lr

08003f1a <I2C_Send7bitAddress>:
  *     @arg I2C_Direction_Transmitter: Transmitter mode
  *     @arg I2C_Direction_Receiver: Receiver mode
  * @retval None.
  */
void I2C_Send7bitAddress(I2C_TypeDef* I2Cx, uint8_t Address, uint8_t I2C_Direction)
{
 8003f1a:	b480      	push	{r7}
 8003f1c:	b083      	sub	sp, #12
 8003f1e:	af00      	add	r7, sp, #0
 8003f20:	6078      	str	r0, [r7, #4]
 8003f22:	460b      	mov	r3, r1
 8003f24:	70fb      	strb	r3, [r7, #3]
 8003f26:	4613      	mov	r3, r2
 8003f28:	70bb      	strb	r3, [r7, #2]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_DIRECTION(I2C_Direction));
  /* Test on the direction to set/reset the read/write bit */
  if (I2C_Direction != I2C_Direction_Transmitter)
 8003f2a:	78bb      	ldrb	r3, [r7, #2]
 8003f2c:	2b00      	cmp	r3, #0
 8003f2e:	d004      	beq.n	8003f3a <I2C_Send7bitAddress+0x20>
  {
    /* Set the address bit0 for read */
    Address |= OAR1_ADD0_Set;
 8003f30:	78fb      	ldrb	r3, [r7, #3]
 8003f32:	f043 0301 	orr.w	r3, r3, #1
 8003f36:	70fb      	strb	r3, [r7, #3]
 8003f38:	e003      	b.n	8003f42 <I2C_Send7bitAddress+0x28>
  }
  else
  {
    /* Reset the address bit0 for write */
    Address &= OAR1_ADD0_Reset;
 8003f3a:	78fb      	ldrb	r3, [r7, #3]
 8003f3c:	f023 0301 	bic.w	r3, r3, #1
 8003f40:	70fb      	strb	r3, [r7, #3]
  }
  /* Send the address */
  I2Cx->DR = Address;
 8003f42:	78fb      	ldrb	r3, [r7, #3]
 8003f44:	b29a      	uxth	r2, r3
 8003f46:	687b      	ldr	r3, [r7, #4]
 8003f48:	821a      	strh	r2, [r3, #16]
}
 8003f4a:	bf00      	nop
 8003f4c:	370c      	adds	r7, #12
 8003f4e:	46bd      	mov	sp, r7
 8003f50:	bc80      	pop	{r7}
 8003f52:	4770      	bx	lr

08003f54 <I2C_ReadRegister>:
  *     @arg I2C_Register_CCR:   CCR register.
  *     @arg I2C_Register_TRISE: TRISE register.
  * @retval The value of the read register.
  */
uint16_t I2C_ReadRegister(I2C_TypeDef* I2Cx, uint8_t I2C_Register)
{
 8003f54:	b480      	push	{r7}
 8003f56:	b085      	sub	sp, #20
 8003f58:	af00      	add	r7, sp, #0
 8003f5a:	6078      	str	r0, [r7, #4]
 8003f5c:	460b      	mov	r3, r1
 8003f5e:	70fb      	strb	r3, [r7, #3]
  __IO uint32_t tmp = 0;
 8003f60:	2300      	movs	r3, #0
 8003f62:	60fb      	str	r3, [r7, #12]

  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_REGISTER(I2C_Register));

  tmp = (uint32_t) I2Cx;
 8003f64:	687b      	ldr	r3, [r7, #4]
 8003f66:	60fb      	str	r3, [r7, #12]
  tmp += I2C_Register;
 8003f68:	78fa      	ldrb	r2, [r7, #3]
 8003f6a:	68fb      	ldr	r3, [r7, #12]
 8003f6c:	4413      	add	r3, r2
 8003f6e:	60fb      	str	r3, [r7, #12]

  /* Return the selected register value */
  return (*(__IO uint16_t *) tmp);
 8003f70:	68fb      	ldr	r3, [r7, #12]
 8003f72:	881b      	ldrh	r3, [r3, #0]
 8003f74:	b29b      	uxth	r3, r3
}
 8003f76:	4618      	mov	r0, r3
 8003f78:	3714      	adds	r7, #20
 8003f7a:	46bd      	mov	sp, r7
 8003f7c:	bc80      	pop	{r7}
 8003f7e:	4770      	bx	lr

08003f80 <I2C_GetLastEvent>:
  * @brief  Returns the last I2Cx Event.
  * @param  I2Cx: where x can be 1 or 2 to select the I2C peripheral.
  * @retval The last event
  */
uint32_t I2C_GetLastEvent(I2C_TypeDef* I2Cx)
{
 8003f80:	b480      	push	{r7}
 8003f82:	b087      	sub	sp, #28
 8003f84:	af00      	add	r7, sp, #0
 8003f86:	6078      	str	r0, [r7, #4]
  uint32_t lastevent = 0;
 8003f88:	2300      	movs	r3, #0
 8003f8a:	617b      	str	r3, [r7, #20]
  uint32_t flag1 = 0, flag2 = 0;
 8003f8c:	2300      	movs	r3, #0
 8003f8e:	613b      	str	r3, [r7, #16]
 8003f90:	2300      	movs	r3, #0
 8003f92:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  /* Read the I2Cx status register */
  flag1 = I2Cx->SR1;
 8003f94:	687b      	ldr	r3, [r7, #4]
 8003f96:	8a9b      	ldrh	r3, [r3, #20]
 8003f98:	b29b      	uxth	r3, r3
 8003f9a:	613b      	str	r3, [r7, #16]
  flag2 = I2Cx->SR2;
 8003f9c:	687b      	ldr	r3, [r7, #4]
 8003f9e:	8b1b      	ldrh	r3, [r3, #24]
 8003fa0:	b29b      	uxth	r3, r3
 8003fa2:	60fb      	str	r3, [r7, #12]
  flag2 = flag2 << 16;
 8003fa4:	68fb      	ldr	r3, [r7, #12]
 8003fa6:	041b      	lsls	r3, r3, #16
 8003fa8:	60fb      	str	r3, [r7, #12]
  /* Get the last event value from I2C status register */
  lastevent = (flag1 | flag2) & FLAG_Mask;
 8003faa:	693a      	ldr	r2, [r7, #16]
 8003fac:	68fb      	ldr	r3, [r7, #12]
 8003fae:	4313      	orrs	r3, r2
 8003fb0:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8003fb4:	617b      	str	r3, [r7, #20]
  /* Return status */
  return lastevent;
 8003fb6:	697b      	ldr	r3, [r7, #20]
}
 8003fb8:	4618      	mov	r0, r3
 8003fba:	371c      	adds	r7, #28
 8003fbc:	46bd      	mov	sp, r7
 8003fbe:	bc80      	pop	{r7}
 8003fc0:	4770      	bx	lr

08003fc2 <I2C_CheckEvent>:
  * @retval An ErrorStatus enumuration value:
  * - SUCCESS: Last event is equal to the I2C_EVENT
  * - ERROR: Last event is different from the I2C_EVENT
  */
ErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, uint32_t I2C_EVENT)
{
 8003fc2:	b480      	push	{r7}
 8003fc4:	b087      	sub	sp, #28
 8003fc6:	af00      	add	r7, sp, #0
 8003fc8:	6078      	str	r0, [r7, #4]
 8003fca:	6039      	str	r1, [r7, #0]
  uint32_t lastevent = 0;
 8003fcc:	2300      	movs	r3, #0
 8003fce:	613b      	str	r3, [r7, #16]
  uint32_t flag1 = 0, flag2 = 0;
 8003fd0:	2300      	movs	r3, #0
 8003fd2:	60fb      	str	r3, [r7, #12]
 8003fd4:	2300      	movs	r3, #0
 8003fd6:	60bb      	str	r3, [r7, #8]
  ErrorStatus status = ERROR;
 8003fd8:	2300      	movs	r3, #0
 8003fda:	75fb      	strb	r3, [r7, #23]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_EVENT(I2C_EVENT));
  /* Read the I2Cx status register */
  flag1 = I2Cx->SR1;
 8003fdc:	687b      	ldr	r3, [r7, #4]
 8003fde:	8a9b      	ldrh	r3, [r3, #20]
 8003fe0:	b29b      	uxth	r3, r3
 8003fe2:	60fb      	str	r3, [r7, #12]
  flag2 = I2Cx->SR2;
 8003fe4:	687b      	ldr	r3, [r7, #4]
 8003fe6:	8b1b      	ldrh	r3, [r3, #24]
 8003fe8:	b29b      	uxth	r3, r3
 8003fea:	60bb      	str	r3, [r7, #8]
  flag2 = flag2 << 16;
 8003fec:	68bb      	ldr	r3, [r7, #8]
 8003fee:	041b      	lsls	r3, r3, #16
 8003ff0:	60bb      	str	r3, [r7, #8]
  /* Get the last event value from I2C status register */
  lastevent = (flag1 | flag2) & I2C_EVENT;//FLAG_Mask;
 8003ff2:	68fa      	ldr	r2, [r7, #12]
 8003ff4:	68bb      	ldr	r3, [r7, #8]
 8003ff6:	4313      	orrs	r3, r2
 8003ff8:	683a      	ldr	r2, [r7, #0]
 8003ffa:	4013      	ands	r3, r2
 8003ffc:	613b      	str	r3, [r7, #16]
  /* Check whether the last event is equal to I2C_EVENT */
  if (lastevent == I2C_EVENT )
 8003ffe:	693a      	ldr	r2, [r7, #16]
 8004000:	683b      	ldr	r3, [r7, #0]
 8004002:	429a      	cmp	r2, r3
 8004004:	d102      	bne.n	800400c <I2C_CheckEvent+0x4a>
  {
    /* SUCCESS: last event is equal to I2C_EVENT */
    status = SUCCESS;
 8004006:	2301      	movs	r3, #1
 8004008:	75fb      	strb	r3, [r7, #23]
 800400a:	e001      	b.n	8004010 <I2C_CheckEvent+0x4e>
  }
  else
  {
    /* ERROR: last event is different from I2C_EVENT */
    status = ERROR;
 800400c:	2300      	movs	r3, #0
 800400e:	75fb      	strb	r3, [r7, #23]
  }
  /* Return status */
  return status;
 8004010:	7dfb      	ldrb	r3, [r7, #23]
}
 8004012:	4618      	mov	r0, r3
 8004014:	371c      	adds	r7, #28
 8004016:	46bd      	mov	sp, r7
 8004018:	bc80      	pop	{r7}
 800401a:	4770      	bx	lr

0800401c <I2C_GetFlagStatus>:
  *   Address matched flag (Slave mode)ENDAD
  *     @arg I2C_FLAG_SB: Start bit flag (Master mode)
  * @retval The new state of I2C_FLAG (SET or RESET).
  */
FlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
{
 800401c:	b480      	push	{r7}
 800401e:	b087      	sub	sp, #28
 8004020:	af00      	add	r7, sp, #0
 8004022:	6078      	str	r0, [r7, #4]
 8004024:	6039      	str	r1, [r7, #0]
  FlagStatus bitstatus = RESET;
 8004026:	2300      	movs	r3, #0
 8004028:	75fb      	strb	r3, [r7, #23]
  __IO uint32_t i2creg = 0, i2cxbase = 0;
 800402a:	2300      	movs	r3, #0
 800402c:	613b      	str	r3, [r7, #16]
 800402e:	2300      	movs	r3, #0
 8004030:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_GET_FLAG(I2C_FLAG));

  /* Get the I2Cx peripheral base address */
  i2cxbase = (uint32_t)I2Cx;
 8004032:	687b      	ldr	r3, [r7, #4]
 8004034:	60fb      	str	r3, [r7, #12]
  
  /* Read flag register index */
  i2creg = I2C_FLAG >> 28;
 8004036:	683b      	ldr	r3, [r7, #0]
 8004038:	0f1b      	lsrs	r3, r3, #28
 800403a:	613b      	str	r3, [r7, #16]
  
  /* Get bit[23:0] of the flag */
  I2C_FLAG &= FLAG_Mask;
 800403c:	683b      	ldr	r3, [r7, #0]
 800403e:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8004042:	603b      	str	r3, [r7, #0]
  
  if(i2creg != 0)
 8004044:	693b      	ldr	r3, [r7, #16]
 8004046:	2b00      	cmp	r3, #0
 8004048:	d003      	beq.n	8004052 <I2C_GetFlagStatus+0x36>
  {
    /* Get the I2Cx SR1 register address */
    i2cxbase += 0x14;
 800404a:	68fb      	ldr	r3, [r7, #12]
 800404c:	3314      	adds	r3, #20
 800404e:	60fb      	str	r3, [r7, #12]
 8004050:	e005      	b.n	800405e <I2C_GetFlagStatus+0x42>
  }
  else
  {
    /* Flag in I2Cx SR2 Register */
    I2C_FLAG = (uint32_t)(I2C_FLAG >> 16);
 8004052:	683b      	ldr	r3, [r7, #0]
 8004054:	0c1b      	lsrs	r3, r3, #16
 8004056:	603b      	str	r3, [r7, #0]
    /* Get the I2Cx SR2 register address */
    i2cxbase += 0x18;
 8004058:	68fb      	ldr	r3, [r7, #12]
 800405a:	3318      	adds	r3, #24
 800405c:	60fb      	str	r3, [r7, #12]
  }
  
  if(((*(__IO uint32_t *)i2cxbase) & I2C_FLAG) != (uint32_t)RESET)
 800405e:	68fb      	ldr	r3, [r7, #12]
 8004060:	681a      	ldr	r2, [r3, #0]
 8004062:	683b      	ldr	r3, [r7, #0]
 8004064:	4013      	ands	r3, r2
 8004066:	2b00      	cmp	r3, #0
 8004068:	d002      	beq.n	8004070 <I2C_GetFlagStatus+0x54>
  {
    /* I2C_FLAG is set */
    bitstatus = SET;
 800406a:	2301      	movs	r3, #1
 800406c:	75fb      	strb	r3, [r7, #23]
 800406e:	e001      	b.n	8004074 <I2C_GetFlagStatus+0x58>
  }
  else
  {
    /* I2C_FLAG is reset */
    bitstatus = RESET;
 8004070:	2300      	movs	r3, #0
 8004072:	75fb      	strb	r3, [r7, #23]
  }
  
  /* Return the I2C_FLAG status */
  return  bitstatus;
 8004074:	7dfb      	ldrb	r3, [r7, #23]
}
 8004076:	4618      	mov	r0, r3
 8004078:	371c      	adds	r7, #28
 800407a:	46bd      	mov	sp, r7
 800407c:	bc80      	pop	{r7}
 800407e:	4770      	bx	lr

08004080 <I2C_ClearFlag>:
  *     register (I2C_GetFlagStatus()) followed by a write operation to I2C_DR
  *     register  (I2C_SendData()).
  * @retval None
  */
void I2C_ClearFlag(I2C_TypeDef* I2Cx, uint32_t I2C_FLAG)
{
 8004080:	b480      	push	{r7}
 8004082:	b085      	sub	sp, #20
 8004084:	af00      	add	r7, sp, #0
 8004086:	6078      	str	r0, [r7, #4]
 8004088:	6039      	str	r1, [r7, #0]
  uint32_t flagpos = 0;
 800408a:	2300      	movs	r3, #0
 800408c:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_CLEAR_FLAG(I2C_FLAG));
  /* Get the I2C flag position */
  flagpos = I2C_FLAG & FLAG_Mask;
 800408e:	683b      	ldr	r3, [r7, #0]
 8004090:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8004094:	60fb      	str	r3, [r7, #12]
  /* Clear the selected I2C flag */
  I2Cx->SR1 = (uint16_t)~flagpos;
 8004096:	68fb      	ldr	r3, [r7, #12]
 8004098:	b29b      	uxth	r3, r3
 800409a:	43db      	mvns	r3, r3
 800409c:	b29a      	uxth	r2, r3
 800409e:	687b      	ldr	r3, [r7, #4]
 80040a0:	829a      	strh	r2, [r3, #20]
}
 80040a2:	bf00      	nop
 80040a4:	3714      	adds	r7, #20
 80040a6:	46bd      	mov	sp, r7
 80040a8:	bc80      	pop	{r7}
 80040aa:	4770      	bx	lr

080040ac <I2C_ClearITPendingBit>:
  *     I2C_SR1 register (I2C_GetITStatus()) followed by a write operation to 
  *     I2C_DR register (I2C_SendData()).
  * @retval None
  */
void I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, uint32_t I2C_IT)
{
 80040ac:	b480      	push	{r7}
 80040ae:	b085      	sub	sp, #20
 80040b0:	af00      	add	r7, sp, #0
 80040b2:	6078      	str	r0, [r7, #4]
 80040b4:	6039      	str	r1, [r7, #0]
  uint32_t flagpos = 0;
 80040b6:	2300      	movs	r3, #0
 80040b8:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_I2C_ALL_PERIPH(I2Cx));
  assert_param(IS_I2C_CLEAR_IT(I2C_IT));
  /* Get the I2C flag position */
  flagpos = I2C_IT & FLAG_Mask;
 80040ba:	683b      	ldr	r3, [r7, #0]
 80040bc:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 80040c0:	60fb      	str	r3, [r7, #12]
  /* Clear the selected I2C flag */
  I2Cx->SR1 = (uint16_t)~flagpos;
 80040c2:	68fb      	ldr	r3, [r7, #12]
 80040c4:	b29b      	uxth	r3, r3
 80040c6:	43db      	mvns	r3, r3
 80040c8:	b29a      	uxth	r2, r3
 80040ca:	687b      	ldr	r3, [r7, #4]
 80040cc:	829a      	strh	r2, [r3, #20]
}
 80040ce:	bf00      	nop
 80040d0:	3714      	adds	r7, #20
 80040d2:	46bd      	mov	sp, r7
 80040d4:	bc80      	pop	{r7}
 80040d6:	4770      	bx	lr

080040d8 <NVIC_PriorityGroupConfig>:
  *     @arg NVIC_PriorityGroup_4: 4 bits for pre-emption priority
  *                                0 bits for subpriority
  * @retval None
  */
void NVIC_PriorityGroupConfig(uint32_t NVIC_PriorityGroup)
{
 80040d8:	b480      	push	{r7}
 80040da:	b083      	sub	sp, #12
 80040dc:	af00      	add	r7, sp, #0
 80040de:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */
  SCB->AIRCR = AIRCR_VECTKEY_MASK | NVIC_PriorityGroup;
 80040e0:	4a05      	ldr	r2, [pc, #20]	; (80040f8 <NVIC_PriorityGroupConfig+0x20>)
 80040e2:	687b      	ldr	r3, [r7, #4]
 80040e4:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 80040e8:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 80040ec:	60d3      	str	r3, [r2, #12]
}
 80040ee:	bf00      	nop
 80040f0:	370c      	adds	r7, #12
 80040f2:	46bd      	mov	sp, r7
 80040f4:	bc80      	pop	{r7}
 80040f6:	4770      	bx	lr
 80040f8:	e000ed00 	.word	0xe000ed00

080040fc <NVIC_Init>:
  * @param  NVIC_InitStruct: pointer to a NVIC_InitTypeDef structure that contains
  *   the configuration information for the specified NVIC peripheral.
  * @retval None
  */
void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct)
{
 80040fc:	b480      	push	{r7}
 80040fe:	b087      	sub	sp, #28
 8004100:	af00      	add	r7, sp, #0
 8004102:	6078      	str	r0, [r7, #4]
  uint32_t tmppriority = 0x00, tmppre = 0x00, tmpsub = 0x0F;
 8004104:	2300      	movs	r3, #0
 8004106:	617b      	str	r3, [r7, #20]
 8004108:	2300      	movs	r3, #0
 800410a:	613b      	str	r3, [r7, #16]
 800410c:	230f      	movs	r3, #15
 800410e:	60fb      	str	r3, [r7, #12]
  /* Check the parameters */
  assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct->NVIC_IRQChannelCmd));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority));  
  assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    
  if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
 8004110:	687b      	ldr	r3, [r7, #4]
 8004112:	78db      	ldrb	r3, [r3, #3]
 8004114:	2b00      	cmp	r3, #0
 8004116:	d03a      	beq.n	800418e <NVIC_Init+0x92>
  {
    /* Compute the Corresponding IRQ Priority --------------------------------*/    
    tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
 8004118:	4b27      	ldr	r3, [pc, #156]	; (80041b8 <NVIC_Init+0xbc>)
 800411a:	68db      	ldr	r3, [r3, #12]
 800411c:	43db      	mvns	r3, r3
 800411e:	0a1b      	lsrs	r3, r3, #8
 8004120:	f003 0307 	and.w	r3, r3, #7
 8004124:	617b      	str	r3, [r7, #20]
    tmppre = (0x4 - tmppriority);
 8004126:	697b      	ldr	r3, [r7, #20]
 8004128:	f1c3 0304 	rsb	r3, r3, #4
 800412c:	613b      	str	r3, [r7, #16]
    tmpsub = tmpsub >> tmppriority;
 800412e:	68fa      	ldr	r2, [r7, #12]
 8004130:	697b      	ldr	r3, [r7, #20]
 8004132:	fa22 f303 	lsr.w	r3, r2, r3
 8004136:	60fb      	str	r3, [r7, #12]

    tmppriority = (uint32_t)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 8004138:	687b      	ldr	r3, [r7, #4]
 800413a:	785b      	ldrb	r3, [r3, #1]
 800413c:	461a      	mov	r2, r3
 800413e:	693b      	ldr	r3, [r7, #16]
 8004140:	fa02 f303 	lsl.w	r3, r2, r3
 8004144:	617b      	str	r3, [r7, #20]
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
 8004146:	687b      	ldr	r3, [r7, #4]
 8004148:	789b      	ldrb	r3, [r3, #2]
 800414a:	461a      	mov	r2, r3
 800414c:	68fb      	ldr	r3, [r7, #12]
 800414e:	4013      	ands	r3, r2
 8004150:	697a      	ldr	r2, [r7, #20]
 8004152:	4313      	orrs	r3, r2
 8004154:	617b      	str	r3, [r7, #20]
    tmppriority = tmppriority << 0x04;
 8004156:	697b      	ldr	r3, [r7, #20]
 8004158:	011b      	lsls	r3, r3, #4
 800415a:	617b      	str	r3, [r7, #20]
        
    NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
 800415c:	4a17      	ldr	r2, [pc, #92]	; (80041bc <NVIC_Init+0xc0>)
 800415e:	687b      	ldr	r3, [r7, #4]
 8004160:	781b      	ldrb	r3, [r3, #0]
 8004162:	6979      	ldr	r1, [r7, #20]
 8004164:	b2c9      	uxtb	r1, r1
 8004166:	4413      	add	r3, r2
 8004168:	460a      	mov	r2, r1
 800416a:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
    
    /* Enable the Selected IRQ Channels --------------------------------------*/
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 800416e:	687b      	ldr	r3, [r7, #4]
 8004170:	781b      	ldrb	r3, [r3, #0]
 8004172:	f003 031f 	and.w	r3, r3, #31
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8004176:	4911      	ldr	r1, [pc, #68]	; (80041bc <NVIC_Init+0xc0>)
 8004178:	687a      	ldr	r2, [r7, #4]
 800417a:	7812      	ldrb	r2, [r2, #0]
 800417c:	0952      	lsrs	r2, r2, #5
 800417e:	b2d2      	uxtb	r2, r2
 8004180:	4610      	mov	r0, r2
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 8004182:	2201      	movs	r2, #1
 8004184:	fa02 f303 	lsl.w	r3, r2, r3
    NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8004188:	f841 3020 	str.w	r3, [r1, r0, lsl #2]
  {
    /* Disable the Selected IRQ Channels -------------------------------------*/
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
  }
}
 800418c:	e00f      	b.n	80041ae <NVIC_Init+0xb2>
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 800418e:	687b      	ldr	r3, [r7, #4]
 8004190:	781b      	ldrb	r3, [r3, #0]
 8004192:	f003 031f 	and.w	r3, r3, #31
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 8004196:	4909      	ldr	r1, [pc, #36]	; (80041bc <NVIC_Init+0xc0>)
 8004198:	687a      	ldr	r2, [r7, #4]
 800419a:	7812      	ldrb	r2, [r2, #0]
 800419c:	0952      	lsrs	r2, r2, #5
 800419e:	b2d2      	uxtb	r2, r2
 80041a0:	4610      	mov	r0, r2
      (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
 80041a2:	2201      	movs	r2, #1
 80041a4:	409a      	lsls	r2, r3
    NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
 80041a6:	f100 0320 	add.w	r3, r0, #32
 80041aa:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
 80041ae:	bf00      	nop
 80041b0:	371c      	adds	r7, #28
 80041b2:	46bd      	mov	sp, r7
 80041b4:	bc80      	pop	{r7}
 80041b6:	4770      	bx	lr
 80041b8:	e000ed00 	.word	0xe000ed00
 80041bc:	e000e100 	.word	0xe000e100

080041c0 <NVIC_SetVectorTable>:
  *     @arg NVIC_VectTab_FLASH
  * @param  Offset: Vector Table base offset field. This value must be a multiple of 0x100.
  * @retval None
  */
void NVIC_SetVectorTable(uint32_t NVIC_VectTab, uint32_t Offset)
{ 
 80041c0:	b480      	push	{r7}
 80041c2:	b083      	sub	sp, #12
 80041c4:	af00      	add	r7, sp, #0
 80041c6:	6078      	str	r0, [r7, #4]
 80041c8:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_NVIC_VECTTAB(NVIC_VectTab));
  assert_param(IS_NVIC_OFFSET(Offset));  
   
  SCB->VTOR = NVIC_VectTab | (Offset & (uint32_t)0x1FFFFF80);
 80041ca:	683b      	ldr	r3, [r7, #0]
 80041cc:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
 80041d0:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 80041d4:	4904      	ldr	r1, [pc, #16]	; (80041e8 <NVIC_SetVectorTable+0x28>)
 80041d6:	687a      	ldr	r2, [r7, #4]
 80041d8:	4313      	orrs	r3, r2
 80041da:	608b      	str	r3, [r1, #8]
}
 80041dc:	bf00      	nop
 80041de:	370c      	adds	r7, #12
 80041e0:	46bd      	mov	sp, r7
 80041e2:	bc80      	pop	{r7}
 80041e4:	4770      	bx	lr
 80041e6:	bf00      	nop
 80041e8:	e000ed00 	.word	0xe000ed00

080041ec <NVIC_EnableIRQ>:
 *
 * Enable a device specific interupt in the NVIC interrupt controller.
 * The interrupt number cannot be a negative value.
 */
static __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
 80041ec:	b480      	push	{r7}
 80041ee:	b083      	sub	sp, #12
 80041f0:	af00      	add	r7, sp, #0
 80041f2:	4603      	mov	r3, r0
 80041f4:	71fb      	strb	r3, [r7, #7]
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
 80041f6:	79fb      	ldrb	r3, [r7, #7]
 80041f8:	f003 031f 	and.w	r3, r3, #31
 80041fc:	2201      	movs	r2, #1
 80041fe:	fa02 f103 	lsl.w	r1, r2, r3
 8004202:	4a05      	ldr	r2, [pc, #20]	; (8004218 <NVIC_EnableIRQ+0x2c>)
 8004204:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8004208:	095b      	lsrs	r3, r3, #5
 800420a:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
}
 800420e:	bf00      	nop
 8004210:	370c      	adds	r7, #12
 8004212:	46bd      	mov	sp, r7
 8004214:	bc80      	pop	{r7}
 8004216:	4770      	bx	lr
 8004218:	e000e100 	.word	0xe000e100

0800421c <NVIC_SetPriority>:
 * interrupt, or negative to specify an internal (core) interrupt. \n
 *
 * Note: The priority cannot be set for every core interrupt.
 */
static __INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 800421c:	b480      	push	{r7}
 800421e:	b083      	sub	sp, #12
 8004220:	af00      	add	r7, sp, #0
 8004222:	4603      	mov	r3, r0
 8004224:	6039      	str	r1, [r7, #0]
 8004226:	71fb      	strb	r3, [r7, #7]
  if(IRQn < 0) {
 8004228:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800422c:	2b00      	cmp	r3, #0
 800422e:	da0b      	bge.n	8004248 <NVIC_SetPriority+0x2c>
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M3 System Interrupts */
 8004230:	683b      	ldr	r3, [r7, #0]
 8004232:	b2da      	uxtb	r2, r3
 8004234:	490c      	ldr	r1, [pc, #48]	; (8004268 <NVIC_SetPriority+0x4c>)
 8004236:	79fb      	ldrb	r3, [r7, #7]
 8004238:	f003 030f 	and.w	r3, r3, #15
 800423c:	3b04      	subs	r3, #4
 800423e:	0112      	lsls	r2, r2, #4
 8004240:	b2d2      	uxtb	r2, r2
 8004242:	440b      	add	r3, r1
 8004244:	761a      	strb	r2, [r3, #24]
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts      */
}
 8004246:	e009      	b.n	800425c <NVIC_SetPriority+0x40>
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts      */
 8004248:	683b      	ldr	r3, [r7, #0]
 800424a:	b2da      	uxtb	r2, r3
 800424c:	4907      	ldr	r1, [pc, #28]	; (800426c <NVIC_SetPriority+0x50>)
 800424e:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8004252:	0112      	lsls	r2, r2, #4
 8004254:	b2d2      	uxtb	r2, r2
 8004256:	440b      	add	r3, r1
 8004258:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
 800425c:	bf00      	nop
 800425e:	370c      	adds	r7, #12
 8004260:	46bd      	mov	sp, r7
 8004262:	bc80      	pop	{r7}
 8004264:	4770      	bx	lr
 8004266:	bf00      	nop
 8004268:	e000ed00 	.word	0xe000ed00
 800426c:	e000e100 	.word	0xe000e100

08004270 <uartTxDMAConfiguration>:
	uartTxDMAConfiguration(USART1, USART1_TX_DMA, u1Fifo.txBuf, 2,1);
}

void uartTxDMAConfiguration(USART_TypeDef *uart, DMA_Channel_TypeDef *dmatx,
		uint8_t *txBuf, uint32_t len, bool ie)
{
 8004270:	b580      	push	{r7, lr}
 8004272:	b090      	sub	sp, #64	; 0x40
 8004274:	af00      	add	r7, sp, #0
 8004276:	60f8      	str	r0, [r7, #12]
 8004278:	60b9      	str	r1, [r7, #8]
 800427a:	607a      	str	r2, [r7, #4]
 800427c:	603b      	str	r3, [r7, #0]
	DMA_InitTypeDef DMA_InitStructure;

	/* DMA1 Channel (triggered by USART_Tx event) Config */
	DMA_Cmd(dmatx, DISABLE);
 800427e:	2100      	movs	r1, #0
 8004280:	68b8      	ldr	r0, [r7, #8]
 8004282:	4b15      	ldr	r3, [pc, #84]	; (80042d8 <uartTxDMAConfiguration+0x68>)
 8004284:	4798      	blx	r3
	DMA_DeInit(dmatx);
 8004286:	68b8      	ldr	r0, [r7, #8]
 8004288:	4b14      	ldr	r3, [pc, #80]	; (80042dc <uartTxDMAConfiguration+0x6c>)
 800428a:	4798      	blx	r3
	DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t) &uart->DR;
 800428c:	68fb      	ldr	r3, [r7, #12]
 800428e:	3304      	adds	r3, #4
 8004290:	617b      	str	r3, [r7, #20]
	DMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t) txBuf;
 8004292:	687b      	ldr	r3, [r7, #4]
 8004294:	61bb      	str	r3, [r7, #24]
	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;
 8004296:	2310      	movs	r3, #16
 8004298:	61fb      	str	r3, [r7, #28]
	DMA_InitStructure.DMA_BufferSize = len;
 800429a:	683b      	ldr	r3, [r7, #0]
 800429c:	623b      	str	r3, [r7, #32]
	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
 800429e:	2300      	movs	r3, #0
 80042a0:	627b      	str	r3, [r7, #36]	; 0x24
	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
 80042a2:	2380      	movs	r3, #128	; 0x80
 80042a4:	62bb      	str	r3, [r7, #40]	; 0x28
	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
 80042a6:	2300      	movs	r3, #0
 80042a8:	62fb      	str	r3, [r7, #44]	; 0x2c
	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
 80042aa:	2300      	movs	r3, #0
 80042ac:	633b      	str	r3, [r7, #48]	; 0x30
	DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
 80042ae:	2300      	movs	r3, #0
 80042b0:	637b      	str	r3, [r7, #52]	; 0x34
	DMA_InitStructure.DMA_Priority = DMA_Priority_VeryHigh;
 80042b2:	f44f 5340 	mov.w	r3, #12288	; 0x3000
 80042b6:	63bb      	str	r3, [r7, #56]	; 0x38
	DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
 80042b8:	2300      	movs	r3, #0
 80042ba:	63fb      	str	r3, [r7, #60]	; 0x3c
	DMA_Init(dmatx, &DMA_InitStructure);
 80042bc:	f107 0314 	add.w	r3, r7, #20
 80042c0:	4619      	mov	r1, r3
 80042c2:	68b8      	ldr	r0, [r7, #8]
 80042c4:	4b06      	ldr	r3, [pc, #24]	; (80042e0 <uartTxDMAConfiguration+0x70>)
 80042c6:	4798      	blx	r3
	DMA_Cmd(dmatx, ENABLE);
 80042c8:	2101      	movs	r1, #1
 80042ca:	68b8      	ldr	r0, [r7, #8]
 80042cc:	4b02      	ldr	r3, [pc, #8]	; (80042d8 <uartTxDMAConfiguration+0x68>)
 80042ce:	4798      	blx	r3

}
 80042d0:	bf00      	nop
 80042d2:	3740      	adds	r7, #64	; 0x40
 80042d4:	46bd      	mov	sp, r7
 80042d6:	bd80      	pop	{r7, pc}
 80042d8:	08003929 	.word	0x08003929
 80042dc:	08003739 	.word	0x08003739
 80042e0:	080038ad 	.word	0x080038ad

080042e4 <uartRxDMAConfiguration>:
 * @param  uart, dmatx,dmarx,interrupt enable
 * @retval : None
 */
void uartRxDMAConfiguration(USART_TypeDef *uart, DMA_Channel_TypeDef *dmarx,
		unsigned char *rxBuf, uint32_t len)
{
 80042e4:	b580      	push	{r7, lr}
 80042e6:	b090      	sub	sp, #64	; 0x40
 80042e8:	af00      	add	r7, sp, #0
 80042ea:	60f8      	str	r0, [r7, #12]
 80042ec:	60b9      	str	r1, [r7, #8]
 80042ee:	607a      	str	r2, [r7, #4]
 80042f0:	603b      	str	r3, [r7, #0]
	DMA_InitTypeDef DMA_InitStructure;

	/* DMA1 Channel (triggered by USART1 Rx event) Config */
	DMA_DeInit(dmarx);
 80042f2:	68b8      	ldr	r0, [r7, #8]
 80042f4:	4b13      	ldr	r3, [pc, #76]	; (8004344 <uartRxDMAConfiguration+0x60>)
 80042f6:	4798      	blx	r3
	DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t) &uart->DR;
 80042f8:	68fb      	ldr	r3, [r7, #12]
 80042fa:	3304      	adds	r3, #4
 80042fc:	617b      	str	r3, [r7, #20]
	DMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t) rxBuf;
 80042fe:	687b      	ldr	r3, [r7, #4]
 8004300:	61bb      	str	r3, [r7, #24]
	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
 8004302:	2300      	movs	r3, #0
 8004304:	61fb      	str	r3, [r7, #28]
	DMA_InitStructure.DMA_BufferSize = len;
 8004306:	683b      	ldr	r3, [r7, #0]
 8004308:	623b      	str	r3, [r7, #32]
	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
 800430a:	2300      	movs	r3, #0
 800430c:	627b      	str	r3, [r7, #36]	; 0x24
	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
 800430e:	2380      	movs	r3, #128	; 0x80
 8004310:	62bb      	str	r3, [r7, #40]	; 0x28
	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
 8004312:	2300      	movs	r3, #0
 8004314:	62fb      	str	r3, [r7, #44]	; 0x2c
	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
 8004316:	2300      	movs	r3, #0
 8004318:	633b      	str	r3, [r7, #48]	; 0x30
	DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
 800431a:	2320      	movs	r3, #32
 800431c:	637b      	str	r3, [r7, #52]	; 0x34
	DMA_InitStructure.DMA_Priority = DMA_Priority_VeryHigh;
 800431e:	f44f 5340 	mov.w	r3, #12288	; 0x3000
 8004322:	63bb      	str	r3, [r7, #56]	; 0x38
	DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
 8004324:	2300      	movs	r3, #0
 8004326:	63fb      	str	r3, [r7, #60]	; 0x3c
	DMA_Init(dmarx, &DMA_InitStructure);
 8004328:	f107 0314 	add.w	r3, r7, #20
 800432c:	4619      	mov	r1, r3
 800432e:	68b8      	ldr	r0, [r7, #8]
 8004330:	4b05      	ldr	r3, [pc, #20]	; (8004348 <uartRxDMAConfiguration+0x64>)
 8004332:	4798      	blx	r3
	DMA_Cmd(dmarx, ENABLE);
 8004334:	2101      	movs	r1, #1
 8004336:	68b8      	ldr	r0, [r7, #8]
 8004338:	4b04      	ldr	r3, [pc, #16]	; (800434c <uartRxDMAConfiguration+0x68>)
 800433a:	4798      	blx	r3

}
 800433c:	bf00      	nop
 800433e:	3740      	adds	r7, #64	; 0x40
 8004340:	46bd      	mov	sp, r7
 8004342:	bd80      	pop	{r7, pc}
 8004344:	08003739 	.word	0x08003739
 8004348:	080038ad 	.word	0x080038ad
 800434c:	08003929 	.word	0x08003929

08004350 <uart1Init>:
void uart1Init(uint32_t baudrate)
{
 8004350:	b590      	push	{r4, r7, lr}
 8004352:	b087      	sub	sp, #28
 8004354:	af00      	add	r7, sp, #0
 8004356:	6078      	str	r0, [r7, #4]

   // US1_QUEUE = xQueueCreate( 10, sizeof( unsigned int ) );

	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1,ENABLE);
 8004358:	2101      	movs	r1, #1
 800435a:	2001      	movs	r0, #1
 800435c:	4b24      	ldr	r3, [pc, #144]	; (80043f0 <uart1Init+0xa0>)
 800435e:	4798      	blx	r3

	USART_DeInit(USART1);
 8004360:	4824      	ldr	r0, [pc, #144]	; (80043f4 <uart1Init+0xa4>)
 8004362:	4b25      	ldr	r3, [pc, #148]	; (80043f8 <uart1Init+0xa8>)
 8004364:	4798      	blx	r3


	USART_InitTypeDef USART_InitStructure;

	/* Enable AFIO,  clocks */
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
 8004366:	2101      	movs	r1, #1
 8004368:	2001      	movs	r0, #1
 800436a:	4b24      	ldr	r3, [pc, #144]	; (80043fc <uart1Init+0xac>)
 800436c:	4798      	blx	r3

	/* Enable GPIO clocks */
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC|RCC_APB2Periph_GPIOA
 800436e:	2101      	movs	r1, #1
 8004370:	201c      	movs	r0, #28
 8004372:	4b22      	ldr	r3, [pc, #136]	; (80043fc <uart1Init+0xac>)
 8004374:	4798      	blx	r3
	|RCC_APB2Periph_GPIOB, ENABLE);

	/* Enable USART3,  clocks */
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
 8004376:	2101      	movs	r1, #1
 8004378:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 800437c:	4b1f      	ldr	r3, [pc, #124]	; (80043fc <uart1Init+0xac>)
 800437e:	4798      	blx	r3
	//GPIO_PinRemapConfig(GPIO_Remap_USART1,ENABLE);

	USART_InitStructure.USART_BaudRate = baudrate;
 8004380:	687b      	ldr	r3, [r7, #4]
 8004382:	60bb      	str	r3, [r7, #8]
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
 8004384:	2300      	movs	r3, #0
 8004386:	81bb      	strh	r3, [r7, #12]
	USART_InitStructure.USART_StopBits = USART_StopBits_1;
 8004388:	2300      	movs	r3, #0
 800438a:	81fb      	strh	r3, [r7, #14]
	USART_InitStructure.USART_Parity = USART_Parity_No;
 800438c:	2300      	movs	r3, #0
 800438e:	823b      	strh	r3, [r7, #16]
	USART_InitStructure.USART_HardwareFlowControl
			= USART_HardwareFlowControl_None;
 8004390:	2300      	movs	r3, #0
 8004392:	82bb      	strh	r3, [r7, #20]
	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 8004394:	230c      	movs	r3, #12
 8004396:	827b      	strh	r3, [r7, #18]
	/* Configure USART3 */
	USART_Init(USART1, &USART_InitStructure);
 8004398:	f107 0308 	add.w	r3, r7, #8
 800439c:	4619      	mov	r1, r3
 800439e:	4815      	ldr	r0, [pc, #84]	; (80043f4 <uart1Init+0xa4>)
 80043a0:	4b17      	ldr	r3, [pc, #92]	; (8004400 <uart1Init+0xb0>)
 80043a2:	4798      	blx	r3

	USART_ClearFlag(USART1, USART_FLAG_CTS | USART_FLAG_LBD  |
 80043a4:	f44f 7158 	mov.w	r1, #864	; 0x360
 80043a8:	4812      	ldr	r0, [pc, #72]	; (80043f4 <uart1Init+0xa4>)
 80043aa:	4b16      	ldr	r3, [pc, #88]	; (8004404 <uart1Init+0xb4>)
 80043ac:	4798      	blx	r3
						USART_FLAG_TC  | USART_FLAG_RXNE );

	uartRxDMAConfiguration(USART1, USART1_RX_DMA, u1Fifo.rxBuf,
 80043ae:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80043b2:	4a15      	ldr	r2, [pc, #84]	; (8004408 <uart1Init+0xb8>)
 80043b4:	4915      	ldr	r1, [pc, #84]	; (800440c <uart1Init+0xbc>)
 80043b6:	480f      	ldr	r0, [pc, #60]	; (80043f4 <uart1Init+0xa4>)
 80043b8:	4c15      	ldr	r4, [pc, #84]	; (8004410 <uart1Init+0xc0>)
 80043ba:	47a0      	blx	r4
			UARTRX_FIFO_SIZE);
	USART_DMACmd(USART1, USART_DMAReq_Tx, ENABLE);
 80043bc:	2201      	movs	r2, #1
 80043be:	2180      	movs	r1, #128	; 0x80
 80043c0:	480c      	ldr	r0, [pc, #48]	; (80043f4 <uart1Init+0xa4>)
 80043c2:	4b14      	ldr	r3, [pc, #80]	; (8004414 <uart1Init+0xc4>)
 80043c4:	4798      	blx	r3
	/* Enable USART_Rx DMA Receive request */
	USART_DMACmd(USART1, USART_DMAReq_Rx, ENABLE);
 80043c6:	2201      	movs	r2, #1
 80043c8:	2140      	movs	r1, #64	; 0x40
 80043ca:	480a      	ldr	r0, [pc, #40]	; (80043f4 <uart1Init+0xa4>)
 80043cc:	4b11      	ldr	r3, [pc, #68]	; (8004414 <uart1Init+0xc4>)
 80043ce:	4798      	blx	r3

	  /* Enable USART_Rx Receive interrupt */
	  //USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);
	    /* Configure USART3 interrupt */
	    NVIC_SetPriority(USART1_RX_DMA_IRQn, 0x03);
 80043d0:	2103      	movs	r1, #3
 80043d2:	200f      	movs	r0, #15
 80043d4:	4b10      	ldr	r3, [pc, #64]	; (8004418 <uart1Init+0xc8>)
 80043d6:	4798      	blx	r3
	    NVIC_EnableIRQ(USART1_RX_DMA_IRQn);
 80043d8:	200f      	movs	r0, #15
 80043da:	4b10      	ldr	r3, [pc, #64]	; (800441c <uart1Init+0xcc>)
 80043dc:	4798      	blx	r3
	/* Enable the USART3 */
	USART_Cmd(USART1, ENABLE);
 80043de:	2101      	movs	r1, #1
 80043e0:	4804      	ldr	r0, [pc, #16]	; (80043f4 <uart1Init+0xa4>)
 80043e2:	4b0f      	ldr	r3, [pc, #60]	; (8004420 <uart1Init+0xd0>)
 80043e4:	4798      	blx	r3
}
 80043e6:	bf00      	nop
 80043e8:	371c      	adds	r7, #28
 80043ea:	46bd      	mov	sp, r7
 80043ec:	bd90      	pop	{r4, r7, pc}
 80043ee:	bf00      	nop
 80043f0:	08003481 	.word	0x08003481
 80043f4:	40013800 	.word	0x40013800
 80043f8:	080028c9 	.word	0x080028c9
 80043fc:	080034bd 	.word	0x080034bd
 8004400:	08002989 	.word	0x08002989
 8004404:	08002afd 	.word	0x08002afd
 8004408:	200057e4 	.word	0x200057e4
 800440c:	40020058 	.word	0x40020058
 8004410:	080042e5 	.word	0x080042e5
 8004414:	08002ab7 	.word	0x08002ab7
 8004418:	0800421d 	.word	0x0800421d
 800441c:	080041ed 	.word	0x080041ed
 8004420:	08002a79 	.word	0x08002a79

08004424 <uart1GetChar>:

//-----------------------------------------------------------------------------------
int uart1GetChar(unsigned char *ch)
{
 8004424:	b590      	push	{r4, r7, lr}
 8004426:	b083      	sub	sp, #12
 8004428:	af00      	add	r7, sp, #0
 800442a:	6078      	str	r0, [r7, #4]

	//int temp = DMA_GetCurrDataCounter(USART1_RX_DMA);
	if (u1Fifo.rxCurrent != (UARTRX_FIFO_SIZE - DMA_GetCurrDataCounter(USART1_RX_DMA)))
 800442c:	4b11      	ldr	r3, [pc, #68]	; (8004474 <uart1GetChar+0x50>)
 800442e:	681c      	ldr	r4, [r3, #0]
 8004430:	4811      	ldr	r0, [pc, #68]	; (8004478 <uart1GetChar+0x54>)
 8004432:	4b12      	ldr	r3, [pc, #72]	; (800447c <uart1GetChar+0x58>)
 8004434:	4798      	blx	r3
 8004436:	4603      	mov	r3, r0
 8004438:	f5c3 6380 	rsb	r3, r3, #1024	; 0x400
 800443c:	429c      	cmp	r4, r3
 800443e:	d013      	beq.n	8004468 <uart1GetChar+0x44>
	{
		*ch = u1Fifo.rxBuf[u1Fifo.rxCurrent];
 8004440:	4b0c      	ldr	r3, [pc, #48]	; (8004474 <uart1GetChar+0x50>)
 8004442:	681b      	ldr	r3, [r3, #0]
 8004444:	4a0b      	ldr	r2, [pc, #44]	; (8004474 <uart1GetChar+0x50>)
 8004446:	4413      	add	r3, r2
 8004448:	7b1a      	ldrb	r2, [r3, #12]
 800444a:	687b      	ldr	r3, [r7, #4]
 800444c:	701a      	strb	r2, [r3, #0]
		u1Fifo.rxCurrent++;
 800444e:	4b09      	ldr	r3, [pc, #36]	; (8004474 <uart1GetChar+0x50>)
 8004450:	681b      	ldr	r3, [r3, #0]
 8004452:	3301      	adds	r3, #1
 8004454:	4a07      	ldr	r2, [pc, #28]	; (8004474 <uart1GetChar+0x50>)
 8004456:	6013      	str	r3, [r2, #0]
		u1Fifo.rxCurrent &= UARTRX_FIFO_SIZE_MASK;
 8004458:	4b06      	ldr	r3, [pc, #24]	; (8004474 <uart1GetChar+0x50>)
 800445a:	681b      	ldr	r3, [r3, #0]
 800445c:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8004460:	4a04      	ldr	r2, [pc, #16]	; (8004474 <uart1GetChar+0x50>)
 8004462:	6013      	str	r3, [r2, #0]
		return 1;
 8004464:	2301      	movs	r3, #1
 8004466:	e000      	b.n	800446a <uart1GetChar+0x46>
	}
	return 0;
 8004468:	2300      	movs	r3, #0
}
 800446a:	4618      	mov	r0, r3
 800446c:	370c      	adds	r7, #12
 800446e:	46bd      	mov	sp, r7
 8004470:	bd90      	pop	{r4, r7, pc}
 8004472:	bf00      	nop
 8004474:	200057d8 	.word	0x200057d8
 8004478:	40020058 	.word	0x40020058
 800447c:	08003999 	.word	0x08003999

08004480 <uart1PutChar>:

//-----------------------------------------------------------------------------------
unsigned int uart1PutChar(unsigned char ch)
{
 8004480:	b480      	push	{r7}
 8004482:	b083      	sub	sp, #12
 8004484:	af00      	add	r7, sp, #0
 8004486:	4603      	mov	r3, r0
 8004488:	71fb      	strb	r3, [r7, #7]

	//	IEC2bits.DMA4IE = 0;
	u1Fifo.txBufB[u1Fifo.txCurrentEnd] = ch;
 800448a:	4b15      	ldr	r3, [pc, #84]	; (80044e0 <uart1PutChar+0x60>)
 800448c:	689b      	ldr	r3, [r3, #8]
 800448e:	4a14      	ldr	r2, [pc, #80]	; (80044e0 <uart1PutChar+0x60>)
 8004490:	4413      	add	r3, r2
 8004492:	79fa      	ldrb	r2, [r7, #7]
 8004494:	f883 244c 	strb.w	r2, [r3, #1100]	; 0x44c
	u1Fifo.txCurrentEnd++;
 8004498:	4b11      	ldr	r3, [pc, #68]	; (80044e0 <uart1PutChar+0x60>)
 800449a:	689b      	ldr	r3, [r3, #8]
 800449c:	3301      	adds	r3, #1
 800449e:	4a10      	ldr	r2, [pc, #64]	; (80044e0 <uart1PutChar+0x60>)
 80044a0:	6093      	str	r3, [r2, #8]
	u1Fifo.txCurrentEnd &= UARTTX_FIFOB_SIZE_MASK;
 80044a2:	4b0f      	ldr	r3, [pc, #60]	; (80044e0 <uart1PutChar+0x60>)
 80044a4:	689b      	ldr	r3, [r3, #8]
 80044a6:	f3c3 0309 	ubfx	r3, r3, #0, #10
 80044aa:	4a0d      	ldr	r2, [pc, #52]	; (80044e0 <uart1PutChar+0x60>)
 80044ac:	6093      	str	r3, [r2, #8]

	if (u1Fifo.txCurrentEnd == u1Fifo.txCurrentStart)
 80044ae:	4b0c      	ldr	r3, [pc, #48]	; (80044e0 <uart1PutChar+0x60>)
 80044b0:	689a      	ldr	r2, [r3, #8]
 80044b2:	4b0b      	ldr	r3, [pc, #44]	; (80044e0 <uart1PutChar+0x60>)
 80044b4:	685b      	ldr	r3, [r3, #4]
 80044b6:	429a      	cmp	r2, r3
 80044b8:	d10c      	bne.n	80044d4 <uart1PutChar+0x54>
	{
		u1Fifo.txCurrentEnd--;
 80044ba:	4b09      	ldr	r3, [pc, #36]	; (80044e0 <uart1PutChar+0x60>)
 80044bc:	689b      	ldr	r3, [r3, #8]
 80044be:	3b01      	subs	r3, #1
 80044c0:	4a07      	ldr	r2, [pc, #28]	; (80044e0 <uart1PutChar+0x60>)
 80044c2:	6093      	str	r3, [r2, #8]
		u1Fifo.txCurrentEnd &= UARTTX_FIFOB_SIZE_MASK;
 80044c4:	4b06      	ldr	r3, [pc, #24]	; (80044e0 <uart1PutChar+0x60>)
 80044c6:	689b      	ldr	r3, [r3, #8]
 80044c8:	f3c3 0309 	ubfx	r3, r3, #0, #10
 80044cc:	4a04      	ldr	r2, [pc, #16]	; (80044e0 <uart1PutChar+0x60>)
 80044ce:	6093      	str	r3, [r2, #8]
		//		IEC2bits.DMA4IE = 1;
		return 0;
 80044d0:	2300      	movs	r3, #0
 80044d2:	e000      	b.n	80044d6 <uart1PutChar+0x56>
	}
	//	IEC2bits.DMA4IE = 1;
	return 1;
 80044d4:	2301      	movs	r3, #1
}
 80044d6:	4618      	mov	r0, r3
 80044d8:	370c      	adds	r7, #12
 80044da:	46bd      	mov	sp, r7
 80044dc:	bc80      	pop	{r7}
 80044de:	4770      	bx	lr
 80044e0:	200057d8 	.word	0x200057d8

080044e4 <uart1TxTask>:

//-----------------------------------------------------------------------------------
void uart1TxTask()
{
 80044e4:	b590      	push	{r4, r7, lr}
 80044e6:	b085      	sub	sp, #20
 80044e8:	af02      	add	r7, sp, #8
	unsigned int cnt0 = 0;
 80044ea:	2300      	movs	r3, #0
 80044ec:	607b      	str	r3, [r7, #4]
	// If DMA COMPLITE
	if ((USART1_TX_DMA->CCR & ((uint32_t) 0x00000001)) == 0)
 80044ee:	4b23      	ldr	r3, [pc, #140]	; (800457c <uart1TxTask+0x98>)
 80044f0:	681b      	ldr	r3, [r3, #0]
 80044f2:	f003 0301 	and.w	r3, r3, #1
 80044f6:	2b00      	cmp	r3, #0
 80044f8:	d13b      	bne.n	8004572 <uart1TxTask+0x8e>
	{
		while ((u1Fifo.txCurrentStart != u1Fifo.txCurrentEnd) && (cnt0< UARTTX_FIFO_SIZE))
 80044fa:	e01a      	b.n	8004532 <uart1TxTask+0x4e>
		{
			u1Fifo.txBuf[cnt0] = u1Fifo.txBufB[u1Fifo.txCurrentStart];
 80044fc:	4b20      	ldr	r3, [pc, #128]	; (8004580 <uart1TxTask+0x9c>)
 80044fe:	685b      	ldr	r3, [r3, #4]
 8004500:	4a1f      	ldr	r2, [pc, #124]	; (8004580 <uart1TxTask+0x9c>)
 8004502:	4413      	add	r3, r2
 8004504:	f893 144c 	ldrb.w	r1, [r3, #1100]	; 0x44c
 8004508:	4a1d      	ldr	r2, [pc, #116]	; (8004580 <uart1TxTask+0x9c>)
 800450a:	687b      	ldr	r3, [r7, #4]
 800450c:	4413      	add	r3, r2
 800450e:	f203 430c 	addw	r3, r3, #1036	; 0x40c
 8004512:	460a      	mov	r2, r1
 8004514:	701a      	strb	r2, [r3, #0]
			u1Fifo.txCurrentStart++;
 8004516:	4b1a      	ldr	r3, [pc, #104]	; (8004580 <uart1TxTask+0x9c>)
 8004518:	685b      	ldr	r3, [r3, #4]
 800451a:	3301      	adds	r3, #1
 800451c:	4a18      	ldr	r2, [pc, #96]	; (8004580 <uart1TxTask+0x9c>)
 800451e:	6053      	str	r3, [r2, #4]
			u1Fifo.txCurrentStart &= UARTTX_FIFOB_SIZE_MASK;
 8004520:	4b17      	ldr	r3, [pc, #92]	; (8004580 <uart1TxTask+0x9c>)
 8004522:	685b      	ldr	r3, [r3, #4]
 8004524:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8004528:	4a15      	ldr	r2, [pc, #84]	; (8004580 <uart1TxTask+0x9c>)
 800452a:	6053      	str	r3, [r2, #4]
			cnt0++;
 800452c:	687b      	ldr	r3, [r7, #4]
 800452e:	3301      	adds	r3, #1
 8004530:	607b      	str	r3, [r7, #4]
		while ((u1Fifo.txCurrentStart != u1Fifo.txCurrentEnd) && (cnt0< UARTTX_FIFO_SIZE))
 8004532:	4b13      	ldr	r3, [pc, #76]	; (8004580 <uart1TxTask+0x9c>)
 8004534:	685a      	ldr	r2, [r3, #4]
 8004536:	4b12      	ldr	r3, [pc, #72]	; (8004580 <uart1TxTask+0x9c>)
 8004538:	689b      	ldr	r3, [r3, #8]
 800453a:	429a      	cmp	r2, r3
 800453c:	d002      	beq.n	8004544 <uart1TxTask+0x60>
 800453e:	687b      	ldr	r3, [r7, #4]
 8004540:	2b3f      	cmp	r3, #63	; 0x3f
 8004542:	d9db      	bls.n	80044fc <uart1TxTask+0x18>
		}
		if (cnt0 > 0)
 8004544:	687b      	ldr	r3, [r7, #4]
 8004546:	2b00      	cmp	r3, #0
 8004548:	d013      	beq.n	8004572 <uart1TxTask+0x8e>
		{

			uartTxDMAConfiguration(USART1, USART1_TX_DMA, u1Fifo.txBuf, cnt0,1);
 800454a:	2301      	movs	r3, #1
 800454c:	9300      	str	r3, [sp, #0]
 800454e:	687b      	ldr	r3, [r7, #4]
 8004550:	4a0c      	ldr	r2, [pc, #48]	; (8004584 <uart1TxTask+0xa0>)
 8004552:	490a      	ldr	r1, [pc, #40]	; (800457c <uart1TxTask+0x98>)
 8004554:	480c      	ldr	r0, [pc, #48]	; (8004588 <uart1TxTask+0xa4>)
 8004556:	4c0d      	ldr	r4, [pc, #52]	; (800458c <uart1TxTask+0xa8>)
 8004558:	47a0      	blx	r4
			DMA_ITConfig(USART1_TX_DMA, DMA_IT_TC, ENABLE);
 800455a:	2201      	movs	r2, #1
 800455c:	2102      	movs	r1, #2
 800455e:	4807      	ldr	r0, [pc, #28]	; (800457c <uart1TxTask+0x98>)
 8004560:	4b0b      	ldr	r3, [pc, #44]	; (8004590 <uart1TxTask+0xac>)
 8004562:	4798      	blx	r3
				//}
				/* Enable USART_Tx DMA Tansmit request */
				/* Configure DMA1_Channel_Tx interrupt */
				NVIC_SetPriority(USART1_TX_DMA_IRQn, 0x02);
 8004564:	2102      	movs	r1, #2
 8004566:	200e      	movs	r0, #14
 8004568:	4b0a      	ldr	r3, [pc, #40]	; (8004594 <uart1TxTask+0xb0>)
 800456a:	4798      	blx	r3
				NVIC_EnableIRQ(USART1_TX_DMA_IRQn);
 800456c:	200e      	movs	r0, #14
 800456e:	4b0a      	ldr	r3, [pc, #40]	; (8004598 <uart1TxTask+0xb4>)
 8004570:	4798      	blx	r3
		}

	}
}
 8004572:	bf00      	nop
 8004574:	370c      	adds	r7, #12
 8004576:	46bd      	mov	sp, r7
 8004578:	bd90      	pop	{r4, r7, pc}
 800457a:	bf00      	nop
 800457c:	40020044 	.word	0x40020044
 8004580:	200057d8 	.word	0x200057d8
 8004584:	20005be4 	.word	0x20005be4
 8004588:	40013800 	.word	0x40013800
 800458c:	08004271 	.word	0x08004271
 8004590:	0800395f 	.word	0x0800395f
 8004594:	0800421d 	.word	0x0800421d
 8004598:	080041ed 	.word	0x080041ed

0800459c <uart1Read>:

//-----------------------------------------------------------------------------------
unsigned int uart1Read(unsigned char *dsn, unsigned int max_len)
{
 800459c:	b580      	push	{r7, lr}
 800459e:	b086      	sub	sp, #24
 80045a0:	af00      	add	r7, sp, #0
 80045a2:	6078      	str	r0, [r7, #4]
 80045a4:	6039      	str	r1, [r7, #0]
	unsigned short cntr = 0, crc = 0;
 80045a6:	2300      	movs	r3, #0
 80045a8:	82fb      	strh	r3, [r7, #22]
 80045aa:	2300      	movs	r3, #0
 80045ac:	82bb      	strh	r3, [r7, #20]
	unsigned char v, *ptr = dsn;
 80045ae:	687b      	ldr	r3, [r7, #4]
 80045b0:	613b      	str	r3, [r7, #16]

	while (uart1GetChar(&v) && (max_len > cntr))
 80045b2:	e00d      	b.n	80045d0 <uart1Read+0x34>
	{
		*ptr = v;
 80045b4:	7bfa      	ldrb	r2, [r7, #15]
 80045b6:	693b      	ldr	r3, [r7, #16]
 80045b8:	701a      	strb	r2, [r3, #0]
		ptr++;
 80045ba:	693b      	ldr	r3, [r7, #16]
 80045bc:	3301      	adds	r3, #1
 80045be:	613b      	str	r3, [r7, #16]
		crc += v;
 80045c0:	7bfb      	ldrb	r3, [r7, #15]
 80045c2:	b29a      	uxth	r2, r3
 80045c4:	8abb      	ldrh	r3, [r7, #20]
 80045c6:	4413      	add	r3, r2
 80045c8:	82bb      	strh	r3, [r7, #20]
		cntr++;
 80045ca:	8afb      	ldrh	r3, [r7, #22]
 80045cc:	3301      	adds	r3, #1
 80045ce:	82fb      	strh	r3, [r7, #22]
	while (uart1GetChar(&v) && (max_len > cntr))
 80045d0:	f107 030f 	add.w	r3, r7, #15
 80045d4:	4618      	mov	r0, r3
 80045d6:	4b07      	ldr	r3, [pc, #28]	; (80045f4 <uart1Read+0x58>)
 80045d8:	4798      	blx	r3
 80045da:	4603      	mov	r3, r0
 80045dc:	2b00      	cmp	r3, #0
 80045de:	d003      	beq.n	80045e8 <uart1Read+0x4c>
 80045e0:	8afb      	ldrh	r3, [r7, #22]
 80045e2:	683a      	ldr	r2, [r7, #0]
 80045e4:	429a      	cmp	r2, r3
 80045e6:	d8e5      	bhi.n	80045b4 <uart1Read+0x18>
	}

	return cntr; //  error here
 80045e8:	8afb      	ldrh	r3, [r7, #22]
}
 80045ea:	4618      	mov	r0, r3
 80045ec:	3718      	adds	r7, #24
 80045ee:	46bd      	mov	sp, r7
 80045f0:	bd80      	pop	{r7, pc}
 80045f2:	bf00      	nop
 80045f4:	08004425 	.word	0x08004425

080045f8 <uart1Write>:

//-----------------------------------------------------------------------------------

void uart1Write(unsigned char *src, unsigned int len)
{
 80045f8:	b580      	push	{r7, lr}
 80045fa:	b084      	sub	sp, #16
 80045fc:	af00      	add	r7, sp, #0
 80045fe:	6078      	str	r0, [r7, #4]
 8004600:	6039      	str	r1, [r7, #0]
	unsigned int Param;
	unsigned char ch;
	unsigned int rezult;
	if (len == 0)
 8004602:	683b      	ldr	r3, [r7, #0]
 8004604:	2b00      	cmp	r3, #0
 8004606:	d014      	beq.n	8004632 <uart1Write+0x3a>
		return;
	while (len>0)
 8004608:	e00d      	b.n	8004626 <uart1Write+0x2e>
	{
		ch = *src;
 800460a:	687b      	ldr	r3, [r7, #4]
 800460c:	781b      	ldrb	r3, [r3, #0]
 800460e:	73fb      	strb	r3, [r7, #15]
		rezult = uart1PutChar(ch);
 8004610:	7bfb      	ldrb	r3, [r7, #15]
 8004612:	4618      	mov	r0, r3
 8004614:	4b09      	ldr	r3, [pc, #36]	; (800463c <uart1Write+0x44>)
 8004616:	4798      	blx	r3
 8004618:	60b8      	str	r0, [r7, #8]
		src++;
 800461a:	687b      	ldr	r3, [r7, #4]
 800461c:	3301      	adds	r3, #1
 800461e:	607b      	str	r3, [r7, #4]
		len--;
 8004620:	683b      	ldr	r3, [r7, #0]
 8004622:	3b01      	subs	r3, #1
 8004624:	603b      	str	r3, [r7, #0]
	while (len>0)
 8004626:	683b      	ldr	r3, [r7, #0]
 8004628:	2b00      	cmp	r3, #0
 800462a:	d1ee      	bne.n	800460a <uart1Write+0x12>
	}
	uart1TxTask();
 800462c:	4b04      	ldr	r3, [pc, #16]	; (8004640 <uart1Write+0x48>)
 800462e:	4798      	blx	r3
 8004630:	e000      	b.n	8004634 <uart1Write+0x3c>
		return;
 8004632:	bf00      	nop
}
 8004634:	3710      	adds	r7, #16
 8004636:	46bd      	mov	sp, r7
 8004638:	bd80      	pop	{r7, pc}
 800463a:	bf00      	nop
 800463c:	08004481 	.word	0x08004481
 8004640:	080044e5 	.word	0x080044e5

08004644 <DMA1_Channel4_IRQHandler>:


//UART 1 DMA INTERRUPT
void DMA1_Channel4_IRQHandler(void)
{
 8004644:	b580      	push	{r7, lr}
 8004646:	af00      	add	r7, sp, #0
	/* Disable DMA1_Channel2 transfer*/
	DMA_Cmd(USART1_TX_DMA, DISABLE);
 8004648:	2100      	movs	r1, #0
 800464a:	4805      	ldr	r0, [pc, #20]	; (8004660 <DMA1_Channel4_IRQHandler+0x1c>)
 800464c:	4b05      	ldr	r3, [pc, #20]	; (8004664 <DMA1_Channel4_IRQHandler+0x20>)
 800464e:	4798      	blx	r3

	/*  Clear DMA1_Channel2 Transfer Complete Flag*/
	DMA_ClearFlag(DMA1_FLAG_TC4);
 8004650:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 8004654:	4b04      	ldr	r3, [pc, #16]	; (8004668 <DMA1_Channel4_IRQHandler+0x24>)
 8004656:	4798      	blx	r3
	uart1TxTask();
 8004658:	4b04      	ldr	r3, [pc, #16]	; (800466c <DMA1_Channel4_IRQHandler+0x28>)
 800465a:	4798      	blx	r3
}
 800465c:	bf00      	nop
 800465e:	bd80      	pop	{r7, pc}
 8004660:	40020044 	.word	0x40020044
 8004664:	08003929 	.word	0x08003929
 8004668:	080039b1 	.word	0x080039b1
 800466c:	080044e5 	.word	0x080044e5

08004670 <DMA1_Channel5_IRQHandler>:

void DMA1_Channel5_IRQHandler(void)
{
 8004670:	b580      	push	{r7, lr}
 8004672:	b082      	sub	sp, #8
 8004674:	af00      	add	r7, sp, #0
	/* Disable DMA1_Channel2 transfer*/
	//DMA_Cmd(USART3_TX_DMA, DISABLE);
	/*  Clear DMA1_Channel2 Transfer Complete Flag*/
	DMA_ClearFlag(DMA1_FLAG_TC5);
 8004676:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 800467a:	4b07      	ldr	r3, [pc, #28]	; (8004698 <DMA1_Channel5_IRQHandler+0x28>)
 800467c:	4798      	blx	r3

	u1Fifo.rxCurrent+=0;
 800467e:	4b07      	ldr	r3, [pc, #28]	; (800469c <DMA1_Channel5_IRQHandler+0x2c>)
 8004680:	681b      	ldr	r3, [r3, #0]
 8004682:	4a06      	ldr	r2, [pc, #24]	; (800469c <DMA1_Channel5_IRQHandler+0x2c>)
 8004684:	6013      	str	r3, [r2, #0]
	int tempTest1 = DMA_GetCurrDataCounter(USART1_RX_DMA);
 8004686:	4806      	ldr	r0, [pc, #24]	; (80046a0 <DMA1_Channel5_IRQHandler+0x30>)
 8004688:	4b06      	ldr	r3, [pc, #24]	; (80046a4 <DMA1_Channel5_IRQHandler+0x34>)
 800468a:	4798      	blx	r3
 800468c:	4603      	mov	r3, r0
 800468e:	607b      	str	r3, [r7, #4]
			tempTest1 +=0;
	//DMARxDataReceived();
	//uart3TxTask();
}
 8004690:	bf00      	nop
 8004692:	3708      	adds	r7, #8
 8004694:	46bd      	mov	sp, r7
 8004696:	bd80      	pop	{r7, pc}
 8004698:	080039b1 	.word	0x080039b1
 800469c:	200057d8 	.word	0x200057d8
 80046a0:	40020058 	.word	0x40020058
 80046a4:	08003999 	.word	0x08003999

080046a8 <uart2Init>:

//----------------------------------------------------------
void uart2Init(uint32_t baudrate)
{
 80046a8:	b590      	push	{r4, r7, lr}
 80046aa:	b087      	sub	sp, #28
 80046ac:	af00      	add	r7, sp, #0
 80046ae:	6078      	str	r0, [r7, #4]

	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1,ENABLE);
 80046b0:	2101      	movs	r1, #1
 80046b2:	2001      	movs	r0, #1
 80046b4:	4b20      	ldr	r3, [pc, #128]	; (8004738 <uart2Init+0x90>)
 80046b6:	4798      	blx	r3

		USART_DeInit(USART2);
 80046b8:	4820      	ldr	r0, [pc, #128]	; (800473c <uart2Init+0x94>)
 80046ba:	4b21      	ldr	r3, [pc, #132]	; (8004740 <uart2Init+0x98>)
 80046bc:	4798      	blx	r3


		USART_InitTypeDef USART_InitStructure;

		/* Enable USART2,  clocks */
		RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
 80046be:	2101      	movs	r1, #1
 80046c0:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 80046c4:	4b1f      	ldr	r3, [pc, #124]	; (8004744 <uart2Init+0x9c>)
 80046c6:	4798      	blx	r3

		USART_InitStructure.USART_BaudRate = baudrate;
 80046c8:	687b      	ldr	r3, [r7, #4]
 80046ca:	60bb      	str	r3, [r7, #8]
		USART_InitStructure.USART_WordLength = USART_WordLength_8b;
 80046cc:	2300      	movs	r3, #0
 80046ce:	81bb      	strh	r3, [r7, #12]
		USART_InitStructure.USART_StopBits = USART_StopBits_1;
 80046d0:	2300      	movs	r3, #0
 80046d2:	81fb      	strh	r3, [r7, #14]
		USART_InitStructure.USART_Parity = USART_Parity_No;
 80046d4:	2300      	movs	r3, #0
 80046d6:	823b      	strh	r3, [r7, #16]
		USART_InitStructure.USART_HardwareFlowControl
				= USART_HardwareFlowControl_None;
 80046d8:	2300      	movs	r3, #0
 80046da:	82bb      	strh	r3, [r7, #20]
		USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 80046dc:	230c      	movs	r3, #12
 80046de:	827b      	strh	r3, [r7, #18]
		/* Configure USART3 */
		USART_Init(USART2, &USART_InitStructure);
 80046e0:	f107 0308 	add.w	r3, r7, #8
 80046e4:	4619      	mov	r1, r3
 80046e6:	4815      	ldr	r0, [pc, #84]	; (800473c <uart2Init+0x94>)
 80046e8:	4b17      	ldr	r3, [pc, #92]	; (8004748 <uart2Init+0xa0>)
 80046ea:	4798      	blx	r3

		USART_ClearFlag(USART2, USART_FLAG_CTS | USART_FLAG_LBD  |
 80046ec:	f44f 7158 	mov.w	r1, #864	; 0x360
 80046f0:	4812      	ldr	r0, [pc, #72]	; (800473c <uart2Init+0x94>)
 80046f2:	4b16      	ldr	r3, [pc, #88]	; (800474c <uart2Init+0xa4>)
 80046f4:	4798      	blx	r3
							USART_FLAG_TC  | USART_FLAG_RXNE );

		uartRxDMAConfiguration(USART2, USART2_RX_DMA, u2Fifo.rxBuf,
 80046f6:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80046fa:	4a15      	ldr	r2, [pc, #84]	; (8004750 <uart2Init+0xa8>)
 80046fc:	4915      	ldr	r1, [pc, #84]	; (8004754 <uart2Init+0xac>)
 80046fe:	480f      	ldr	r0, [pc, #60]	; (800473c <uart2Init+0x94>)
 8004700:	4c15      	ldr	r4, [pc, #84]	; (8004758 <uart2Init+0xb0>)
 8004702:	47a0      	blx	r4
				UARTRX_FIFO_SIZE);
		USART_DMACmd(USART2, USART_DMAReq_Tx, ENABLE);
 8004704:	2201      	movs	r2, #1
 8004706:	2180      	movs	r1, #128	; 0x80
 8004708:	480c      	ldr	r0, [pc, #48]	; (800473c <uart2Init+0x94>)
 800470a:	4b14      	ldr	r3, [pc, #80]	; (800475c <uart2Init+0xb4>)
 800470c:	4798      	blx	r3
		/* Enable USART_Rx DMA Receive request */
		USART_DMACmd(USART2, USART_DMAReq_Rx, ENABLE);
 800470e:	2201      	movs	r2, #1
 8004710:	2140      	movs	r1, #64	; 0x40
 8004712:	480a      	ldr	r0, [pc, #40]	; (800473c <uart2Init+0x94>)
 8004714:	4b11      	ldr	r3, [pc, #68]	; (800475c <uart2Init+0xb4>)
 8004716:	4798      	blx	r3

		  /* Enable USART_Rx Receive interrupt */
		  //USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);
		    /* Configure USART3 interrupt */
		    NVIC_SetPriority(USART2_RX_DMA_IRQn, 0x07);
 8004718:	2107      	movs	r1, #7
 800471a:	2010      	movs	r0, #16
 800471c:	4b10      	ldr	r3, [pc, #64]	; (8004760 <uart2Init+0xb8>)
 800471e:	4798      	blx	r3
		    NVIC_EnableIRQ(USART2_RX_DMA_IRQn);
 8004720:	2010      	movs	r0, #16
 8004722:	4b10      	ldr	r3, [pc, #64]	; (8004764 <uart2Init+0xbc>)
 8004724:	4798      	blx	r3
		/* Enable the USART3 */
		USART_Cmd(USART2, ENABLE);
 8004726:	2101      	movs	r1, #1
 8004728:	4804      	ldr	r0, [pc, #16]	; (800473c <uart2Init+0x94>)
 800472a:	4b0f      	ldr	r3, [pc, #60]	; (8004768 <uart2Init+0xc0>)
 800472c:	4798      	blx	r3


}
 800472e:	bf00      	nop
 8004730:	371c      	adds	r7, #28
 8004732:	46bd      	mov	sp, r7
 8004734:	bd90      	pop	{r4, r7, pc}
 8004736:	bf00      	nop
 8004738:	08003481 	.word	0x08003481
 800473c:	40004400 	.word	0x40004400
 8004740:	080028c9 	.word	0x080028c9
 8004744:	080034f9 	.word	0x080034f9
 8004748:	08002989 	.word	0x08002989
 800474c:	08002afd 	.word	0x08002afd
 8004750:	20006030 	.word	0x20006030
 8004754:	4002006c 	.word	0x4002006c
 8004758:	080042e5 	.word	0x080042e5
 800475c:	08002ab7 	.word	0x08002ab7
 8004760:	0800421d 	.word	0x0800421d
 8004764:	080041ed 	.word	0x080041ed
 8004768:	08002a79 	.word	0x08002a79

0800476c <uart2GetChar>:

}
//-----------------------------------------------------------------------------------

int uart2GetChar(unsigned char *ch)
{
 800476c:	b590      	push	{r4, r7, lr}
 800476e:	b083      	sub	sp, #12
 8004770:	af00      	add	r7, sp, #0
 8004772:	6078      	str	r0, [r7, #4]

	//int temp = DMA_GetCurrDataCounter(USART1_RX_DMA);
	if (u2Fifo.rxCurrent != (UARTRX_FIFO_SIZE - DMA_GetCurrDataCounter(USART2_RX_DMA)))
 8004774:	4b11      	ldr	r3, [pc, #68]	; (80047bc <uart2GetChar+0x50>)
 8004776:	681c      	ldr	r4, [r3, #0]
 8004778:	4811      	ldr	r0, [pc, #68]	; (80047c0 <uart2GetChar+0x54>)
 800477a:	4b12      	ldr	r3, [pc, #72]	; (80047c4 <uart2GetChar+0x58>)
 800477c:	4798      	blx	r3
 800477e:	4603      	mov	r3, r0
 8004780:	f5c3 6380 	rsb	r3, r3, #1024	; 0x400
 8004784:	429c      	cmp	r4, r3
 8004786:	d013      	beq.n	80047b0 <uart2GetChar+0x44>
	{
		*ch = u2Fifo.rxBuf[u2Fifo.rxCurrent];
 8004788:	4b0c      	ldr	r3, [pc, #48]	; (80047bc <uart2GetChar+0x50>)
 800478a:	681b      	ldr	r3, [r3, #0]
 800478c:	4a0b      	ldr	r2, [pc, #44]	; (80047bc <uart2GetChar+0x50>)
 800478e:	4413      	add	r3, r2
 8004790:	7b1a      	ldrb	r2, [r3, #12]
 8004792:	687b      	ldr	r3, [r7, #4]
 8004794:	701a      	strb	r2, [r3, #0]
		u2Fifo.rxCurrent++;
 8004796:	4b09      	ldr	r3, [pc, #36]	; (80047bc <uart2GetChar+0x50>)
 8004798:	681b      	ldr	r3, [r3, #0]
 800479a:	3301      	adds	r3, #1
 800479c:	4a07      	ldr	r2, [pc, #28]	; (80047bc <uart2GetChar+0x50>)
 800479e:	6013      	str	r3, [r2, #0]
		u2Fifo.rxCurrent &= UARTRX_FIFO_SIZE_MASK;
 80047a0:	4b06      	ldr	r3, [pc, #24]	; (80047bc <uart2GetChar+0x50>)
 80047a2:	681b      	ldr	r3, [r3, #0]
 80047a4:	f3c3 0309 	ubfx	r3, r3, #0, #10
 80047a8:	4a04      	ldr	r2, [pc, #16]	; (80047bc <uart2GetChar+0x50>)
 80047aa:	6013      	str	r3, [r2, #0]
		return 1;
 80047ac:	2301      	movs	r3, #1
 80047ae:	e000      	b.n	80047b2 <uart2GetChar+0x46>
	}
	return 0;
 80047b0:	2300      	movs	r3, #0

}
 80047b2:	4618      	mov	r0, r3
 80047b4:	370c      	adds	r7, #12
 80047b6:	46bd      	mov	sp, r7
 80047b8:	bd90      	pop	{r4, r7, pc}
 80047ba:	bf00      	nop
 80047bc:	20006024 	.word	0x20006024
 80047c0:	4002006c 	.word	0x4002006c
 80047c4:	08003999 	.word	0x08003999

080047c8 <uart2PutChar>:
//-----------------------------------------------------------------------------------
int uart2PutChar(unsigned char ch)
{
 80047c8:	b480      	push	{r7}
 80047ca:	b083      	sub	sp, #12
 80047cc:	af00      	add	r7, sp, #0
 80047ce:	4603      	mov	r3, r0
 80047d0:	71fb      	strb	r3, [r7, #7]
	//	IEC2bits.DMA4IE = 0;
	u2Fifo.txBufB[u2Fifo.txCurrentEnd] = ch;
 80047d2:	4b15      	ldr	r3, [pc, #84]	; (8004828 <uart2PutChar+0x60>)
 80047d4:	689b      	ldr	r3, [r3, #8]
 80047d6:	4a14      	ldr	r2, [pc, #80]	; (8004828 <uart2PutChar+0x60>)
 80047d8:	4413      	add	r3, r2
 80047da:	79fa      	ldrb	r2, [r7, #7]
 80047dc:	f883 244c 	strb.w	r2, [r3, #1100]	; 0x44c
	u2Fifo.txCurrentEnd++;
 80047e0:	4b11      	ldr	r3, [pc, #68]	; (8004828 <uart2PutChar+0x60>)
 80047e2:	689b      	ldr	r3, [r3, #8]
 80047e4:	3301      	adds	r3, #1
 80047e6:	4a10      	ldr	r2, [pc, #64]	; (8004828 <uart2PutChar+0x60>)
 80047e8:	6093      	str	r3, [r2, #8]
	u2Fifo.txCurrentEnd &= UARTTX_FIFOB_SIZE_MASK;
 80047ea:	4b0f      	ldr	r3, [pc, #60]	; (8004828 <uart2PutChar+0x60>)
 80047ec:	689b      	ldr	r3, [r3, #8]
 80047ee:	f3c3 0309 	ubfx	r3, r3, #0, #10
 80047f2:	4a0d      	ldr	r2, [pc, #52]	; (8004828 <uart2PutChar+0x60>)
 80047f4:	6093      	str	r3, [r2, #8]

	if (u2Fifo.txCurrentEnd == u2Fifo.txCurrentStart)
 80047f6:	4b0c      	ldr	r3, [pc, #48]	; (8004828 <uart2PutChar+0x60>)
 80047f8:	689a      	ldr	r2, [r3, #8]
 80047fa:	4b0b      	ldr	r3, [pc, #44]	; (8004828 <uart2PutChar+0x60>)
 80047fc:	685b      	ldr	r3, [r3, #4]
 80047fe:	429a      	cmp	r2, r3
 8004800:	d10c      	bne.n	800481c <uart2PutChar+0x54>
	{
		u2Fifo.txCurrentEnd--;
 8004802:	4b09      	ldr	r3, [pc, #36]	; (8004828 <uart2PutChar+0x60>)
 8004804:	689b      	ldr	r3, [r3, #8]
 8004806:	3b01      	subs	r3, #1
 8004808:	4a07      	ldr	r2, [pc, #28]	; (8004828 <uart2PutChar+0x60>)
 800480a:	6093      	str	r3, [r2, #8]
		u2Fifo.txCurrentEnd &= UARTTX_FIFOB_SIZE_MASK;
 800480c:	4b06      	ldr	r3, [pc, #24]	; (8004828 <uart2PutChar+0x60>)
 800480e:	689b      	ldr	r3, [r3, #8]
 8004810:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8004814:	4a04      	ldr	r2, [pc, #16]	; (8004828 <uart2PutChar+0x60>)
 8004816:	6093      	str	r3, [r2, #8]
		//		IEC2bits.DMA4IE = 1;
		return 0;
 8004818:	2300      	movs	r3, #0
 800481a:	e000      	b.n	800481e <uart2PutChar+0x56>
	}
	//	IEC2bits.DMA4IE = 1;
	return 1;
 800481c:	2301      	movs	r3, #1

}
 800481e:	4618      	mov	r0, r3
 8004820:	370c      	adds	r7, #12
 8004822:	46bd      	mov	sp, r7
 8004824:	bc80      	pop	{r7}
 8004826:	4770      	bx	lr
 8004828:	20006024 	.word	0x20006024

0800482c <uart2TxTask>:
void uart2TxTask()
{
 800482c:	b590      	push	{r4, r7, lr}
 800482e:	b085      	sub	sp, #20
 8004830:	af02      	add	r7, sp, #8

	unsigned int cnt2 = 0;
 8004832:	2300      	movs	r3, #0
 8004834:	607b      	str	r3, [r7, #4]
	// If DMA COMPLITE
	if ((USART2_TX_DMA->CCR & ((uint32_t) 0x00000001)) == 0)
 8004836:	4b23      	ldr	r3, [pc, #140]	; (80048c4 <uart2TxTask+0x98>)
 8004838:	681b      	ldr	r3, [r3, #0]
 800483a:	f003 0301 	and.w	r3, r3, #1
 800483e:	2b00      	cmp	r3, #0
 8004840:	d13b      	bne.n	80048ba <uart2TxTask+0x8e>
	{
		while ((u2Fifo.txCurrentStart != u2Fifo.txCurrentEnd) && (cnt2< UARTTX_FIFO_SIZE))
 8004842:	e01a      	b.n	800487a <uart2TxTask+0x4e>
		{
			u2Fifo.txBuf[cnt2] = u2Fifo.txBufB[u2Fifo.txCurrentStart];
 8004844:	4b20      	ldr	r3, [pc, #128]	; (80048c8 <uart2TxTask+0x9c>)
 8004846:	685b      	ldr	r3, [r3, #4]
 8004848:	4a1f      	ldr	r2, [pc, #124]	; (80048c8 <uart2TxTask+0x9c>)
 800484a:	4413      	add	r3, r2
 800484c:	f893 144c 	ldrb.w	r1, [r3, #1100]	; 0x44c
 8004850:	4a1d      	ldr	r2, [pc, #116]	; (80048c8 <uart2TxTask+0x9c>)
 8004852:	687b      	ldr	r3, [r7, #4]
 8004854:	4413      	add	r3, r2
 8004856:	f203 430c 	addw	r3, r3, #1036	; 0x40c
 800485a:	460a      	mov	r2, r1
 800485c:	701a      	strb	r2, [r3, #0]
			u2Fifo.txCurrentStart++;
 800485e:	4b1a      	ldr	r3, [pc, #104]	; (80048c8 <uart2TxTask+0x9c>)
 8004860:	685b      	ldr	r3, [r3, #4]
 8004862:	3301      	adds	r3, #1
 8004864:	4a18      	ldr	r2, [pc, #96]	; (80048c8 <uart2TxTask+0x9c>)
 8004866:	6053      	str	r3, [r2, #4]
			u2Fifo.txCurrentStart &= UARTTX_FIFOB_SIZE_MASK;
 8004868:	4b17      	ldr	r3, [pc, #92]	; (80048c8 <uart2TxTask+0x9c>)
 800486a:	685b      	ldr	r3, [r3, #4]
 800486c:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8004870:	4a15      	ldr	r2, [pc, #84]	; (80048c8 <uart2TxTask+0x9c>)
 8004872:	6053      	str	r3, [r2, #4]
			cnt2++;
 8004874:	687b      	ldr	r3, [r7, #4]
 8004876:	3301      	adds	r3, #1
 8004878:	607b      	str	r3, [r7, #4]
		while ((u2Fifo.txCurrentStart != u2Fifo.txCurrentEnd) && (cnt2< UARTTX_FIFO_SIZE))
 800487a:	4b13      	ldr	r3, [pc, #76]	; (80048c8 <uart2TxTask+0x9c>)
 800487c:	685a      	ldr	r2, [r3, #4]
 800487e:	4b12      	ldr	r3, [pc, #72]	; (80048c8 <uart2TxTask+0x9c>)
 8004880:	689b      	ldr	r3, [r3, #8]
 8004882:	429a      	cmp	r2, r3
 8004884:	d002      	beq.n	800488c <uart2TxTask+0x60>
 8004886:	687b      	ldr	r3, [r7, #4]
 8004888:	2b3f      	cmp	r3, #63	; 0x3f
 800488a:	d9db      	bls.n	8004844 <uart2TxTask+0x18>
		}
		if (cnt2 > 0)
 800488c:	687b      	ldr	r3, [r7, #4]
 800488e:	2b00      	cmp	r3, #0
 8004890:	d013      	beq.n	80048ba <uart2TxTask+0x8e>
		{

			uartTxDMAConfiguration(USART2, USART2_TX_DMA, u2Fifo.txBuf, cnt2,1);
 8004892:	2301      	movs	r3, #1
 8004894:	9300      	str	r3, [sp, #0]
 8004896:	687b      	ldr	r3, [r7, #4]
 8004898:	4a0c      	ldr	r2, [pc, #48]	; (80048cc <uart2TxTask+0xa0>)
 800489a:	490a      	ldr	r1, [pc, #40]	; (80048c4 <uart2TxTask+0x98>)
 800489c:	480c      	ldr	r0, [pc, #48]	; (80048d0 <uart2TxTask+0xa4>)
 800489e:	4c0d      	ldr	r4, [pc, #52]	; (80048d4 <uart2TxTask+0xa8>)
 80048a0:	47a0      	blx	r4
			DMA_ITConfig(USART2_TX_DMA, DMA_IT_TC, ENABLE);
 80048a2:	2201      	movs	r2, #1
 80048a4:	2102      	movs	r1, #2
 80048a6:	4807      	ldr	r0, [pc, #28]	; (80048c4 <uart2TxTask+0x98>)
 80048a8:	4b0b      	ldr	r3, [pc, #44]	; (80048d8 <uart2TxTask+0xac>)
 80048aa:	4798      	blx	r3
				//}
				/* Enable USART_Tx DMA Tansmit request */
				/* Configure DMA1_Channel_Tx interrupt */
				NVIC_SetPriority(USART2_TX_DMA_IRQn, 0x06);
 80048ac:	2106      	movs	r1, #6
 80048ae:	2011      	movs	r0, #17
 80048b0:	4b0a      	ldr	r3, [pc, #40]	; (80048dc <uart2TxTask+0xb0>)
 80048b2:	4798      	blx	r3
				NVIC_EnableIRQ(USART2_TX_DMA_IRQn);
 80048b4:	2011      	movs	r0, #17
 80048b6:	4b0a      	ldr	r3, [pc, #40]	; (80048e0 <uart2TxTask+0xb4>)
 80048b8:	4798      	blx	r3
		}

	}

}
 80048ba:	bf00      	nop
 80048bc:	370c      	adds	r7, #12
 80048be:	46bd      	mov	sp, r7
 80048c0:	bd90      	pop	{r4, r7, pc}
 80048c2:	bf00      	nop
 80048c4:	40020080 	.word	0x40020080
 80048c8:	20006024 	.word	0x20006024
 80048cc:	20006430 	.word	0x20006430
 80048d0:	40004400 	.word	0x40004400
 80048d4:	08004271 	.word	0x08004271
 80048d8:	0800395f 	.word	0x0800395f
 80048dc:	0800421d 	.word	0x0800421d
 80048e0:	080041ed 	.word	0x080041ed

080048e4 <uart2Read>:
	}
	return 0; //  error here
}
//-----------------------------------------------------------------------------------
unsigned int uart2Read(unsigned char *dsn, unsigned int max_len)
{
 80048e4:	b580      	push	{r7, lr}
 80048e6:	b086      	sub	sp, #24
 80048e8:	af00      	add	r7, sp, #0
 80048ea:	6078      	str	r0, [r7, #4]
 80048ec:	6039      	str	r1, [r7, #0]
	unsigned short cnt = 0, crc = 0;
 80048ee:	2300      	movs	r3, #0
 80048f0:	82fb      	strh	r3, [r7, #22]
 80048f2:	2300      	movs	r3, #0
 80048f4:	82bb      	strh	r3, [r7, #20]
	unsigned char v, *ptr = dsn;
 80048f6:	687b      	ldr	r3, [r7, #4]
 80048f8:	613b      	str	r3, [r7, #16]
		*ptr = v;
		ptr++;
	}
return 32;
*/
	while (uart2GetChar(&v) && (max_len > cnt))
 80048fa:	e00d      	b.n	8004918 <uart2Read+0x34>
	{
		*ptr = v;
 80048fc:	7bfa      	ldrb	r2, [r7, #15]
 80048fe:	693b      	ldr	r3, [r7, #16]
 8004900:	701a      	strb	r2, [r3, #0]
		ptr++;
 8004902:	693b      	ldr	r3, [r7, #16]
 8004904:	3301      	adds	r3, #1
 8004906:	613b      	str	r3, [r7, #16]
		crc += v;
 8004908:	7bfb      	ldrb	r3, [r7, #15]
 800490a:	b29a      	uxth	r2, r3
 800490c:	8abb      	ldrh	r3, [r7, #20]
 800490e:	4413      	add	r3, r2
 8004910:	82bb      	strh	r3, [r7, #20]
		cnt++;
 8004912:	8afb      	ldrh	r3, [r7, #22]
 8004914:	3301      	adds	r3, #1
 8004916:	82fb      	strh	r3, [r7, #22]
	while (uart2GetChar(&v) && (max_len > cnt))
 8004918:	f107 030f 	add.w	r3, r7, #15
 800491c:	4618      	mov	r0, r3
 800491e:	4b07      	ldr	r3, [pc, #28]	; (800493c <uart2Read+0x58>)
 8004920:	4798      	blx	r3
 8004922:	4603      	mov	r3, r0
 8004924:	2b00      	cmp	r3, #0
 8004926:	d003      	beq.n	8004930 <uart2Read+0x4c>
 8004928:	8afb      	ldrh	r3, [r7, #22]
 800492a:	683a      	ldr	r2, [r7, #0]
 800492c:	429a      	cmp	r2, r3
 800492e:	d8e5      	bhi.n	80048fc <uart2Read+0x18>
	}
	return cnt; //  error here
 8004930:	8afb      	ldrh	r3, [r7, #22]
}
 8004932:	4618      	mov	r0, r3
 8004934:	3718      	adds	r7, #24
 8004936:	46bd      	mov	sp, r7
 8004938:	bd80      	pop	{r7, pc}
 800493a:	bf00      	nop
 800493c:	0800476d 	.word	0x0800476d

08004940 <uart2Write>:
	rezult = uart2PutChar(0x55);
	rezult = uart2PutChar(0x03);
	uart2TxTask();
}
void uart2Write(unsigned char *src, unsigned int len)
{
 8004940:	b580      	push	{r7, lr}
 8004942:	b084      	sub	sp, #16
 8004944:	af00      	add	r7, sp, #0
 8004946:	6078      	str	r0, [r7, #4]
 8004948:	6039      	str	r1, [r7, #0]
	unsigned char ch;
	unsigned int rezult;
	if (len == 0)
 800494a:	683b      	ldr	r3, [r7, #0]
 800494c:	2b00      	cmp	r3, #0
 800494e:	d014      	beq.n	800497a <uart2Write+0x3a>
		return;
	while (len--)
 8004950:	e00b      	b.n	800496a <uart2Write+0x2a>
	{
		ch = *src;
 8004952:	687b      	ldr	r3, [r7, #4]
 8004954:	781b      	ldrb	r3, [r3, #0]
 8004956:	73fb      	strb	r3, [r7, #15]
		rezult = uart2PutChar(ch);
 8004958:	7bfb      	ldrb	r3, [r7, #15]
 800495a:	4618      	mov	r0, r3
 800495c:	4b09      	ldr	r3, [pc, #36]	; (8004984 <uart2Write+0x44>)
 800495e:	4798      	blx	r3
 8004960:	4603      	mov	r3, r0
 8004962:	60bb      	str	r3, [r7, #8]
		src++;
 8004964:	687b      	ldr	r3, [r7, #4]
 8004966:	3301      	adds	r3, #1
 8004968:	607b      	str	r3, [r7, #4]
	while (len--)
 800496a:	683b      	ldr	r3, [r7, #0]
 800496c:	1e5a      	subs	r2, r3, #1
 800496e:	603a      	str	r2, [r7, #0]
 8004970:	2b00      	cmp	r3, #0
 8004972:	d1ee      	bne.n	8004952 <uart2Write+0x12>
	}
	uart2TxTask();
 8004974:	4b04      	ldr	r3, [pc, #16]	; (8004988 <uart2Write+0x48>)
 8004976:	4798      	blx	r3
 8004978:	e000      	b.n	800497c <uart2Write+0x3c>
		return;
 800497a:	bf00      	nop
}
 800497c:	3710      	adds	r7, #16
 800497e:	46bd      	mov	sp, r7
 8004980:	bd80      	pop	{r7, pc}
 8004982:	bf00      	nop
 8004984:	080047c9 	.word	0x080047c9
 8004988:	0800482d 	.word	0x0800482d

0800498c <DMA1_Channel7_IRQHandler>:

//UART 2 DMA INTERRUPT
void DMA1_Channel7_IRQHandler(void)
{
 800498c:	b580      	push	{r7, lr}
 800498e:	af00      	add	r7, sp, #0
	/* Disable DMA1_Channel6 transfer*/
	DMA_Cmd(USART2_TX_DMA, DISABLE);
 8004990:	2100      	movs	r1, #0
 8004992:	4807      	ldr	r0, [pc, #28]	; (80049b0 <DMA1_Channel7_IRQHandler+0x24>)
 8004994:	4b07      	ldr	r3, [pc, #28]	; (80049b4 <DMA1_Channel7_IRQHandler+0x28>)
 8004996:	4798      	blx	r3

	/*  Clear DMA1_Channel6 Transfer Complete Flag*/
	DMA_ClearITPendingBit(DMA1_FLAG_TC7);
 8004998:	f04f 7000 	mov.w	r0, #33554432	; 0x2000000
 800499c:	4b06      	ldr	r3, [pc, #24]	; (80049b8 <DMA1_Channel7_IRQHandler+0x2c>)
 800499e:	4798      	blx	r3
	DMA_ClearFlag(DMA1_FLAG_TC7);
 80049a0:	f04f 7000 	mov.w	r0, #33554432	; 0x2000000
 80049a4:	4b05      	ldr	r3, [pc, #20]	; (80049bc <DMA1_Channel7_IRQHandler+0x30>)
 80049a6:	4798      	blx	r3
	uart2TxTask();
 80049a8:	4b05      	ldr	r3, [pc, #20]	; (80049c0 <DMA1_Channel7_IRQHandler+0x34>)
 80049aa:	4798      	blx	r3
}
 80049ac:	bf00      	nop
 80049ae:	bd80      	pop	{r7, pc}
 80049b0:	40020080 	.word	0x40020080
 80049b4:	08003929 	.word	0x08003929
 80049b8:	080039e5 	.word	0x080039e5
 80049bc:	080039b1 	.word	0x080039b1
 80049c0:	0800482d 	.word	0x0800482d

080049c4 <DMA1_Channel6_IRQHandler>:

void DMA1_Channel6_IRQHandler(void)
{
 80049c4:	b580      	push	{r7, lr}
 80049c6:	b082      	sub	sp, #8
 80049c8:	af00      	add	r7, sp, #0
	/* Disable DMA1_Channel7 transfer*/
	//DMA_Cmd(USART3_TX_DMA, DISABLE);
	/*  Clear DMA1_Channel7 Transfer Complete Flag*/
	DMA_ClearFlag(DMA1_FLAG_TC6);
 80049ca:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 80049ce:	4b07      	ldr	r3, [pc, #28]	; (80049ec <DMA1_Channel6_IRQHandler+0x28>)
 80049d0:	4798      	blx	r3

	u2Fifo.rxCurrent+=0;
 80049d2:	4b07      	ldr	r3, [pc, #28]	; (80049f0 <DMA1_Channel6_IRQHandler+0x2c>)
 80049d4:	681b      	ldr	r3, [r3, #0]
 80049d6:	4a06      	ldr	r2, [pc, #24]	; (80049f0 <DMA1_Channel6_IRQHandler+0x2c>)
 80049d8:	6013      	str	r3, [r2, #0]
	int tempTest2 = DMA_GetCurrDataCounter(USART2_RX_DMA);
 80049da:	4806      	ldr	r0, [pc, #24]	; (80049f4 <DMA1_Channel6_IRQHandler+0x30>)
 80049dc:	4b06      	ldr	r3, [pc, #24]	; (80049f8 <DMA1_Channel6_IRQHandler+0x34>)
 80049de:	4798      	blx	r3
 80049e0:	4603      	mov	r3, r0
 80049e2:	607b      	str	r3, [r7, #4]
			tempTest2 +=0;
	//DMARxDataReceived();
	//uart2TxTask();
}
 80049e4:	bf00      	nop
 80049e6:	3708      	adds	r7, #8
 80049e8:	46bd      	mov	sp, r7
 80049ea:	bd80      	pop	{r7, pc}
 80049ec:	080039b1 	.word	0x080039b1
 80049f0:	20006024 	.word	0x20006024
 80049f4:	4002006c 	.word	0x4002006c
 80049f8:	08003999 	.word	0x08003999

080049fc <uart3Init>:

//------------------------------------------------------------------------------------
void uart3Init(uint32_t baudrate)
{
 80049fc:	b590      	push	{r4, r7, lr}
 80049fe:	b087      	sub	sp, #28
 8004a00:	af00      	add	r7, sp, #0
 8004a02:	6078      	str	r0, [r7, #4]

	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1,ENABLE);
 8004a04:	2101      	movs	r1, #1
 8004a06:	2001      	movs	r0, #1
 8004a08:	4b26      	ldr	r3, [pc, #152]	; (8004aa4 <uart3Init+0xa8>)
 8004a0a:	4798      	blx	r3

	USART_DeInit(USART3);
 8004a0c:	4826      	ldr	r0, [pc, #152]	; (8004aa8 <uart3Init+0xac>)
 8004a0e:	4b27      	ldr	r3, [pc, #156]	; (8004aac <uart3Init+0xb0>)
 8004a10:	4798      	blx	r3


	USART_InitTypeDef USART_InitStructure;

	/* Enable AFIO,  clocks */
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
 8004a12:	2101      	movs	r1, #1
 8004a14:	2001      	movs	r0, #1
 8004a16:	4b26      	ldr	r3, [pc, #152]	; (8004ab0 <uart3Init+0xb4>)
 8004a18:	4798      	blx	r3

	/* Enable GPIO clocks */
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC|RCC_APB2Periph_GPIOA
 8004a1a:	2101      	movs	r1, #1
 8004a1c:	201c      	movs	r0, #28
 8004a1e:	4b24      	ldr	r3, [pc, #144]	; (8004ab0 <uart3Init+0xb4>)
 8004a20:	4798      	blx	r3
	|RCC_APB2Periph_GPIOB, ENABLE);

	/* Enable USART3,  clocks */
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);
 8004a22:	2101      	movs	r1, #1
 8004a24:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 8004a28:	4b22      	ldr	r3, [pc, #136]	; (8004ab4 <uart3Init+0xb8>)
 8004a2a:	4798      	blx	r3
    GPIO_PinRemapConfig(GPIO_PartialRemap_USART3,ENABLE);
 8004a2c:	2101      	movs	r1, #1
 8004a2e:	4822      	ldr	r0, [pc, #136]	; (8004ab8 <uart3Init+0xbc>)
 8004a30:	4b22      	ldr	r3, [pc, #136]	; (8004abc <uart3Init+0xc0>)
 8004a32:	4798      	blx	r3

	USART_InitStructure.USART_BaudRate = baudrate;
 8004a34:	687b      	ldr	r3, [r7, #4]
 8004a36:	60bb      	str	r3, [r7, #8]
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
 8004a38:	2300      	movs	r3, #0
 8004a3a:	81bb      	strh	r3, [r7, #12]
	USART_InitStructure.USART_StopBits = USART_StopBits_1;
 8004a3c:	2300      	movs	r3, #0
 8004a3e:	81fb      	strh	r3, [r7, #14]
	USART_InitStructure.USART_Parity = USART_Parity_No;
 8004a40:	2300      	movs	r3, #0
 8004a42:	823b      	strh	r3, [r7, #16]
	USART_InitStructure.USART_HardwareFlowControl
			= USART_HardwareFlowControl_None;
 8004a44:	2300      	movs	r3, #0
 8004a46:	82bb      	strh	r3, [r7, #20]
	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 8004a48:	230c      	movs	r3, #12
 8004a4a:	827b      	strh	r3, [r7, #18]
	/* Configure USART3 */
	USART_Init(USART3, &USART_InitStructure);
 8004a4c:	f107 0308 	add.w	r3, r7, #8
 8004a50:	4619      	mov	r1, r3
 8004a52:	4815      	ldr	r0, [pc, #84]	; (8004aa8 <uart3Init+0xac>)
 8004a54:	4b1a      	ldr	r3, [pc, #104]	; (8004ac0 <uart3Init+0xc4>)
 8004a56:	4798      	blx	r3

	USART_ClearFlag(USART3, USART_FLAG_CTS | USART_FLAG_LBD  |
 8004a58:	f44f 7158 	mov.w	r1, #864	; 0x360
 8004a5c:	4812      	ldr	r0, [pc, #72]	; (8004aa8 <uart3Init+0xac>)
 8004a5e:	4b19      	ldr	r3, [pc, #100]	; (8004ac4 <uart3Init+0xc8>)
 8004a60:	4798      	blx	r3
						USART_FLAG_TC  | USART_FLAG_RXNE );

	uartRxDMAConfiguration(USART3, USART3_RX_DMA, u3Fifo.rxBuf,UARTRX_FIFO_SIZE);
 8004a62:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8004a66:	4a18      	ldr	r2, [pc, #96]	; (8004ac8 <uart3Init+0xcc>)
 8004a68:	4918      	ldr	r1, [pc, #96]	; (8004acc <uart3Init+0xd0>)
 8004a6a:	480f      	ldr	r0, [pc, #60]	; (8004aa8 <uart3Init+0xac>)
 8004a6c:	4c18      	ldr	r4, [pc, #96]	; (8004ad0 <uart3Init+0xd4>)
 8004a6e:	47a0      	blx	r4
	USART_DMACmd(USART3, USART_DMAReq_Tx, ENABLE);
 8004a70:	2201      	movs	r2, #1
 8004a72:	2180      	movs	r1, #128	; 0x80
 8004a74:	480c      	ldr	r0, [pc, #48]	; (8004aa8 <uart3Init+0xac>)
 8004a76:	4b17      	ldr	r3, [pc, #92]	; (8004ad4 <uart3Init+0xd8>)
 8004a78:	4798      	blx	r3
	/* Enable USART_Rx DMA Receive request */
	USART_DMACmd(USART3, USART_DMAReq_Rx, ENABLE);
 8004a7a:	2201      	movs	r2, #1
 8004a7c:	2140      	movs	r1, #64	; 0x40
 8004a7e:	480a      	ldr	r0, [pc, #40]	; (8004aa8 <uart3Init+0xac>)
 8004a80:	4b14      	ldr	r3, [pc, #80]	; (8004ad4 <uart3Init+0xd8>)
 8004a82:	4798      	blx	r3

	  /* Enable USART_Rx Receive interrupt */
	  //USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);
	    /* Configure USART3 interrupt */
	    NVIC_SetPriority(USART3_RX_DMA_IRQn, 0x01);
 8004a84:	2101      	movs	r1, #1
 8004a86:	200d      	movs	r0, #13
 8004a88:	4b13      	ldr	r3, [pc, #76]	; (8004ad8 <uart3Init+0xdc>)
 8004a8a:	4798      	blx	r3
	    NVIC_EnableIRQ(USART3_RX_DMA_IRQn);
 8004a8c:	200d      	movs	r0, #13
 8004a8e:	4b13      	ldr	r3, [pc, #76]	; (8004adc <uart3Init+0xe0>)
 8004a90:	4798      	blx	r3
	/* Enable the USART3 */
	USART_Cmd(USART3, ENABLE);
 8004a92:	2101      	movs	r1, #1
 8004a94:	4804      	ldr	r0, [pc, #16]	; (8004aa8 <uart3Init+0xac>)
 8004a96:	4b12      	ldr	r3, [pc, #72]	; (8004ae0 <uart3Init+0xe4>)
 8004a98:	4798      	blx	r3
}
 8004a9a:	bf00      	nop
 8004a9c:	371c      	adds	r7, #28
 8004a9e:	46bd      	mov	sp, r7
 8004aa0:	bd90      	pop	{r4, r7, pc}
 8004aa2:	bf00      	nop
 8004aa4:	08003481 	.word	0x08003481
 8004aa8:	40004800 	.word	0x40004800
 8004aac:	080028c9 	.word	0x080028c9
 8004ab0:	080034bd 	.word	0x080034bd
 8004ab4:	080034f9 	.word	0x080034f9
 8004ab8:	00140010 	.word	0x00140010
 8004abc:	08002fa5 	.word	0x08002fa5
 8004ac0:	08002989 	.word	0x08002989
 8004ac4:	08002afd 	.word	0x08002afd
 8004ac8:	2000687c 	.word	0x2000687c
 8004acc:	40020030 	.word	0x40020030
 8004ad0:	080042e5 	.word	0x080042e5
 8004ad4:	08002ab7 	.word	0x08002ab7
 8004ad8:	0800421d 	.word	0x0800421d
 8004adc:	080041ed 	.word	0x080041ed
 8004ae0:	08002a79 	.word	0x08002a79

08004ae4 <uart3GetChar>:

int uart3GetChar(unsigned char *ch3)
{
 8004ae4:	b590      	push	{r4, r7, lr}
 8004ae6:	b085      	sub	sp, #20
 8004ae8:	af00      	add	r7, sp, #0
 8004aea:	6078      	str	r0, [r7, #4]
	int temp = DMA_GetCurrDataCounter(USART3_RX_DMA);
 8004aec:	4813      	ldr	r0, [pc, #76]	; (8004b3c <uart3GetChar+0x58>)
 8004aee:	4b14      	ldr	r3, [pc, #80]	; (8004b40 <uart3GetChar+0x5c>)
 8004af0:	4798      	blx	r3
 8004af2:	4603      	mov	r3, r0
 8004af4:	60fb      	str	r3, [r7, #12]
	if (u3Fifo.rxCurrent != (UARTRX_FIFO_SIZE - DMA_GetCurrDataCounter(USART3_RX_DMA)))
 8004af6:	4b13      	ldr	r3, [pc, #76]	; (8004b44 <uart3GetChar+0x60>)
 8004af8:	681c      	ldr	r4, [r3, #0]
 8004afa:	4810      	ldr	r0, [pc, #64]	; (8004b3c <uart3GetChar+0x58>)
 8004afc:	4b10      	ldr	r3, [pc, #64]	; (8004b40 <uart3GetChar+0x5c>)
 8004afe:	4798      	blx	r3
 8004b00:	4603      	mov	r3, r0
 8004b02:	f5c3 6380 	rsb	r3, r3, #1024	; 0x400
 8004b06:	429c      	cmp	r4, r3
 8004b08:	d013      	beq.n	8004b32 <uart3GetChar+0x4e>
	{
		*ch3 = u3Fifo.rxBuf[u3Fifo.rxCurrent];
 8004b0a:	4b0e      	ldr	r3, [pc, #56]	; (8004b44 <uart3GetChar+0x60>)
 8004b0c:	681b      	ldr	r3, [r3, #0]
 8004b0e:	4a0d      	ldr	r2, [pc, #52]	; (8004b44 <uart3GetChar+0x60>)
 8004b10:	4413      	add	r3, r2
 8004b12:	7b1a      	ldrb	r2, [r3, #12]
 8004b14:	687b      	ldr	r3, [r7, #4]
 8004b16:	701a      	strb	r2, [r3, #0]
		u3Fifo.rxCurrent++;
 8004b18:	4b0a      	ldr	r3, [pc, #40]	; (8004b44 <uart3GetChar+0x60>)
 8004b1a:	681b      	ldr	r3, [r3, #0]
 8004b1c:	3301      	adds	r3, #1
 8004b1e:	4a09      	ldr	r2, [pc, #36]	; (8004b44 <uart3GetChar+0x60>)
 8004b20:	6013      	str	r3, [r2, #0]
		u3Fifo.rxCurrent &= UARTRX_FIFO_SIZE_MASK;
 8004b22:	4b08      	ldr	r3, [pc, #32]	; (8004b44 <uart3GetChar+0x60>)
 8004b24:	681b      	ldr	r3, [r3, #0]
 8004b26:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8004b2a:	4a06      	ldr	r2, [pc, #24]	; (8004b44 <uart3GetChar+0x60>)
 8004b2c:	6013      	str	r3, [r2, #0]
		return 1;
 8004b2e:	2301      	movs	r3, #1
 8004b30:	e000      	b.n	8004b34 <uart3GetChar+0x50>
	}
	return 0;
 8004b32:	2300      	movs	r3, #0
}
 8004b34:	4618      	mov	r0, r3
 8004b36:	3714      	adds	r7, #20
 8004b38:	46bd      	mov	sp, r7
 8004b3a:	bd90      	pop	{r4, r7, pc}
 8004b3c:	40020030 	.word	0x40020030
 8004b40:	08003999 	.word	0x08003999
 8004b44:	20006870 	.word	0x20006870

08004b48 <uart3PutChar>:

unsigned int uart3PutChar(unsigned char ch)
{
 8004b48:	b480      	push	{r7}
 8004b4a:	b083      	sub	sp, #12
 8004b4c:	af00      	add	r7, sp, #0
 8004b4e:	4603      	mov	r3, r0
 8004b50:	71fb      	strb	r3, [r7, #7]

	//	IEC2bits.DMA4IE = 0;
	u3Fifo.txBufB[u3Fifo.txCurrentEnd] = ch;
 8004b52:	4b15      	ldr	r3, [pc, #84]	; (8004ba8 <uart3PutChar+0x60>)
 8004b54:	689b      	ldr	r3, [r3, #8]
 8004b56:	4a14      	ldr	r2, [pc, #80]	; (8004ba8 <uart3PutChar+0x60>)
 8004b58:	4413      	add	r3, r2
 8004b5a:	79fa      	ldrb	r2, [r7, #7]
 8004b5c:	f883 244c 	strb.w	r2, [r3, #1100]	; 0x44c
	u3Fifo.txCurrentEnd++;
 8004b60:	4b11      	ldr	r3, [pc, #68]	; (8004ba8 <uart3PutChar+0x60>)
 8004b62:	689b      	ldr	r3, [r3, #8]
 8004b64:	3301      	adds	r3, #1
 8004b66:	4a10      	ldr	r2, [pc, #64]	; (8004ba8 <uart3PutChar+0x60>)
 8004b68:	6093      	str	r3, [r2, #8]
	u3Fifo.txCurrentEnd &= UARTTX_FIFOB_SIZE_MASK;
 8004b6a:	4b0f      	ldr	r3, [pc, #60]	; (8004ba8 <uart3PutChar+0x60>)
 8004b6c:	689b      	ldr	r3, [r3, #8]
 8004b6e:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8004b72:	4a0d      	ldr	r2, [pc, #52]	; (8004ba8 <uart3PutChar+0x60>)
 8004b74:	6093      	str	r3, [r2, #8]

	if (u3Fifo.txCurrentEnd == u3Fifo.txCurrentStart)
 8004b76:	4b0c      	ldr	r3, [pc, #48]	; (8004ba8 <uart3PutChar+0x60>)
 8004b78:	689a      	ldr	r2, [r3, #8]
 8004b7a:	4b0b      	ldr	r3, [pc, #44]	; (8004ba8 <uart3PutChar+0x60>)
 8004b7c:	685b      	ldr	r3, [r3, #4]
 8004b7e:	429a      	cmp	r2, r3
 8004b80:	d10c      	bne.n	8004b9c <uart3PutChar+0x54>
	{
		u3Fifo.txCurrentEnd--;
 8004b82:	4b09      	ldr	r3, [pc, #36]	; (8004ba8 <uart3PutChar+0x60>)
 8004b84:	689b      	ldr	r3, [r3, #8]
 8004b86:	3b01      	subs	r3, #1
 8004b88:	4a07      	ldr	r2, [pc, #28]	; (8004ba8 <uart3PutChar+0x60>)
 8004b8a:	6093      	str	r3, [r2, #8]
		u3Fifo.txCurrentEnd &= UARTTX_FIFOB_SIZE_MASK;
 8004b8c:	4b06      	ldr	r3, [pc, #24]	; (8004ba8 <uart3PutChar+0x60>)
 8004b8e:	689b      	ldr	r3, [r3, #8]
 8004b90:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8004b94:	4a04      	ldr	r2, [pc, #16]	; (8004ba8 <uart3PutChar+0x60>)
 8004b96:	6093      	str	r3, [r2, #8]
		//		IEC2bits.DMA4IE = 1;
		return 0;
 8004b98:	2300      	movs	r3, #0
 8004b9a:	e000      	b.n	8004b9e <uart3PutChar+0x56>
	}
	//	IEC2bits.DMA4IE = 1;
	return 1;
 8004b9c:	2301      	movs	r3, #1
}
 8004b9e:	4618      	mov	r0, r3
 8004ba0:	370c      	adds	r7, #12
 8004ba2:	46bd      	mov	sp, r7
 8004ba4:	bc80      	pop	{r7}
 8004ba6:	4770      	bx	lr
 8004ba8:	20006870 	.word	0x20006870

08004bac <uart3TxTask>:

void uart3TxTask()
{
 8004bac:	b590      	push	{r4, r7, lr}
 8004bae:	b085      	sub	sp, #20
 8004bb0:	af02      	add	r7, sp, #8
	unsigned int cnt1 = 0;
 8004bb2:	2300      	movs	r3, #0
 8004bb4:	607b      	str	r3, [r7, #4]
	// If DMA COMPLITE


	if ((USART3_TX_DMA->CCR & ((uint32_t) 0x00000001)) == 0)
 8004bb6:	4b26      	ldr	r3, [pc, #152]	; (8004c50 <uart3TxTask+0xa4>)
 8004bb8:	681b      	ldr	r3, [r3, #0]
 8004bba:	f003 0301 	and.w	r3, r3, #1
 8004bbe:	2b00      	cmp	r3, #0
 8004bc0:	d142      	bne.n	8004c48 <uart3TxTask+0x9c>
	{
		while ((u3Fifo.txCurrentStart != u3Fifo.txCurrentEnd) && (cnt1< UARTTX_FIFO_SIZE))
 8004bc2:	e021      	b.n	8004c08 <uart3TxTask+0x5c>
		{
			u3Fifo.txBuf[cnt1] = u3Fifo.txBufB[u3Fifo.txCurrentStart];
 8004bc4:	4b23      	ldr	r3, [pc, #140]	; (8004c54 <uart3TxTask+0xa8>)
 8004bc6:	685b      	ldr	r3, [r3, #4]
 8004bc8:	4a22      	ldr	r2, [pc, #136]	; (8004c54 <uart3TxTask+0xa8>)
 8004bca:	4413      	add	r3, r2
 8004bcc:	f893 144c 	ldrb.w	r1, [r3, #1100]	; 0x44c
 8004bd0:	4a20      	ldr	r2, [pc, #128]	; (8004c54 <uart3TxTask+0xa8>)
 8004bd2:	687b      	ldr	r3, [r7, #4]
 8004bd4:	4413      	add	r3, r2
 8004bd6:	f203 430c 	addw	r3, r3, #1036	; 0x40c
 8004bda:	460a      	mov	r2, r1
 8004bdc:	701a      	strb	r2, [r3, #0]
			u3Fifo.txBufB[u3Fifo.txCurrentStart] = 0;
 8004bde:	4b1d      	ldr	r3, [pc, #116]	; (8004c54 <uart3TxTask+0xa8>)
 8004be0:	685b      	ldr	r3, [r3, #4]
 8004be2:	4a1c      	ldr	r2, [pc, #112]	; (8004c54 <uart3TxTask+0xa8>)
 8004be4:	4413      	add	r3, r2
 8004be6:	2200      	movs	r2, #0
 8004be8:	f883 244c 	strb.w	r2, [r3, #1100]	; 0x44c
			u3Fifo.txCurrentStart++;
 8004bec:	4b19      	ldr	r3, [pc, #100]	; (8004c54 <uart3TxTask+0xa8>)
 8004bee:	685b      	ldr	r3, [r3, #4]
 8004bf0:	3301      	adds	r3, #1
 8004bf2:	4a18      	ldr	r2, [pc, #96]	; (8004c54 <uart3TxTask+0xa8>)
 8004bf4:	6053      	str	r3, [r2, #4]
			u3Fifo.txCurrentStart &= UARTTX_FIFOB_SIZE_MASK;
 8004bf6:	4b17      	ldr	r3, [pc, #92]	; (8004c54 <uart3TxTask+0xa8>)
 8004bf8:	685b      	ldr	r3, [r3, #4]
 8004bfa:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8004bfe:	4a15      	ldr	r2, [pc, #84]	; (8004c54 <uart3TxTask+0xa8>)
 8004c00:	6053      	str	r3, [r2, #4]
			cnt1++;
 8004c02:	687b      	ldr	r3, [r7, #4]
 8004c04:	3301      	adds	r3, #1
 8004c06:	607b      	str	r3, [r7, #4]
		while ((u3Fifo.txCurrentStart != u3Fifo.txCurrentEnd) && (cnt1< UARTTX_FIFO_SIZE))
 8004c08:	4b12      	ldr	r3, [pc, #72]	; (8004c54 <uart3TxTask+0xa8>)
 8004c0a:	685a      	ldr	r2, [r3, #4]
 8004c0c:	4b11      	ldr	r3, [pc, #68]	; (8004c54 <uart3TxTask+0xa8>)
 8004c0e:	689b      	ldr	r3, [r3, #8]
 8004c10:	429a      	cmp	r2, r3
 8004c12:	d002      	beq.n	8004c1a <uart3TxTask+0x6e>
 8004c14:	687b      	ldr	r3, [r7, #4]
 8004c16:	2b3f      	cmp	r3, #63	; 0x3f
 8004c18:	d9d4      	bls.n	8004bc4 <uart3TxTask+0x18>
		}


		if (cnt1 > 0)
 8004c1a:	687b      	ldr	r3, [r7, #4]
 8004c1c:	2b00      	cmp	r3, #0
 8004c1e:	d013      	beq.n	8004c48 <uart3TxTask+0x9c>
		{
			uartTxDMAConfiguration(USART3, USART3_TX_DMA, u3Fifo.txBuf, cnt1,1);
 8004c20:	2301      	movs	r3, #1
 8004c22:	9300      	str	r3, [sp, #0]
 8004c24:	687b      	ldr	r3, [r7, #4]
 8004c26:	4a0c      	ldr	r2, [pc, #48]	; (8004c58 <uart3TxTask+0xac>)
 8004c28:	4909      	ldr	r1, [pc, #36]	; (8004c50 <uart3TxTask+0xa4>)
 8004c2a:	480c      	ldr	r0, [pc, #48]	; (8004c5c <uart3TxTask+0xb0>)
 8004c2c:	4c0c      	ldr	r4, [pc, #48]	; (8004c60 <uart3TxTask+0xb4>)
 8004c2e:	47a0      	blx	r4
			DMA_ITConfig(USART3_TX_DMA, DMA_IT_TC, ENABLE);
 8004c30:	2201      	movs	r2, #1
 8004c32:	2102      	movs	r1, #2
 8004c34:	4806      	ldr	r0, [pc, #24]	; (8004c50 <uart3TxTask+0xa4>)
 8004c36:	4b0b      	ldr	r3, [pc, #44]	; (8004c64 <uart3TxTask+0xb8>)
 8004c38:	4798      	blx	r3
				//}
				/* Enable USART_Tx DMA Tansmit request */
				/* Configure DMA1_Channel_Tx interrupt */
				NVIC_SetPriority(USART3_TX_DMA_IRQn, 0x03);
 8004c3a:	2103      	movs	r1, #3
 8004c3c:	200c      	movs	r0, #12
 8004c3e:	4b0a      	ldr	r3, [pc, #40]	; (8004c68 <uart3TxTask+0xbc>)
 8004c40:	4798      	blx	r3
				NVIC_EnableIRQ(USART3_TX_DMA_IRQn);
 8004c42:	200c      	movs	r0, #12
 8004c44:	4b09      	ldr	r3, [pc, #36]	; (8004c6c <uart3TxTask+0xc0>)
 8004c46:	4798      	blx	r3


		}
	}
}
 8004c48:	bf00      	nop
 8004c4a:	370c      	adds	r7, #12
 8004c4c:	46bd      	mov	sp, r7
 8004c4e:	bd90      	pop	{r4, r7, pc}
 8004c50:	4002001c 	.word	0x4002001c
 8004c54:	20006870 	.word	0x20006870
 8004c58:	20006c7c 	.word	0x20006c7c
 8004c5c:	40004800 	.word	0x40004800
 8004c60:	08004271 	.word	0x08004271
 8004c64:	0800395f 	.word	0x0800395f
 8004c68:	0800421d 	.word	0x0800421d
 8004c6c:	080041ed 	.word	0x080041ed

08004c70 <uart3Read>:

unsigned int uart3Read(unsigned char *dsn3, unsigned int max_len3)
{
 8004c70:	b580      	push	{r7, lr}
 8004c72:	b086      	sub	sp, #24
 8004c74:	af00      	add	r7, sp, #0
 8004c76:	6078      	str	r0, [r7, #4]
 8004c78:	6039      	str	r1, [r7, #0]
	unsigned short cntr3 = 0, crc3 = 0;
 8004c7a:	2300      	movs	r3, #0
 8004c7c:	82fb      	strh	r3, [r7, #22]
 8004c7e:	2300      	movs	r3, #0
 8004c80:	82bb      	strh	r3, [r7, #20]
	unsigned char v3;
	unsigned char *ptr3 = dsn3;
 8004c82:	687b      	ldr	r3, [r7, #4]
 8004c84:	613b      	str	r3, [r7, #16]

	while (uart3GetChar(&v3) && (max_len3 > cntr3))
 8004c86:	e00d      	b.n	8004ca4 <uart3Read+0x34>
	{
		*ptr3 = v3;
 8004c88:	7bfa      	ldrb	r2, [r7, #15]
 8004c8a:	693b      	ldr	r3, [r7, #16]
 8004c8c:	701a      	strb	r2, [r3, #0]
		ptr3++;
 8004c8e:	693b      	ldr	r3, [r7, #16]
 8004c90:	3301      	adds	r3, #1
 8004c92:	613b      	str	r3, [r7, #16]
		crc3 += v3;
 8004c94:	7bfb      	ldrb	r3, [r7, #15]
 8004c96:	b29a      	uxth	r2, r3
 8004c98:	8abb      	ldrh	r3, [r7, #20]
 8004c9a:	4413      	add	r3, r2
 8004c9c:	82bb      	strh	r3, [r7, #20]
		cntr3++;
 8004c9e:	8afb      	ldrh	r3, [r7, #22]
 8004ca0:	3301      	adds	r3, #1
 8004ca2:	82fb      	strh	r3, [r7, #22]
	while (uart3GetChar(&v3) && (max_len3 > cntr3))
 8004ca4:	f107 030f 	add.w	r3, r7, #15
 8004ca8:	4618      	mov	r0, r3
 8004caa:	4b07      	ldr	r3, [pc, #28]	; (8004cc8 <uart3Read+0x58>)
 8004cac:	4798      	blx	r3
 8004cae:	4603      	mov	r3, r0
 8004cb0:	2b00      	cmp	r3, #0
 8004cb2:	d003      	beq.n	8004cbc <uart3Read+0x4c>
 8004cb4:	8afb      	ldrh	r3, [r7, #22]
 8004cb6:	683a      	ldr	r2, [r7, #0]
 8004cb8:	429a      	cmp	r2, r3
 8004cba:	d8e5      	bhi.n	8004c88 <uart3Read+0x18>
	}
	return cntr3; //  error here
 8004cbc:	8afb      	ldrh	r3, [r7, #22]
}
 8004cbe:	4618      	mov	r0, r3
 8004cc0:	3718      	adds	r7, #24
 8004cc2:	46bd      	mov	sp, r7
 8004cc4:	bd80      	pop	{r7, pc}
 8004cc6:	bf00      	nop
 8004cc8:	08004ae5 	.word	0x08004ae5

08004ccc <uart3Write>:

void uart3Write(unsigned char *src3, unsigned int len3)
{
 8004ccc:	b580      	push	{r7, lr}
 8004cce:	b084      	sub	sp, #16
 8004cd0:	af00      	add	r7, sp, #0
 8004cd2:	6078      	str	r0, [r7, #4]
 8004cd4:	6039      	str	r1, [r7, #0]
//	unsigned int Param3;
	unsigned char ch3 = 0;
 8004cd6:	2300      	movs	r3, #0
 8004cd8:	73fb      	strb	r3, [r7, #15]
	unsigned int rezult3;
	if (len3 == 0)
 8004cda:	683b      	ldr	r3, [r7, #0]
 8004cdc:	2b00      	cmp	r3, #0
 8004cde:	d01d      	beq.n	8004d1c <uart3Write+0x50>
		return;

	while (len3>0)
 8004ce0:	e00d      	b.n	8004cfe <uart3Write+0x32>
	{
		ch3 = *src3;
 8004ce2:	687b      	ldr	r3, [r7, #4]
 8004ce4:	781b      	ldrb	r3, [r3, #0]
 8004ce6:	73fb      	strb	r3, [r7, #15]
		rezult3 = uart3PutChar(ch3);
 8004ce8:	7bfb      	ldrb	r3, [r7, #15]
 8004cea:	4618      	mov	r0, r3
 8004cec:	4b0d      	ldr	r3, [pc, #52]	; (8004d24 <uart3Write+0x58>)
 8004cee:	4798      	blx	r3
 8004cf0:	60b8      	str	r0, [r7, #8]
		src3++;
 8004cf2:	687b      	ldr	r3, [r7, #4]
 8004cf4:	3301      	adds	r3, #1
 8004cf6:	607b      	str	r3, [r7, #4]
		len3--;
 8004cf8:	683b      	ldr	r3, [r7, #0]
 8004cfa:	3b01      	subs	r3, #1
 8004cfc:	603b      	str	r3, [r7, #0]
	while (len3>0)
 8004cfe:	683b      	ldr	r3, [r7, #0]
 8004d00:	2b00      	cmp	r3, #0
 8004d02:	d1ee      	bne.n	8004ce2 <uart3Write+0x16>
	}


	DMA_Cmd(USART3_TX_DMA, DISABLE);
 8004d04:	2100      	movs	r1, #0
 8004d06:	4808      	ldr	r0, [pc, #32]	; (8004d28 <uart3Write+0x5c>)
 8004d08:	4b08      	ldr	r3, [pc, #32]	; (8004d2c <uart3Write+0x60>)
 8004d0a:	4798      	blx	r3
	DMA_ITConfig(USART3_TX_DMA, DMA_IT_TC, DISABLE);
 8004d0c:	2200      	movs	r2, #0
 8004d0e:	2102      	movs	r1, #2
 8004d10:	4805      	ldr	r0, [pc, #20]	; (8004d28 <uart3Write+0x5c>)
 8004d12:	4b07      	ldr	r3, [pc, #28]	; (8004d30 <uart3Write+0x64>)
 8004d14:	4798      	blx	r3

	uart3TxTask();
 8004d16:	4b07      	ldr	r3, [pc, #28]	; (8004d34 <uart3Write+0x68>)
 8004d18:	4798      	blx	r3
 8004d1a:	e000      	b.n	8004d1e <uart3Write+0x52>
		return;
 8004d1c:	bf00      	nop

}
 8004d1e:	3710      	adds	r7, #16
 8004d20:	46bd      	mov	sp, r7
 8004d22:	bd80      	pop	{r7, pc}
 8004d24:	08004b49 	.word	0x08004b49
 8004d28:	4002001c 	.word	0x4002001c
 8004d2c:	08003929 	.word	0x08003929
 8004d30:	0800395f 	.word	0x0800395f
 8004d34:	08004bad 	.word	0x08004bad

08004d38 <DMA1_Channel2_IRQHandler>:
	uart3TxTask();
}

//UART 3 DMA INTERRUPT
void DMA1_Channel2_IRQHandler(void)
{
 8004d38:	b580      	push	{r7, lr}
 8004d3a:	af00      	add	r7, sp, #0

	/* Disable DMA1_Channel2 transfer*/
	DMA_Cmd(USART3_TX_DMA, DISABLE);
 8004d3c:	2100      	movs	r1, #0
 8004d3e:	4806      	ldr	r0, [pc, #24]	; (8004d58 <DMA1_Channel2_IRQHandler+0x20>)
 8004d40:	4b06      	ldr	r3, [pc, #24]	; (8004d5c <DMA1_Channel2_IRQHandler+0x24>)
 8004d42:	4798      	blx	r3

	DMA_ClearITPendingBit(DMA1_FLAG_TC2);
 8004d44:	2020      	movs	r0, #32
 8004d46:	4b06      	ldr	r3, [pc, #24]	; (8004d60 <DMA1_Channel2_IRQHandler+0x28>)
 8004d48:	4798      	blx	r3
	DMA_ClearFlag(DMA1_FLAG_TC2);
 8004d4a:	2020      	movs	r0, #32
 8004d4c:	4b05      	ldr	r3, [pc, #20]	; (8004d64 <DMA1_Channel2_IRQHandler+0x2c>)
 8004d4e:	4798      	blx	r3

    uart3TxTask();
 8004d50:	4b05      	ldr	r3, [pc, #20]	; (8004d68 <DMA1_Channel2_IRQHandler+0x30>)
 8004d52:	4798      	blx	r3

}
 8004d54:	bf00      	nop
 8004d56:	bd80      	pop	{r7, pc}
 8004d58:	4002001c 	.word	0x4002001c
 8004d5c:	08003929 	.word	0x08003929
 8004d60:	080039e5 	.word	0x080039e5
 8004d64:	080039b1 	.word	0x080039b1
 8004d68:	08004bad 	.word	0x08004bad

08004d6c <DMA1_Channel3_IRQHandler>:

void DMA1_Channel3_IRQHandler(void)
{
 8004d6c:	b580      	push	{r7, lr}
 8004d6e:	b082      	sub	sp, #8
 8004d70:	af00      	add	r7, sp, #0
	/* Disable DMA1_Channel2 transfer*/
	//DMA_Cmd(USART3_TX_DMA, DISABLE);
	/*  Clear DMA1_Channel2 Transfer Complete Flag*/
	DMA_ClearFlag(DMA1_FLAG_TC3);
 8004d72:	f44f 7000 	mov.w	r0, #512	; 0x200
 8004d76:	4b07      	ldr	r3, [pc, #28]	; (8004d94 <DMA1_Channel3_IRQHandler+0x28>)
 8004d78:	4798      	blx	r3

	u3Fifo.rxCurrent+=0;
 8004d7a:	4b07      	ldr	r3, [pc, #28]	; (8004d98 <DMA1_Channel3_IRQHandler+0x2c>)
 8004d7c:	681b      	ldr	r3, [r3, #0]
 8004d7e:	4a06      	ldr	r2, [pc, #24]	; (8004d98 <DMA1_Channel3_IRQHandler+0x2c>)
 8004d80:	6013      	str	r3, [r2, #0]
	int tempTest3 = DMA_GetCurrDataCounter(USART3_RX_DMA);
 8004d82:	4806      	ldr	r0, [pc, #24]	; (8004d9c <DMA1_Channel3_IRQHandler+0x30>)
 8004d84:	4b06      	ldr	r3, [pc, #24]	; (8004da0 <DMA1_Channel3_IRQHandler+0x34>)
 8004d86:	4798      	blx	r3
 8004d88:	4603      	mov	r3, r0
 8004d8a:	607b      	str	r3, [r7, #4]
			tempTest3 +=0;


	//DMARxDataReceived();
	//uart3TxTask();
}
 8004d8c:	bf00      	nop
 8004d8e:	3708      	adds	r7, #8
 8004d90:	46bd      	mov	sp, r7
 8004d92:	bd80      	pop	{r7, pc}
 8004d94:	080039b1 	.word	0x080039b1
 8004d98:	20006870 	.word	0x20006870
 8004d9c:	40020030 	.word	0x40020030
 8004da0:	08003999 	.word	0x08003999

08004da4 <TIM8_CC_IRQHandler>:



}
void TIM8_CC_IRQHandler(void)
{
 8004da4:	b580      	push	{r7, lr}
 8004da6:	b082      	sub	sp, #8
 8004da8:	af00      	add	r7, sp, #0
	static uint16_t oldCC3, oldCC4,oldP4;
	static int led1 = 0, led2 = 0;
	uint16_t tmp;
	if (TIM_GetITStatus(TIM8, TIM_IT_CC3) == SET)
 8004daa:	2108      	movs	r1, #8
 8004dac:	4832      	ldr	r0, [pc, #200]	; (8004e78 <TIM8_CC_IRQHandler+0xd4>)
 8004dae:	4b33      	ldr	r3, [pc, #204]	; (8004e7c <TIM8_CC_IRQHandler+0xd8>)
 8004db0:	4798      	blx	r3
 8004db2:	4603      	mov	r3, r0
 8004db4:	2b01      	cmp	r3, #1
 8004db6:	d12b      	bne.n	8004e10 <TIM8_CC_IRQHandler+0x6c>
	{
		if (led1 == 0)
 8004db8:	4b31      	ldr	r3, [pc, #196]	; (8004e80 <TIM8_CC_IRQHandler+0xdc>)
 8004dba:	681b      	ldr	r3, [r3, #0]
 8004dbc:	2b00      	cmp	r3, #0
 8004dbe:	d104      	bne.n	8004dca <TIM8_CC_IRQHandler+0x26>
		{
			GPIO_SetBits(GPIOB, GPIO_Pin_1);
 8004dc0:	2102      	movs	r1, #2
 8004dc2:	4830      	ldr	r0, [pc, #192]	; (8004e84 <TIM8_CC_IRQHandler+0xe0>)
 8004dc4:	4b30      	ldr	r3, [pc, #192]	; (8004e88 <TIM8_CC_IRQHandler+0xe4>)
 8004dc6:	4798      	blx	r3
 8004dc8:	e003      	b.n	8004dd2 <TIM8_CC_IRQHandler+0x2e>
		}
		else
		{
			GPIO_ResetBits(GPIOB, GPIO_Pin_1);
 8004dca:	2102      	movs	r1, #2
 8004dcc:	482d      	ldr	r0, [pc, #180]	; (8004e84 <TIM8_CC_IRQHandler+0xe0>)
 8004dce:	4b2f      	ldr	r3, [pc, #188]	; (8004e8c <TIM8_CC_IRQHandler+0xe8>)
 8004dd0:	4798      	blx	r3
		}
		led1 ^= 1;
 8004dd2:	4b2b      	ldr	r3, [pc, #172]	; (8004e80 <TIM8_CC_IRQHandler+0xdc>)
 8004dd4:	681b      	ldr	r3, [r3, #0]
 8004dd6:	f083 0301 	eor.w	r3, r3, #1
 8004dda:	4a29      	ldr	r2, [pc, #164]	; (8004e80 <TIM8_CC_IRQHandler+0xdc>)
 8004ddc:	6013      	str	r3, [r2, #0]
		// Clear TIM3 Capture compare interrupt pending bit
		TIM_ClearITPendingBit(TIM8, TIM_IT_CC3);
 8004dde:	2108      	movs	r1, #8
 8004de0:	4825      	ldr	r0, [pc, #148]	; (8004e78 <TIM8_CC_IRQHandler+0xd4>)
 8004de2:	4b2b      	ldr	r3, [pc, #172]	; (8004e90 <TIM8_CC_IRQHandler+0xec>)
 8004de4:	4798      	blx	r3
		tmp = TIM_GetCapture3(TIM8);
 8004de6:	4824      	ldr	r0, [pc, #144]	; (8004e78 <TIM8_CC_IRQHandler+0xd4>)
 8004de8:	4b2a      	ldr	r3, [pc, #168]	; (8004e94 <TIM8_CC_IRQHandler+0xf0>)
 8004dea:	4798      	blx	r3
 8004dec:	4603      	mov	r3, r0
 8004dee:	80fb      	strh	r3, [r7, #6]

		// Wind Calculation
		// 100hz = 40 ms
		pwmcVlue[0] = (8 * 100000000 / 25) / ((uint32_t) (tmp - oldCC3) * 5); // Convert in mm/s
 8004df0:	88fb      	ldrh	r3, [r7, #6]
 8004df2:	4a29      	ldr	r2, [pc, #164]	; (8004e98 <TIM8_CC_IRQHandler+0xf4>)
 8004df4:	8812      	ldrh	r2, [r2, #0]
 8004df6:	1a9b      	subs	r3, r3, r2
 8004df8:	461a      	mov	r2, r3
 8004dfa:	4613      	mov	r3, r2
 8004dfc:	009b      	lsls	r3, r3, #2
 8004dfe:	4413      	add	r3, r2
 8004e00:	4a26      	ldr	r2, [pc, #152]	; (8004e9c <TIM8_CC_IRQHandler+0xf8>)
 8004e02:	fbb2 f3f3 	udiv	r3, r2, r3
 8004e06:	4a26      	ldr	r2, [pc, #152]	; (8004ea0 <TIM8_CC_IRQHandler+0xfc>)
 8004e08:	6013      	str	r3, [r2, #0]
		oldCC3 = tmp;
 8004e0a:	4a23      	ldr	r2, [pc, #140]	; (8004e98 <TIM8_CC_IRQHandler+0xf4>)
 8004e0c:	88fb      	ldrh	r3, [r7, #6]
 8004e0e:	8013      	strh	r3, [r2, #0]
	}
	if (TIM_GetITStatus(TIM8, TIM_IT_CC4) == SET)
 8004e10:	2110      	movs	r1, #16
 8004e12:	4819      	ldr	r0, [pc, #100]	; (8004e78 <TIM8_CC_IRQHandler+0xd4>)
 8004e14:	4b19      	ldr	r3, [pc, #100]	; (8004e7c <TIM8_CC_IRQHandler+0xd8>)
 8004e16:	4798      	blx	r3
 8004e18:	4603      	mov	r3, r0
 8004e1a:	2b01      	cmp	r3, #1
 8004e1c:	d128      	bne.n	8004e70 <TIM8_CC_IRQHandler+0xcc>
		}
		else
		{
	//		GPIO_ResetBits(GPIOB, GPIO_Pin_0);
		}
		led2 ^= 1;
 8004e1e:	4b21      	ldr	r3, [pc, #132]	; (8004ea4 <TIM8_CC_IRQHandler+0x100>)
 8004e20:	681b      	ldr	r3, [r3, #0]
 8004e22:	f083 0301 	eor.w	r3, r3, #1
 8004e26:	4a1f      	ldr	r2, [pc, #124]	; (8004ea4 <TIM8_CC_IRQHandler+0x100>)
 8004e28:	6013      	str	r3, [r2, #0]

		// Clear TIM3 Capture compare interrupt pending bit
		TIM_ClearITPendingBit(TIM8, TIM_IT_CC4);
 8004e2a:	2110      	movs	r1, #16
 8004e2c:	4812      	ldr	r0, [pc, #72]	; (8004e78 <TIM8_CC_IRQHandler+0xd4>)
 8004e2e:	4b18      	ldr	r3, [pc, #96]	; (8004e90 <TIM8_CC_IRQHandler+0xec>)
 8004e30:	4798      	blx	r3
		tmp = TIM_GetCapture4(TIM8);
 8004e32:	4811      	ldr	r0, [pc, #68]	; (8004e78 <TIM8_CC_IRQHandler+0xd4>)
 8004e34:	4b1c      	ldr	r3, [pc, #112]	; (8004ea8 <TIM8_CC_IRQHandler+0x104>)
 8004e36:	4798      	blx	r3
 8004e38:	4603      	mov	r3, r0
 8004e3a:	80fb      	strh	r3, [r7, #6]
		// Generator RPM calculation
		// 500us - 1 cycle
		pwmcVlue[1] = 60 * 10000000 / ((uint32_t) (tmp - oldCC4 + oldP4) * 5); // Convert in rpm*10^-3 in 1 minute
 8004e3c:	88fb      	ldrh	r3, [r7, #6]
 8004e3e:	4a1b      	ldr	r2, [pc, #108]	; (8004eac <TIM8_CC_IRQHandler+0x108>)
 8004e40:	8812      	ldrh	r2, [r2, #0]
 8004e42:	1a9b      	subs	r3, r3, r2
 8004e44:	4a1a      	ldr	r2, [pc, #104]	; (8004eb0 <TIM8_CC_IRQHandler+0x10c>)
 8004e46:	8812      	ldrh	r2, [r2, #0]
 8004e48:	4413      	add	r3, r2
 8004e4a:	461a      	mov	r2, r3
 8004e4c:	4613      	mov	r3, r2
 8004e4e:	009b      	lsls	r3, r3, #2
 8004e50:	4413      	add	r3, r2
 8004e52:	4a18      	ldr	r2, [pc, #96]	; (8004eb4 <TIM8_CC_IRQHandler+0x110>)
 8004e54:	fbb2 f3f3 	udiv	r3, r2, r3
 8004e58:	4a11      	ldr	r2, [pc, #68]	; (8004ea0 <TIM8_CC_IRQHandler+0xfc>)
 8004e5a:	6053      	str	r3, [r2, #4]
		oldP4 = tmp - oldCC4;
 8004e5c:	4b13      	ldr	r3, [pc, #76]	; (8004eac <TIM8_CC_IRQHandler+0x108>)
 8004e5e:	881b      	ldrh	r3, [r3, #0]
 8004e60:	88fa      	ldrh	r2, [r7, #6]
 8004e62:	1ad3      	subs	r3, r2, r3
 8004e64:	b29a      	uxth	r2, r3
 8004e66:	4b12      	ldr	r3, [pc, #72]	; (8004eb0 <TIM8_CC_IRQHandler+0x10c>)
 8004e68:	801a      	strh	r2, [r3, #0]
		oldCC4 = tmp;
 8004e6a:	4a10      	ldr	r2, [pc, #64]	; (8004eac <TIM8_CC_IRQHandler+0x108>)
 8004e6c:	88fb      	ldrh	r3, [r7, #6]
 8004e6e:	8013      	strh	r3, [r2, #0]
	}

}
 8004e70:	bf00      	nop
 8004e72:	3708      	adds	r7, #8
 8004e74:	46bd      	mov	sp, r7
 8004e76:	bd80      	pop	{r7, pc}
 8004e78:	40013400 	.word	0x40013400
 8004e7c:	08003ba9 	.word	0x08003ba9
 8004e80:	200070c4 	.word	0x200070c4
 8004e84:	40010c00 	.word	0x40010c00
 8004e88:	08002f6d 	.word	0x08002f6d
 8004e8c:	08002f89 	.word	0x08002f89
 8004e90:	08003bfb 	.word	0x08003bfb
 8004e94:	08003b57 	.word	0x08003b57
 8004e98:	200070c8 	.word	0x200070c8
 8004e9c:	01e84800 	.word	0x01e84800
 8004ea0:	200070bc 	.word	0x200070bc
 8004ea4:	200070cc 	.word	0x200070cc
 8004ea8:	08003b6f 	.word	0x08003b6f
 8004eac:	200070d0 	.word	0x200070d0
 8004eb0:	200070d2 	.word	0x200070d2
 8004eb4:	23c34600 	.word	0x23c34600

08004eb8 <leap_year>:
uint16 month_day_tableAcc[] = { 31, 59, 90, 120, 151, 181, 212, 243, 273, 304,
		334, 375 };

unsigned char leap_year(unsigned int test_year);
//?????????? 1, ???? ??? test_year - ??????????
unsigned char leap_year(unsigned int test_year) {
 8004eb8:	b480      	push	{r7}
 8004eba:	b083      	sub	sp, #12
 8004ebc:	af00      	add	r7, sp, #0
 8004ebe:	6078      	str	r0, [r7, #4]
	if (((test_year % 4 == 0) && (test_year % 100)) || (test_year % 400 == 0))
 8004ec0:	687b      	ldr	r3, [r7, #4]
 8004ec2:	f003 0303 	and.w	r3, r3, #3
 8004ec6:	2b00      	cmp	r3, #0
 8004ec8:	d10a      	bne.n	8004ee0 <leap_year+0x28>
 8004eca:	687a      	ldr	r2, [r7, #4]
 8004ecc:	4b0e      	ldr	r3, [pc, #56]	; (8004f08 <leap_year+0x50>)
 8004ece:	fba3 1302 	umull	r1, r3, r3, r2
 8004ed2:	095b      	lsrs	r3, r3, #5
 8004ed4:	2164      	movs	r1, #100	; 0x64
 8004ed6:	fb01 f303 	mul.w	r3, r1, r3
 8004eda:	1ad3      	subs	r3, r2, r3
 8004edc:	2b00      	cmp	r3, #0
 8004ede:	d10b      	bne.n	8004ef8 <leap_year+0x40>
 8004ee0:	687a      	ldr	r2, [r7, #4]
 8004ee2:	4b09      	ldr	r3, [pc, #36]	; (8004f08 <leap_year+0x50>)
 8004ee4:	fba3 1302 	umull	r1, r3, r3, r2
 8004ee8:	09db      	lsrs	r3, r3, #7
 8004eea:	f44f 71c8 	mov.w	r1, #400	; 0x190
 8004eee:	fb01 f303 	mul.w	r3, r1, r3
 8004ef2:	1ad3      	subs	r3, r2, r3
 8004ef4:	2b00      	cmp	r3, #0
 8004ef6:	d101      	bne.n	8004efc <leap_year+0x44>
		return 1;
 8004ef8:	2301      	movs	r3, #1
 8004efa:	e000      	b.n	8004efe <leap_year+0x46>
	else
		return 0;
 8004efc:	2300      	movs	r3, #0
}
 8004efe:	4618      	mov	r0, r3
 8004f00:	370c      	adds	r7, #12
 8004f02:	46bd      	mov	sp, r7
 8004f04:	bc80      	pop	{r7}
 8004f06:	4770      	bx	lr
 8004f08:	51eb851f 	.word	0x51eb851f

08004f0c <at91_bcd_int>:
unsigned int at91_bcd_int(unsigned char bcd) {
 8004f0c:	b480      	push	{r7}
 8004f0e:	b083      	sub	sp, #12
 8004f10:	af00      	add	r7, sp, #0
 8004f12:	4603      	mov	r3, r0
 8004f14:	71fb      	strb	r3, [r7, #7]
	return ((bcd & 0x0F) + (((bcd & 0xF0) >> 4) * 10));
 8004f16:	79fb      	ldrb	r3, [r7, #7]
 8004f18:	f003 020f 	and.w	r2, r3, #15
 8004f1c:	79fb      	ldrb	r3, [r7, #7]
 8004f1e:	091b      	lsrs	r3, r3, #4
 8004f20:	b2db      	uxtb	r3, r3
 8004f22:	4619      	mov	r1, r3
 8004f24:	460b      	mov	r3, r1
 8004f26:	009b      	lsls	r3, r3, #2
 8004f28:	440b      	add	r3, r1
 8004f2a:	005b      	lsls	r3, r3, #1
 8004f2c:	4413      	add	r3, r2

}
 8004f2e:	4618      	mov	r0, r3
 8004f30:	370c      	adds	r7, #12
 8004f32:	46bd      	mov	sp, r7
 8004f34:	bc80      	pop	{r7}
 8004f36:	4770      	bx	lr

08004f38 <GetDayOfWeek>:

unsigned int GetDayOfWeek(DATATIME *dt) {
 8004f38:	b580      	push	{r7, lr}
 8004f3a:	b086      	sub	sp, #24
 8004f3c:	af00      	add	r7, sp, #0
 8004f3e:	6078      	str	r0, [r7, #4]
	unsigned char Mounths[] = { 5, 1, 1, 4, 6, 2, 4, 0, 3, 5, 1, 3 };
 8004f40:	4a28      	ldr	r2, [pc, #160]	; (8004fe4 <GetDayOfWeek+0xac>)
 8004f42:	f107 0308 	add.w	r3, r7, #8
 8004f46:	ca07      	ldmia	r2, {r0, r1, r2}
 8004f48:	e883 0007 	stmia.w	r3, {r0, r1, r2}

	int DayOfWeek = (dt->Years + (int) (dt->Years / 4) + Mounths[dt->Month - 1]
 8004f4c:	687b      	ldr	r3, [r7, #4]
 8004f4e:	881b      	ldrh	r3, [r3, #0]
 8004f50:	b29b      	uxth	r3, r3
 8004f52:	461a      	mov	r2, r3
 8004f54:	687b      	ldr	r3, [r7, #4]
 8004f56:	881b      	ldrh	r3, [r3, #0]
 8004f58:	b29b      	uxth	r3, r3
 8004f5a:	089b      	lsrs	r3, r3, #2
 8004f5c:	b29b      	uxth	r3, r3
 8004f5e:	4413      	add	r3, r2
 8004f60:	687a      	ldr	r2, [r7, #4]
 8004f62:	8852      	ldrh	r2, [r2, #2]
 8004f64:	b292      	uxth	r2, r2
 8004f66:	3a01      	subs	r2, #1
 8004f68:	3218      	adds	r2, #24
 8004f6a:	443a      	add	r2, r7
 8004f6c:	f812 2c10 	ldrb.w	r2, [r2, #-16]
 8004f70:	4413      	add	r3, r2
			+ dt->Data);
 8004f72:	687a      	ldr	r2, [r7, #4]
 8004f74:	8892      	ldrh	r2, [r2, #4]
 8004f76:	b292      	uxth	r2, r2
	int DayOfWeek = (dt->Years + (int) (dt->Years / 4) + Mounths[dt->Month - 1]
 8004f78:	4413      	add	r3, r2
 8004f7a:	617b      	str	r3, [r7, #20]

	if (leap_year(dt->Years) == 1 && dt->Month < 2)
 8004f7c:	687b      	ldr	r3, [r7, #4]
 8004f7e:	881b      	ldrh	r3, [r3, #0]
 8004f80:	b29b      	uxth	r3, r3
 8004f82:	4618      	mov	r0, r3
 8004f84:	4b18      	ldr	r3, [pc, #96]	; (8004fe8 <GetDayOfWeek+0xb0>)
 8004f86:	4798      	blx	r3
 8004f88:	4603      	mov	r3, r0
 8004f8a:	2b01      	cmp	r3, #1
 8004f8c:	d113      	bne.n	8004fb6 <GetDayOfWeek+0x7e>
 8004f8e:	687b      	ldr	r3, [r7, #4]
 8004f90:	885b      	ldrh	r3, [r3, #2]
 8004f92:	b29b      	uxth	r3, r3
 8004f94:	2b01      	cmp	r3, #1
 8004f96:	d80e      	bhi.n	8004fb6 <GetDayOfWeek+0x7e>
		DayOfWeek = (DayOfWeek - 1) % 7;
 8004f98:	697b      	ldr	r3, [r7, #20]
 8004f9a:	1e5a      	subs	r2, r3, #1
 8004f9c:	4b13      	ldr	r3, [pc, #76]	; (8004fec <GetDayOfWeek+0xb4>)
 8004f9e:	fb83 1302 	smull	r1, r3, r3, r2
 8004fa2:	4413      	add	r3, r2
 8004fa4:	1099      	asrs	r1, r3, #2
 8004fa6:	17d3      	asrs	r3, r2, #31
 8004fa8:	1ac9      	subs	r1, r1, r3
 8004faa:	460b      	mov	r3, r1
 8004fac:	00db      	lsls	r3, r3, #3
 8004fae:	1a5b      	subs	r3, r3, r1
 8004fb0:	1ad3      	subs	r3, r2, r3
 8004fb2:	617b      	str	r3, [r7, #20]
 8004fb4:	e00c      	b.n	8004fd0 <GetDayOfWeek+0x98>
	else
		DayOfWeek = (DayOfWeek) % 7;
 8004fb6:	697a      	ldr	r2, [r7, #20]
 8004fb8:	4b0c      	ldr	r3, [pc, #48]	; (8004fec <GetDayOfWeek+0xb4>)
 8004fba:	fb83 1302 	smull	r1, r3, r3, r2
 8004fbe:	4413      	add	r3, r2
 8004fc0:	1099      	asrs	r1, r3, #2
 8004fc2:	17d3      	asrs	r3, r2, #31
 8004fc4:	1ac9      	subs	r1, r1, r3
 8004fc6:	460b      	mov	r3, r1
 8004fc8:	00db      	lsls	r3, r3, #3
 8004fca:	1a5b      	subs	r3, r3, r1
 8004fcc:	1ad3      	subs	r3, r2, r3
 8004fce:	617b      	str	r3, [r7, #20]
	if (DayOfWeek == 0)
 8004fd0:	697b      	ldr	r3, [r7, #20]
 8004fd2:	2b00      	cmp	r3, #0
 8004fd4:	d101      	bne.n	8004fda <GetDayOfWeek+0xa2>
		DayOfWeek = 7;
 8004fd6:	2307      	movs	r3, #7
 8004fd8:	617b      	str	r3, [r7, #20]
	return DayOfWeek;
 8004fda:	697b      	ldr	r3, [r7, #20]

}
 8004fdc:	4618      	mov	r0, r3
 8004fde:	3718      	adds	r7, #24
 8004fe0:	46bd      	mov	sp, r7
 8004fe2:	bd80      	pop	{r7, pc}
 8004fe4:	08014948 	.word	0x08014948
 8004fe8:	08004eb9 	.word	0x08004eb9
 8004fec:	92492493 	.word	0x92492493

08004ff0 <at91_int_bcd>:
unsigned char at91_int_bcd(unsigned int value) {
 8004ff0:	b480      	push	{r7}
 8004ff2:	b085      	sub	sp, #20
 8004ff4:	af00      	add	r7, sp, #0
 8004ff6:	6078      	str	r0, [r7, #4]
	char tmp[2];
	tmp[1] = (value % 10) + 0;
 8004ff8:	6879      	ldr	r1, [r7, #4]
 8004ffa:	4b16      	ldr	r3, [pc, #88]	; (8005054 <at91_int_bcd+0x64>)
 8004ffc:	fba3 2301 	umull	r2, r3, r3, r1
 8005000:	08da      	lsrs	r2, r3, #3
 8005002:	4613      	mov	r3, r2
 8005004:	009b      	lsls	r3, r3, #2
 8005006:	4413      	add	r3, r2
 8005008:	005b      	lsls	r3, r3, #1
 800500a:	1aca      	subs	r2, r1, r3
 800500c:	b2d3      	uxtb	r3, r2
 800500e:	737b      	strb	r3, [r7, #13]
	value /= 10;
 8005010:	687b      	ldr	r3, [r7, #4]
 8005012:	4a10      	ldr	r2, [pc, #64]	; (8005054 <at91_int_bcd+0x64>)
 8005014:	fba2 2303 	umull	r2, r3, r2, r3
 8005018:	08db      	lsrs	r3, r3, #3
 800501a:	607b      	str	r3, [r7, #4]
	tmp[0] = (value % 10) + 0;
 800501c:	6879      	ldr	r1, [r7, #4]
 800501e:	4b0d      	ldr	r3, [pc, #52]	; (8005054 <at91_int_bcd+0x64>)
 8005020:	fba3 2301 	umull	r2, r3, r3, r1
 8005024:	08da      	lsrs	r2, r3, #3
 8005026:	4613      	mov	r3, r2
 8005028:	009b      	lsls	r3, r3, #2
 800502a:	4413      	add	r3, r2
 800502c:	005b      	lsls	r3, r3, #1
 800502e:	1aca      	subs	r2, r1, r3
 8005030:	b2d3      	uxtb	r3, r2
 8005032:	733b      	strb	r3, [r7, #12]
	return ((tmp[1] & 0x0F) | ((tmp[0] & 0x0F) << 4));
 8005034:	7b7b      	ldrb	r3, [r7, #13]
 8005036:	b25b      	sxtb	r3, r3
 8005038:	f003 030f 	and.w	r3, r3, #15
 800503c:	b25a      	sxtb	r2, r3
 800503e:	7b3b      	ldrb	r3, [r7, #12]
 8005040:	011b      	lsls	r3, r3, #4
 8005042:	b25b      	sxtb	r3, r3
 8005044:	4313      	orrs	r3, r2
 8005046:	b25b      	sxtb	r3, r3
 8005048:	b2db      	uxtb	r3, r3
}
 800504a:	4618      	mov	r0, r3
 800504c:	3714      	adds	r7, #20
 800504e:	46bd      	mov	sp, r7
 8005050:	bc80      	pop	{r7}
 8005052:	4770      	bx	lr
 8005054:	cccccccd 	.word	0xcccccccd

08005058 <UpdateTime>:

u8 data[7];
u8 dataoff[7];

void UpdateTime(void) {
 8005058:	b580      	push	{r7, lr}
 800505a:	b082      	sub	sp, #8
 800505c:	af00      	add	r7, sp, #0

	if (ResetTime) {
 800505e:	4b64      	ldr	r3, [pc, #400]	; (80051f0 <UpdateTime+0x198>)
 8005060:	681b      	ldr	r3, [r3, #0]
 8005062:	2b00      	cmp	r3, #0
 8005064:	f000 80c0 	beq.w	80051e8 <UpdateTime+0x190>
		BKP_WriteBackupRegister(BKP_DR7, 4);
 8005068:	2104      	movs	r1, #4
 800506a:	201c      	movs	r0, #28
 800506c:	4b61      	ldr	r3, [pc, #388]	; (80051f4 <UpdateTime+0x19c>)
 800506e:	4798      	blx	r3
		if (!I2C_Time_BufferRead(data, 0, 7))
 8005070:	2207      	movs	r2, #7
 8005072:	2100      	movs	r1, #0
 8005074:	4860      	ldr	r0, [pc, #384]	; (80051f8 <UpdateTime+0x1a0>)
 8005076:	4b61      	ldr	r3, [pc, #388]	; (80051fc <UpdateTime+0x1a4>)
 8005078:	4798      	blx	r3
 800507a:	4603      	mov	r3, r0
 800507c:	f083 0301 	eor.w	r3, r3, #1
 8005080:	b2db      	uxtb	r3, r3
 8005082:	2b00      	cmp	r3, #0
 8005084:	f040 80af 	bne.w	80051e6 <UpdateTime+0x18e>
			return;
		RTClock[0].Sec = at91_bcd_int(data[0]);
 8005088:	4b5b      	ldr	r3, [pc, #364]	; (80051f8 <UpdateTime+0x1a0>)
 800508a:	781b      	ldrb	r3, [r3, #0]
 800508c:	4618      	mov	r0, r3
 800508e:	4b5c      	ldr	r3, [pc, #368]	; (8005200 <UpdateTime+0x1a8>)
 8005090:	4798      	blx	r3
 8005092:	4603      	mov	r3, r0
 8005094:	b29a      	uxth	r2, r3
 8005096:	4b5b      	ldr	r3, [pc, #364]	; (8005204 <UpdateTime+0x1ac>)
 8005098:	819a      	strh	r2, [r3, #12]
		RTClock[0].Min = at91_bcd_int(data[1]);
 800509a:	4b57      	ldr	r3, [pc, #348]	; (80051f8 <UpdateTime+0x1a0>)
 800509c:	785b      	ldrb	r3, [r3, #1]
 800509e:	4618      	mov	r0, r3
 80050a0:	4b57      	ldr	r3, [pc, #348]	; (8005200 <UpdateTime+0x1a8>)
 80050a2:	4798      	blx	r3
 80050a4:	4603      	mov	r3, r0
 80050a6:	b29a      	uxth	r2, r3
 80050a8:	4b56      	ldr	r3, [pc, #344]	; (8005204 <UpdateTime+0x1ac>)
 80050aa:	815a      	strh	r2, [r3, #10]
		RTClock[0].Hour = at91_bcd_int(data[2]);
 80050ac:	4b52      	ldr	r3, [pc, #328]	; (80051f8 <UpdateTime+0x1a0>)
 80050ae:	789b      	ldrb	r3, [r3, #2]
 80050b0:	4618      	mov	r0, r3
 80050b2:	4b53      	ldr	r3, [pc, #332]	; (8005200 <UpdateTime+0x1a8>)
 80050b4:	4798      	blx	r3
 80050b6:	4603      	mov	r3, r0
 80050b8:	b29a      	uxth	r2, r3
 80050ba:	4b52      	ldr	r3, [pc, #328]	; (8005204 <UpdateTime+0x1ac>)
 80050bc:	811a      	strh	r2, [r3, #8]
		RTClock[0].Day = at91_bcd_int(data[3]);
 80050be:	4b4e      	ldr	r3, [pc, #312]	; (80051f8 <UpdateTime+0x1a0>)
 80050c0:	78db      	ldrb	r3, [r3, #3]
 80050c2:	4618      	mov	r0, r3
 80050c4:	4b4e      	ldr	r3, [pc, #312]	; (8005200 <UpdateTime+0x1a8>)
 80050c6:	4798      	blx	r3
 80050c8:	4603      	mov	r3, r0
 80050ca:	b29a      	uxth	r2, r3
 80050cc:	4b4d      	ldr	r3, [pc, #308]	; (8005204 <UpdateTime+0x1ac>)
 80050ce:	80da      	strh	r2, [r3, #6]
		RTClock[0].Data = at91_bcd_int(data[4]);
 80050d0:	4b49      	ldr	r3, [pc, #292]	; (80051f8 <UpdateTime+0x1a0>)
 80050d2:	791b      	ldrb	r3, [r3, #4]
 80050d4:	4618      	mov	r0, r3
 80050d6:	4b4a      	ldr	r3, [pc, #296]	; (8005200 <UpdateTime+0x1a8>)
 80050d8:	4798      	blx	r3
 80050da:	4603      	mov	r3, r0
 80050dc:	b29a      	uxth	r2, r3
 80050de:	4b49      	ldr	r3, [pc, #292]	; (8005204 <UpdateTime+0x1ac>)
 80050e0:	809a      	strh	r2, [r3, #4]
		RTClock[0].Month = at91_bcd_int(data[5]);
 80050e2:	4b45      	ldr	r3, [pc, #276]	; (80051f8 <UpdateTime+0x1a0>)
 80050e4:	795b      	ldrb	r3, [r3, #5]
 80050e6:	4618      	mov	r0, r3
 80050e8:	4b45      	ldr	r3, [pc, #276]	; (8005200 <UpdateTime+0x1a8>)
 80050ea:	4798      	blx	r3
 80050ec:	4603      	mov	r3, r0
 80050ee:	b29a      	uxth	r2, r3
 80050f0:	4b44      	ldr	r3, [pc, #272]	; (8005204 <UpdateTime+0x1ac>)
 80050f2:	805a      	strh	r2, [r3, #2]
		RTClock[0].Years = (at91_bcd_int(data[6]) + 2000);
 80050f4:	4b40      	ldr	r3, [pc, #256]	; (80051f8 <UpdateTime+0x1a0>)
 80050f6:	799b      	ldrb	r3, [r3, #6]
 80050f8:	4618      	mov	r0, r3
 80050fa:	4b41      	ldr	r3, [pc, #260]	; (8005200 <UpdateTime+0x1a8>)
 80050fc:	4798      	blx	r3
 80050fe:	4603      	mov	r3, r0
 8005100:	b29b      	uxth	r3, r3
 8005102:	f503 63fa 	add.w	r3, r3, #2000	; 0x7d0
 8005106:	b29a      	uxth	r2, r3
 8005108:	4b3e      	ldr	r3, [pc, #248]	; (8005204 <UpdateTime+0x1ac>)
 800510a:	801a      	strh	r2, [r3, #0]

		if ((RTClock[0].Hour == 12) && (pxConfig->devcfg.GSMtime == 1)
 800510c:	4b3d      	ldr	r3, [pc, #244]	; (8005204 <UpdateTime+0x1ac>)
 800510e:	891b      	ldrh	r3, [r3, #8]
 8005110:	2b0c      	cmp	r3, #12
 8005112:	d113      	bne.n	800513c <UpdateTime+0xe4>
 8005114:	4b3c      	ldr	r3, [pc, #240]	; (8005208 <UpdateTime+0x1b0>)
 8005116:	681b      	ldr	r3, [r3, #0]
 8005118:	f8b3 3100 	ldrh.w	r3, [r3, #256]	; 0x100
 800511c:	b29b      	uxth	r3, r3
 800511e:	2b01      	cmp	r3, #1
 8005120:	d10c      	bne.n	800513c <UpdateTime+0xe4>
				&& (!FlagGSMtime) && (LedConnect)) {
 8005122:	4b3a      	ldr	r3, [pc, #232]	; (800520c <UpdateTime+0x1b4>)
 8005124:	781b      	ldrb	r3, [r3, #0]
 8005126:	f083 0301 	eor.w	r3, r3, #1
 800512a:	b2db      	uxtb	r3, r3
 800512c:	2b00      	cmp	r3, #0
 800512e:	d005      	beq.n	800513c <UpdateTime+0xe4>
 8005130:	4b37      	ldr	r3, [pc, #220]	; (8005210 <UpdateTime+0x1b8>)
 8005132:	781b      	ldrb	r3, [r3, #0]
 8005134:	2b00      	cmp	r3, #0
 8005136:	d001      	beq.n	800513c <UpdateTime+0xe4>
			GSM_clock();
 8005138:	4b36      	ldr	r3, [pc, #216]	; (8005214 <UpdateTime+0x1bc>)
 800513a:	4798      	blx	r3
		/*if ((RTClock[0].Hour == 12)&&(pxConfig->devcfg.GSMtime == 2)&&(!FlagGPStime)&&(LedGPS))
		 {
		 //GPS_clock();
		 //FlagGPStime = 1;
		 }*/
		if (((RTClock[0].Hour == 23) && (RTClock[0].Min == 59)
 800513c:	4b31      	ldr	r3, [pc, #196]	; (8005204 <UpdateTime+0x1ac>)
 800513e:	891b      	ldrh	r3, [r3, #8]
 8005140:	2b17      	cmp	r3, #23
 8005142:	d10f      	bne.n	8005164 <UpdateTime+0x10c>
 8005144:	4b2f      	ldr	r3, [pc, #188]	; (8005204 <UpdateTime+0x1ac>)
 8005146:	895b      	ldrh	r3, [r3, #10]
 8005148:	2b3b      	cmp	r3, #59	; 0x3b
 800514a:	d10b      	bne.n	8005164 <UpdateTime+0x10c>
				&& (RTClock[0].Sec == 59) && ((FlagGSMtime) || (FlagGPStime)))
 800514c:	4b2d      	ldr	r3, [pc, #180]	; (8005204 <UpdateTime+0x1ac>)
 800514e:	899b      	ldrh	r3, [r3, #12]
 8005150:	2b3b      	cmp	r3, #59	; 0x3b
 8005152:	d107      	bne.n	8005164 <UpdateTime+0x10c>
 8005154:	4b2d      	ldr	r3, [pc, #180]	; (800520c <UpdateTime+0x1b4>)
 8005156:	781b      	ldrb	r3, [r3, #0]
 8005158:	2b00      	cmp	r3, #0
 800515a:	d10a      	bne.n	8005172 <UpdateTime+0x11a>
 800515c:	4b2e      	ldr	r3, [pc, #184]	; (8005218 <UpdateTime+0x1c0>)
 800515e:	781b      	ldrb	r3, [r3, #0]
 8005160:	2b00      	cmp	r3, #0
 8005162:	d106      	bne.n	8005172 <UpdateTime+0x11a>
				|| (pxConfig->devcfg.GSMtime == 0)) {
 8005164:	4b28      	ldr	r3, [pc, #160]	; (8005208 <UpdateTime+0x1b0>)
 8005166:	681b      	ldr	r3, [r3, #0]
 8005168:	f8b3 3100 	ldrh.w	r3, [r3, #256]	; 0x100
 800516c:	b29b      	uxth	r3, r3
 800516e:	2b00      	cmp	r3, #0
 8005170:	d105      	bne.n	800517e <UpdateTime+0x126>
			FlagGSMtime = 0;
 8005172:	4b26      	ldr	r3, [pc, #152]	; (800520c <UpdateTime+0x1b4>)
 8005174:	2200      	movs	r2, #0
 8005176:	701a      	strb	r2, [r3, #0]
			FlagGPStime = 0;
 8005178:	4b27      	ldr	r3, [pc, #156]	; (8005218 <UpdateTime+0x1c0>)
 800517a:	2200      	movs	r2, #0
 800517c:	701a      	strb	r2, [r3, #0]

		}
		uint8_t SetDataTime[6] = { at91_int_bcd(RTClock[0].Sec), at91_int_bcd(
 800517e:	4b21      	ldr	r3, [pc, #132]	; (8005204 <UpdateTime+0x1ac>)
 8005180:	899b      	ldrh	r3, [r3, #12]
 8005182:	4618      	mov	r0, r3
 8005184:	4b25      	ldr	r3, [pc, #148]	; (800521c <UpdateTime+0x1c4>)
 8005186:	4798      	blx	r3
 8005188:	4603      	mov	r3, r0
 800518a:	703b      	strb	r3, [r7, #0]
				RTClock[0].Min), at91_int_bcd(RTClock[0].Hour), at91_int_bcd(
 800518c:	4b1d      	ldr	r3, [pc, #116]	; (8005204 <UpdateTime+0x1ac>)
 800518e:	895b      	ldrh	r3, [r3, #10]
		uint8_t SetDataTime[6] = { at91_int_bcd(RTClock[0].Sec), at91_int_bcd(
 8005190:	4618      	mov	r0, r3
 8005192:	4b22      	ldr	r3, [pc, #136]	; (800521c <UpdateTime+0x1c4>)
 8005194:	4798      	blx	r3
 8005196:	4603      	mov	r3, r0
 8005198:	707b      	strb	r3, [r7, #1]
				RTClock[0].Min), at91_int_bcd(RTClock[0].Hour), at91_int_bcd(
 800519a:	4b1a      	ldr	r3, [pc, #104]	; (8005204 <UpdateTime+0x1ac>)
 800519c:	891b      	ldrh	r3, [r3, #8]
 800519e:	4618      	mov	r0, r3
 80051a0:	4b1e      	ldr	r3, [pc, #120]	; (800521c <UpdateTime+0x1c4>)
 80051a2:	4798      	blx	r3
 80051a4:	4603      	mov	r3, r0
		uint8_t SetDataTime[6] = { at91_int_bcd(RTClock[0].Sec), at91_int_bcd(
 80051a6:	70bb      	strb	r3, [r7, #2]
				RTClock[0].Day), at91_int_bcd(RTClock[0].Data), at91_int_bcd(
 80051a8:	4b16      	ldr	r3, [pc, #88]	; (8005204 <UpdateTime+0x1ac>)
 80051aa:	88db      	ldrh	r3, [r3, #6]
				RTClock[0].Min), at91_int_bcd(RTClock[0].Hour), at91_int_bcd(
 80051ac:	4618      	mov	r0, r3
 80051ae:	4b1b      	ldr	r3, [pc, #108]	; (800521c <UpdateTime+0x1c4>)
 80051b0:	4798      	blx	r3
 80051b2:	4603      	mov	r3, r0
		uint8_t SetDataTime[6] = { at91_int_bcd(RTClock[0].Sec), at91_int_bcd(
 80051b4:	70fb      	strb	r3, [r7, #3]
				RTClock[0].Day), at91_int_bcd(RTClock[0].Data), at91_int_bcd(
 80051b6:	4b13      	ldr	r3, [pc, #76]	; (8005204 <UpdateTime+0x1ac>)
 80051b8:	889b      	ldrh	r3, [r3, #4]
 80051ba:	4618      	mov	r0, r3
 80051bc:	4b17      	ldr	r3, [pc, #92]	; (800521c <UpdateTime+0x1c4>)
 80051be:	4798      	blx	r3
 80051c0:	4603      	mov	r3, r0
		uint8_t SetDataTime[6] = { at91_int_bcd(RTClock[0].Sec), at91_int_bcd(
 80051c2:	713b      	strb	r3, [r7, #4]
				RTClock[0].Month) };
 80051c4:	4b0f      	ldr	r3, [pc, #60]	; (8005204 <UpdateTime+0x1ac>)
 80051c6:	885b      	ldrh	r3, [r3, #2]
				RTClock[0].Day), at91_int_bcd(RTClock[0].Data), at91_int_bcd(
 80051c8:	4618      	mov	r0, r3
 80051ca:	4b14      	ldr	r3, [pc, #80]	; (800521c <UpdateTime+0x1c4>)
 80051cc:	4798      	blx	r3
 80051ce:	4603      	mov	r3, r0
		uint8_t SetDataTime[6] = { at91_int_bcd(RTClock[0].Sec), at91_int_bcd(
 80051d0:	717b      	strb	r3, [r7, #5]
		I2C_Time_BufferWrite(SetDataTime, 7, 6);
 80051d2:	463b      	mov	r3, r7
 80051d4:	2206      	movs	r2, #6
 80051d6:	2107      	movs	r1, #7
 80051d8:	4618      	mov	r0, r3
 80051da:	4b11      	ldr	r3, [pc, #68]	; (8005220 <UpdateTime+0x1c8>)
 80051dc:	4798      	blx	r3

		ResetTimeEnd = 0;
 80051de:	4b11      	ldr	r3, [pc, #68]	; (8005224 <UpdateTime+0x1cc>)
 80051e0:	2200      	movs	r2, #0
 80051e2:	601a      	str	r2, [r3, #0]
 80051e4:	e000      	b.n	80051e8 <UpdateTime+0x190>
			return;
 80051e6:	bf00      	nop
	}

}
 80051e8:	3708      	adds	r7, #8
 80051ea:	46bd      	mov	sp, r7
 80051ec:	bd80      	pop	{r7, pc}
 80051ee:	bf00      	nop
 80051f0:	200072bc 	.word	0x200072bc
 80051f4:	08003621 	.word	0x08003621
 80051f8:	20007100 	.word	0x20007100
 80051fc:	08005bb5 	.word	0x08005bb5
 8005200:	08004f0d 	.word	0x08004f0d
 8005204:	200070d4 	.word	0x200070d4
 8005208:	20000148 	.word	0x20000148
 800520c:	200070fc 	.word	0x200070fc
 8005210:	200072b5 	.word	0x200072b5
 8005214:	0800c1ed 	.word	0x0800c1ed
 8005218:	200070fd 	.word	0x200070fd
 800521c:	08004ff1 	.word	0x08004ff1
 8005220:	080060b5 	.word	0x080060b5
 8005224:	200072bd 	.word	0x200072bd

08005228 <rtcInit>:

bool rtcInit(void) {
 8005228:	b580      	push	{r7, lr}
 800522a:	b082      	sub	sp, #8
 800522c:	af00      	add	r7, sp, #0

	BKP_WriteBackupRegister(BKP_DR7, 18);
 800522e:	2112      	movs	r1, #18
 8005230:	201c      	movs	r0, #28
 8005232:	4b66      	ldr	r3, [pc, #408]	; (80053cc <rtcInit+0x1a4>)
 8005234:	4798      	blx	r3
	uint8_t buffWr;
	u16 u16_WaitForOscSource;
	int counter = 10;
 8005236:	230a      	movs	r3, #10
 8005238:	607b      	str	r3, [r7, #4]
	buffWr = 156;
 800523a:	239c      	movs	r3, #156	; 0x9c
 800523c:	70fb      	strb	r3, [r7, #3]
	while (!I2C_Time_BufferWrite(buffWr, 14, 1)) {
 800523e:	e006      	b.n	800524e <rtcInit+0x26>
		if (counter-- <= 0)
 8005240:	687b      	ldr	r3, [r7, #4]
 8005242:	1e5a      	subs	r2, r3, #1
 8005244:	607a      	str	r2, [r7, #4]
 8005246:	2b00      	cmp	r3, #0
 8005248:	dc01      	bgt.n	800524e <rtcInit+0x26>
			return false;
 800524a:	2300      	movs	r3, #0
 800524c:	e0b9      	b.n	80053c2 <rtcInit+0x19a>
	while (!I2C_Time_BufferWrite(buffWr, 14, 1)) {
 800524e:	78fb      	ldrb	r3, [r7, #3]
 8005250:	2201      	movs	r2, #1
 8005252:	210e      	movs	r1, #14
 8005254:	4618      	mov	r0, r3
 8005256:	4b5e      	ldr	r3, [pc, #376]	; (80053d0 <rtcInit+0x1a8>)
 8005258:	4798      	blx	r3
 800525a:	4603      	mov	r3, r0
 800525c:	f083 0301 	eor.w	r3, r3, #1
 8005260:	b2db      	uxtb	r3, r3
 8005262:	2b00      	cmp	r3, #0
 8005264:	d1ec      	bne.n	8005240 <rtcInit+0x18>
	}
	vTaskDelay(5);
 8005266:	2005      	movs	r0, #5
 8005268:	4b5a      	ldr	r3, [pc, #360]	; (80053d4 <rtcInit+0x1ac>)
 800526a:	4798      	blx	r3

	//for(u16_WaitForOscSource=0;u16_WaitForOscSource<5000;u16_WaitForOscSource++);
	counter = 10;
 800526c:	230a      	movs	r3, #10
 800526e:	607b      	str	r3, [r7, #4]
	buffWr = 184;
 8005270:	23b8      	movs	r3, #184	; 0xb8
 8005272:	70fb      	strb	r3, [r7, #3]
	while (!I2C_Time_BufferWrite(buffWr, 15, 1)) {
 8005274:	e006      	b.n	8005284 <rtcInit+0x5c>
		if (counter-- <= 0)
 8005276:	687b      	ldr	r3, [r7, #4]
 8005278:	1e5a      	subs	r2, r3, #1
 800527a:	607a      	str	r2, [r7, #4]
 800527c:	2b00      	cmp	r3, #0
 800527e:	dc01      	bgt.n	8005284 <rtcInit+0x5c>
			return false;
 8005280:	2300      	movs	r3, #0
 8005282:	e09e      	b.n	80053c2 <rtcInit+0x19a>
	while (!I2C_Time_BufferWrite(buffWr, 15, 1)) {
 8005284:	78fb      	ldrb	r3, [r7, #3]
 8005286:	2201      	movs	r2, #1
 8005288:	210f      	movs	r1, #15
 800528a:	4618      	mov	r0, r3
 800528c:	4b50      	ldr	r3, [pc, #320]	; (80053d0 <rtcInit+0x1a8>)
 800528e:	4798      	blx	r3
 8005290:	4603      	mov	r3, r0
 8005292:	f083 0301 	eor.w	r3, r3, #1
 8005296:	b2db      	uxtb	r3, r3
 8005298:	2b00      	cmp	r3, #0
 800529a:	d1ec      	bne.n	8005276 <rtcInit+0x4e>
	}
	vTaskDelay(5);
 800529c:	2005      	movs	r0, #5
 800529e:	4b4d      	ldr	r3, [pc, #308]	; (80053d4 <rtcInit+0x1ac>)
 80052a0:	4798      	blx	r3

	//for(u16_WaitForOscSource=0;u16_WaitForOscSource<5000;u16_WaitForOscSource++);
	counter = 10;
 80052a2:	230a      	movs	r3, #10
 80052a4:	607b      	str	r3, [r7, #4]
	while (!I2C_Time_BufferRead(data, 0, 7)) {
 80052a6:	e006      	b.n	80052b6 <rtcInit+0x8e>
		if (counter-- <= 0)
 80052a8:	687b      	ldr	r3, [r7, #4]
 80052aa:	1e5a      	subs	r2, r3, #1
 80052ac:	607a      	str	r2, [r7, #4]
 80052ae:	2b00      	cmp	r3, #0
 80052b0:	dc01      	bgt.n	80052b6 <rtcInit+0x8e>
			return false;
 80052b2:	2300      	movs	r3, #0
 80052b4:	e085      	b.n	80053c2 <rtcInit+0x19a>
	while (!I2C_Time_BufferRead(data, 0, 7)) {
 80052b6:	2207      	movs	r2, #7
 80052b8:	2100      	movs	r1, #0
 80052ba:	4847      	ldr	r0, [pc, #284]	; (80053d8 <rtcInit+0x1b0>)
 80052bc:	4b47      	ldr	r3, [pc, #284]	; (80053dc <rtcInit+0x1b4>)
 80052be:	4798      	blx	r3
 80052c0:	4603      	mov	r3, r0
 80052c2:	f083 0301 	eor.w	r3, r3, #1
 80052c6:	b2db      	uxtb	r3, r3
 80052c8:	2b00      	cmp	r3, #0
 80052ca:	d1ed      	bne.n	80052a8 <rtcInit+0x80>
	}


	BKP_WriteBackupRegister(BKP_DR7, 19);
 80052cc:	2113      	movs	r1, #19
 80052ce:	201c      	movs	r0, #28
 80052d0:	4b3e      	ldr	r3, [pc, #248]	; (80053cc <rtcInit+0x1a4>)
 80052d2:	4798      	blx	r3
	RTClock[0].Sec = at91_bcd_int(data[0]);
 80052d4:	4b40      	ldr	r3, [pc, #256]	; (80053d8 <rtcInit+0x1b0>)
 80052d6:	781b      	ldrb	r3, [r3, #0]
 80052d8:	4618      	mov	r0, r3
 80052da:	4b41      	ldr	r3, [pc, #260]	; (80053e0 <rtcInit+0x1b8>)
 80052dc:	4798      	blx	r3
 80052de:	4603      	mov	r3, r0
 80052e0:	b29a      	uxth	r2, r3
 80052e2:	4b40      	ldr	r3, [pc, #256]	; (80053e4 <rtcInit+0x1bc>)
 80052e4:	819a      	strh	r2, [r3, #12]
	RTClock[0].Min = at91_bcd_int(data[1]);
 80052e6:	4b3c      	ldr	r3, [pc, #240]	; (80053d8 <rtcInit+0x1b0>)
 80052e8:	785b      	ldrb	r3, [r3, #1]
 80052ea:	4618      	mov	r0, r3
 80052ec:	4b3c      	ldr	r3, [pc, #240]	; (80053e0 <rtcInit+0x1b8>)
 80052ee:	4798      	blx	r3
 80052f0:	4603      	mov	r3, r0
 80052f2:	b29a      	uxth	r2, r3
 80052f4:	4b3b      	ldr	r3, [pc, #236]	; (80053e4 <rtcInit+0x1bc>)
 80052f6:	815a      	strh	r2, [r3, #10]
	RTClock[0].Hour = at91_bcd_int(data[2]);
 80052f8:	4b37      	ldr	r3, [pc, #220]	; (80053d8 <rtcInit+0x1b0>)
 80052fa:	789b      	ldrb	r3, [r3, #2]
 80052fc:	4618      	mov	r0, r3
 80052fe:	4b38      	ldr	r3, [pc, #224]	; (80053e0 <rtcInit+0x1b8>)
 8005300:	4798      	blx	r3
 8005302:	4603      	mov	r3, r0
 8005304:	b29a      	uxth	r2, r3
 8005306:	4b37      	ldr	r3, [pc, #220]	; (80053e4 <rtcInit+0x1bc>)
 8005308:	811a      	strh	r2, [r3, #8]
	RTClock[0].Day = at91_bcd_int(data[3]);
 800530a:	4b33      	ldr	r3, [pc, #204]	; (80053d8 <rtcInit+0x1b0>)
 800530c:	78db      	ldrb	r3, [r3, #3]
 800530e:	4618      	mov	r0, r3
 8005310:	4b33      	ldr	r3, [pc, #204]	; (80053e0 <rtcInit+0x1b8>)
 8005312:	4798      	blx	r3
 8005314:	4603      	mov	r3, r0
 8005316:	b29a      	uxth	r2, r3
 8005318:	4b32      	ldr	r3, [pc, #200]	; (80053e4 <rtcInit+0x1bc>)
 800531a:	80da      	strh	r2, [r3, #6]
	RTClock[0].Data = at91_bcd_int(data[4]);
 800531c:	4b2e      	ldr	r3, [pc, #184]	; (80053d8 <rtcInit+0x1b0>)
 800531e:	791b      	ldrb	r3, [r3, #4]
 8005320:	4618      	mov	r0, r3
 8005322:	4b2f      	ldr	r3, [pc, #188]	; (80053e0 <rtcInit+0x1b8>)
 8005324:	4798      	blx	r3
 8005326:	4603      	mov	r3, r0
 8005328:	b29a      	uxth	r2, r3
 800532a:	4b2e      	ldr	r3, [pc, #184]	; (80053e4 <rtcInit+0x1bc>)
 800532c:	809a      	strh	r2, [r3, #4]
	RTClock[0].Month = at91_bcd_int(data[5]);
 800532e:	4b2a      	ldr	r3, [pc, #168]	; (80053d8 <rtcInit+0x1b0>)
 8005330:	795b      	ldrb	r3, [r3, #5]
 8005332:	4618      	mov	r0, r3
 8005334:	4b2a      	ldr	r3, [pc, #168]	; (80053e0 <rtcInit+0x1b8>)
 8005336:	4798      	blx	r3
 8005338:	4603      	mov	r3, r0
 800533a:	b29a      	uxth	r2, r3
 800533c:	4b29      	ldr	r3, [pc, #164]	; (80053e4 <rtcInit+0x1bc>)
 800533e:	805a      	strh	r2, [r3, #2]
	RTClock[0].Years = (at91_bcd_int(data[6]) + 2000);
 8005340:	4b25      	ldr	r3, [pc, #148]	; (80053d8 <rtcInit+0x1b0>)
 8005342:	799b      	ldrb	r3, [r3, #6]
 8005344:	4618      	mov	r0, r3
 8005346:	4b26      	ldr	r3, [pc, #152]	; (80053e0 <rtcInit+0x1b8>)
 8005348:	4798      	blx	r3
 800534a:	4603      	mov	r3, r0
 800534c:	b29b      	uxth	r3, r3
 800534e:	f503 63fa 	add.w	r3, r3, #2000	; 0x7d0
 8005352:	b29a      	uxth	r2, r3
 8005354:	4b23      	ldr	r3, [pc, #140]	; (80053e4 <rtcInit+0x1bc>)
 8005356:	801a      	strh	r2, [r3, #0]
	vTaskDelay(20);
 8005358:	2014      	movs	r0, #20
 800535a:	4b1e      	ldr	r3, [pc, #120]	; (80053d4 <rtcInit+0x1ac>)
 800535c:	4798      	blx	r3
	ResetTime = 1;
 800535e:	4b22      	ldr	r3, [pc, #136]	; (80053e8 <rtcInit+0x1c0>)
 8005360:	2201      	movs	r2, #1
 8005362:	601a      	str	r2, [r3, #0]
	if (RTClock[0].Years == 2000) {
 8005364:	4b1f      	ldr	r3, [pc, #124]	; (80053e4 <rtcInit+0x1bc>)
 8005366:	881b      	ldrh	r3, [r3, #0]
 8005368:	f5b3 6ffa 	cmp.w	r3, #2000	; 0x7d0
 800536c:	d117      	bne.n	800539e <rtcInit+0x176>
		RTClock[0].Sec = 255;
 800536e:	4b1d      	ldr	r3, [pc, #116]	; (80053e4 <rtcInit+0x1bc>)
 8005370:	22ff      	movs	r2, #255	; 0xff
 8005372:	819a      	strh	r2, [r3, #12]
		RTClock[0].Min = 255;
 8005374:	4b1b      	ldr	r3, [pc, #108]	; (80053e4 <rtcInit+0x1bc>)
 8005376:	22ff      	movs	r2, #255	; 0xff
 8005378:	815a      	strh	r2, [r3, #10]
		RTClock[0].Hour = 255;
 800537a:	4b1a      	ldr	r3, [pc, #104]	; (80053e4 <rtcInit+0x1bc>)
 800537c:	22ff      	movs	r2, #255	; 0xff
 800537e:	811a      	strh	r2, [r3, #8]
		RTClock[0].Day = 255;
 8005380:	4b18      	ldr	r3, [pc, #96]	; (80053e4 <rtcInit+0x1bc>)
 8005382:	22ff      	movs	r2, #255	; 0xff
 8005384:	80da      	strh	r2, [r3, #6]
		RTClock[0].Data = 255;
 8005386:	4b17      	ldr	r3, [pc, #92]	; (80053e4 <rtcInit+0x1bc>)
 8005388:	22ff      	movs	r2, #255	; 0xff
 800538a:	809a      	strh	r2, [r3, #4]
		RTClock[0].Month = 255;
 800538c:	4b15      	ldr	r3, [pc, #84]	; (80053e4 <rtcInit+0x1bc>)
 800538e:	22ff      	movs	r2, #255	; 0xff
 8005390:	805a      	strh	r2, [r3, #2]
		RTClock[0].Years = 255;
 8005392:	4b14      	ldr	r3, [pc, #80]	; (80053e4 <rtcInit+0x1bc>)
 8005394:	22ff      	movs	r2, #255	; 0xff
 8005396:	801a      	strh	r2, [r3, #0]
		ResetTime = 0;
 8005398:	4b13      	ldr	r3, [pc, #76]	; (80053e8 <rtcInit+0x1c0>)
 800539a:	2200      	movs	r2, #0
 800539c:	601a      	str	r2, [r3, #0]
	}

	BKP_WriteBackupRegister(BKP_DR7, 20);
 800539e:	2114      	movs	r1, #20
 80053a0:	201c      	movs	r0, #28
 80053a2:	4b0a      	ldr	r3, [pc, #40]	; (80053cc <rtcInit+0x1a4>)
 80053a4:	4798      	blx	r3
	if (!I2C_Time_BufferRead(dataoff, 7, 6))
 80053a6:	2206      	movs	r2, #6
 80053a8:	2107      	movs	r1, #7
 80053aa:	4810      	ldr	r0, [pc, #64]	; (80053ec <rtcInit+0x1c4>)
 80053ac:	4b0b      	ldr	r3, [pc, #44]	; (80053dc <rtcInit+0x1b4>)
 80053ae:	4798      	blx	r3
 80053b0:	4603      	mov	r3, r0
 80053b2:	f083 0301 	eor.w	r3, r3, #1
 80053b6:	b2db      	uxtb	r3, r3
 80053b8:	2b00      	cmp	r3, #0
 80053ba:	d001      	beq.n	80053c0 <rtcInit+0x198>
		return false;
 80053bc:	2300      	movs	r3, #0
 80053be:	e000      	b.n	80053c2 <rtcInit+0x19a>
	return true;
 80053c0:	2301      	movs	r3, #1
}
 80053c2:	4618      	mov	r0, r3
 80053c4:	3708      	adds	r7, #8
 80053c6:	46bd      	mov	sp, r7
 80053c8:	bd80      	pop	{r7, pc}
 80053ca:	bf00      	nop
 80053cc:	08003621 	.word	0x08003621
 80053d0:	080060b5 	.word	0x080060b5
 80053d4:	08001529 	.word	0x08001529
 80053d8:	20007100 	.word	0x20007100
 80053dc:	08005bb5 	.word	0x08005bb5
 80053e0:	08004f0d 	.word	0x08004f0d
 80053e4:	200070d4 	.word	0x200070d4
 80053e8:	200072bc 	.word	0x200072bc
 80053ec:	20007108 	.word	0x20007108

080053f0 <rtcGetDataTimeOff>:

void rtcGetDataTimeOff(DATATIME *dt) {
 80053f0:	b580      	push	{r7, lr}
 80053f2:	b082      	sub	sp, #8
 80053f4:	af00      	add	r7, sp, #0
 80053f6:	6078      	str	r0, [r7, #4]
	dt->MSec = 0;
 80053f8:	687b      	ldr	r3, [r7, #4]
 80053fa:	2200      	movs	r2, #0
 80053fc:	739a      	strb	r2, [r3, #14]
 80053fe:	2200      	movs	r2, #0
 8005400:	73da      	strb	r2, [r3, #15]
	dt->Sec = at91_bcd_int(dataoff[0]);
 8005402:	4b1f      	ldr	r3, [pc, #124]	; (8005480 <rtcGetDataTimeOff+0x90>)
 8005404:	781b      	ldrb	r3, [r3, #0]
 8005406:	4618      	mov	r0, r3
 8005408:	4b1e      	ldr	r3, [pc, #120]	; (8005484 <rtcGetDataTimeOff+0x94>)
 800540a:	4798      	blx	r3
 800540c:	4603      	mov	r3, r0
 800540e:	b29a      	uxth	r2, r3
 8005410:	687b      	ldr	r3, [r7, #4]
 8005412:	819a      	strh	r2, [r3, #12]
	dt->Min = at91_bcd_int(dataoff[1]);
 8005414:	4b1a      	ldr	r3, [pc, #104]	; (8005480 <rtcGetDataTimeOff+0x90>)
 8005416:	785b      	ldrb	r3, [r3, #1]
 8005418:	4618      	mov	r0, r3
 800541a:	4b1a      	ldr	r3, [pc, #104]	; (8005484 <rtcGetDataTimeOff+0x94>)
 800541c:	4798      	blx	r3
 800541e:	4603      	mov	r3, r0
 8005420:	b29a      	uxth	r2, r3
 8005422:	687b      	ldr	r3, [r7, #4]
 8005424:	815a      	strh	r2, [r3, #10]
	dt->Hour = at91_bcd_int(dataoff[2]);
 8005426:	4b16      	ldr	r3, [pc, #88]	; (8005480 <rtcGetDataTimeOff+0x90>)
 8005428:	789b      	ldrb	r3, [r3, #2]
 800542a:	4618      	mov	r0, r3
 800542c:	4b15      	ldr	r3, [pc, #84]	; (8005484 <rtcGetDataTimeOff+0x94>)
 800542e:	4798      	blx	r3
 8005430:	4603      	mov	r3, r0
 8005432:	b29a      	uxth	r2, r3
 8005434:	687b      	ldr	r3, [r7, #4]
 8005436:	811a      	strh	r2, [r3, #8]
	dt->Day = at91_bcd_int(dataoff[3]);
 8005438:	4b11      	ldr	r3, [pc, #68]	; (8005480 <rtcGetDataTimeOff+0x90>)
 800543a:	78db      	ldrb	r3, [r3, #3]
 800543c:	4618      	mov	r0, r3
 800543e:	4b11      	ldr	r3, [pc, #68]	; (8005484 <rtcGetDataTimeOff+0x94>)
 8005440:	4798      	blx	r3
 8005442:	4603      	mov	r3, r0
 8005444:	b29a      	uxth	r2, r3
 8005446:	687b      	ldr	r3, [r7, #4]
 8005448:	80da      	strh	r2, [r3, #6]
	dt->Data = at91_bcd_int(dataoff[4]);
 800544a:	4b0d      	ldr	r3, [pc, #52]	; (8005480 <rtcGetDataTimeOff+0x90>)
 800544c:	791b      	ldrb	r3, [r3, #4]
 800544e:	4618      	mov	r0, r3
 8005450:	4b0c      	ldr	r3, [pc, #48]	; (8005484 <rtcGetDataTimeOff+0x94>)
 8005452:	4798      	blx	r3
 8005454:	4603      	mov	r3, r0
 8005456:	b29a      	uxth	r2, r3
 8005458:	687b      	ldr	r3, [r7, #4]
 800545a:	809a      	strh	r2, [r3, #4]
	dt->Month = at91_bcd_int(dataoff[5]);
 800545c:	4b08      	ldr	r3, [pc, #32]	; (8005480 <rtcGetDataTimeOff+0x90>)
 800545e:	795b      	ldrb	r3, [r3, #5]
 8005460:	4618      	mov	r0, r3
 8005462:	4b08      	ldr	r3, [pc, #32]	; (8005484 <rtcGetDataTimeOff+0x94>)
 8005464:	4798      	blx	r3
 8005466:	4603      	mov	r3, r0
 8005468:	b29a      	uxth	r2, r3
 800546a:	687b      	ldr	r3, [r7, #4]
 800546c:	805a      	strh	r2, [r3, #2]
	dt->Years = RTClock[0].Years;
 800546e:	4b06      	ldr	r3, [pc, #24]	; (8005488 <rtcGetDataTimeOff+0x98>)
 8005470:	881a      	ldrh	r2, [r3, #0]
 8005472:	687b      	ldr	r3, [r7, #4]
 8005474:	801a      	strh	r2, [r3, #0]

}
 8005476:	bf00      	nop
 8005478:	3708      	adds	r7, #8
 800547a:	46bd      	mov	sp, r7
 800547c:	bd80      	pop	{r7, pc}
 800547e:	bf00      	nop
 8005480:	20007108 	.word	0x20007108
 8005484:	08004f0d 	.word	0x08004f0d
 8005488:	200070d4 	.word	0x200070d4

0800548c <rtcGetDataTime>:
void rtcGetDataTime(DATATIME *dt) {
 800548c:	b480      	push	{r7}
 800548e:	b083      	sub	sp, #12
 8005490:	af00      	add	r7, sp, #0
 8005492:	6078      	str	r0, [r7, #4]
	dt->MSec = RTClock[0].MSec;
 8005494:	4b12      	ldr	r3, [pc, #72]	; (80054e0 <rtcGetDataTime+0x54>)
 8005496:	89da      	ldrh	r2, [r3, #14]
 8005498:	687b      	ldr	r3, [r7, #4]
 800549a:	81da      	strh	r2, [r3, #14]
	dt->Sec = RTClock[0].Sec;
 800549c:	4b10      	ldr	r3, [pc, #64]	; (80054e0 <rtcGetDataTime+0x54>)
 800549e:	899a      	ldrh	r2, [r3, #12]
 80054a0:	687b      	ldr	r3, [r7, #4]
 80054a2:	819a      	strh	r2, [r3, #12]
	dt->Min = RTClock[0].Min;
 80054a4:	4b0e      	ldr	r3, [pc, #56]	; (80054e0 <rtcGetDataTime+0x54>)
 80054a6:	895a      	ldrh	r2, [r3, #10]
 80054a8:	687b      	ldr	r3, [r7, #4]
 80054aa:	815a      	strh	r2, [r3, #10]
	dt->Hour = RTClock[0].Hour;
 80054ac:	4b0c      	ldr	r3, [pc, #48]	; (80054e0 <rtcGetDataTime+0x54>)
 80054ae:	891a      	ldrh	r2, [r3, #8]
 80054b0:	687b      	ldr	r3, [r7, #4]
 80054b2:	811a      	strh	r2, [r3, #8]
	dt->Day = RTClock[0].Day;
 80054b4:	4b0a      	ldr	r3, [pc, #40]	; (80054e0 <rtcGetDataTime+0x54>)
 80054b6:	88da      	ldrh	r2, [r3, #6]
 80054b8:	687b      	ldr	r3, [r7, #4]
 80054ba:	80da      	strh	r2, [r3, #6]
	dt->Data = RTClock[0].Data;
 80054bc:	4b08      	ldr	r3, [pc, #32]	; (80054e0 <rtcGetDataTime+0x54>)
 80054be:	889a      	ldrh	r2, [r3, #4]
 80054c0:	687b      	ldr	r3, [r7, #4]
 80054c2:	809a      	strh	r2, [r3, #4]
	dt->Month = RTClock[0].Month;
 80054c4:	4b06      	ldr	r3, [pc, #24]	; (80054e0 <rtcGetDataTime+0x54>)
 80054c6:	885a      	ldrh	r2, [r3, #2]
 80054c8:	687b      	ldr	r3, [r7, #4]
 80054ca:	805a      	strh	r2, [r3, #2]
	dt->Years = RTClock[0].Years;
 80054cc:	4b04      	ldr	r3, [pc, #16]	; (80054e0 <rtcGetDataTime+0x54>)
 80054ce:	881a      	ldrh	r2, [r3, #0]
 80054d0:	687b      	ldr	r3, [r7, #4]
 80054d2:	801a      	strh	r2, [r3, #0]

}
 80054d4:	bf00      	nop
 80054d6:	370c      	adds	r7, #12
 80054d8:	46bd      	mov	sp, r7
 80054da:	bc80      	pop	{r7}
 80054dc:	4770      	bx	lr
 80054de:	bf00      	nop
 80054e0:	200070d4 	.word	0x200070d4

080054e4 <rtcSetDataTime>:
	RTClock[1].Month = RTClock[0].Month + shift;
	RTClock[1].Years = RTClock[0].Years;

}

void rtcSetDataTime(DATATIME *dt) {
 80054e4:	b580      	push	{r7, lr}
 80054e6:	b08a      	sub	sp, #40	; 0x28
 80054e8:	af00      	add	r7, sp, #0
 80054ea:	6078      	str	r0, [r7, #4]
	uint8_t count = 0;
 80054ec:	2300      	movs	r3, #0
 80054ee:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
	DATATIME tempClk;

	if ((dt->Years > 2100) | (dt->Years < 2010) | (dt->Month < 1)
 80054f2:	687b      	ldr	r3, [r7, #4]
 80054f4:	881b      	ldrh	r3, [r3, #0]
 80054f6:	b29b      	uxth	r3, r3
 80054f8:	f640 0234 	movw	r2, #2100	; 0x834
 80054fc:	4293      	cmp	r3, r2
 80054fe:	bf8c      	ite	hi
 8005500:	2301      	movhi	r3, #1
 8005502:	2300      	movls	r3, #0
 8005504:	b2da      	uxtb	r2, r3
 8005506:	687b      	ldr	r3, [r7, #4]
 8005508:	881b      	ldrh	r3, [r3, #0]
 800550a:	b29b      	uxth	r3, r3
 800550c:	f240 71d9 	movw	r1, #2009	; 0x7d9
 8005510:	428b      	cmp	r3, r1
 8005512:	bf94      	ite	ls
 8005514:	2301      	movls	r3, #1
 8005516:	2300      	movhi	r3, #0
 8005518:	b2db      	uxtb	r3, r3
 800551a:	4313      	orrs	r3, r2
 800551c:	b2db      	uxtb	r3, r3
 800551e:	461a      	mov	r2, r3
 8005520:	687b      	ldr	r3, [r7, #4]
 8005522:	885b      	ldrh	r3, [r3, #2]
 8005524:	b29b      	uxth	r3, r3
 8005526:	2b00      	cmp	r3, #0
 8005528:	bf0c      	ite	eq
 800552a:	2301      	moveq	r3, #1
 800552c:	2300      	movne	r3, #0
 800552e:	b2db      	uxtb	r3, r3
 8005530:	4313      	orrs	r3, r2
			| (dt->Month > 12) | (dt->Data < 1) | (dt->Data > 31)
 8005532:	687a      	ldr	r2, [r7, #4]
 8005534:	8852      	ldrh	r2, [r2, #2]
 8005536:	b292      	uxth	r2, r2
 8005538:	2a0c      	cmp	r2, #12
 800553a:	bf8c      	ite	hi
 800553c:	2201      	movhi	r2, #1
 800553e:	2200      	movls	r2, #0
 8005540:	b2d2      	uxtb	r2, r2
 8005542:	4313      	orrs	r3, r2
 8005544:	687a      	ldr	r2, [r7, #4]
 8005546:	8892      	ldrh	r2, [r2, #4]
 8005548:	b292      	uxth	r2, r2
 800554a:	2a00      	cmp	r2, #0
 800554c:	bf0c      	ite	eq
 800554e:	2201      	moveq	r2, #1
 8005550:	2200      	movne	r2, #0
 8005552:	b2d2      	uxtb	r2, r2
 8005554:	4313      	orrs	r3, r2
 8005556:	687a      	ldr	r2, [r7, #4]
 8005558:	8892      	ldrh	r2, [r2, #4]
 800555a:	b292      	uxth	r2, r2
 800555c:	2a1f      	cmp	r2, #31
 800555e:	bf8c      	ite	hi
 8005560:	2201      	movhi	r2, #1
 8005562:	2200      	movls	r2, #0
 8005564:	b2d2      	uxtb	r2, r2
			| (dt->Hour < 0) | (dt->Hour > 23) | (dt->Min < 0) | (dt->Min > 59)
 8005566:	4313      	orrs	r3, r2
 8005568:	687a      	ldr	r2, [r7, #4]
 800556a:	8912      	ldrh	r2, [r2, #8]
 800556c:	b292      	uxth	r2, r2
 800556e:	2a17      	cmp	r2, #23
 8005570:	bf8c      	ite	hi
 8005572:	2201      	movhi	r2, #1
 8005574:	2200      	movls	r2, #0
 8005576:	b2d2      	uxtb	r2, r2
 8005578:	4313      	orrs	r3, r2
 800557a:	687a      	ldr	r2, [r7, #4]
 800557c:	8952      	ldrh	r2, [r2, #10]
 800557e:	b292      	uxth	r2, r2
 8005580:	2a3b      	cmp	r2, #59	; 0x3b
 8005582:	bf8c      	ite	hi
 8005584:	2201      	movhi	r2, #1
 8005586:	2200      	movls	r2, #0
 8005588:	b2d2      	uxtb	r2, r2
			| (dt->Sec < 0) | (dt->Sec > 59))
 800558a:	4313      	orrs	r3, r2
 800558c:	687a      	ldr	r2, [r7, #4]
 800558e:	8992      	ldrh	r2, [r2, #12]
 8005590:	b292      	uxth	r2, r2
 8005592:	2a3b      	cmp	r2, #59	; 0x3b
 8005594:	bf8c      	ite	hi
 8005596:	2201      	movhi	r2, #1
 8005598:	2200      	movls	r2, #0
 800559a:	b2d2      	uxtb	r2, r2
 800559c:	4313      	orrs	r3, r2
	if ((dt->Years > 2100) | (dt->Years < 2010) | (dt->Month < 1)
 800559e:	2b00      	cmp	r3, #0
 80055a0:	f040 8085 	bne.w	80056ae <rtcSetDataTime+0x1ca>
		return;

	rtcGetDataTime(&tempClk);
 80055a4:	f107 0314 	add.w	r3, r7, #20
 80055a8:	4618      	mov	r0, r3
 80055aa:	4b43      	ldr	r3, [pc, #268]	; (80056b8 <rtcSetDataTime+0x1d4>)
 80055ac:	4798      	blx	r3

	if (((abs(tempClk.Min - (dt->Min)) > 10) || (tempClk.Hour != dt->Hour)
 80055ae:	8bfb      	ldrh	r3, [r7, #30]
 80055b0:	461a      	mov	r2, r3
 80055b2:	687b      	ldr	r3, [r7, #4]
 80055b4:	895b      	ldrh	r3, [r3, #10]
 80055b6:	b29b      	uxth	r3, r3
 80055b8:	1ad3      	subs	r3, r2, r3
 80055ba:	2b00      	cmp	r3, #0
 80055bc:	bfb8      	it	lt
 80055be:	425b      	neglt	r3, r3
 80055c0:	2b0a      	cmp	r3, #10
 80055c2:	dc17      	bgt.n	80055f4 <rtcSetDataTime+0x110>
 80055c4:	8bba      	ldrh	r2, [r7, #28]
 80055c6:	687b      	ldr	r3, [r7, #4]
 80055c8:	891b      	ldrh	r3, [r3, #8]
 80055ca:	b29b      	uxth	r3, r3
 80055cc:	429a      	cmp	r2, r3
 80055ce:	d111      	bne.n	80055f4 <rtcSetDataTime+0x110>
			|| (tempClk.Data != dt->Data) || (tempClk.Month != dt->Month)
 80055d0:	8b3a      	ldrh	r2, [r7, #24]
 80055d2:	687b      	ldr	r3, [r7, #4]
 80055d4:	889b      	ldrh	r3, [r3, #4]
 80055d6:	b29b      	uxth	r3, r3
 80055d8:	429a      	cmp	r2, r3
 80055da:	d10b      	bne.n	80055f4 <rtcSetDataTime+0x110>
 80055dc:	8afa      	ldrh	r2, [r7, #22]
 80055de:	687b      	ldr	r3, [r7, #4]
 80055e0:	885b      	ldrh	r3, [r3, #2]
 80055e2:	b29b      	uxth	r3, r3
 80055e4:	429a      	cmp	r2, r3
 80055e6:	d105      	bne.n	80055f4 <rtcSetDataTime+0x110>
			|| (tempClk.Years != dt->Years))) {
 80055e8:	8aba      	ldrh	r2, [r7, #20]
 80055ea:	687b      	ldr	r3, [r7, #4]
 80055ec:	881b      	ldrh	r3, [r3, #0]
 80055ee:	b29b      	uxth	r3, r3
 80055f0:	429a      	cmp	r2, r3
 80055f2:	d005      	beq.n	8005600 <rtcSetDataTime+0x11c>
		JrnlTime = 1;
 80055f4:	4b31      	ldr	r3, [pc, #196]	; (80056bc <rtcSetDataTime+0x1d8>)
 80055f6:	2201      	movs	r2, #1
 80055f8:	601a      	str	r2, [r3, #0]
		ResetTimeEnd = 1;
 80055fa:	4b31      	ldr	r3, [pc, #196]	; (80056c0 <rtcSetDataTime+0x1dc>)
 80055fc:	2201      	movs	r2, #1
 80055fe:	601a      	str	r2, [r3, #0]
	}

	uint8_t SetDataTime[7] = { at91_int_bcd(dt->Sec), at91_int_bcd(dt->Min),
 8005600:	687b      	ldr	r3, [r7, #4]
 8005602:	899b      	ldrh	r3, [r3, #12]
 8005604:	b29b      	uxth	r3, r3
 8005606:	4618      	mov	r0, r3
 8005608:	4b2e      	ldr	r3, [pc, #184]	; (80056c4 <rtcSetDataTime+0x1e0>)
 800560a:	4798      	blx	r3
 800560c:	4603      	mov	r3, r0
 800560e:	733b      	strb	r3, [r7, #12]
 8005610:	687b      	ldr	r3, [r7, #4]
 8005612:	895b      	ldrh	r3, [r3, #10]
 8005614:	b29b      	uxth	r3, r3
 8005616:	4618      	mov	r0, r3
 8005618:	4b2a      	ldr	r3, [pc, #168]	; (80056c4 <rtcSetDataTime+0x1e0>)
 800561a:	4798      	blx	r3
 800561c:	4603      	mov	r3, r0
 800561e:	737b      	strb	r3, [r7, #13]
			at91_int_bcd(dt->Hour), at91_int_bcd(dt->Day), at91_int_bcd(
 8005620:	687b      	ldr	r3, [r7, #4]
 8005622:	891b      	ldrh	r3, [r3, #8]
 8005624:	b29b      	uxth	r3, r3
 8005626:	4618      	mov	r0, r3
 8005628:	4b26      	ldr	r3, [pc, #152]	; (80056c4 <rtcSetDataTime+0x1e0>)
 800562a:	4798      	blx	r3
 800562c:	4603      	mov	r3, r0
	uint8_t SetDataTime[7] = { at91_int_bcd(dt->Sec), at91_int_bcd(dt->Min),
 800562e:	73bb      	strb	r3, [r7, #14]
			at91_int_bcd(dt->Hour), at91_int_bcd(dt->Day), at91_int_bcd(
 8005630:	687b      	ldr	r3, [r7, #4]
 8005632:	88db      	ldrh	r3, [r3, #6]
 8005634:	b29b      	uxth	r3, r3
 8005636:	4618      	mov	r0, r3
 8005638:	4b22      	ldr	r3, [pc, #136]	; (80056c4 <rtcSetDataTime+0x1e0>)
 800563a:	4798      	blx	r3
 800563c:	4603      	mov	r3, r0
	uint8_t SetDataTime[7] = { at91_int_bcd(dt->Sec), at91_int_bcd(dt->Min),
 800563e:	73fb      	strb	r3, [r7, #15]
					dt->Data), at91_int_bcd(dt->Month), at91_int_bcd(
 8005640:	687b      	ldr	r3, [r7, #4]
 8005642:	889b      	ldrh	r3, [r3, #4]
 8005644:	b29b      	uxth	r3, r3
			at91_int_bcd(dt->Hour), at91_int_bcd(dt->Day), at91_int_bcd(
 8005646:	4618      	mov	r0, r3
 8005648:	4b1e      	ldr	r3, [pc, #120]	; (80056c4 <rtcSetDataTime+0x1e0>)
 800564a:	4798      	blx	r3
 800564c:	4603      	mov	r3, r0
	uint8_t SetDataTime[7] = { at91_int_bcd(dt->Sec), at91_int_bcd(dt->Min),
 800564e:	743b      	strb	r3, [r7, #16]
					dt->Data), at91_int_bcd(dt->Month), at91_int_bcd(
 8005650:	687b      	ldr	r3, [r7, #4]
 8005652:	885b      	ldrh	r3, [r3, #2]
 8005654:	b29b      	uxth	r3, r3
 8005656:	4618      	mov	r0, r3
 8005658:	4b1a      	ldr	r3, [pc, #104]	; (80056c4 <rtcSetDataTime+0x1e0>)
 800565a:	4798      	blx	r3
 800565c:	4603      	mov	r3, r0
	uint8_t SetDataTime[7] = { at91_int_bcd(dt->Sec), at91_int_bcd(dt->Min),
 800565e:	747b      	strb	r3, [r7, #17]
					dt->Years - 2000) };
 8005660:	687b      	ldr	r3, [r7, #4]
 8005662:	881b      	ldrh	r3, [r3, #0]
 8005664:	b29b      	uxth	r3, r3
 8005666:	f5a3 63fa 	sub.w	r3, r3, #2000	; 0x7d0
					dt->Data), at91_int_bcd(dt->Month), at91_int_bcd(
 800566a:	4618      	mov	r0, r3
 800566c:	4b15      	ldr	r3, [pc, #84]	; (80056c4 <rtcSetDataTime+0x1e0>)
 800566e:	4798      	blx	r3
 8005670:	4603      	mov	r3, r0
	uint8_t SetDataTime[7] = { at91_int_bcd(dt->Sec), at91_int_bcd(dt->Min),
 8005672:	74bb      	strb	r3, [r7, #18]
	while (!I2C_Time_BufferWrite(SetDataTime, 0, 7)) {
 8005674:	e008      	b.n	8005688 <rtcSetDataTime+0x1a4>
		count++;
 8005676:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 800567a:	3301      	adds	r3, #1
 800567c:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
		if (count > 10)
 8005680:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
 8005684:	2b0a      	cmp	r3, #10
 8005686:	d80d      	bhi.n	80056a4 <rtcSetDataTime+0x1c0>
	while (!I2C_Time_BufferWrite(SetDataTime, 0, 7)) {
 8005688:	f107 030c 	add.w	r3, r7, #12
 800568c:	2207      	movs	r2, #7
 800568e:	2100      	movs	r1, #0
 8005690:	4618      	mov	r0, r3
 8005692:	4b0d      	ldr	r3, [pc, #52]	; (80056c8 <rtcSetDataTime+0x1e4>)
 8005694:	4798      	blx	r3
 8005696:	4603      	mov	r3, r0
 8005698:	f083 0301 	eor.w	r3, r3, #1
 800569c:	b2db      	uxtb	r3, r3
 800569e:	2b00      	cmp	r3, #0
 80056a0:	d1e9      	bne.n	8005676 <rtcSetDataTime+0x192>
 80056a2:	e000      	b.n	80056a6 <rtcSetDataTime+0x1c2>
			break;
 80056a4:	bf00      	nop
	}
	ResetTime = 1;
 80056a6:	4b09      	ldr	r3, [pc, #36]	; (80056cc <rtcSetDataTime+0x1e8>)
 80056a8:	2201      	movs	r2, #1
 80056aa:	601a      	str	r2, [r3, #0]
 80056ac:	e000      	b.n	80056b0 <rtcSetDataTime+0x1cc>
		return;
 80056ae:	bf00      	nop

}
 80056b0:	3728      	adds	r7, #40	; 0x28
 80056b2:	46bd      	mov	sp, r7
 80056b4:	bd80      	pop	{r7, pc}
 80056b6:	bf00      	nop
 80056b8:	0800548d 	.word	0x0800548d
 80056bc:	200072bb 	.word	0x200072bb
 80056c0:	200072bd 	.word	0x200072bd
 80056c4:	08004ff1 	.word	0x08004ff1
 80056c8:	080060b5 	.word	0x080060b5
 80056cc:	200072bc 	.word	0x200072bc

080056d0 <rtcSetLocalDataTime>:

void rtcSetLocalDataTime(DATATIME *dt) {
 80056d0:	b580      	push	{r7, lr}
 80056d2:	b084      	sub	sp, #16
 80056d4:	af00      	add	r7, sp, #0
 80056d6:	6078      	str	r0, [r7, #4]
	dt->Day = GetDayOfWeek(dt);
 80056d8:	6878      	ldr	r0, [r7, #4]
 80056da:	4b7d      	ldr	r3, [pc, #500]	; (80058d0 <rtcSetLocalDataTime+0x200>)
 80056dc:	4798      	blx	r3
 80056de:	4603      	mov	r3, r0
 80056e0:	b29a      	uxth	r2, r3
 80056e2:	687b      	ldr	r3, [r7, #4]
 80056e4:	80da      	strh	r2, [r3, #6]
	int shift = 0; //our shift amount
 80056e6:	2300      	movs	r3, #0
 80056e8:	60fb      	str	r3, [r7, #12]

	if (dt->Month > 3 && dt->Month < 10) {
 80056ea:	687b      	ldr	r3, [r7, #4]
 80056ec:	885b      	ldrh	r3, [r3, #2]
 80056ee:	b29b      	uxth	r3, r3
 80056f0:	2b03      	cmp	r3, #3
 80056f2:	d906      	bls.n	8005702 <rtcSetLocalDataTime+0x32>
 80056f4:	687b      	ldr	r3, [r7, #4]
 80056f6:	885b      	ldrh	r3, [r3, #2]
 80056f8:	b29b      	uxth	r3, r3
 80056fa:	2b09      	cmp	r3, #9
 80056fc:	d801      	bhi.n	8005702 <rtcSetLocalDataTime+0x32>
		shift = 1;
 80056fe:	2301      	movs	r3, #1
 8005700:	60fb      	str	r3, [r7, #12]
	}
	if (dt->Month == 3 && dt->Data > 24 && dt->Day == 7 && dt->Hour > 1) {
 8005702:	687b      	ldr	r3, [r7, #4]
 8005704:	885b      	ldrh	r3, [r3, #2]
 8005706:	b29b      	uxth	r3, r3
 8005708:	2b03      	cmp	r3, #3
 800570a:	d110      	bne.n	800572e <rtcSetLocalDataTime+0x5e>
 800570c:	687b      	ldr	r3, [r7, #4]
 800570e:	889b      	ldrh	r3, [r3, #4]
 8005710:	b29b      	uxth	r3, r3
 8005712:	2b18      	cmp	r3, #24
 8005714:	d90b      	bls.n	800572e <rtcSetLocalDataTime+0x5e>
 8005716:	687b      	ldr	r3, [r7, #4]
 8005718:	88db      	ldrh	r3, [r3, #6]
 800571a:	b29b      	uxth	r3, r3
 800571c:	2b07      	cmp	r3, #7
 800571e:	d106      	bne.n	800572e <rtcSetLocalDataTime+0x5e>
 8005720:	687b      	ldr	r3, [r7, #4]
 8005722:	891b      	ldrh	r3, [r3, #8]
 8005724:	b29b      	uxth	r3, r3
 8005726:	2b01      	cmp	r3, #1
 8005728:	d901      	bls.n	800572e <rtcSetLocalDataTime+0x5e>
		shift = 1;
 800572a:	2301      	movs	r3, #1
 800572c:	60fb      	str	r3, [r7, #12]
	}

	if (dt->Month == 3 && dt->Data > 24 && dt->Day != 7
 800572e:	687b      	ldr	r3, [r7, #4]
 8005730:	885b      	ldrh	r3, [r3, #2]
 8005732:	b29b      	uxth	r3, r3
 8005734:	2b03      	cmp	r3, #3
 8005736:	d117      	bne.n	8005768 <rtcSetLocalDataTime+0x98>
 8005738:	687b      	ldr	r3, [r7, #4]
 800573a:	889b      	ldrh	r3, [r3, #4]
 800573c:	b29b      	uxth	r3, r3
 800573e:	2b18      	cmp	r3, #24
 8005740:	d912      	bls.n	8005768 <rtcSetLocalDataTime+0x98>
 8005742:	687b      	ldr	r3, [r7, #4]
 8005744:	88db      	ldrh	r3, [r3, #6]
 8005746:	b29b      	uxth	r3, r3
 8005748:	2b07      	cmp	r3, #7
 800574a:	d00d      	beq.n	8005768 <rtcSetLocalDataTime+0x98>
			&& (7 - dt->Day) > (31 - dt->Data)) {
 800574c:	687b      	ldr	r3, [r7, #4]
 800574e:	88db      	ldrh	r3, [r3, #6]
 8005750:	b29b      	uxth	r3, r3
 8005752:	f1c3 0207 	rsb	r2, r3, #7
 8005756:	687b      	ldr	r3, [r7, #4]
 8005758:	889b      	ldrh	r3, [r3, #4]
 800575a:	b29b      	uxth	r3, r3
 800575c:	f1c3 031f 	rsb	r3, r3, #31
 8005760:	429a      	cmp	r2, r3
 8005762:	dd01      	ble.n	8005768 <rtcSetLocalDataTime+0x98>
		shift = 1;
 8005764:	2301      	movs	r3, #1
 8005766:	60fb      	str	r3, [r7, #12]
	}

	if (dt->Month == 10
 8005768:	687b      	ldr	r3, [r7, #4]
 800576a:	885b      	ldrh	r3, [r3, #2]
 800576c:	b29b      	uxth	r3, r3
 800576e:	2b0a      	cmp	r3, #10
 8005770:	d11c      	bne.n	80057ac <rtcSetLocalDataTime+0xdc>
			&& ((dt->Data <= 24)
 8005772:	687b      	ldr	r3, [r7, #4]
 8005774:	889b      	ldrh	r3, [r3, #4]
 8005776:	b29b      	uxth	r3, r3
 8005778:	2b18      	cmp	r3, #24
 800577a:	d915      	bls.n	80057a8 <rtcSetLocalDataTime+0xd8>
					|| (dt->Data > 24 && dt->Day != 7
 800577c:	687b      	ldr	r3, [r7, #4]
 800577e:	889b      	ldrh	r3, [r3, #4]
 8005780:	b29b      	uxth	r3, r3
 8005782:	2b18      	cmp	r3, #24
 8005784:	d912      	bls.n	80057ac <rtcSetLocalDataTime+0xdc>
 8005786:	687b      	ldr	r3, [r7, #4]
 8005788:	88db      	ldrh	r3, [r3, #6]
 800578a:	b29b      	uxth	r3, r3
 800578c:	2b07      	cmp	r3, #7
 800578e:	d00d      	beq.n	80057ac <rtcSetLocalDataTime+0xdc>
							&& (7 - dt->Day) <= (31 - dt->Data)))) {
 8005790:	687b      	ldr	r3, [r7, #4]
 8005792:	88db      	ldrh	r3, [r3, #6]
 8005794:	b29b      	uxth	r3, r3
 8005796:	f1c3 0207 	rsb	r2, r3, #7
 800579a:	687b      	ldr	r3, [r7, #4]
 800579c:	889b      	ldrh	r3, [r3, #4]
 800579e:	b29b      	uxth	r3, r3
 80057a0:	f1c3 031f 	rsb	r3, r3, #31
 80057a4:	429a      	cmp	r2, r3
 80057a6:	dc01      	bgt.n	80057ac <rtcSetLocalDataTime+0xdc>
		shift = 1;
 80057a8:	2301      	movs	r3, #1
 80057aa:	60fb      	str	r3, [r7, #12]
	}

	if (dt->Month == 10 && dt->Data > 24 && dt->Day == 7 && dt->Hour < 1) {
 80057ac:	687b      	ldr	r3, [r7, #4]
 80057ae:	885b      	ldrh	r3, [r3, #2]
 80057b0:	b29b      	uxth	r3, r3
 80057b2:	2b0a      	cmp	r3, #10
 80057b4:	d110      	bne.n	80057d8 <rtcSetLocalDataTime+0x108>
 80057b6:	687b      	ldr	r3, [r7, #4]
 80057b8:	889b      	ldrh	r3, [r3, #4]
 80057ba:	b29b      	uxth	r3, r3
 80057bc:	2b18      	cmp	r3, #24
 80057be:	d90b      	bls.n	80057d8 <rtcSetLocalDataTime+0x108>
 80057c0:	687b      	ldr	r3, [r7, #4]
 80057c2:	88db      	ldrh	r3, [r3, #6]
 80057c4:	b29b      	uxth	r3, r3
 80057c6:	2b07      	cmp	r3, #7
 80057c8:	d106      	bne.n	80057d8 <rtcSetLocalDataTime+0x108>
 80057ca:	687b      	ldr	r3, [r7, #4]
 80057cc:	891b      	ldrh	r3, [r3, #8]
 80057ce:	b29b      	uxth	r3, r3
 80057d0:	2b00      	cmp	r3, #0
 80057d2:	d101      	bne.n	80057d8 <rtcSetLocalDataTime+0x108>
		shift = 1;
 80057d4:	2301      	movs	r3, #1
 80057d6:	60fb      	str	r3, [r7, #12]
	}

	RTClock[0].MSec = dt->MSec;
 80057d8:	687b      	ldr	r3, [r7, #4]
 80057da:	89db      	ldrh	r3, [r3, #14]
 80057dc:	b29a      	uxth	r2, r3
 80057de:	4b3d      	ldr	r3, [pc, #244]	; (80058d4 <rtcSetLocalDataTime+0x204>)
 80057e0:	81da      	strh	r2, [r3, #14]
	RTClock[0].Sec = dt->Sec;
 80057e2:	687b      	ldr	r3, [r7, #4]
 80057e4:	899b      	ldrh	r3, [r3, #12]
 80057e6:	b29a      	uxth	r2, r3
 80057e8:	4b3a      	ldr	r3, [pc, #232]	; (80058d4 <rtcSetLocalDataTime+0x204>)
 80057ea:	819a      	strh	r2, [r3, #12]
	RTClock[0].Min = dt->Min;
 80057ec:	687b      	ldr	r3, [r7, #4]
 80057ee:	895b      	ldrh	r3, [r3, #10]
 80057f0:	b29a      	uxth	r2, r3
 80057f2:	4b38      	ldr	r3, [pc, #224]	; (80058d4 <rtcSetLocalDataTime+0x204>)
 80057f4:	815a      	strh	r2, [r3, #10]

	if (shift == 1) {
 80057f6:	68fb      	ldr	r3, [r7, #12]
 80057f8:	2b01      	cmp	r3, #1
 80057fa:	d114      	bne.n	8005826 <rtcSetLocalDataTime+0x156>
		if (dt->Hour == 0) {
 80057fc:	687b      	ldr	r3, [r7, #4]
 80057fe:	891b      	ldrh	r3, [r3, #8]
 8005800:	b29b      	uxth	r3, r3
 8005802:	2b00      	cmp	r3, #0
 8005804:	d103      	bne.n	800580e <rtcSetLocalDataTime+0x13e>
			RTClock[0].Hour = 23;
 8005806:	4b33      	ldr	r3, [pc, #204]	; (80058d4 <rtcSetLocalDataTime+0x204>)
 8005808:	2217      	movs	r2, #23
 800580a:	811a      	strh	r2, [r3, #8]
 800580c:	e010      	b.n	8005830 <rtcSetLocalDataTime+0x160>
		} else {
			RTClock[0].Hour = dt->Hour - shift;
 800580e:	687b      	ldr	r3, [r7, #4]
 8005810:	891b      	ldrh	r3, [r3, #8]
 8005812:	b29a      	uxth	r2, r3
 8005814:	68fb      	ldr	r3, [r7, #12]
 8005816:	b29b      	uxth	r3, r3
 8005818:	1ad3      	subs	r3, r2, r3
 800581a:	b29a      	uxth	r2, r3
 800581c:	4b2d      	ldr	r3, [pc, #180]	; (80058d4 <rtcSetLocalDataTime+0x204>)
 800581e:	811a      	strh	r2, [r3, #8]
			shift = 0;
 8005820:	2300      	movs	r3, #0
 8005822:	60fb      	str	r3, [r7, #12]
 8005824:	e004      	b.n	8005830 <rtcSetLocalDataTime+0x160>
		}
	} else {
		RTClock[0].Hour = dt->Hour;
 8005826:	687b      	ldr	r3, [r7, #4]
 8005828:	891b      	ldrh	r3, [r3, #8]
 800582a:	b29a      	uxth	r2, r3
 800582c:	4b29      	ldr	r3, [pc, #164]	; (80058d4 <rtcSetLocalDataTime+0x204>)
 800582e:	811a      	strh	r2, [r3, #8]
	}

	if (shift == 1) {
 8005830:	68fb      	ldr	r3, [r7, #12]
 8005832:	2b01      	cmp	r3, #1
 8005834:	d112      	bne.n	800585c <rtcSetLocalDataTime+0x18c>
		if (dt->Day == 1) {
 8005836:	687b      	ldr	r3, [r7, #4]
 8005838:	88db      	ldrh	r3, [r3, #6]
 800583a:	b29b      	uxth	r3, r3
 800583c:	2b01      	cmp	r3, #1
 800583e:	d103      	bne.n	8005848 <rtcSetLocalDataTime+0x178>
			RTClock[0].Day = 7;
 8005840:	4b24      	ldr	r3, [pc, #144]	; (80058d4 <rtcSetLocalDataTime+0x204>)
 8005842:	2207      	movs	r2, #7
 8005844:	80da      	strh	r2, [r3, #6]
 8005846:	e00e      	b.n	8005866 <rtcSetLocalDataTime+0x196>
		} else {
			RTClock[0].Day = dt->Day - shift;
 8005848:	687b      	ldr	r3, [r7, #4]
 800584a:	88db      	ldrh	r3, [r3, #6]
 800584c:	b29a      	uxth	r2, r3
 800584e:	68fb      	ldr	r3, [r7, #12]
 8005850:	b29b      	uxth	r3, r3
 8005852:	1ad3      	subs	r3, r2, r3
 8005854:	b29a      	uxth	r2, r3
 8005856:	4b1f      	ldr	r3, [pc, #124]	; (80058d4 <rtcSetLocalDataTime+0x204>)
 8005858:	80da      	strh	r2, [r3, #6]
 800585a:	e004      	b.n	8005866 <rtcSetLocalDataTime+0x196>
		}
	} else {
		RTClock[0].Day = dt->Day;
 800585c:	687b      	ldr	r3, [r7, #4]
 800585e:	88db      	ldrh	r3, [r3, #6]
 8005860:	b29a      	uxth	r2, r3
 8005862:	4b1c      	ldr	r3, [pc, #112]	; (80058d4 <rtcSetLocalDataTime+0x204>)
 8005864:	80da      	strh	r2, [r3, #6]
	}

	if (shift == 1) {
 8005866:	68fb      	ldr	r3, [r7, #12]
 8005868:	2b01      	cmp	r3, #1
 800586a:	d11a      	bne.n	80058a2 <rtcSetLocalDataTime+0x1d2>
		if (dt->Data == 1) {
 800586c:	687b      	ldr	r3, [r7, #4]
 800586e:	889b      	ldrh	r3, [r3, #4]
 8005870:	b29b      	uxth	r3, r3
 8005872:	2b01      	cmp	r3, #1
 8005874:	d109      	bne.n	800588a <rtcSetLocalDataTime+0x1ba>
			RTClock[0].Data = month_day_table[dt->Month - 2];
 8005876:	687b      	ldr	r3, [r7, #4]
 8005878:	885b      	ldrh	r3, [r3, #2]
 800587a:	b29b      	uxth	r3, r3
 800587c:	3b02      	subs	r3, #2
 800587e:	4a16      	ldr	r2, [pc, #88]	; (80058d8 <rtcSetLocalDataTime+0x208>)
 8005880:	5cd3      	ldrb	r3, [r2, r3]
 8005882:	b29a      	uxth	r2, r3
 8005884:	4b13      	ldr	r3, [pc, #76]	; (80058d4 <rtcSetLocalDataTime+0x204>)
 8005886:	809a      	strh	r2, [r3, #4]
 8005888:	e010      	b.n	80058ac <rtcSetLocalDataTime+0x1dc>
		} else {
			RTClock[0].Data = dt->Data - shift;
 800588a:	687b      	ldr	r3, [r7, #4]
 800588c:	889b      	ldrh	r3, [r3, #4]
 800588e:	b29a      	uxth	r2, r3
 8005890:	68fb      	ldr	r3, [r7, #12]
 8005892:	b29b      	uxth	r3, r3
 8005894:	1ad3      	subs	r3, r2, r3
 8005896:	b29a      	uxth	r2, r3
 8005898:	4b0e      	ldr	r3, [pc, #56]	; (80058d4 <rtcSetLocalDataTime+0x204>)
 800589a:	809a      	strh	r2, [r3, #4]
			shift = 0;
 800589c:	2300      	movs	r3, #0
 800589e:	60fb      	str	r3, [r7, #12]
 80058a0:	e004      	b.n	80058ac <rtcSetLocalDataTime+0x1dc>
		}
	} else {
		RTClock[0].Data = dt->Data;
 80058a2:	687b      	ldr	r3, [r7, #4]
 80058a4:	889b      	ldrh	r3, [r3, #4]
 80058a6:	b29a      	uxth	r2, r3
 80058a8:	4b0a      	ldr	r3, [pc, #40]	; (80058d4 <rtcSetLocalDataTime+0x204>)
 80058aa:	809a      	strh	r2, [r3, #4]
	}

	RTClock[0].Month = dt->Month - shift;
 80058ac:	687b      	ldr	r3, [r7, #4]
 80058ae:	885b      	ldrh	r3, [r3, #2]
 80058b0:	b29a      	uxth	r2, r3
 80058b2:	68fb      	ldr	r3, [r7, #12]
 80058b4:	b29b      	uxth	r3, r3
 80058b6:	1ad3      	subs	r3, r2, r3
 80058b8:	b29a      	uxth	r2, r3
 80058ba:	4b06      	ldr	r3, [pc, #24]	; (80058d4 <rtcSetLocalDataTime+0x204>)
 80058bc:	805a      	strh	r2, [r3, #2]
	RTClock[0].Years = dt->Years;
 80058be:	687b      	ldr	r3, [r7, #4]
 80058c0:	881b      	ldrh	r3, [r3, #0]
 80058c2:	b29a      	uxth	r2, r3
 80058c4:	4b03      	ldr	r3, [pc, #12]	; (80058d4 <rtcSetLocalDataTime+0x204>)
 80058c6:	801a      	strh	r2, [r3, #0]
}
 80058c8:	bf00      	nop
 80058ca:	3710      	adds	r7, #16
 80058cc:	46bd      	mov	sp, r7
 80058ce:	bd80      	pop	{r7, pc}
 80058d0:	08004f39 	.word	0x08004f39
 80058d4:	200070d4 	.word	0x200070d4
 80058d8:	2000014c 	.word	0x2000014c

080058dc <itoaFix>:

//-----------------------------------------------------------

void itoaFix(int n, char s[]) {
 80058dc:	b480      	push	{r7}
 80058de:	b083      	sub	sp, #12
 80058e0:	af00      	add	r7, sp, #0
 80058e2:	6078      	str	r0, [r7, #4]
 80058e4:	6039      	str	r1, [r7, #0]
	n = n % 100;
 80058e6:	687b      	ldr	r3, [r7, #4]
 80058e8:	4a16      	ldr	r2, [pc, #88]	; (8005944 <itoaFix+0x68>)
 80058ea:	fb82 1203 	smull	r1, r2, r2, r3
 80058ee:	1151      	asrs	r1, r2, #5
 80058f0:	17da      	asrs	r2, r3, #31
 80058f2:	1a8a      	subs	r2, r1, r2
 80058f4:	2164      	movs	r1, #100	; 0x64
 80058f6:	fb01 f202 	mul.w	r2, r1, r2
 80058fa:	1a9b      	subs	r3, r3, r2
 80058fc:	607b      	str	r3, [r7, #4]

	s[0] = n / 10 + 48;
 80058fe:	687b      	ldr	r3, [r7, #4]
 8005900:	4a11      	ldr	r2, [pc, #68]	; (8005948 <itoaFix+0x6c>)
 8005902:	fb82 1203 	smull	r1, r2, r2, r3
 8005906:	1092      	asrs	r2, r2, #2
 8005908:	17db      	asrs	r3, r3, #31
 800590a:	1ad3      	subs	r3, r2, r3
 800590c:	b2db      	uxtb	r3, r3
 800590e:	3330      	adds	r3, #48	; 0x30
 8005910:	b2da      	uxtb	r2, r3
 8005912:	683b      	ldr	r3, [r7, #0]
 8005914:	701a      	strb	r2, [r3, #0]
	s[1] = n % 10 + 48;
 8005916:	687a      	ldr	r2, [r7, #4]
 8005918:	4b0b      	ldr	r3, [pc, #44]	; (8005948 <itoaFix+0x6c>)
 800591a:	fb83 1302 	smull	r1, r3, r3, r2
 800591e:	1099      	asrs	r1, r3, #2
 8005920:	17d3      	asrs	r3, r2, #31
 8005922:	1ac9      	subs	r1, r1, r3
 8005924:	460b      	mov	r3, r1
 8005926:	009b      	lsls	r3, r3, #2
 8005928:	440b      	add	r3, r1
 800592a:	005b      	lsls	r3, r3, #1
 800592c:	1ad1      	subs	r1, r2, r3
 800592e:	b2ca      	uxtb	r2, r1
 8005930:	683b      	ldr	r3, [r7, #0]
 8005932:	3301      	adds	r3, #1
 8005934:	3230      	adds	r2, #48	; 0x30
 8005936:	b2d2      	uxtb	r2, r2
 8005938:	701a      	strb	r2, [r3, #0]
}
 800593a:	bf00      	nop
 800593c:	370c      	adds	r7, #12
 800593e:	46bd      	mov	sp, r7
 8005940:	bc80      	pop	{r7}
 8005942:	4770      	bx	lr
 8005944:	51eb851f 	.word	0x51eb851f
 8005948:	66666667 	.word	0x66666667

0800594c <rtcGetiFixDateTime>:

void rtcGetiFixDateTime(char *dt) {
 800594c:	b580      	push	{r7, lr}
 800594e:	b08c      	sub	sp, #48	; 0x30
 8005950:	af00      	add	r7, sp, #0
 8005952:	6078      	str	r0, [r7, #4]
	char buffer[2];
	DATATIME dtC[2];

	dt[0] = 48;
 8005954:	687b      	ldr	r3, [r7, #4]
 8005956:	2230      	movs	r2, #48	; 0x30
 8005958:	701a      	strb	r2, [r3, #0]

	dt[1] = 49;
 800595a:	687b      	ldr	r3, [r7, #4]
 800595c:	3301      	adds	r3, #1
 800595e:	2231      	movs	r2, #49	; 0x31
 8005960:	701a      	strb	r2, [r3, #0]

	rtcGetDataTime(dtC);
 8005962:	f107 030c 	add.w	r3, r7, #12
 8005966:	4618      	mov	r0, r3
 8005968:	4b41      	ldr	r3, [pc, #260]	; (8005a70 <rtcGetiFixDateTime+0x124>)
 800596a:	4798      	blx	r3

	itoaFix(dtC->Years, buffer);
 800596c:	89bb      	ldrh	r3, [r7, #12]
 800596e:	461a      	mov	r2, r3
 8005970:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8005974:	4619      	mov	r1, r3
 8005976:	4610      	mov	r0, r2
 8005978:	4b3e      	ldr	r3, [pc, #248]	; (8005a74 <rtcGetiFixDateTime+0x128>)
 800597a:	4798      	blx	r3
	dt[2] = buffer[0];
 800597c:	687b      	ldr	r3, [r7, #4]
 800597e:	3302      	adds	r3, #2
 8005980:	f897 202c 	ldrb.w	r2, [r7, #44]	; 0x2c
 8005984:	701a      	strb	r2, [r3, #0]
	dt[3] = buffer[1];
 8005986:	687b      	ldr	r3, [r7, #4]
 8005988:	3303      	adds	r3, #3
 800598a:	f897 202d 	ldrb.w	r2, [r7, #45]	; 0x2d
 800598e:	701a      	strb	r2, [r3, #0]
	itoaFix(dtC->Month, buffer);
 8005990:	89fb      	ldrh	r3, [r7, #14]
 8005992:	461a      	mov	r2, r3
 8005994:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8005998:	4619      	mov	r1, r3
 800599a:	4610      	mov	r0, r2
 800599c:	4b35      	ldr	r3, [pc, #212]	; (8005a74 <rtcGetiFixDateTime+0x128>)
 800599e:	4798      	blx	r3
	dt[4] = buffer[0];
 80059a0:	687b      	ldr	r3, [r7, #4]
 80059a2:	3304      	adds	r3, #4
 80059a4:	f897 202c 	ldrb.w	r2, [r7, #44]	; 0x2c
 80059a8:	701a      	strb	r2, [r3, #0]
	dt[5] = buffer[1];
 80059aa:	687b      	ldr	r3, [r7, #4]
 80059ac:	3305      	adds	r3, #5
 80059ae:	f897 202d 	ldrb.w	r2, [r7, #45]	; 0x2d
 80059b2:	701a      	strb	r2, [r3, #0]
	itoaFix(dtC->Data, buffer);
 80059b4:	8a3b      	ldrh	r3, [r7, #16]
 80059b6:	461a      	mov	r2, r3
 80059b8:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 80059bc:	4619      	mov	r1, r3
 80059be:	4610      	mov	r0, r2
 80059c0:	4b2c      	ldr	r3, [pc, #176]	; (8005a74 <rtcGetiFixDateTime+0x128>)
 80059c2:	4798      	blx	r3
	dt[6] = buffer[0];
 80059c4:	687b      	ldr	r3, [r7, #4]
 80059c6:	3306      	adds	r3, #6
 80059c8:	f897 202c 	ldrb.w	r2, [r7, #44]	; 0x2c
 80059cc:	701a      	strb	r2, [r3, #0]
	dt[7] = buffer[1];
 80059ce:	687b      	ldr	r3, [r7, #4]
 80059d0:	3307      	adds	r3, #7
 80059d2:	f897 202d 	ldrb.w	r2, [r7, #45]	; 0x2d
 80059d6:	701a      	strb	r2, [r3, #0]
	itoaFix(dtC->Hour, buffer);
 80059d8:	8abb      	ldrh	r3, [r7, #20]
 80059da:	461a      	mov	r2, r3
 80059dc:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 80059e0:	4619      	mov	r1, r3
 80059e2:	4610      	mov	r0, r2
 80059e4:	4b23      	ldr	r3, [pc, #140]	; (8005a74 <rtcGetiFixDateTime+0x128>)
 80059e6:	4798      	blx	r3
	dt[8] = buffer[0];
 80059e8:	687b      	ldr	r3, [r7, #4]
 80059ea:	3308      	adds	r3, #8
 80059ec:	f897 202c 	ldrb.w	r2, [r7, #44]	; 0x2c
 80059f0:	701a      	strb	r2, [r3, #0]
	dt[9] = buffer[1];
 80059f2:	687b      	ldr	r3, [r7, #4]
 80059f4:	3309      	adds	r3, #9
 80059f6:	f897 202d 	ldrb.w	r2, [r7, #45]	; 0x2d
 80059fa:	701a      	strb	r2, [r3, #0]
	itoaFix(dtC->Min, buffer);
 80059fc:	8afb      	ldrh	r3, [r7, #22]
 80059fe:	461a      	mov	r2, r3
 8005a00:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8005a04:	4619      	mov	r1, r3
 8005a06:	4610      	mov	r0, r2
 8005a08:	4b1a      	ldr	r3, [pc, #104]	; (8005a74 <rtcGetiFixDateTime+0x128>)
 8005a0a:	4798      	blx	r3
	dt[10] = buffer[0];
 8005a0c:	687b      	ldr	r3, [r7, #4]
 8005a0e:	330a      	adds	r3, #10
 8005a10:	f897 202c 	ldrb.w	r2, [r7, #44]	; 0x2c
 8005a14:	701a      	strb	r2, [r3, #0]
	dt[11] = buffer[1];
 8005a16:	687b      	ldr	r3, [r7, #4]
 8005a18:	330b      	adds	r3, #11
 8005a1a:	f897 202d 	ldrb.w	r2, [r7, #45]	; 0x2d
 8005a1e:	701a      	strb	r2, [r3, #0]
	itoaFix(dtC->Sec, buffer);
 8005a20:	8b3b      	ldrh	r3, [r7, #24]
 8005a22:	461a      	mov	r2, r3
 8005a24:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8005a28:	4619      	mov	r1, r3
 8005a2a:	4610      	mov	r0, r2
 8005a2c:	4b11      	ldr	r3, [pc, #68]	; (8005a74 <rtcGetiFixDateTime+0x128>)
 8005a2e:	4798      	blx	r3
	dt[12] = buffer[0];
 8005a30:	687b      	ldr	r3, [r7, #4]
 8005a32:	330c      	adds	r3, #12
 8005a34:	f897 202c 	ldrb.w	r2, [r7, #44]	; 0x2c
 8005a38:	701a      	strb	r2, [r3, #0]
	dt[13] = buffer[1];
 8005a3a:	687b      	ldr	r3, [r7, #4]
 8005a3c:	330d      	adds	r3, #13
 8005a3e:	f897 202d 	ldrb.w	r2, [r7, #45]	; 0x2d
 8005a42:	701a      	strb	r2, [r3, #0]
	itoaFix(dtC->MSec, buffer);
 8005a44:	8b7b      	ldrh	r3, [r7, #26]
 8005a46:	461a      	mov	r2, r3
 8005a48:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 8005a4c:	4619      	mov	r1, r3
 8005a4e:	4610      	mov	r0, r2
 8005a50:	4b08      	ldr	r3, [pc, #32]	; (8005a74 <rtcGetiFixDateTime+0x128>)
 8005a52:	4798      	blx	r3
	dt[14] = buffer[0];
 8005a54:	687b      	ldr	r3, [r7, #4]
 8005a56:	330e      	adds	r3, #14
 8005a58:	f897 202c 	ldrb.w	r2, [r7, #44]	; 0x2c
 8005a5c:	701a      	strb	r2, [r3, #0]
	dt[15] = buffer[1];
 8005a5e:	687b      	ldr	r3, [r7, #4]
 8005a60:	330f      	adds	r3, #15
 8005a62:	f897 202d 	ldrb.w	r2, [r7, #45]	; 0x2d
 8005a66:	701a      	strb	r2, [r3, #0]
}
 8005a68:	bf00      	nop
 8005a6a:	3730      	adds	r7, #48	; 0x30
 8005a6c:	46bd      	mov	sp, r7
 8005a6e:	bd80      	pop	{r7, pc}
 8005a70:	0800548d 	.word	0x0800548d
 8005a74:	080058dd 	.word	0x080058dd

08005a78 <rtcSetiFixDateTime>:

void rtcSetiFixDateTime(char *dt) {
 8005a78:	b580      	push	{r7, lr}
 8005a7a:	b088      	sub	sp, #32
 8005a7c:	af00      	add	r7, sp, #0
 8005a7e:	6078      	str	r0, [r7, #4]
	char buffer[3];
	buffer[2] = 0;
 8005a80:	2300      	movs	r3, #0
 8005a82:	77bb      	strb	r3, [r7, #30]
	DATATIME dtC;

	if (dt[1] == 49)
 8005a84:	687b      	ldr	r3, [r7, #4]
 8005a86:	3301      	adds	r3, #1
 8005a88:	781b      	ldrb	r3, [r3, #0]
 8005a8a:	2b31      	cmp	r3, #49	; 0x31
 8005a8c:	d103      	bne.n	8005a96 <rtcSetiFixDateTime+0x1e>
		iFixLocal = true;
 8005a8e:	4b45      	ldr	r3, [pc, #276]	; (8005ba4 <rtcSetiFixDateTime+0x12c>)
 8005a90:	2201      	movs	r2, #1
 8005a92:	701a      	strb	r2, [r3, #0]
 8005a94:	e002      	b.n	8005a9c <rtcSetiFixDateTime+0x24>
	else
		iFixLocal = false;
 8005a96:	4b43      	ldr	r3, [pc, #268]	; (8005ba4 <rtcSetiFixDateTime+0x12c>)
 8005a98:	2200      	movs	r2, #0
 8005a9a:	701a      	strb	r2, [r3, #0]

	buffer[0] = dt[2];
 8005a9c:	687b      	ldr	r3, [r7, #4]
 8005a9e:	789b      	ldrb	r3, [r3, #2]
 8005aa0:	773b      	strb	r3, [r7, #28]
	buffer[1] = dt[3];
 8005aa2:	687b      	ldr	r3, [r7, #4]
 8005aa4:	78db      	ldrb	r3, [r3, #3]
 8005aa6:	777b      	strb	r3, [r7, #29]
	dtC.Years = atoi(buffer);
 8005aa8:	f107 031c 	add.w	r3, r7, #28
 8005aac:	4618      	mov	r0, r3
 8005aae:	4b3e      	ldr	r3, [pc, #248]	; (8005ba8 <rtcSetiFixDateTime+0x130>)
 8005ab0:	4798      	blx	r3
 8005ab2:	4603      	mov	r3, r0
 8005ab4:	b29b      	uxth	r3, r3
 8005ab6:	81bb      	strh	r3, [r7, #12]

	buffer[0] = dt[4];
 8005ab8:	687b      	ldr	r3, [r7, #4]
 8005aba:	791b      	ldrb	r3, [r3, #4]
 8005abc:	773b      	strb	r3, [r7, #28]
	buffer[1] = dt[5];
 8005abe:	687b      	ldr	r3, [r7, #4]
 8005ac0:	795b      	ldrb	r3, [r3, #5]
 8005ac2:	777b      	strb	r3, [r7, #29]
	dtC.Month = atoi(buffer);
 8005ac4:	f107 031c 	add.w	r3, r7, #28
 8005ac8:	4618      	mov	r0, r3
 8005aca:	4b37      	ldr	r3, [pc, #220]	; (8005ba8 <rtcSetiFixDateTime+0x130>)
 8005acc:	4798      	blx	r3
 8005ace:	4603      	mov	r3, r0
 8005ad0:	b29b      	uxth	r3, r3
 8005ad2:	81fb      	strh	r3, [r7, #14]

	buffer[0] = dt[6];
 8005ad4:	687b      	ldr	r3, [r7, #4]
 8005ad6:	799b      	ldrb	r3, [r3, #6]
 8005ad8:	773b      	strb	r3, [r7, #28]
	buffer[1] = dt[7];
 8005ada:	687b      	ldr	r3, [r7, #4]
 8005adc:	79db      	ldrb	r3, [r3, #7]
 8005ade:	777b      	strb	r3, [r7, #29]
	dtC.Data = atoi(buffer);
 8005ae0:	f107 031c 	add.w	r3, r7, #28
 8005ae4:	4618      	mov	r0, r3
 8005ae6:	4b30      	ldr	r3, [pc, #192]	; (8005ba8 <rtcSetiFixDateTime+0x130>)
 8005ae8:	4798      	blx	r3
 8005aea:	4603      	mov	r3, r0
 8005aec:	b29b      	uxth	r3, r3
 8005aee:	823b      	strh	r3, [r7, #16]

	buffer[0] = dt[8];
 8005af0:	687b      	ldr	r3, [r7, #4]
 8005af2:	7a1b      	ldrb	r3, [r3, #8]
 8005af4:	773b      	strb	r3, [r7, #28]
	buffer[1] = dt[9];
 8005af6:	687b      	ldr	r3, [r7, #4]
 8005af8:	7a5b      	ldrb	r3, [r3, #9]
 8005afa:	777b      	strb	r3, [r7, #29]
	dtC.Hour = atoi(buffer);
 8005afc:	f107 031c 	add.w	r3, r7, #28
 8005b00:	4618      	mov	r0, r3
 8005b02:	4b29      	ldr	r3, [pc, #164]	; (8005ba8 <rtcSetiFixDateTime+0x130>)
 8005b04:	4798      	blx	r3
 8005b06:	4603      	mov	r3, r0
 8005b08:	b29b      	uxth	r3, r3
 8005b0a:	82bb      	strh	r3, [r7, #20]

	buffer[0] = dt[10];
 8005b0c:	687b      	ldr	r3, [r7, #4]
 8005b0e:	7a9b      	ldrb	r3, [r3, #10]
 8005b10:	773b      	strb	r3, [r7, #28]
	buffer[1] = dt[11];
 8005b12:	687b      	ldr	r3, [r7, #4]
 8005b14:	7adb      	ldrb	r3, [r3, #11]
 8005b16:	777b      	strb	r3, [r7, #29]
	dtC.Min = atoi(buffer);
 8005b18:	f107 031c 	add.w	r3, r7, #28
 8005b1c:	4618      	mov	r0, r3
 8005b1e:	4b22      	ldr	r3, [pc, #136]	; (8005ba8 <rtcSetiFixDateTime+0x130>)
 8005b20:	4798      	blx	r3
 8005b22:	4603      	mov	r3, r0
 8005b24:	b29b      	uxth	r3, r3
 8005b26:	82fb      	strh	r3, [r7, #22]

	buffer[0] = dt[12];
 8005b28:	687b      	ldr	r3, [r7, #4]
 8005b2a:	7b1b      	ldrb	r3, [r3, #12]
 8005b2c:	773b      	strb	r3, [r7, #28]
	buffer[1] = dt[13];
 8005b2e:	687b      	ldr	r3, [r7, #4]
 8005b30:	7b5b      	ldrb	r3, [r3, #13]
 8005b32:	777b      	strb	r3, [r7, #29]
	dtC.Sec = atoi(buffer);
 8005b34:	f107 031c 	add.w	r3, r7, #28
 8005b38:	4618      	mov	r0, r3
 8005b3a:	4b1b      	ldr	r3, [pc, #108]	; (8005ba8 <rtcSetiFixDateTime+0x130>)
 8005b3c:	4798      	blx	r3
 8005b3e:	4603      	mov	r3, r0
 8005b40:	b29b      	uxth	r3, r3
 8005b42:	833b      	strh	r3, [r7, #24]

	buffer[0] = dt[14];
 8005b44:	687b      	ldr	r3, [r7, #4]
 8005b46:	7b9b      	ldrb	r3, [r3, #14]
 8005b48:	773b      	strb	r3, [r7, #28]
	buffer[1] = dt[15];
 8005b4a:	687b      	ldr	r3, [r7, #4]
 8005b4c:	7bdb      	ldrb	r3, [r3, #15]
 8005b4e:	777b      	strb	r3, [r7, #29]
	dtC.MSec = atoi(buffer);
 8005b50:	f107 031c 	add.w	r3, r7, #28
 8005b54:	4618      	mov	r0, r3
 8005b56:	4b14      	ldr	r3, [pc, #80]	; (8005ba8 <rtcSetiFixDateTime+0x130>)
 8005b58:	4798      	blx	r3
 8005b5a:	4603      	mov	r3, r0
 8005b5c:	b29b      	uxth	r3, r3
 8005b5e:	837b      	strh	r3, [r7, #26]

	if (dtC.Years > 70)
 8005b60:	89bb      	ldrh	r3, [r7, #12]
 8005b62:	2b46      	cmp	r3, #70	; 0x46
 8005b64:	d905      	bls.n	8005b72 <rtcSetiFixDateTime+0xfa>
		dtC.Years += 1900;
 8005b66:	89bb      	ldrh	r3, [r7, #12]
 8005b68:	f203 736c 	addw	r3, r3, #1900	; 0x76c
 8005b6c:	b29b      	uxth	r3, r3
 8005b6e:	81bb      	strh	r3, [r7, #12]
 8005b70:	e004      	b.n	8005b7c <rtcSetiFixDateTime+0x104>
	else
		dtC.Years += 2000;
 8005b72:	89bb      	ldrh	r3, [r7, #12]
 8005b74:	f503 63fa 	add.w	r3, r3, #2000	; 0x7d0
 8005b78:	b29b      	uxth	r3, r3
 8005b7a:	81bb      	strh	r3, [r7, #12]

	if (iFixLocal)
 8005b7c:	4b09      	ldr	r3, [pc, #36]	; (8005ba4 <rtcSetiFixDateTime+0x12c>)
 8005b7e:	781b      	ldrb	r3, [r3, #0]
 8005b80:	2b00      	cmp	r3, #0
 8005b82:	d005      	beq.n	8005b90 <rtcSetiFixDateTime+0x118>
		rtcSetLocalDataTime(&dtC);
 8005b84:	f107 030c 	add.w	r3, r7, #12
 8005b88:	4618      	mov	r0, r3
 8005b8a:	4b08      	ldr	r3, [pc, #32]	; (8005bac <rtcSetiFixDateTime+0x134>)
 8005b8c:	4798      	blx	r3
	else
		rtcSetDataTime(&dtC);
}
 8005b8e:	e004      	b.n	8005b9a <rtcSetiFixDateTime+0x122>
		rtcSetDataTime(&dtC);
 8005b90:	f107 030c 	add.w	r3, r7, #12
 8005b94:	4618      	mov	r0, r3
 8005b96:	4b06      	ldr	r3, [pc, #24]	; (8005bb0 <rtcSetiFixDateTime+0x138>)
 8005b98:	4798      	blx	r3
}
 8005b9a:	bf00      	nop
 8005b9c:	3720      	adds	r7, #32
 8005b9e:	46bd      	mov	sp, r7
 8005ba0:	bd80      	pop	{r7, pc}
 8005ba2:	bf00      	nop
 8005ba4:	200070f4 	.word	0x200070f4
 8005ba8:	0801457d 	.word	0x0801457d
 8005bac:	080056d1 	.word	0x080056d1
 8005bb0:	080054e5 	.word	0x080054e5

08005bb4 <I2C_Time_BufferRead>:
	CopyDataBytes((uint8*) overalBuff, (uint8*) aBuf, strlen(overalBuff) + 1);

}

/////////////////////   I2C///////////////////////////////////////////////////////////////////////////////
bool I2C_Time_BufferRead(u8 *pBuffer, u16 ReadAddr, u16 NumByteToRead) {
 8005bb4:	b580      	push	{r7, lr}
 8005bb6:	b086      	sub	sp, #24
 8005bb8:	af00      	add	r7, sp, #0
 8005bba:	6078      	str	r0, [r7, #4]
 8005bbc:	460b      	mov	r3, r1
 8005bbe:	807b      	strh	r3, [r7, #2]
 8005bc0:	4613      	mov	r3, r2
 8005bc2:	803b      	strh	r3, [r7, #0]
	if (initMK == 1) {
 8005bc4:	4b8f      	ldr	r3, [pc, #572]	; (8005e04 <I2C_Time_BufferRead+0x250>)
 8005bc6:	681b      	ldr	r3, [r3, #0]
 8005bc8:	2b01      	cmp	r3, #1
 8005bca:	f040 8117 	bne.w	8005dfc <I2C_Time_BufferRead+0x248>
		int counter = RETRY_NUMBER;
 8005bce:	f640 33b8 	movw	r3, #3000	; 0xbb8
 8005bd2:	617b      	str	r3, [r7, #20]
		vu16 SR_Tmp;
		/* While the bus is busy */
		while (I2C_GetFlagStatus(I2C1, I2C_FLAG_BUSY)) {
 8005bd4:	e00d      	b.n	8005bf2 <I2C_Time_BufferRead+0x3e>
			if (counter-- <= 0)
 8005bd6:	697b      	ldr	r3, [r7, #20]
 8005bd8:	1e5a      	subs	r2, r3, #1
 8005bda:	617a      	str	r2, [r7, #20]
 8005bdc:	2b00      	cmp	r3, #0
 8005bde:	dc08      	bgt.n	8005bf2 <I2C_Time_BufferRead+0x3e>
				return I2C_EE_Relaunch();
 8005be0:	4b89      	ldr	r3, [pc, #548]	; (8005e08 <I2C_Time_BufferRead+0x254>)
 8005be2:	4798      	blx	r3
 8005be4:	4603      	mov	r3, r0
 8005be6:	2b00      	cmp	r3, #0
 8005be8:	bf14      	ite	ne
 8005bea:	2301      	movne	r3, #1
 8005bec:	2300      	moveq	r3, #0
 8005bee:	b2db      	uxtb	r3, r3
 8005bf0:	e23a      	b.n	8006068 <I2C_Time_BufferRead+0x4b4>
		while (I2C_GetFlagStatus(I2C1, I2C_FLAG_BUSY)) {
 8005bf2:	f44f 3100 	mov.w	r1, #131072	; 0x20000
 8005bf6:	4885      	ldr	r0, [pc, #532]	; (8005e0c <I2C_Time_BufferRead+0x258>)
 8005bf8:	4b85      	ldr	r3, [pc, #532]	; (8005e10 <I2C_Time_BufferRead+0x25c>)
 8005bfa:	4798      	blx	r3
 8005bfc:	4603      	mov	r3, r0
 8005bfe:	2b00      	cmp	r3, #0
 8005c00:	d1e9      	bne.n	8005bd6 <I2C_Time_BufferRead+0x22>
		}
		BKP_WriteBackupRegister(BKP_DR7, 5);
 8005c02:	2105      	movs	r1, #5
 8005c04:	201c      	movs	r0, #28
 8005c06:	4b83      	ldr	r3, [pc, #524]	; (8005e14 <I2C_Time_BufferRead+0x260>)
 8005c08:	4798      	blx	r3
		/* Send START condition */
		I2C_GenerateSTART(I2C1, ENABLE);
 8005c0a:	2101      	movs	r1, #1
 8005c0c:	487f      	ldr	r0, [pc, #508]	; (8005e0c <I2C_Time_BufferRead+0x258>)
 8005c0e:	4b82      	ldr	r3, [pc, #520]	; (8005e18 <I2C_Time_BufferRead+0x264>)
 8005c10:	4798      	blx	r3

		/* Test on EV5 and clear it */
		counter = RETRY_NUMBER;
 8005c12:	f640 33b8 	movw	r3, #3000	; 0xbb8
 8005c16:	617b      	str	r3, [r7, #20]
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT)) {
 8005c18:	e00d      	b.n	8005c36 <I2C_Time_BufferRead+0x82>
			if (counter-- <= 0)
 8005c1a:	697b      	ldr	r3, [r7, #20]
 8005c1c:	1e5a      	subs	r2, r3, #1
 8005c1e:	617a      	str	r2, [r7, #20]
 8005c20:	2b00      	cmp	r3, #0
 8005c22:	dc08      	bgt.n	8005c36 <I2C_Time_BufferRead+0x82>
				return I2C_EE_Relaunch();
 8005c24:	4b78      	ldr	r3, [pc, #480]	; (8005e08 <I2C_Time_BufferRead+0x254>)
 8005c26:	4798      	blx	r3
 8005c28:	4603      	mov	r3, r0
 8005c2a:	2b00      	cmp	r3, #0
 8005c2c:	bf14      	ite	ne
 8005c2e:	2301      	movne	r3, #1
 8005c30:	2300      	moveq	r3, #0
 8005c32:	b2db      	uxtb	r3, r3
 8005c34:	e218      	b.n	8006068 <I2C_Time_BufferRead+0x4b4>
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT)) {
 8005c36:	4979      	ldr	r1, [pc, #484]	; (8005e1c <I2C_Time_BufferRead+0x268>)
 8005c38:	4874      	ldr	r0, [pc, #464]	; (8005e0c <I2C_Time_BufferRead+0x258>)
 8005c3a:	4b79      	ldr	r3, [pc, #484]	; (8005e20 <I2C_Time_BufferRead+0x26c>)
 8005c3c:	4798      	blx	r3
 8005c3e:	4603      	mov	r3, r0
 8005c40:	2b00      	cmp	r3, #0
 8005c42:	d0ea      	beq.n	8005c1a <I2C_Time_BufferRead+0x66>
		}
		BKP_WriteBackupRegister(BKP_DR7, 6);
 8005c44:	2106      	movs	r1, #6
 8005c46:	201c      	movs	r0, #28
 8005c48:	4b72      	ldr	r3, [pc, #456]	; (8005e14 <I2C_Time_BufferRead+0x260>)
 8005c4a:	4798      	blx	r3
		/* Send EEPROM address for write */
		I2C_Send7bitAddress(I2C1, 0xD0, I2C_Direction_Transmitter);
 8005c4c:	2200      	movs	r2, #0
 8005c4e:	21d0      	movs	r1, #208	; 0xd0
 8005c50:	486e      	ldr	r0, [pc, #440]	; (8005e0c <I2C_Time_BufferRead+0x258>)
 8005c52:	4b74      	ldr	r3, [pc, #464]	; (8005e24 <I2C_Time_BufferRead+0x270>)
 8005c54:	4798      	blx	r3

		/* Test on EV6 and clear it */
		counter = RETRY_NUMBER;
 8005c56:	f640 33b8 	movw	r3, #3000	; 0xbb8
 8005c5a:	617b      	str	r3, [r7, #20]
		BKP_WriteBackupRegister(BKP_DR7, 7);
 8005c5c:	2107      	movs	r1, #7
 8005c5e:	201c      	movs	r0, #28
 8005c60:	4b6c      	ldr	r3, [pc, #432]	; (8005e14 <I2C_Time_BufferRead+0x260>)
 8005c62:	4798      	blx	r3
		/*while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED)) {
			if (counter-- <= 0)
				return I2C_EE_Relaunch();
		}*/
		  while(!I2C_GetFlagStatus(I2C1, I2C_FLAG_ADDR))
 8005c64:	e00d      	b.n	8005c82 <I2C_Time_BufferRead+0xce>
		  {
		  	  if(counter-- <= 0) return I2C_EE_Relaunch();
 8005c66:	697b      	ldr	r3, [r7, #20]
 8005c68:	1e5a      	subs	r2, r3, #1
 8005c6a:	617a      	str	r2, [r7, #20]
 8005c6c:	2b00      	cmp	r3, #0
 8005c6e:	dc08      	bgt.n	8005c82 <I2C_Time_BufferRead+0xce>
 8005c70:	4b65      	ldr	r3, [pc, #404]	; (8005e08 <I2C_Time_BufferRead+0x254>)
 8005c72:	4798      	blx	r3
 8005c74:	4603      	mov	r3, r0
 8005c76:	2b00      	cmp	r3, #0
 8005c78:	bf14      	ite	ne
 8005c7a:	2301      	movne	r3, #1
 8005c7c:	2300      	moveq	r3, #0
 8005c7e:	b2db      	uxtb	r3, r3
 8005c80:	e1f2      	b.n	8006068 <I2C_Time_BufferRead+0x4b4>
		  while(!I2C_GetFlagStatus(I2C1, I2C_FLAG_ADDR))
 8005c82:	4969      	ldr	r1, [pc, #420]	; (8005e28 <I2C_Time_BufferRead+0x274>)
 8005c84:	4861      	ldr	r0, [pc, #388]	; (8005e0c <I2C_Time_BufferRead+0x258>)
 8005c86:	4b62      	ldr	r3, [pc, #392]	; (8005e10 <I2C_Time_BufferRead+0x25c>)
 8005c88:	4798      	blx	r3
 8005c8a:	4603      	mov	r3, r0
 8005c8c:	2b00      	cmp	r3, #0
 8005c8e:	d0ea      	beq.n	8005c66 <I2C_Time_BufferRead+0xb2>
		    }

		  /* Read I2C1 SR1 register*/
		  SR_Tmp = I2C_ReadRegister(I2C1, I2C_Register_SR1);
 8005c90:	2114      	movs	r1, #20
 8005c92:	485e      	ldr	r0, [pc, #376]	; (8005e0c <I2C_Time_BufferRead+0x258>)
 8005c94:	4b65      	ldr	r3, [pc, #404]	; (8005e2c <I2C_Time_BufferRead+0x278>)
 8005c96:	4798      	blx	r3
 8005c98:	4603      	mov	r3, r0
 8005c9a:	81fb      	strh	r3, [r7, #14]



		/* Clear EV6 by setting again the PE bit */
		I2C_Cmd(I2C1, ENABLE);
 8005c9c:	2101      	movs	r1, #1
 8005c9e:	485b      	ldr	r0, [pc, #364]	; (8005e0c <I2C_Time_BufferRead+0x258>)
 8005ca0:	4b63      	ldr	r3, [pc, #396]	; (8005e30 <I2C_Time_BufferRead+0x27c>)
 8005ca2:	4798      	blx	r3
		BKP_WriteBackupRegister(BKP_DR7, 8);
 8005ca4:	2108      	movs	r1, #8
 8005ca6:	201c      	movs	r0, #28
 8005ca8:	4b5a      	ldr	r3, [pc, #360]	; (8005e14 <I2C_Time_BufferRead+0x260>)
 8005caa:	4798      	blx	r3
		I2C_SendData(I2C1, ReadAddr & 0xFF);
 8005cac:	887b      	ldrh	r3, [r7, #2]
 8005cae:	b2db      	uxtb	r3, r3
 8005cb0:	4619      	mov	r1, r3
 8005cb2:	4856      	ldr	r0, [pc, #344]	; (8005e0c <I2C_Time_BufferRead+0x258>)
 8005cb4:	4b5f      	ldr	r3, [pc, #380]	; (8005e34 <I2C_Time_BufferRead+0x280>)
 8005cb6:	4798      	blx	r3

		/* Test on EV8 and clear it */
		counter = RETRY_NUMBER;
 8005cb8:	f640 33b8 	movw	r3, #3000	; 0xbb8
 8005cbc:	617b      	str	r3, [r7, #20]
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED)) {
 8005cbe:	e00d      	b.n	8005cdc <I2C_Time_BufferRead+0x128>
			if (counter-- <= 0)
 8005cc0:	697b      	ldr	r3, [r7, #20]
 8005cc2:	1e5a      	subs	r2, r3, #1
 8005cc4:	617a      	str	r2, [r7, #20]
 8005cc6:	2b00      	cmp	r3, #0
 8005cc8:	dc08      	bgt.n	8005cdc <I2C_Time_BufferRead+0x128>
				return I2C_EE_Relaunch();
 8005cca:	4b4f      	ldr	r3, [pc, #316]	; (8005e08 <I2C_Time_BufferRead+0x254>)
 8005ccc:	4798      	blx	r3
 8005cce:	4603      	mov	r3, r0
 8005cd0:	2b00      	cmp	r3, #0
 8005cd2:	bf14      	ite	ne
 8005cd4:	2301      	movne	r3, #1
 8005cd6:	2300      	moveq	r3, #0
 8005cd8:	b2db      	uxtb	r3, r3
 8005cda:	e1c5      	b.n	8006068 <I2C_Time_BufferRead+0x4b4>
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED)) {
 8005cdc:	4956      	ldr	r1, [pc, #344]	; (8005e38 <I2C_Time_BufferRead+0x284>)
 8005cde:	484b      	ldr	r0, [pc, #300]	; (8005e0c <I2C_Time_BufferRead+0x258>)
 8005ce0:	4b4f      	ldr	r3, [pc, #316]	; (8005e20 <I2C_Time_BufferRead+0x26c>)
 8005ce2:	4798      	blx	r3
 8005ce4:	4603      	mov	r3, r0
 8005ce6:	2b00      	cmp	r3, #0
 8005ce8:	d0ea      	beq.n	8005cc0 <I2C_Time_BufferRead+0x10c>
		}
		BKP_WriteBackupRegister(BKP_DR7, 9);
 8005cea:	2109      	movs	r1, #9
 8005cec:	201c      	movs	r0, #28
 8005cee:	4b49      	ldr	r3, [pc, #292]	; (8005e14 <I2C_Time_BufferRead+0x260>)
 8005cf0:	4798      	blx	r3
		/* Send STRAT condition a second time */
		I2C_GenerateSTART(I2C1, ENABLE);
 8005cf2:	2101      	movs	r1, #1
 8005cf4:	4845      	ldr	r0, [pc, #276]	; (8005e0c <I2C_Time_BufferRead+0x258>)
 8005cf6:	4b48      	ldr	r3, [pc, #288]	; (8005e18 <I2C_Time_BufferRead+0x264>)
 8005cf8:	4798      	blx	r3

		/* Test on EV5 and clear it */
		counter = RETRY_NUMBER;
 8005cfa:	f640 33b8 	movw	r3, #3000	; 0xbb8
 8005cfe:	617b      	str	r3, [r7, #20]
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT)) {
 8005d00:	e00d      	b.n	8005d1e <I2C_Time_BufferRead+0x16a>
			if (counter-- <= 0)
 8005d02:	697b      	ldr	r3, [r7, #20]
 8005d04:	1e5a      	subs	r2, r3, #1
 8005d06:	617a      	str	r2, [r7, #20]
 8005d08:	2b00      	cmp	r3, #0
 8005d0a:	dc08      	bgt.n	8005d1e <I2C_Time_BufferRead+0x16a>
				return I2C_EE_Relaunch();
 8005d0c:	4b3e      	ldr	r3, [pc, #248]	; (8005e08 <I2C_Time_BufferRead+0x254>)
 8005d0e:	4798      	blx	r3
 8005d10:	4603      	mov	r3, r0
 8005d12:	2b00      	cmp	r3, #0
 8005d14:	bf14      	ite	ne
 8005d16:	2301      	movne	r3, #1
 8005d18:	2300      	moveq	r3, #0
 8005d1a:	b2db      	uxtb	r3, r3
 8005d1c:	e1a4      	b.n	8006068 <I2C_Time_BufferRead+0x4b4>
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT)) {
 8005d1e:	493f      	ldr	r1, [pc, #252]	; (8005e1c <I2C_Time_BufferRead+0x268>)
 8005d20:	483a      	ldr	r0, [pc, #232]	; (8005e0c <I2C_Time_BufferRead+0x258>)
 8005d22:	4b3f      	ldr	r3, [pc, #252]	; (8005e20 <I2C_Time_BufferRead+0x26c>)
 8005d24:	4798      	blx	r3
 8005d26:	4603      	mov	r3, r0
 8005d28:	2b00      	cmp	r3, #0
 8005d2a:	d0ea      	beq.n	8005d02 <I2C_Time_BufferRead+0x14e>
		}
		BKP_WriteBackupRegister(BKP_DR7, 9);
 8005d2c:	2109      	movs	r1, #9
 8005d2e:	201c      	movs	r0, #28
 8005d30:	4b38      	ldr	r3, [pc, #224]	; (8005e14 <I2C_Time_BufferRead+0x260>)
 8005d32:	4798      	blx	r3
		/* Send EEPROM address for read */
		I2C_Send7bitAddress(I2C1, 0xD0, I2C_Direction_Receiver);
 8005d34:	2201      	movs	r2, #1
 8005d36:	21d0      	movs	r1, #208	; 0xd0
 8005d38:	4834      	ldr	r0, [pc, #208]	; (8005e0c <I2C_Time_BufferRead+0x258>)
 8005d3a:	4b3a      	ldr	r3, [pc, #232]	; (8005e24 <I2C_Time_BufferRead+0x270>)
 8005d3c:	4798      	blx	r3

		/* Test on EV6 and clear it */
		counter = RETRY_NUMBER;
 8005d3e:	f640 33b8 	movw	r3, #3000	; 0xbb8
 8005d42:	617b      	str	r3, [r7, #20]
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED)) {
 8005d44:	e00d      	b.n	8005d62 <I2C_Time_BufferRead+0x1ae>
			if (counter-- <= 0)
 8005d46:	697b      	ldr	r3, [r7, #20]
 8005d48:	1e5a      	subs	r2, r3, #1
 8005d4a:	617a      	str	r2, [r7, #20]
 8005d4c:	2b00      	cmp	r3, #0
 8005d4e:	dc08      	bgt.n	8005d62 <I2C_Time_BufferRead+0x1ae>
				return I2C_EE_Relaunch();
 8005d50:	4b2d      	ldr	r3, [pc, #180]	; (8005e08 <I2C_Time_BufferRead+0x254>)
 8005d52:	4798      	blx	r3
 8005d54:	4603      	mov	r3, r0
 8005d56:	2b00      	cmp	r3, #0
 8005d58:	bf14      	ite	ne
 8005d5a:	2301      	movne	r3, #1
 8005d5c:	2300      	moveq	r3, #0
 8005d5e:	b2db      	uxtb	r3, r3
 8005d60:	e182      	b.n	8006068 <I2C_Time_BufferRead+0x4b4>
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED)) {
 8005d62:	4936      	ldr	r1, [pc, #216]	; (8005e3c <I2C_Time_BufferRead+0x288>)
 8005d64:	4829      	ldr	r0, [pc, #164]	; (8005e0c <I2C_Time_BufferRead+0x258>)
 8005d66:	4b2e      	ldr	r3, [pc, #184]	; (8005e20 <I2C_Time_BufferRead+0x26c>)
 8005d68:	4798      	blx	r3
 8005d6a:	4603      	mov	r3, r0
 8005d6c:	2b00      	cmp	r3, #0
 8005d6e:	d0ea      	beq.n	8005d46 <I2C_Time_BufferRead+0x192>
		}
		BKP_WriteBackupRegister(BKP_DR7, 10);
 8005d70:	210a      	movs	r1, #10
 8005d72:	201c      	movs	r0, #28
 8005d74:	4b27      	ldr	r3, [pc, #156]	; (8005e14 <I2C_Time_BufferRead+0x260>)
 8005d76:	4798      	blx	r3
		/* While there is data to be read */
		counter = RETRY_NUMBER;
 8005d78:	f640 33b8 	movw	r3, #3000	; 0xbb8
 8005d7c:	617b      	str	r3, [r7, #20]
		while (NumByteToRead) {
 8005d7e:	e030      	b.n	8005de2 <I2C_Time_BufferRead+0x22e>
			if (NumByteToRead == 1) {
 8005d80:	883b      	ldrh	r3, [r7, #0]
 8005d82:	2b01      	cmp	r3, #1
 8005d84:	d107      	bne.n	8005d96 <I2C_Time_BufferRead+0x1e2>
				/* Disable Acknowledgement */
				I2C_AcknowledgeConfig(I2C1, DISABLE);
 8005d86:	2100      	movs	r1, #0
 8005d88:	4820      	ldr	r0, [pc, #128]	; (8005e0c <I2C_Time_BufferRead+0x258>)
 8005d8a:	4b2d      	ldr	r3, [pc, #180]	; (8005e40 <I2C_Time_BufferRead+0x28c>)
 8005d8c:	4798      	blx	r3

				/* Send STOP Condition */
				I2C_GenerateSTOP(I2C1, ENABLE);
 8005d8e:	2101      	movs	r1, #1
 8005d90:	481e      	ldr	r0, [pc, #120]	; (8005e0c <I2C_Time_BufferRead+0x258>)
 8005d92:	4b2c      	ldr	r3, [pc, #176]	; (8005e44 <I2C_Time_BufferRead+0x290>)
 8005d94:	4798      	blx	r3
			}
			BKP_WriteBackupRegister(BKP_DR7, 11);
 8005d96:	210b      	movs	r1, #11
 8005d98:	201c      	movs	r0, #28
 8005d9a:	4b1e      	ldr	r3, [pc, #120]	; (8005e14 <I2C_Time_BufferRead+0x260>)
 8005d9c:	4798      	blx	r3
			/* Test on EV7 and clear it */
			if (I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_RECEIVED)) {
 8005d9e:	492a      	ldr	r1, [pc, #168]	; (8005e48 <I2C_Time_BufferRead+0x294>)
 8005da0:	481a      	ldr	r0, [pc, #104]	; (8005e0c <I2C_Time_BufferRead+0x258>)
 8005da2:	4b1f      	ldr	r3, [pc, #124]	; (8005e20 <I2C_Time_BufferRead+0x26c>)
 8005da4:	4798      	blx	r3
 8005da6:	4603      	mov	r3, r0
 8005da8:	2b00      	cmp	r3, #0
 8005daa:	d00c      	beq.n	8005dc6 <I2C_Time_BufferRead+0x212>
				/* Read a byte from the EEPROM */
				*pBuffer = I2C_ReceiveData(I2C1);
 8005dac:	4817      	ldr	r0, [pc, #92]	; (8005e0c <I2C_Time_BufferRead+0x258>)
 8005dae:	4b27      	ldr	r3, [pc, #156]	; (8005e4c <I2C_Time_BufferRead+0x298>)
 8005db0:	4798      	blx	r3
 8005db2:	4603      	mov	r3, r0
 8005db4:	461a      	mov	r2, r3
 8005db6:	687b      	ldr	r3, [r7, #4]
 8005db8:	701a      	strb	r2, [r3, #0]

				/* Point to the next location where the byte read will be saved */
				pBuffer++;
 8005dba:	687b      	ldr	r3, [r7, #4]
 8005dbc:	3301      	adds	r3, #1
 8005dbe:	607b      	str	r3, [r7, #4]

				/* Decrement the read bytes counter */
				NumByteToRead--;
 8005dc0:	883b      	ldrh	r3, [r7, #0]
 8005dc2:	3b01      	subs	r3, #1
 8005dc4:	803b      	strh	r3, [r7, #0]

			}
			if (counter-- <= 0)
 8005dc6:	697b      	ldr	r3, [r7, #20]
 8005dc8:	1e5a      	subs	r2, r3, #1
 8005dca:	617a      	str	r2, [r7, #20]
 8005dcc:	2b00      	cmp	r3, #0
 8005dce:	dc08      	bgt.n	8005de2 <I2C_Time_BufferRead+0x22e>
				return I2C_EE_Relaunch();
 8005dd0:	4b0d      	ldr	r3, [pc, #52]	; (8005e08 <I2C_Time_BufferRead+0x254>)
 8005dd2:	4798      	blx	r3
 8005dd4:	4603      	mov	r3, r0
 8005dd6:	2b00      	cmp	r3, #0
 8005dd8:	bf14      	ite	ne
 8005dda:	2301      	movne	r3, #1
 8005ddc:	2300      	moveq	r3, #0
 8005dde:	b2db      	uxtb	r3, r3
 8005de0:	e142      	b.n	8006068 <I2C_Time_BufferRead+0x4b4>
		while (NumByteToRead) {
 8005de2:	883b      	ldrh	r3, [r7, #0]
 8005de4:	2b00      	cmp	r3, #0
 8005de6:	d1cb      	bne.n	8005d80 <I2C_Time_BufferRead+0x1cc>
		}
		BKP_WriteBackupRegister(BKP_DR7, 12);
 8005de8:	210c      	movs	r1, #12
 8005dea:	201c      	movs	r0, #28
 8005dec:	4b09      	ldr	r3, [pc, #36]	; (8005e14 <I2C_Time_BufferRead+0x260>)
 8005dee:	4798      	blx	r3
		/* Enable Acknowledgement to be ready for another reception */
		I2C_AcknowledgeConfig(I2C1, ENABLE);
 8005df0:	2101      	movs	r1, #1
 8005df2:	4806      	ldr	r0, [pc, #24]	; (8005e0c <I2C_Time_BufferRead+0x258>)
 8005df4:	4b12      	ldr	r3, [pc, #72]	; (8005e40 <I2C_Time_BufferRead+0x28c>)
 8005df6:	4798      	blx	r3
		return true;
 8005df8:	2301      	movs	r3, #1
 8005dfa:	e135      	b.n	8006068 <I2C_Time_BufferRead+0x4b4>

	} else {
		int counter = RETRY_NUMBER;
 8005dfc:	f640 33b8 	movw	r3, #3000	; 0xbb8
 8005e00:	613b      	str	r3, [r7, #16]
		/* While the bus is busy */
		while (I2C_GetFlagStatus(I2C1, I2C_FLAG_BUSY)) {
 8005e02:	e033      	b.n	8005e6c <I2C_Time_BufferRead+0x2b8>
 8005e04:	20007194 	.word	0x20007194
 8005e08:	080120b1 	.word	0x080120b1
 8005e0c:	40005400 	.word	0x40005400
 8005e10:	0800401d 	.word	0x0800401d
 8005e14:	08003621 	.word	0x08003621
 8005e18:	08003de3 	.word	0x08003de3
 8005e1c:	00030001 	.word	0x00030001
 8005e20:	08003fc3 	.word	0x08003fc3
 8005e24:	08003f1b 	.word	0x08003f1b
 8005e28:	10000002 	.word	0x10000002
 8005e2c:	08003f55 	.word	0x08003f55
 8005e30:	08003da5 	.word	0x08003da5
 8005e34:	08003ee3 	.word	0x08003ee3
 8005e38:	00070084 	.word	0x00070084
 8005e3c:	00030002 	.word	0x00030002
 8005e40:	08003e5f 	.word	0x08003e5f
 8005e44:	08003e21 	.word	0x08003e21
 8005e48:	00030040 	.word	0x00030040
 8005e4c:	08003f01 	.word	0x08003f01
			if (counter-- <= 0)
 8005e50:	693b      	ldr	r3, [r7, #16]
 8005e52:	1e5a      	subs	r2, r3, #1
 8005e54:	613a      	str	r2, [r7, #16]
 8005e56:	2b00      	cmp	r3, #0
 8005e58:	dc08      	bgt.n	8005e6c <I2C_Time_BufferRead+0x2b8>
				return I2C_EE_Relaunch();
 8005e5a:	4b85      	ldr	r3, [pc, #532]	; (8006070 <I2C_Time_BufferRead+0x4bc>)
 8005e5c:	4798      	blx	r3
 8005e5e:	4603      	mov	r3, r0
 8005e60:	2b00      	cmp	r3, #0
 8005e62:	bf14      	ite	ne
 8005e64:	2301      	movne	r3, #1
 8005e66:	2300      	moveq	r3, #0
 8005e68:	b2db      	uxtb	r3, r3
 8005e6a:	e0fd      	b.n	8006068 <I2C_Time_BufferRead+0x4b4>
		while (I2C_GetFlagStatus(I2C1, I2C_FLAG_BUSY)) {
 8005e6c:	f44f 3100 	mov.w	r1, #131072	; 0x20000
 8005e70:	4880      	ldr	r0, [pc, #512]	; (8006074 <I2C_Time_BufferRead+0x4c0>)
 8005e72:	4b81      	ldr	r3, [pc, #516]	; (8006078 <I2C_Time_BufferRead+0x4c4>)
 8005e74:	4798      	blx	r3
 8005e76:	4603      	mov	r3, r0
 8005e78:	2b00      	cmp	r3, #0
 8005e7a:	d1e9      	bne.n	8005e50 <I2C_Time_BufferRead+0x29c>
		}
		BKP_WriteBackupRegister(BKP_DR7, 5);
 8005e7c:	2105      	movs	r1, #5
 8005e7e:	201c      	movs	r0, #28
 8005e80:	4b7e      	ldr	r3, [pc, #504]	; (800607c <I2C_Time_BufferRead+0x4c8>)
 8005e82:	4798      	blx	r3
		/* Send START condition */
		I2C_GenerateSTART(I2C1, ENABLE);
 8005e84:	2101      	movs	r1, #1
 8005e86:	487b      	ldr	r0, [pc, #492]	; (8006074 <I2C_Time_BufferRead+0x4c0>)
 8005e88:	4b7d      	ldr	r3, [pc, #500]	; (8006080 <I2C_Time_BufferRead+0x4cc>)
 8005e8a:	4798      	blx	r3

		/* Test on EV5 and clear it */
		counter = RETRY_NUMBER;
 8005e8c:	f640 33b8 	movw	r3, #3000	; 0xbb8
 8005e90:	613b      	str	r3, [r7, #16]
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT)) {
 8005e92:	e00d      	b.n	8005eb0 <I2C_Time_BufferRead+0x2fc>
			if (counter-- <= 0)
 8005e94:	693b      	ldr	r3, [r7, #16]
 8005e96:	1e5a      	subs	r2, r3, #1
 8005e98:	613a      	str	r2, [r7, #16]
 8005e9a:	2b00      	cmp	r3, #0
 8005e9c:	dc08      	bgt.n	8005eb0 <I2C_Time_BufferRead+0x2fc>
				return I2C_EE_Relaunch();
 8005e9e:	4b74      	ldr	r3, [pc, #464]	; (8006070 <I2C_Time_BufferRead+0x4bc>)
 8005ea0:	4798      	blx	r3
 8005ea2:	4603      	mov	r3, r0
 8005ea4:	2b00      	cmp	r3, #0
 8005ea6:	bf14      	ite	ne
 8005ea8:	2301      	movne	r3, #1
 8005eaa:	2300      	moveq	r3, #0
 8005eac:	b2db      	uxtb	r3, r3
 8005eae:	e0db      	b.n	8006068 <I2C_Time_BufferRead+0x4b4>
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT)) {
 8005eb0:	4974      	ldr	r1, [pc, #464]	; (8006084 <I2C_Time_BufferRead+0x4d0>)
 8005eb2:	4870      	ldr	r0, [pc, #448]	; (8006074 <I2C_Time_BufferRead+0x4c0>)
 8005eb4:	4b74      	ldr	r3, [pc, #464]	; (8006088 <I2C_Time_BufferRead+0x4d4>)
 8005eb6:	4798      	blx	r3
 8005eb8:	4603      	mov	r3, r0
 8005eba:	2b00      	cmp	r3, #0
 8005ebc:	d0ea      	beq.n	8005e94 <I2C_Time_BufferRead+0x2e0>
		}
		BKP_WriteBackupRegister(BKP_DR7, 6);
 8005ebe:	2106      	movs	r1, #6
 8005ec0:	201c      	movs	r0, #28
 8005ec2:	4b6e      	ldr	r3, [pc, #440]	; (800607c <I2C_Time_BufferRead+0x4c8>)
 8005ec4:	4798      	blx	r3
		/* Send EEPROM address for write */
		I2C_Send7bitAddress(I2C1, 0xD0, I2C_Direction_Transmitter);
 8005ec6:	2200      	movs	r2, #0
 8005ec8:	21d0      	movs	r1, #208	; 0xd0
 8005eca:	486a      	ldr	r0, [pc, #424]	; (8006074 <I2C_Time_BufferRead+0x4c0>)
 8005ecc:	4b6f      	ldr	r3, [pc, #444]	; (800608c <I2C_Time_BufferRead+0x4d8>)
 8005ece:	4798      	blx	r3

		/* Test on EV6 and clear it */
		counter = RETRY_NUMBER;
 8005ed0:	f640 33b8 	movw	r3, #3000	; 0xbb8
 8005ed4:	613b      	str	r3, [r7, #16]
		BKP_WriteBackupRegister(BKP_DR7, 7);
 8005ed6:	2107      	movs	r1, #7
 8005ed8:	201c      	movs	r0, #28
 8005eda:	4b68      	ldr	r3, [pc, #416]	; (800607c <I2C_Time_BufferRead+0x4c8>)
 8005edc:	4798      	blx	r3
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED)) {
 8005ede:	e00d      	b.n	8005efc <I2C_Time_BufferRead+0x348>
			if (counter-- <= 0)
 8005ee0:	693b      	ldr	r3, [r7, #16]
 8005ee2:	1e5a      	subs	r2, r3, #1
 8005ee4:	613a      	str	r2, [r7, #16]
 8005ee6:	2b00      	cmp	r3, #0
 8005ee8:	dc08      	bgt.n	8005efc <I2C_Time_BufferRead+0x348>
				return I2C_EE_Relaunch();
 8005eea:	4b61      	ldr	r3, [pc, #388]	; (8006070 <I2C_Time_BufferRead+0x4bc>)
 8005eec:	4798      	blx	r3
 8005eee:	4603      	mov	r3, r0
 8005ef0:	2b00      	cmp	r3, #0
 8005ef2:	bf14      	ite	ne
 8005ef4:	2301      	movne	r3, #1
 8005ef6:	2300      	moveq	r3, #0
 8005ef8:	b2db      	uxtb	r3, r3
 8005efa:	e0b5      	b.n	8006068 <I2C_Time_BufferRead+0x4b4>
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED)) {
 8005efc:	4964      	ldr	r1, [pc, #400]	; (8006090 <I2C_Time_BufferRead+0x4dc>)
 8005efe:	485d      	ldr	r0, [pc, #372]	; (8006074 <I2C_Time_BufferRead+0x4c0>)
 8005f00:	4b61      	ldr	r3, [pc, #388]	; (8006088 <I2C_Time_BufferRead+0x4d4>)
 8005f02:	4798      	blx	r3
 8005f04:	4603      	mov	r3, r0
 8005f06:	2b00      	cmp	r3, #0
 8005f08:	d0ea      	beq.n	8005ee0 <I2C_Time_BufferRead+0x32c>
		}

		/* Clear EV6 by setting again the PE bit */
		I2C_Cmd(I2C1, ENABLE);
 8005f0a:	2101      	movs	r1, #1
 8005f0c:	4859      	ldr	r0, [pc, #356]	; (8006074 <I2C_Time_BufferRead+0x4c0>)
 8005f0e:	4b61      	ldr	r3, [pc, #388]	; (8006094 <I2C_Time_BufferRead+0x4e0>)
 8005f10:	4798      	blx	r3
		BKP_WriteBackupRegister(BKP_DR7, 8);
 8005f12:	2108      	movs	r1, #8
 8005f14:	201c      	movs	r0, #28
 8005f16:	4b59      	ldr	r3, [pc, #356]	; (800607c <I2C_Time_BufferRead+0x4c8>)
 8005f18:	4798      	blx	r3
		I2C_SendData(I2C1, ReadAddr & 0xFF);
 8005f1a:	887b      	ldrh	r3, [r7, #2]
 8005f1c:	b2db      	uxtb	r3, r3
 8005f1e:	4619      	mov	r1, r3
 8005f20:	4854      	ldr	r0, [pc, #336]	; (8006074 <I2C_Time_BufferRead+0x4c0>)
 8005f22:	4b5d      	ldr	r3, [pc, #372]	; (8006098 <I2C_Time_BufferRead+0x4e4>)
 8005f24:	4798      	blx	r3

		/* Test on EV8 and clear it */
		counter = RETRY_NUMBER;
 8005f26:	f640 33b8 	movw	r3, #3000	; 0xbb8
 8005f2a:	613b      	str	r3, [r7, #16]
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED)) {
 8005f2c:	e00d      	b.n	8005f4a <I2C_Time_BufferRead+0x396>
			if (counter-- <= 0)
 8005f2e:	693b      	ldr	r3, [r7, #16]
 8005f30:	1e5a      	subs	r2, r3, #1
 8005f32:	613a      	str	r2, [r7, #16]
 8005f34:	2b00      	cmp	r3, #0
 8005f36:	dc08      	bgt.n	8005f4a <I2C_Time_BufferRead+0x396>
				return I2C_EE_Relaunch();
 8005f38:	4b4d      	ldr	r3, [pc, #308]	; (8006070 <I2C_Time_BufferRead+0x4bc>)
 8005f3a:	4798      	blx	r3
 8005f3c:	4603      	mov	r3, r0
 8005f3e:	2b00      	cmp	r3, #0
 8005f40:	bf14      	ite	ne
 8005f42:	2301      	movne	r3, #1
 8005f44:	2300      	moveq	r3, #0
 8005f46:	b2db      	uxtb	r3, r3
 8005f48:	e08e      	b.n	8006068 <I2C_Time_BufferRead+0x4b4>
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED)) {
 8005f4a:	4954      	ldr	r1, [pc, #336]	; (800609c <I2C_Time_BufferRead+0x4e8>)
 8005f4c:	4849      	ldr	r0, [pc, #292]	; (8006074 <I2C_Time_BufferRead+0x4c0>)
 8005f4e:	4b4e      	ldr	r3, [pc, #312]	; (8006088 <I2C_Time_BufferRead+0x4d4>)
 8005f50:	4798      	blx	r3
 8005f52:	4603      	mov	r3, r0
 8005f54:	2b00      	cmp	r3, #0
 8005f56:	d0ea      	beq.n	8005f2e <I2C_Time_BufferRead+0x37a>
		}
		BKP_WriteBackupRegister(BKP_DR7, 9);
 8005f58:	2109      	movs	r1, #9
 8005f5a:	201c      	movs	r0, #28
 8005f5c:	4b47      	ldr	r3, [pc, #284]	; (800607c <I2C_Time_BufferRead+0x4c8>)
 8005f5e:	4798      	blx	r3
		/* Send STRAT condition a second time */
		I2C_GenerateSTART(I2C1, ENABLE);
 8005f60:	2101      	movs	r1, #1
 8005f62:	4844      	ldr	r0, [pc, #272]	; (8006074 <I2C_Time_BufferRead+0x4c0>)
 8005f64:	4b46      	ldr	r3, [pc, #280]	; (8006080 <I2C_Time_BufferRead+0x4cc>)
 8005f66:	4798      	blx	r3

		/* Test on EV5 and clear it */
		counter = RETRY_NUMBER;
 8005f68:	f640 33b8 	movw	r3, #3000	; 0xbb8
 8005f6c:	613b      	str	r3, [r7, #16]
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT)) {
 8005f6e:	e00d      	b.n	8005f8c <I2C_Time_BufferRead+0x3d8>
			if (counter-- <= 0)
 8005f70:	693b      	ldr	r3, [r7, #16]
 8005f72:	1e5a      	subs	r2, r3, #1
 8005f74:	613a      	str	r2, [r7, #16]
 8005f76:	2b00      	cmp	r3, #0
 8005f78:	dc08      	bgt.n	8005f8c <I2C_Time_BufferRead+0x3d8>
				return I2C_EE_Relaunch();
 8005f7a:	4b3d      	ldr	r3, [pc, #244]	; (8006070 <I2C_Time_BufferRead+0x4bc>)
 8005f7c:	4798      	blx	r3
 8005f7e:	4603      	mov	r3, r0
 8005f80:	2b00      	cmp	r3, #0
 8005f82:	bf14      	ite	ne
 8005f84:	2301      	movne	r3, #1
 8005f86:	2300      	moveq	r3, #0
 8005f88:	b2db      	uxtb	r3, r3
 8005f8a:	e06d      	b.n	8006068 <I2C_Time_BufferRead+0x4b4>
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT)) {
 8005f8c:	493d      	ldr	r1, [pc, #244]	; (8006084 <I2C_Time_BufferRead+0x4d0>)
 8005f8e:	4839      	ldr	r0, [pc, #228]	; (8006074 <I2C_Time_BufferRead+0x4c0>)
 8005f90:	4b3d      	ldr	r3, [pc, #244]	; (8006088 <I2C_Time_BufferRead+0x4d4>)
 8005f92:	4798      	blx	r3
 8005f94:	4603      	mov	r3, r0
 8005f96:	2b00      	cmp	r3, #0
 8005f98:	d0ea      	beq.n	8005f70 <I2C_Time_BufferRead+0x3bc>
		}
		BKP_WriteBackupRegister(BKP_DR7, 9);
 8005f9a:	2109      	movs	r1, #9
 8005f9c:	201c      	movs	r0, #28
 8005f9e:	4b37      	ldr	r3, [pc, #220]	; (800607c <I2C_Time_BufferRead+0x4c8>)
 8005fa0:	4798      	blx	r3
		/* Send EEPROM address for read */
		I2C_Send7bitAddress(I2C1, 0xD0, I2C_Direction_Receiver);
 8005fa2:	2201      	movs	r2, #1
 8005fa4:	21d0      	movs	r1, #208	; 0xd0
 8005fa6:	4833      	ldr	r0, [pc, #204]	; (8006074 <I2C_Time_BufferRead+0x4c0>)
 8005fa8:	4b38      	ldr	r3, [pc, #224]	; (800608c <I2C_Time_BufferRead+0x4d8>)
 8005faa:	4798      	blx	r3

		/* Test on EV6 and clear it */
		counter = RETRY_NUMBER;
 8005fac:	f640 33b8 	movw	r3, #3000	; 0xbb8
 8005fb0:	613b      	str	r3, [r7, #16]
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED)) {
 8005fb2:	e00d      	b.n	8005fd0 <I2C_Time_BufferRead+0x41c>
			if (counter-- <= 0)
 8005fb4:	693b      	ldr	r3, [r7, #16]
 8005fb6:	1e5a      	subs	r2, r3, #1
 8005fb8:	613a      	str	r2, [r7, #16]
 8005fba:	2b00      	cmp	r3, #0
 8005fbc:	dc08      	bgt.n	8005fd0 <I2C_Time_BufferRead+0x41c>
				return I2C_EE_Relaunch();
 8005fbe:	4b2c      	ldr	r3, [pc, #176]	; (8006070 <I2C_Time_BufferRead+0x4bc>)
 8005fc0:	4798      	blx	r3
 8005fc2:	4603      	mov	r3, r0
 8005fc4:	2b00      	cmp	r3, #0
 8005fc6:	bf14      	ite	ne
 8005fc8:	2301      	movne	r3, #1
 8005fca:	2300      	moveq	r3, #0
 8005fcc:	b2db      	uxtb	r3, r3
 8005fce:	e04b      	b.n	8006068 <I2C_Time_BufferRead+0x4b4>
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED)) {
 8005fd0:	4933      	ldr	r1, [pc, #204]	; (80060a0 <I2C_Time_BufferRead+0x4ec>)
 8005fd2:	4828      	ldr	r0, [pc, #160]	; (8006074 <I2C_Time_BufferRead+0x4c0>)
 8005fd4:	4b2c      	ldr	r3, [pc, #176]	; (8006088 <I2C_Time_BufferRead+0x4d4>)
 8005fd6:	4798      	blx	r3
 8005fd8:	4603      	mov	r3, r0
 8005fda:	2b00      	cmp	r3, #0
 8005fdc:	d0ea      	beq.n	8005fb4 <I2C_Time_BufferRead+0x400>
		}
		BKP_WriteBackupRegister(BKP_DR7, 10);
 8005fde:	210a      	movs	r1, #10
 8005fe0:	201c      	movs	r0, #28
 8005fe2:	4b26      	ldr	r3, [pc, #152]	; (800607c <I2C_Time_BufferRead+0x4c8>)
 8005fe4:	4798      	blx	r3
		/* While there is data to be read */
		counter = RETRY_NUMBER;
 8005fe6:	f640 33b8 	movw	r3, #3000	; 0xbb8
 8005fea:	613b      	str	r3, [r7, #16]
		while (NumByteToRead) {
 8005fec:	e030      	b.n	8006050 <I2C_Time_BufferRead+0x49c>
			if (NumByteToRead == 1) {
 8005fee:	883b      	ldrh	r3, [r7, #0]
 8005ff0:	2b01      	cmp	r3, #1
 8005ff2:	d107      	bne.n	8006004 <I2C_Time_BufferRead+0x450>
				/* Disable Acknowledgement */
				I2C_AcknowledgeConfig(I2C1, DISABLE);
 8005ff4:	2100      	movs	r1, #0
 8005ff6:	481f      	ldr	r0, [pc, #124]	; (8006074 <I2C_Time_BufferRead+0x4c0>)
 8005ff8:	4b2a      	ldr	r3, [pc, #168]	; (80060a4 <I2C_Time_BufferRead+0x4f0>)
 8005ffa:	4798      	blx	r3

				/* Send STOP Condition */
				I2C_GenerateSTOP(I2C1, ENABLE);
 8005ffc:	2101      	movs	r1, #1
 8005ffe:	481d      	ldr	r0, [pc, #116]	; (8006074 <I2C_Time_BufferRead+0x4c0>)
 8006000:	4b29      	ldr	r3, [pc, #164]	; (80060a8 <I2C_Time_BufferRead+0x4f4>)
 8006002:	4798      	blx	r3
			}
			BKP_WriteBackupRegister(BKP_DR7, 11);
 8006004:	210b      	movs	r1, #11
 8006006:	201c      	movs	r0, #28
 8006008:	4b1c      	ldr	r3, [pc, #112]	; (800607c <I2C_Time_BufferRead+0x4c8>)
 800600a:	4798      	blx	r3
			/* Test on EV7 and clear it */
			if (I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_RECEIVED)) {
 800600c:	4927      	ldr	r1, [pc, #156]	; (80060ac <I2C_Time_BufferRead+0x4f8>)
 800600e:	4819      	ldr	r0, [pc, #100]	; (8006074 <I2C_Time_BufferRead+0x4c0>)
 8006010:	4b1d      	ldr	r3, [pc, #116]	; (8006088 <I2C_Time_BufferRead+0x4d4>)
 8006012:	4798      	blx	r3
 8006014:	4603      	mov	r3, r0
 8006016:	2b00      	cmp	r3, #0
 8006018:	d00c      	beq.n	8006034 <I2C_Time_BufferRead+0x480>
				/* Read a byte from the EEPROM */
				*pBuffer = I2C_ReceiveData(I2C1);
 800601a:	4816      	ldr	r0, [pc, #88]	; (8006074 <I2C_Time_BufferRead+0x4c0>)
 800601c:	4b24      	ldr	r3, [pc, #144]	; (80060b0 <I2C_Time_BufferRead+0x4fc>)
 800601e:	4798      	blx	r3
 8006020:	4603      	mov	r3, r0
 8006022:	461a      	mov	r2, r3
 8006024:	687b      	ldr	r3, [r7, #4]
 8006026:	701a      	strb	r2, [r3, #0]

				/* Point to the next location where the byte read will be saved */
				pBuffer++;
 8006028:	687b      	ldr	r3, [r7, #4]
 800602a:	3301      	adds	r3, #1
 800602c:	607b      	str	r3, [r7, #4]

				/* Decrement the read bytes counter */
				NumByteToRead--;
 800602e:	883b      	ldrh	r3, [r7, #0]
 8006030:	3b01      	subs	r3, #1
 8006032:	803b      	strh	r3, [r7, #0]

			}
			if (counter-- <= 0)
 8006034:	693b      	ldr	r3, [r7, #16]
 8006036:	1e5a      	subs	r2, r3, #1
 8006038:	613a      	str	r2, [r7, #16]
 800603a:	2b00      	cmp	r3, #0
 800603c:	dc08      	bgt.n	8006050 <I2C_Time_BufferRead+0x49c>
				return I2C_EE_Relaunch();
 800603e:	4b0c      	ldr	r3, [pc, #48]	; (8006070 <I2C_Time_BufferRead+0x4bc>)
 8006040:	4798      	blx	r3
 8006042:	4603      	mov	r3, r0
 8006044:	2b00      	cmp	r3, #0
 8006046:	bf14      	ite	ne
 8006048:	2301      	movne	r3, #1
 800604a:	2300      	moveq	r3, #0
 800604c:	b2db      	uxtb	r3, r3
 800604e:	e00b      	b.n	8006068 <I2C_Time_BufferRead+0x4b4>
		while (NumByteToRead) {
 8006050:	883b      	ldrh	r3, [r7, #0]
 8006052:	2b00      	cmp	r3, #0
 8006054:	d1cb      	bne.n	8005fee <I2C_Time_BufferRead+0x43a>
		}
		BKP_WriteBackupRegister(BKP_DR7, 12);
 8006056:	210c      	movs	r1, #12
 8006058:	201c      	movs	r0, #28
 800605a:	4b08      	ldr	r3, [pc, #32]	; (800607c <I2C_Time_BufferRead+0x4c8>)
 800605c:	4798      	blx	r3
		/* Enable Acknowledgement to be ready for another reception */
		I2C_AcknowledgeConfig(I2C1, ENABLE);
 800605e:	2101      	movs	r1, #1
 8006060:	4804      	ldr	r0, [pc, #16]	; (8006074 <I2C_Time_BufferRead+0x4c0>)
 8006062:	4b10      	ldr	r3, [pc, #64]	; (80060a4 <I2C_Time_BufferRead+0x4f0>)
 8006064:	4798      	blx	r3
		return true;
 8006066:	2301      	movs	r3, #1
	}
}
 8006068:	4618      	mov	r0, r3
 800606a:	3718      	adds	r7, #24
 800606c:	46bd      	mov	sp, r7
 800606e:	bd80      	pop	{r7, pc}
 8006070:	080120b1 	.word	0x080120b1
 8006074:	40005400 	.word	0x40005400
 8006078:	0800401d 	.word	0x0800401d
 800607c:	08003621 	.word	0x08003621
 8006080:	08003de3 	.word	0x08003de3
 8006084:	00030001 	.word	0x00030001
 8006088:	08003fc3 	.word	0x08003fc3
 800608c:	08003f1b 	.word	0x08003f1b
 8006090:	00070082 	.word	0x00070082
 8006094:	08003da5 	.word	0x08003da5
 8006098:	08003ee3 	.word	0x08003ee3
 800609c:	00070084 	.word	0x00070084
 80060a0:	00030002 	.word	0x00030002
 80060a4:	08003e5f 	.word	0x08003e5f
 80060a8:	08003e21 	.word	0x08003e21
 80060ac:	00030040 	.word	0x00030040
 80060b0:	08003f01 	.word	0x08003f01

080060b4 <I2C_Time_BufferWrite>:

bool I2C_Time_BufferWrite(u8 *pBuffer, u16 WriteAddr, u16 NumByteToWrite) {
 80060b4:	b580      	push	{r7, lr}
 80060b6:	b084      	sub	sp, #16
 80060b8:	af00      	add	r7, sp, #0
 80060ba:	6078      	str	r0, [r7, #4]
 80060bc:	460b      	mov	r3, r1
 80060be:	807b      	strh	r3, [r7, #2]
 80060c0:	4613      	mov	r3, r2
 80060c2:	803b      	strh	r3, [r7, #0]
	if (initMK == 1) {
 80060c4:	4b8f      	ldr	r3, [pc, #572]	; (8006304 <I2C_Time_BufferWrite+0x250>)
 80060c6:	681b      	ldr	r3, [r3, #0]
 80060c8:	2b01      	cmp	r3, #1
 80060ca:	f040 809f 	bne.w	800620c <I2C_Time_BufferWrite+0x158>
		int counter = RETRY_NUMBER;
 80060ce:	f640 33b8 	movw	r3, #3000	; 0xbb8
 80060d2:	60fb      	str	r3, [r7, #12]
		/* While the bus is busy */
		/*while (I2C_GetFlagStatus(I2C1, I2C_FLAG_BUSY)) {
			if (counter-- <= 0)
				return I2C_EE_Relaunch();
		}*/
		BKP_WriteBackupRegister(BKP_DR7, 13);
 80060d4:	210d      	movs	r1, #13
 80060d6:	201c      	movs	r0, #28
 80060d8:	4b8b      	ldr	r3, [pc, #556]	; (8006308 <I2C_Time_BufferWrite+0x254>)
 80060da:	4798      	blx	r3
		/* Send START condition */
		I2C_GenerateSTART(I2C1, ENABLE);
 80060dc:	2101      	movs	r1, #1
 80060de:	488b      	ldr	r0, [pc, #556]	; (800630c <I2C_Time_BufferWrite+0x258>)
 80060e0:	4b8b      	ldr	r3, [pc, #556]	; (8006310 <I2C_Time_BufferWrite+0x25c>)
 80060e2:	4798      	blx	r3

		/* Test on EV5 and clear it */
		counter = RETRY_NUMBER;
 80060e4:	f640 33b8 	movw	r3, #3000	; 0xbb8
 80060e8:	60fb      	str	r3, [r7, #12]
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT)) {
 80060ea:	e00d      	b.n	8006108 <I2C_Time_BufferWrite+0x54>
			if (counter-- <= 0)
 80060ec:	68fb      	ldr	r3, [r7, #12]
 80060ee:	1e5a      	subs	r2, r3, #1
 80060f0:	60fa      	str	r2, [r7, #12]
 80060f2:	2b00      	cmp	r3, #0
 80060f4:	dc08      	bgt.n	8006108 <I2C_Time_BufferWrite+0x54>
				return I2C_EE_Relaunch();
 80060f6:	4b87      	ldr	r3, [pc, #540]	; (8006314 <I2C_Time_BufferWrite+0x260>)
 80060f8:	4798      	blx	r3
 80060fa:	4603      	mov	r3, r0
 80060fc:	2b00      	cmp	r3, #0
 80060fe:	bf14      	ite	ne
 8006100:	2301      	movne	r3, #1
 8006102:	2300      	moveq	r3, #0
 8006104:	b2db      	uxtb	r3, r3
 8006106:	e13c      	b.n	8006382 <I2C_Time_BufferWrite+0x2ce>
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT)) {
 8006108:	4983      	ldr	r1, [pc, #524]	; (8006318 <I2C_Time_BufferWrite+0x264>)
 800610a:	4880      	ldr	r0, [pc, #512]	; (800630c <I2C_Time_BufferWrite+0x258>)
 800610c:	4b83      	ldr	r3, [pc, #524]	; (800631c <I2C_Time_BufferWrite+0x268>)
 800610e:	4798      	blx	r3
 8006110:	4603      	mov	r3, r0
 8006112:	2b00      	cmp	r3, #0
 8006114:	d0ea      	beq.n	80060ec <I2C_Time_BufferWrite+0x38>
		}
		BKP_WriteBackupRegister(BKP_DR7, 14);
 8006116:	210e      	movs	r1, #14
 8006118:	201c      	movs	r0, #28
 800611a:	4b7b      	ldr	r3, [pc, #492]	; (8006308 <I2C_Time_BufferWrite+0x254>)
 800611c:	4798      	blx	r3
		/* Send EEPROM address for write */
		I2C_Send7bitAddress(I2C1, 0xD0, I2C_Direction_Transmitter);
 800611e:	2200      	movs	r2, #0
 8006120:	21d0      	movs	r1, #208	; 0xd0
 8006122:	487a      	ldr	r0, [pc, #488]	; (800630c <I2C_Time_BufferWrite+0x258>)
 8006124:	4b7e      	ldr	r3, [pc, #504]	; (8006320 <I2C_Time_BufferWrite+0x26c>)
 8006126:	4798      	blx	r3

		/* Test on EV6 and clear it */
		counter = RETRY_NUMBER;
 8006128:	f640 33b8 	movw	r3, #3000	; 0xbb8
 800612c:	60fb      	str	r3, [r7, #12]
		/*while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED)) {
			if (counter-- <= 0)
				return I2C_EE_Relaunch();
		}*/
		  while(!I2C_GetFlagStatus(I2C1, I2C_FLAG_ADDR))
 800612e:	e00d      	b.n	800614c <I2C_Time_BufferWrite+0x98>
		  {
		  	  if(counter-- <= 0) return I2C_EE_Relaunch();
 8006130:	68fb      	ldr	r3, [r7, #12]
 8006132:	1e5a      	subs	r2, r3, #1
 8006134:	60fa      	str	r2, [r7, #12]
 8006136:	2b00      	cmp	r3, #0
 8006138:	dc08      	bgt.n	800614c <I2C_Time_BufferWrite+0x98>
 800613a:	4b76      	ldr	r3, [pc, #472]	; (8006314 <I2C_Time_BufferWrite+0x260>)
 800613c:	4798      	blx	r3
 800613e:	4603      	mov	r3, r0
 8006140:	2b00      	cmp	r3, #0
 8006142:	bf14      	ite	ne
 8006144:	2301      	movne	r3, #1
 8006146:	2300      	moveq	r3, #0
 8006148:	b2db      	uxtb	r3, r3
 800614a:	e11a      	b.n	8006382 <I2C_Time_BufferWrite+0x2ce>
		  while(!I2C_GetFlagStatus(I2C1, I2C_FLAG_ADDR))
 800614c:	4975      	ldr	r1, [pc, #468]	; (8006324 <I2C_Time_BufferWrite+0x270>)
 800614e:	486f      	ldr	r0, [pc, #444]	; (800630c <I2C_Time_BufferWrite+0x258>)
 8006150:	4b75      	ldr	r3, [pc, #468]	; (8006328 <I2C_Time_BufferWrite+0x274>)
 8006152:	4798      	blx	r3
 8006154:	4603      	mov	r3, r0
 8006156:	2b00      	cmp	r3, #0
 8006158:	d0ea      	beq.n	8006130 <I2C_Time_BufferWrite+0x7c>
		    }

		BKP_WriteBackupRegister(BKP_DR7, 15);
 800615a:	210f      	movs	r1, #15
 800615c:	201c      	movs	r0, #28
 800615e:	4b6a      	ldr	r3, [pc, #424]	; (8006308 <I2C_Time_BufferWrite+0x254>)
 8006160:	4798      	blx	r3
		//  counter = RETRY_NUMBER;
		//  while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED))
		//  {
		//	if(counter-- <= 0) return I2C_EE_Relaunch();
		//  }
		I2C_SendData(I2C1, WriteAddr & 0xFF);
 8006162:	887b      	ldrh	r3, [r7, #2]
 8006164:	b2db      	uxtb	r3, r3
 8006166:	4619      	mov	r1, r3
 8006168:	4868      	ldr	r0, [pc, #416]	; (800630c <I2C_Time_BufferWrite+0x258>)
 800616a:	4b70      	ldr	r3, [pc, #448]	; (800632c <I2C_Time_BufferWrite+0x278>)
 800616c:	4798      	blx	r3

		/* Test on EV8 and clear it */
		counter = RETRY_NUMBER;
 800616e:	f640 33b8 	movw	r3, #3000	; 0xbb8
 8006172:	60fb      	str	r3, [r7, #12]
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED)) {
 8006174:	e00d      	b.n	8006192 <I2C_Time_BufferWrite+0xde>
			if (counter-- <= 0)
 8006176:	68fb      	ldr	r3, [r7, #12]
 8006178:	1e5a      	subs	r2, r3, #1
 800617a:	60fa      	str	r2, [r7, #12]
 800617c:	2b00      	cmp	r3, #0
 800617e:	dc08      	bgt.n	8006192 <I2C_Time_BufferWrite+0xde>
				return I2C_EE_Relaunch();
 8006180:	4b64      	ldr	r3, [pc, #400]	; (8006314 <I2C_Time_BufferWrite+0x260>)
 8006182:	4798      	blx	r3
 8006184:	4603      	mov	r3, r0
 8006186:	2b00      	cmp	r3, #0
 8006188:	bf14      	ite	ne
 800618a:	2301      	movne	r3, #1
 800618c:	2300      	moveq	r3, #0
 800618e:	b2db      	uxtb	r3, r3
 8006190:	e0f7      	b.n	8006382 <I2C_Time_BufferWrite+0x2ce>
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED)) {
 8006192:	4967      	ldr	r1, [pc, #412]	; (8006330 <I2C_Time_BufferWrite+0x27c>)
 8006194:	485d      	ldr	r0, [pc, #372]	; (800630c <I2C_Time_BufferWrite+0x258>)
 8006196:	4b61      	ldr	r3, [pc, #388]	; (800631c <I2C_Time_BufferWrite+0x268>)
 8006198:	4798      	blx	r3
 800619a:	4603      	mov	r3, r0
 800619c:	2b00      	cmp	r3, #0
 800619e:	d0ea      	beq.n	8006176 <I2C_Time_BufferWrite+0xc2>
		}
		BKP_WriteBackupRegister(BKP_DR7, 16);
 80061a0:	2110      	movs	r1, #16
 80061a2:	201c      	movs	r0, #28
 80061a4:	4b58      	ldr	r3, [pc, #352]	; (8006308 <I2C_Time_BufferWrite+0x254>)
 80061a6:	4798      	blx	r3
		/* While there is data to be written */
		while (NumByteToWrite--) {
 80061a8:	e021      	b.n	80061ee <I2C_Time_BufferWrite+0x13a>
			/* Send the current byte */
			I2C_SendData(I2C1, *pBuffer);
 80061aa:	687b      	ldr	r3, [r7, #4]
 80061ac:	781b      	ldrb	r3, [r3, #0]
 80061ae:	4619      	mov	r1, r3
 80061b0:	4856      	ldr	r0, [pc, #344]	; (800630c <I2C_Time_BufferWrite+0x258>)
 80061b2:	4b5e      	ldr	r3, [pc, #376]	; (800632c <I2C_Time_BufferWrite+0x278>)
 80061b4:	4798      	blx	r3

			/* Point to the next byte to be written */
			pBuffer++;
 80061b6:	687b      	ldr	r3, [r7, #4]
 80061b8:	3301      	adds	r3, #1
 80061ba:	607b      	str	r3, [r7, #4]

			/* Test on EV8 and clear it */
			counter = RETRY_NUMBER;
 80061bc:	f640 33b8 	movw	r3, #3000	; 0xbb8
 80061c0:	60fb      	str	r3, [r7, #12]
			while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED)) {
 80061c2:	e00d      	b.n	80061e0 <I2C_Time_BufferWrite+0x12c>
				if (counter-- <= 0)
 80061c4:	68fb      	ldr	r3, [r7, #12]
 80061c6:	1e5a      	subs	r2, r3, #1
 80061c8:	60fa      	str	r2, [r7, #12]
 80061ca:	2b00      	cmp	r3, #0
 80061cc:	dc08      	bgt.n	80061e0 <I2C_Time_BufferWrite+0x12c>
					return I2C_EE_Relaunch();
 80061ce:	4b51      	ldr	r3, [pc, #324]	; (8006314 <I2C_Time_BufferWrite+0x260>)
 80061d0:	4798      	blx	r3
 80061d2:	4603      	mov	r3, r0
 80061d4:	2b00      	cmp	r3, #0
 80061d6:	bf14      	ite	ne
 80061d8:	2301      	movne	r3, #1
 80061da:	2300      	moveq	r3, #0
 80061dc:	b2db      	uxtb	r3, r3
 80061de:	e0d0      	b.n	8006382 <I2C_Time_BufferWrite+0x2ce>
			while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED)) {
 80061e0:	4953      	ldr	r1, [pc, #332]	; (8006330 <I2C_Time_BufferWrite+0x27c>)
 80061e2:	484a      	ldr	r0, [pc, #296]	; (800630c <I2C_Time_BufferWrite+0x258>)
 80061e4:	4b4d      	ldr	r3, [pc, #308]	; (800631c <I2C_Time_BufferWrite+0x268>)
 80061e6:	4798      	blx	r3
 80061e8:	4603      	mov	r3, r0
 80061ea:	2b00      	cmp	r3, #0
 80061ec:	d0ea      	beq.n	80061c4 <I2C_Time_BufferWrite+0x110>
		while (NumByteToWrite--) {
 80061ee:	883b      	ldrh	r3, [r7, #0]
 80061f0:	1e5a      	subs	r2, r3, #1
 80061f2:	803a      	strh	r2, [r7, #0]
 80061f4:	2b00      	cmp	r3, #0
 80061f6:	d1d8      	bne.n	80061aa <I2C_Time_BufferWrite+0xf6>
			}
		}
		BKP_WriteBackupRegister(BKP_DR7, 17);
 80061f8:	2111      	movs	r1, #17
 80061fa:	201c      	movs	r0, #28
 80061fc:	4b42      	ldr	r3, [pc, #264]	; (8006308 <I2C_Time_BufferWrite+0x254>)
 80061fe:	4798      	blx	r3
		/* Send STOP condition */
		I2C_GenerateSTOP(I2C1, ENABLE);
 8006200:	2101      	movs	r1, #1
 8006202:	4842      	ldr	r0, [pc, #264]	; (800630c <I2C_Time_BufferWrite+0x258>)
 8006204:	4b4b      	ldr	r3, [pc, #300]	; (8006334 <I2C_Time_BufferWrite+0x280>)
 8006206:	4798      	blx	r3
		return true;
 8006208:	2301      	movs	r3, #1
 800620a:	e0ba      	b.n	8006382 <I2C_Time_BufferWrite+0x2ce>

	} else {
		int counter = RETRY_NUMBER;
 800620c:	f640 33b8 	movw	r3, #3000	; 0xbb8
 8006210:	60bb      	str	r3, [r7, #8]
		/* While the bus is busy */
	/*	while (I2C_GetFlagStatus(I2C1, I2C_FLAG_BUSY)) {
			if (counter-- <= 0)
				return I2C_EE_Relaunch();
		}*/
		BKP_WriteBackupRegister(BKP_DR7, 13);
 8006212:	210d      	movs	r1, #13
 8006214:	201c      	movs	r0, #28
 8006216:	4b3c      	ldr	r3, [pc, #240]	; (8006308 <I2C_Time_BufferWrite+0x254>)
 8006218:	4798      	blx	r3
		/* Send START condition */
		I2C_GenerateSTART(I2C1, ENABLE);
 800621a:	2101      	movs	r1, #1
 800621c:	483b      	ldr	r0, [pc, #236]	; (800630c <I2C_Time_BufferWrite+0x258>)
 800621e:	4b3c      	ldr	r3, [pc, #240]	; (8006310 <I2C_Time_BufferWrite+0x25c>)
 8006220:	4798      	blx	r3

		/* Test on EV5 and clear it */
		counter = RETRY_NUMBER;
 8006222:	f640 33b8 	movw	r3, #3000	; 0xbb8
 8006226:	60bb      	str	r3, [r7, #8]
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT)) {
 8006228:	e00d      	b.n	8006246 <I2C_Time_BufferWrite+0x192>
			if (counter-- <= 0)
 800622a:	68bb      	ldr	r3, [r7, #8]
 800622c:	1e5a      	subs	r2, r3, #1
 800622e:	60ba      	str	r2, [r7, #8]
 8006230:	2b00      	cmp	r3, #0
 8006232:	dc08      	bgt.n	8006246 <I2C_Time_BufferWrite+0x192>
				return I2C_EE_Relaunch();
 8006234:	4b37      	ldr	r3, [pc, #220]	; (8006314 <I2C_Time_BufferWrite+0x260>)
 8006236:	4798      	blx	r3
 8006238:	4603      	mov	r3, r0
 800623a:	2b00      	cmp	r3, #0
 800623c:	bf14      	ite	ne
 800623e:	2301      	movne	r3, #1
 8006240:	2300      	moveq	r3, #0
 8006242:	b2db      	uxtb	r3, r3
 8006244:	e09d      	b.n	8006382 <I2C_Time_BufferWrite+0x2ce>
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT)) {
 8006246:	4934      	ldr	r1, [pc, #208]	; (8006318 <I2C_Time_BufferWrite+0x264>)
 8006248:	4830      	ldr	r0, [pc, #192]	; (800630c <I2C_Time_BufferWrite+0x258>)
 800624a:	4b34      	ldr	r3, [pc, #208]	; (800631c <I2C_Time_BufferWrite+0x268>)
 800624c:	4798      	blx	r3
 800624e:	4603      	mov	r3, r0
 8006250:	2b00      	cmp	r3, #0
 8006252:	d0ea      	beq.n	800622a <I2C_Time_BufferWrite+0x176>
		}
		BKP_WriteBackupRegister(BKP_DR7, 14);
 8006254:	210e      	movs	r1, #14
 8006256:	201c      	movs	r0, #28
 8006258:	4b2b      	ldr	r3, [pc, #172]	; (8006308 <I2C_Time_BufferWrite+0x254>)
 800625a:	4798      	blx	r3
		/* Send EEPROM address for write */
		I2C_Send7bitAddress(I2C1, 0xD0, I2C_Direction_Transmitter);
 800625c:	2200      	movs	r2, #0
 800625e:	21d0      	movs	r1, #208	; 0xd0
 8006260:	482a      	ldr	r0, [pc, #168]	; (800630c <I2C_Time_BufferWrite+0x258>)
 8006262:	4b2f      	ldr	r3, [pc, #188]	; (8006320 <I2C_Time_BufferWrite+0x26c>)
 8006264:	4798      	blx	r3

		/* Test on EV6 and clear it */
		counter = RETRY_NUMBER;
 8006266:	f640 33b8 	movw	r3, #3000	; 0xbb8
 800626a:	60bb      	str	r3, [r7, #8]
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED)) {
 800626c:	e00d      	b.n	800628a <I2C_Time_BufferWrite+0x1d6>
			if (counter-- <= 0)
 800626e:	68bb      	ldr	r3, [r7, #8]
 8006270:	1e5a      	subs	r2, r3, #1
 8006272:	60ba      	str	r2, [r7, #8]
 8006274:	2b00      	cmp	r3, #0
 8006276:	dc08      	bgt.n	800628a <I2C_Time_BufferWrite+0x1d6>
				return I2C_EE_Relaunch();
 8006278:	4b26      	ldr	r3, [pc, #152]	; (8006314 <I2C_Time_BufferWrite+0x260>)
 800627a:	4798      	blx	r3
 800627c:	4603      	mov	r3, r0
 800627e:	2b00      	cmp	r3, #0
 8006280:	bf14      	ite	ne
 8006282:	2301      	movne	r3, #1
 8006284:	2300      	moveq	r3, #0
 8006286:	b2db      	uxtb	r3, r3
 8006288:	e07b      	b.n	8006382 <I2C_Time_BufferWrite+0x2ce>
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED)) {
 800628a:	492b      	ldr	r1, [pc, #172]	; (8006338 <I2C_Time_BufferWrite+0x284>)
 800628c:	481f      	ldr	r0, [pc, #124]	; (800630c <I2C_Time_BufferWrite+0x258>)
 800628e:	4b23      	ldr	r3, [pc, #140]	; (800631c <I2C_Time_BufferWrite+0x268>)
 8006290:	4798      	blx	r3
 8006292:	4603      	mov	r3, r0
 8006294:	2b00      	cmp	r3, #0
 8006296:	d0ea      	beq.n	800626e <I2C_Time_BufferWrite+0x1ba>
		}
		BKP_WriteBackupRegister(BKP_DR7, 15);
 8006298:	210f      	movs	r1, #15
 800629a:	201c      	movs	r0, #28
 800629c:	4b1a      	ldr	r3, [pc, #104]	; (8006308 <I2C_Time_BufferWrite+0x254>)
 800629e:	4798      	blx	r3
		//  counter = RETRY_NUMBER;
		//  while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED))
		//  {
		//	if(counter-- <= 0) return I2C_EE_Relaunch();
		//  }
		I2C_SendData(I2C1, WriteAddr & 0xFF);
 80062a0:	887b      	ldrh	r3, [r7, #2]
 80062a2:	b2db      	uxtb	r3, r3
 80062a4:	4619      	mov	r1, r3
 80062a6:	4819      	ldr	r0, [pc, #100]	; (800630c <I2C_Time_BufferWrite+0x258>)
 80062a8:	4b20      	ldr	r3, [pc, #128]	; (800632c <I2C_Time_BufferWrite+0x278>)
 80062aa:	4798      	blx	r3

		/* Test on EV8 and clear it */
		counter = RETRY_NUMBER;
 80062ac:	f640 33b8 	movw	r3, #3000	; 0xbb8
 80062b0:	60bb      	str	r3, [r7, #8]
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED)) {
 80062b2:	e00d      	b.n	80062d0 <I2C_Time_BufferWrite+0x21c>
			if (counter-- <= 0)
 80062b4:	68bb      	ldr	r3, [r7, #8]
 80062b6:	1e5a      	subs	r2, r3, #1
 80062b8:	60ba      	str	r2, [r7, #8]
 80062ba:	2b00      	cmp	r3, #0
 80062bc:	dc08      	bgt.n	80062d0 <I2C_Time_BufferWrite+0x21c>
				return I2C_EE_Relaunch();
 80062be:	4b15      	ldr	r3, [pc, #84]	; (8006314 <I2C_Time_BufferWrite+0x260>)
 80062c0:	4798      	blx	r3
 80062c2:	4603      	mov	r3, r0
 80062c4:	2b00      	cmp	r3, #0
 80062c6:	bf14      	ite	ne
 80062c8:	2301      	movne	r3, #1
 80062ca:	2300      	moveq	r3, #0
 80062cc:	b2db      	uxtb	r3, r3
 80062ce:	e058      	b.n	8006382 <I2C_Time_BufferWrite+0x2ce>
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED)) {
 80062d0:	4917      	ldr	r1, [pc, #92]	; (8006330 <I2C_Time_BufferWrite+0x27c>)
 80062d2:	480e      	ldr	r0, [pc, #56]	; (800630c <I2C_Time_BufferWrite+0x258>)
 80062d4:	4b11      	ldr	r3, [pc, #68]	; (800631c <I2C_Time_BufferWrite+0x268>)
 80062d6:	4798      	blx	r3
 80062d8:	4603      	mov	r3, r0
 80062da:	2b00      	cmp	r3, #0
 80062dc:	d0ea      	beq.n	80062b4 <I2C_Time_BufferWrite+0x200>
		}
		BKP_WriteBackupRegister(BKP_DR7, 16);
 80062de:	2110      	movs	r1, #16
 80062e0:	201c      	movs	r0, #28
 80062e2:	4b09      	ldr	r3, [pc, #36]	; (8006308 <I2C_Time_BufferWrite+0x254>)
 80062e4:	4798      	blx	r3
		/* While there is data to be written */
		while (NumByteToWrite--) {
 80062e6:	e03e      	b.n	8006366 <I2C_Time_BufferWrite+0x2b2>
			/* Send the current byte */
			I2C_SendData(I2C1, *pBuffer);
 80062e8:	687b      	ldr	r3, [r7, #4]
 80062ea:	781b      	ldrb	r3, [r3, #0]
 80062ec:	4619      	mov	r1, r3
 80062ee:	4807      	ldr	r0, [pc, #28]	; (800630c <I2C_Time_BufferWrite+0x258>)
 80062f0:	4b0e      	ldr	r3, [pc, #56]	; (800632c <I2C_Time_BufferWrite+0x278>)
 80062f2:	4798      	blx	r3

			/* Point to the next byte to be written */
			pBuffer++;
 80062f4:	687b      	ldr	r3, [r7, #4]
 80062f6:	3301      	adds	r3, #1
 80062f8:	607b      	str	r3, [r7, #4]

			/* Test on EV8 and clear it */
			counter = RETRY_NUMBER;
 80062fa:	f640 33b8 	movw	r3, #3000	; 0xbb8
 80062fe:	60bb      	str	r3, [r7, #8]
			while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED)) {
 8006300:	e02a      	b.n	8006358 <I2C_Time_BufferWrite+0x2a4>
 8006302:	bf00      	nop
 8006304:	20007194 	.word	0x20007194
 8006308:	08003621 	.word	0x08003621
 800630c:	40005400 	.word	0x40005400
 8006310:	08003de3 	.word	0x08003de3
 8006314:	080120b1 	.word	0x080120b1
 8006318:	00030001 	.word	0x00030001
 800631c:	08003fc3 	.word	0x08003fc3
 8006320:	08003f1b 	.word	0x08003f1b
 8006324:	10000002 	.word	0x10000002
 8006328:	0800401d 	.word	0x0800401d
 800632c:	08003ee3 	.word	0x08003ee3
 8006330:	00070084 	.word	0x00070084
 8006334:	08003e21 	.word	0x08003e21
 8006338:	00070082 	.word	0x00070082
				if (counter-- <= 0)
 800633c:	68bb      	ldr	r3, [r7, #8]
 800633e:	1e5a      	subs	r2, r3, #1
 8006340:	60ba      	str	r2, [r7, #8]
 8006342:	2b00      	cmp	r3, #0
 8006344:	dc08      	bgt.n	8006358 <I2C_Time_BufferWrite+0x2a4>
					return I2C_EE_Relaunch();
 8006346:	4b11      	ldr	r3, [pc, #68]	; (800638c <I2C_Time_BufferWrite+0x2d8>)
 8006348:	4798      	blx	r3
 800634a:	4603      	mov	r3, r0
 800634c:	2b00      	cmp	r3, #0
 800634e:	bf14      	ite	ne
 8006350:	2301      	movne	r3, #1
 8006352:	2300      	moveq	r3, #0
 8006354:	b2db      	uxtb	r3, r3
 8006356:	e014      	b.n	8006382 <I2C_Time_BufferWrite+0x2ce>
			while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED)) {
 8006358:	490d      	ldr	r1, [pc, #52]	; (8006390 <I2C_Time_BufferWrite+0x2dc>)
 800635a:	480e      	ldr	r0, [pc, #56]	; (8006394 <I2C_Time_BufferWrite+0x2e0>)
 800635c:	4b0e      	ldr	r3, [pc, #56]	; (8006398 <I2C_Time_BufferWrite+0x2e4>)
 800635e:	4798      	blx	r3
 8006360:	4603      	mov	r3, r0
 8006362:	2b00      	cmp	r3, #0
 8006364:	d0ea      	beq.n	800633c <I2C_Time_BufferWrite+0x288>
		while (NumByteToWrite--) {
 8006366:	883b      	ldrh	r3, [r7, #0]
 8006368:	1e5a      	subs	r2, r3, #1
 800636a:	803a      	strh	r2, [r7, #0]
 800636c:	2b00      	cmp	r3, #0
 800636e:	d1bb      	bne.n	80062e8 <I2C_Time_BufferWrite+0x234>
			}
		}
		BKP_WriteBackupRegister(BKP_DR7, 17);
 8006370:	2111      	movs	r1, #17
 8006372:	201c      	movs	r0, #28
 8006374:	4b09      	ldr	r3, [pc, #36]	; (800639c <I2C_Time_BufferWrite+0x2e8>)
 8006376:	4798      	blx	r3
		/* Send STOP condition */
		I2C_GenerateSTOP(I2C1, ENABLE);
 8006378:	2101      	movs	r1, #1
 800637a:	4806      	ldr	r0, [pc, #24]	; (8006394 <I2C_Time_BufferWrite+0x2e0>)
 800637c:	4b08      	ldr	r3, [pc, #32]	; (80063a0 <I2C_Time_BufferWrite+0x2ec>)
 800637e:	4798      	blx	r3
		return true;
 8006380:	2301      	movs	r3, #1
	}
}
 8006382:	4618      	mov	r0, r3
 8006384:	3710      	adds	r7, #16
 8006386:	46bd      	mov	sp, r7
 8006388:	bd80      	pop	{r7, pc}
 800638a:	bf00      	nop
 800638c:	080120b1 	.word	0x080120b1
 8006390:	00070084 	.word	0x00070084
 8006394:	40005400 	.word	0x40005400
 8006398:	08003fc3 	.word	0x08003fc3
 800639c:	08003621 	.word	0x08003621
 80063a0:	08003e21 	.word	0x08003e21

080063a4 <atcIncrementCounter>:

void atcIncrementCounter() {
 80063a4:	b480      	push	{r7}
 80063a6:	af00      	add	r7, sp, #0
	atcTickCounter++;
 80063a8:	4b04      	ldr	r3, [pc, #16]	; (80063bc <atcIncrementCounter+0x18>)
 80063aa:	681b      	ldr	r3, [r3, #0]
 80063ac:	3301      	adds	r3, #1
 80063ae:	4a03      	ldr	r2, [pc, #12]	; (80063bc <atcIncrementCounter+0x18>)
 80063b0:	6013      	str	r3, [r2, #0]
}
 80063b2:	bf00      	nop
 80063b4:	46bd      	mov	sp, r7
 80063b6:	bc80      	pop	{r7}
 80063b8:	4770      	bx	lr
 80063ba:	bf00      	nop
 80063bc:	200070f8 	.word	0x200070f8

080063c0 <atcResetCounter>:
extern CountReset;
void atcResetCounter() {
 80063c0:	b480      	push	{r7}
 80063c2:	af00      	add	r7, sp, #0
	CountReset++;
 80063c4:	4b05      	ldr	r3, [pc, #20]	; (80063dc <atcResetCounter+0x1c>)
 80063c6:	681b      	ldr	r3, [r3, #0]
 80063c8:	3301      	adds	r3, #1
 80063ca:	4a04      	ldr	r2, [pc, #16]	; (80063dc <atcResetCounter+0x1c>)
 80063cc:	6013      	str	r3, [r2, #0]
	atcTickCounter = 0;
 80063ce:	4b04      	ldr	r3, [pc, #16]	; (80063e0 <atcResetCounter+0x20>)
 80063d0:	2200      	movs	r2, #0
 80063d2:	601a      	str	r2, [r3, #0]
}
 80063d4:	bf00      	nop
 80063d6:	46bd      	mov	sp, r7
 80063d8:	bc80      	pop	{r7}
 80063da:	4770      	bx	lr
 80063dc:	2000942c 	.word	0x2000942c
 80063e0:	200070f8 	.word	0x200070f8

080063e4 <atcGetCounter>:
u32 atcGetCounter() {
 80063e4:	b480      	push	{r7}
 80063e6:	af00      	add	r7, sp, #0
	return atcTickCounter;
 80063e8:	4b02      	ldr	r3, [pc, #8]	; (80063f4 <atcGetCounter+0x10>)
 80063ea:	681b      	ldr	r3, [r3, #0]
}
 80063ec:	4618      	mov	r0, r3
 80063ee:	46bd      	mov	sp, r7
 80063f0:	bc80      	pop	{r7}
 80063f2:	4770      	bx	lr
 80063f4:	200070f8 	.word	0x200070f8

080063f8 <SwapBuffer>:
void SwapBuffer(uint8 *buf, uint16 len);
inline uint16 SwapWord(uint16 Word) {
	return (Word >> 8) | (Word << 8);
}

inline void SwapBuffer(unsigned char *buf, uint16 len) {
 80063f8:	b480      	push	{r7}
 80063fa:	b085      	sub	sp, #20
 80063fc:	af00      	add	r7, sp, #0
 80063fe:	6078      	str	r0, [r7, #4]
 8006400:	460b      	mov	r3, r1
 8006402:	807b      	strh	r3, [r7, #2]
	unsigned char tint;

	while (len--) {
 8006404:	e00d      	b.n	8006422 <SwapBuffer+0x2a>
		tint = *buf;
 8006406:	687b      	ldr	r3, [r7, #4]
 8006408:	781b      	ldrb	r3, [r3, #0]
 800640a:	73fb      	strb	r3, [r7, #15]
		*buf = *(buf + 1);
 800640c:	687b      	ldr	r3, [r7, #4]
 800640e:	785a      	ldrb	r2, [r3, #1]
 8006410:	687b      	ldr	r3, [r7, #4]
 8006412:	701a      	strb	r2, [r3, #0]
		*(buf + 1) = tint;
 8006414:	687b      	ldr	r3, [r7, #4]
 8006416:	3301      	adds	r3, #1
 8006418:	7bfa      	ldrb	r2, [r7, #15]
 800641a:	701a      	strb	r2, [r3, #0]
		buf += 2;
 800641c:	687b      	ldr	r3, [r7, #4]
 800641e:	3302      	adds	r3, #2
 8006420:	607b      	str	r3, [r7, #4]
	while (len--) {
 8006422:	887b      	ldrh	r3, [r7, #2]
 8006424:	1e5a      	subs	r2, r3, #1
 8006426:	807a      	strh	r2, [r7, #2]
 8006428:	2b00      	cmp	r3, #0
 800642a:	d1ec      	bne.n	8006406 <SwapBuffer+0xe>
	}
}
 800642c:	bf00      	nop
 800642e:	bf00      	nop
 8006430:	3714      	adds	r7, #20
 8006432:	46bd      	mov	sp, r7
 8006434:	bc80      	pop	{r7}
 8006436:	4770      	bx	lr

08006438 <RVnetSlaveProcess>:
//======================================================================
//extern void BOOTSTART( void );

RVNET_DATATYPE RVnetSlaveProcess(uint8 *px_buf, RVNET_DATATYPE pkSize,
		uint8 device_address) {
 8006438:	b580      	push	{r7, lr}
 800643a:	b084      	sub	sp, #16
 800643c:	af00      	add	r7, sp, #0
 800643e:	6078      	str	r0, [r7, #4]
 8006440:	460b      	mov	r3, r1
 8006442:	70fb      	strb	r3, [r7, #3]
 8006444:	4613      	mov	r3, r2
 8006446:	70bb      	strb	r3, [r7, #2]
	volatile uint8 *pxPack = px_buf;
 8006448:	687b      	ldr	r3, [r7, #4]
 800644a:	60fb      	str	r3, [r7, #12]
	if (*pxPack == device_address) {
 800644c:	68fb      	ldr	r3, [r7, #12]
 800644e:	781b      	ldrb	r3, [r3, #0]
 8006450:	b2db      	uxtb	r3, r3
 8006452:	78ba      	ldrb	r2, [r7, #2]
 8006454:	429a      	cmp	r2, r3
 8006456:	d16d      	bne.n	8006534 <RVnetSlaveProcess+0xfc>
		if (CheckCRC(pxPack, pkSize)) {
 8006458:	78fb      	ldrb	r3, [r7, #3]
 800645a:	4619      	mov	r1, r3
 800645c:	68f8      	ldr	r0, [r7, #12]
 800645e:	4b3e      	ldr	r3, [pc, #248]	; (8006558 <RVnetSlaveProcess+0x120>)
 8006460:	4798      	blx	r3
 8006462:	4603      	mov	r3, r0
 8006464:	2b00      	cmp	r3, #0
 8006466:	d063      	beq.n	8006530 <RVnetSlaveProcess+0xf8>
			pxPack++;
 8006468:	68fb      	ldr	r3, [r7, #12]
 800646a:	3301      	adds	r3, #1
 800646c:	60fb      	str	r3, [r7, #12]
			switch (*pxPack) {
 800646e:	68fb      	ldr	r3, [r7, #12]
 8006470:	781b      	ldrb	r3, [r3, #0]
 8006472:	b2db      	uxtb	r3, r3
 8006474:	2b10      	cmp	r3, #16
 8006476:	d852      	bhi.n	800651e <RVnetSlaveProcess+0xe6>
 8006478:	a201      	add	r2, pc, #4	; (adr r2, 8006480 <RVnetSlaveProcess+0x48>)
 800647a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800647e:	bf00      	nop
 8006480:	080064c5 	.word	0x080064c5
 8006484:	080064d7 	.word	0x080064d7
 8006488:	080064d7 	.word	0x080064d7
 800648c:	080064e9 	.word	0x080064e9
 8006490:	080064e9 	.word	0x080064e9
 8006494:	080064fb 	.word	0x080064fb
 8006498:	0800651f 	.word	0x0800651f
 800649c:	0800651f 	.word	0x0800651f
 80064a0:	0800651f 	.word	0x0800651f
 80064a4:	0800651f 	.word	0x0800651f
 80064a8:	0800651f 	.word	0x0800651f
 80064ac:	0800651f 	.word	0x0800651f
 80064b0:	0800651f 	.word	0x0800651f
 80064b4:	0800651f 	.word	0x0800651f
 80064b8:	0800651f 	.word	0x0800651f
 80064bc:	0800651f 	.word	0x0800651f
 80064c0:	0800650d 	.word	0x0800650d
			case 0x00:
				pxPack++;
 80064c4:	68fb      	ldr	r3, [r7, #12]
 80064c6:	3301      	adds	r3, #1
 80064c8:	60fb      	str	r3, [r7, #12]
				pkSize = ReadDeviceID(pxPack);
 80064ca:	68f8      	ldr	r0, [r7, #12]
 80064cc:	4b23      	ldr	r3, [pc, #140]	; (800655c <RVnetSlaveProcess+0x124>)
 80064ce:	4798      	blx	r3
 80064d0:	4603      	mov	r3, r0
 80064d2:	70fb      	strb	r3, [r7, #3]
				break;
 80064d4:	e030      	b.n	8006538 <RVnetSlaveProcess+0x100>
			case 0x01:
			case 0x02:
				pxPack++;
 80064d6:	68fb      	ldr	r3, [r7, #12]
 80064d8:	3301      	adds	r3, #1
 80064da:	60fb      	str	r3, [r7, #12]
				pkSize = ReadNBits(pxPack);
 80064dc:	68f8      	ldr	r0, [r7, #12]
 80064de:	4b20      	ldr	r3, [pc, #128]	; (8006560 <RVnetSlaveProcess+0x128>)
 80064e0:	4798      	blx	r3
 80064e2:	4603      	mov	r3, r0
 80064e4:	70fb      	strb	r3, [r7, #3]
				break;
 80064e6:	e027      	b.n	8006538 <RVnetSlaveProcess+0x100>
			case 0x03:
			case 0x04:
				pxPack++;
 80064e8:	68fb      	ldr	r3, [r7, #12]
 80064ea:	3301      	adds	r3, #1
 80064ec:	60fb      	str	r3, [r7, #12]
				pkSize = ReadNWords(pxPack);
 80064ee:	68f8      	ldr	r0, [r7, #12]
 80064f0:	4b1c      	ldr	r3, [pc, #112]	; (8006564 <RVnetSlaveProcess+0x12c>)
 80064f2:	4798      	blx	r3
 80064f4:	4603      	mov	r3, r0
 80064f6:	70fb      	strb	r3, [r7, #3]
				break;
 80064f8:	e01e      	b.n	8006538 <RVnetSlaveProcess+0x100>
			case 0x05:
				pxPack++;
 80064fa:	68fb      	ldr	r3, [r7, #12]
 80064fc:	3301      	adds	r3, #1
 80064fe:	60fb      	str	r3, [r7, #12]
				pkSize = WriteBit(pxPack);
 8006500:	68f8      	ldr	r0, [r7, #12]
 8006502:	4b19      	ldr	r3, [pc, #100]	; (8006568 <RVnetSlaveProcess+0x130>)
 8006504:	4798      	blx	r3
 8006506:	4603      	mov	r3, r0
 8006508:	70fb      	strb	r3, [r7, #3]
				break;
 800650a:	e015      	b.n	8006538 <RVnetSlaveProcess+0x100>
			case 0x10:
				pxPack++;
 800650c:	68fb      	ldr	r3, [r7, #12]
 800650e:	3301      	adds	r3, #1
 8006510:	60fb      	str	r3, [r7, #12]
				pkSize = WriteNWords(pxPack);
 8006512:	68f8      	ldr	r0, [r7, #12]
 8006514:	4b15      	ldr	r3, [pc, #84]	; (800656c <RVnetSlaveProcess+0x134>)
 8006516:	4798      	blx	r3
 8006518:	4603      	mov	r3, r0
 800651a:	70fb      	strb	r3, [r7, #3]
				break;
 800651c:	e00c      	b.n	8006538 <RVnetSlaveProcess+0x100>
			default:
				pxPack++;
 800651e:	68fb      	ldr	r3, [r7, #12]
 8006520:	3301      	adds	r3, #1
 8006522:	60fb      	str	r3, [r7, #12]
				pkSize = ErrorAddress(pxPack);
 8006524:	68f8      	ldr	r0, [r7, #12]
 8006526:	4b12      	ldr	r3, [pc, #72]	; (8006570 <RVnetSlaveProcess+0x138>)
 8006528:	4798      	blx	r3
 800652a:	4603      	mov	r3, r0
 800652c:	70fb      	strb	r3, [r7, #3]
				break;
 800652e:	e003      	b.n	8006538 <RVnetSlaveProcess+0x100>

			}
		} else
			return 0;
 8006530:	2300      	movs	r3, #0
 8006532:	e00d      	b.n	8006550 <RVnetSlaveProcess+0x118>
	} else
		return 0;
 8006534:	2300      	movs	r3, #0
 8006536:	e00b      	b.n	8006550 <RVnetSlaveProcess+0x118>
	pkSize += 2;
 8006538:	78fb      	ldrb	r3, [r7, #3]
 800653a:	3302      	adds	r3, #2
 800653c:	70fb      	strb	r3, [r7, #3]
	SetCRC(px_buf, pkSize);
 800653e:	78fb      	ldrb	r3, [r7, #3]
 8006540:	4619      	mov	r1, r3
 8006542:	6878      	ldr	r0, [r7, #4]
 8006544:	4b0b      	ldr	r3, [pc, #44]	; (8006574 <RVnetSlaveProcess+0x13c>)
 8006546:	4798      	blx	r3
	pkSize += 2;
 8006548:	78fb      	ldrb	r3, [r7, #3]
 800654a:	3302      	adds	r3, #2
 800654c:	70fb      	strb	r3, [r7, #3]
	return pkSize;
 800654e:	78fb      	ldrb	r3, [r7, #3]
}
 8006550:	4618      	mov	r0, r3
 8006552:	3710      	adds	r7, #16
 8006554:	46bd      	mov	sp, r7
 8006556:	bd80      	pop	{r7, pc}
 8006558:	08006d45 	.word	0x08006d45
 800655c:	08006579 	.word	0x08006579
 8006560:	08006731 	.word	0x08006731
 8006564:	080065bd 	.word	0x080065bd
 8006568:	080067f1 	.word	0x080067f1
 800656c:	0800667d 	.word	0x0800667d
 8006570:	080068ed 	.word	0x080068ed
 8006574:	08006d9d 	.word	0x08006d9d

08006578 <ReadDeviceID>:
//======================================================================
RVNET_DATATYPE ReadDeviceID(unsigned char *pxPack) {
 8006578:	b480      	push	{r7}
 800657a:	b083      	sub	sp, #12
 800657c:	af00      	add	r7, sp, #0
 800657e:	6078      	str	r0, [r7, #4]
	//   
	*pxPack = 0x00;
 8006580:	687b      	ldr	r3, [r7, #4]
 8006582:	2200      	movs	r2, #0
 8006584:	701a      	strb	r2, [r3, #0]
	pxPack++;
 8006586:	687b      	ldr	r3, [r7, #4]
 8006588:	3301      	adds	r3, #1
 800658a:	607b      	str	r3, [r7, #4]
	*pxPack = 0x01;
 800658c:	687b      	ldr	r3, [r7, #4]
 800658e:	2201      	movs	r2, #1
 8006590:	701a      	strb	r2, [r3, #0]
	pxPack++;
 8006592:	687b      	ldr	r3, [r7, #4]
 8006594:	3301      	adds	r3, #1
 8006596:	607b      	str	r3, [r7, #4]
	*pxPack = 0x01;
 8006598:	687b      	ldr	r3, [r7, #4]
 800659a:	2201      	movs	r2, #1
 800659c:	701a      	strb	r2, [r3, #0]
	pxPack++;
 800659e:	687b      	ldr	r3, [r7, #4]
 80065a0:	3301      	adds	r3, #1
 80065a2:	607b      	str	r3, [r7, #4]
	*pxPack = 0x01;
 80065a4:	687b      	ldr	r3, [r7, #4]
 80065a6:	2201      	movs	r2, #1
 80065a8:	701a      	strb	r2, [r3, #0]
	pxPack++;
 80065aa:	687b      	ldr	r3, [r7, #4]
 80065ac:	3301      	adds	r3, #1
 80065ae:	607b      	str	r3, [r7, #4]
	return 4;
 80065b0:	2304      	movs	r3, #4
}
 80065b2:	4618      	mov	r0, r3
 80065b4:	370c      	adds	r7, #12
 80065b6:	46bd      	mov	sp, r7
 80065b8:	bc80      	pop	{r7}
 80065ba:	4770      	bx	lr

080065bc <ReadNWords>:
//======================================================================
RVNET_DATATYPE ReadNWords(uint8 *pxPack) {
 80065bc:	b580      	push	{r7, lr}
 80065be:	b084      	sub	sp, #16
 80065c0:	af00      	add	r7, sp, #0
 80065c2:	6078      	str	r0, [r7, #4]
	volatile uint16 base, wnum;
	//      
	base = *(pxPack) << 8;
 80065c4:	687b      	ldr	r3, [r7, #4]
 80065c6:	781b      	ldrb	r3, [r3, #0]
 80065c8:	b29b      	uxth	r3, r3
 80065ca:	021b      	lsls	r3, r3, #8
 80065cc:	b29b      	uxth	r3, r3
 80065ce:	81fb      	strh	r3, [r7, #14]
	base += *(pxPack + 1);
 80065d0:	687b      	ldr	r3, [r7, #4]
 80065d2:	3301      	adds	r3, #1
 80065d4:	781b      	ldrb	r3, [r3, #0]
 80065d6:	b29a      	uxth	r2, r3
 80065d8:	89fb      	ldrh	r3, [r7, #14]
 80065da:	b29b      	uxth	r3, r3
 80065dc:	4413      	add	r3, r2
 80065de:	b29b      	uxth	r3, r3
 80065e0:	81fb      	strh	r3, [r7, #14]
	wnum = *(pxPack + 2) << 8;
 80065e2:	687b      	ldr	r3, [r7, #4]
 80065e4:	3302      	adds	r3, #2
 80065e6:	781b      	ldrb	r3, [r3, #0]
 80065e8:	b29b      	uxth	r3, r3
 80065ea:	021b      	lsls	r3, r3, #8
 80065ec:	b29b      	uxth	r3, r3
 80065ee:	81bb      	strh	r3, [r7, #12]
	wnum += *(pxPack + 3);
 80065f0:	687b      	ldr	r3, [r7, #4]
 80065f2:	3303      	adds	r3, #3
 80065f4:	781b      	ldrb	r3, [r3, #0]
 80065f6:	b29a      	uxth	r2, r3
 80065f8:	89bb      	ldrh	r3, [r7, #12]
 80065fa:	b29b      	uxth	r3, r3
 80065fc:	4413      	add	r3, r2
 80065fe:	b29b      	uxth	r3, r3
 8006600:	81bb      	strh	r3, [r7, #12]
	if (wnum > 123) {
 8006602:	89bb      	ldrh	r3, [r7, #12]
 8006604:	b29b      	uxth	r3, r3
 8006606:	2b7b      	cmp	r3, #123	; 0x7b
 8006608:	d904      	bls.n	8006614 <ReadNWords+0x58>
		return ErrorAddress(pxPack);
 800660a:	6878      	ldr	r0, [r7, #4]
 800660c:	4b18      	ldr	r3, [pc, #96]	; (8006670 <ReadNWords+0xb4>)
 800660e:	4798      	blx	r3
 8006610:	4603      	mov	r3, r0
 8006612:	e029      	b.n	8006668 <ReadNWords+0xac>
	}
	*pxPack = (unsigned char) (wnum * 2);
 8006614:	89bb      	ldrh	r3, [r7, #12]
 8006616:	b29b      	uxth	r3, r3
 8006618:	b2db      	uxtb	r3, r3
 800661a:	005b      	lsls	r3, r3, #1
 800661c:	b2da      	uxtb	r2, r3
 800661e:	687b      	ldr	r3, [r7, #4]
 8006620:	701a      	strb	r2, [r3, #0]
	if (MemGetWords(base, (uint16*) (pxPack + 1), wnum) == 0) {
 8006622:	89fb      	ldrh	r3, [r7, #14]
 8006624:	b298      	uxth	r0, r3
 8006626:	687b      	ldr	r3, [r7, #4]
 8006628:	3301      	adds	r3, #1
 800662a:	89ba      	ldrh	r2, [r7, #12]
 800662c:	b292      	uxth	r2, r2
 800662e:	4619      	mov	r1, r3
 8006630:	4b10      	ldr	r3, [pc, #64]	; (8006674 <ReadNWords+0xb8>)
 8006632:	4798      	blx	r3
 8006634:	4603      	mov	r3, r0
 8006636:	f083 0301 	eor.w	r3, r3, #1
 800663a:	b2db      	uxtb	r3, r3
 800663c:	2b00      	cmp	r3, #0
 800663e:	d004      	beq.n	800664a <ReadNWords+0x8e>
		return ErrorAddress(pxPack);
 8006640:	6878      	ldr	r0, [r7, #4]
 8006642:	4b0b      	ldr	r3, [pc, #44]	; (8006670 <ReadNWords+0xb4>)
 8006644:	4798      	blx	r3
 8006646:	4603      	mov	r3, r0
 8006648:	e00e      	b.n	8006668 <ReadNWords+0xac>
	}
	SwapBuffer(pxPack + 1, wnum);
 800664a:	687b      	ldr	r3, [r7, #4]
 800664c:	3301      	adds	r3, #1
 800664e:	89ba      	ldrh	r2, [r7, #12]
 8006650:	b292      	uxth	r2, r2
 8006652:	4611      	mov	r1, r2
 8006654:	4618      	mov	r0, r3
 8006656:	4b08      	ldr	r3, [pc, #32]	; (8006678 <ReadNWords+0xbc>)
 8006658:	4798      	blx	r3
	return (RVNET_DATATYPE) (wnum * 2 + 1);
 800665a:	89bb      	ldrh	r3, [r7, #12]
 800665c:	b29b      	uxth	r3, r3
 800665e:	b2db      	uxtb	r3, r3
 8006660:	005b      	lsls	r3, r3, #1
 8006662:	b2db      	uxtb	r3, r3
 8006664:	3301      	adds	r3, #1
 8006666:	b2db      	uxtb	r3, r3
}
 8006668:	4618      	mov	r0, r3
 800666a:	3710      	adds	r7, #16
 800666c:	46bd      	mov	sp, r7
 800666e:	bd80      	pop	{r7, pc}
 8006670:	080068ed 	.word	0x080068ed
 8006674:	08006bfd 	.word	0x08006bfd
 8006678:	080063f9 	.word	0x080063f9

0800667c <WriteNWords>:
//======================================================================
RVNET_DATATYPE WriteNWords(unsigned char *pxPack) {
 800667c:	b580      	push	{r7, lr}
 800667e:	b084      	sub	sp, #16
 8006680:	af00      	add	r7, sp, #0
 8006682:	6078      	str	r0, [r7, #4]
	volatile uint16 base, wnum;
	//      
	base = *(pxPack) << 8;
 8006684:	687b      	ldr	r3, [r7, #4]
 8006686:	781b      	ldrb	r3, [r3, #0]
 8006688:	b29b      	uxth	r3, r3
 800668a:	021b      	lsls	r3, r3, #8
 800668c:	b29b      	uxth	r3, r3
 800668e:	81bb      	strh	r3, [r7, #12]
	base += *(pxPack + 1);
 8006690:	687b      	ldr	r3, [r7, #4]
 8006692:	3301      	adds	r3, #1
 8006694:	781b      	ldrb	r3, [r3, #0]
 8006696:	b29a      	uxth	r2, r3
 8006698:	89bb      	ldrh	r3, [r7, #12]
 800669a:	b29b      	uxth	r3, r3
 800669c:	4413      	add	r3, r2
 800669e:	b29b      	uxth	r3, r3
 80066a0:	81bb      	strh	r3, [r7, #12]
	wnum = *(pxPack + 2) << 8;
 80066a2:	687b      	ldr	r3, [r7, #4]
 80066a4:	3302      	adds	r3, #2
 80066a6:	781b      	ldrb	r3, [r3, #0]
 80066a8:	b29b      	uxth	r3, r3
 80066aa:	021b      	lsls	r3, r3, #8
 80066ac:	b29b      	uxth	r3, r3
 80066ae:	817b      	strh	r3, [r7, #10]
	wnum += *(pxPack + 3);
 80066b0:	687b      	ldr	r3, [r7, #4]
 80066b2:	3303      	adds	r3, #3
 80066b4:	781b      	ldrb	r3, [r3, #0]
 80066b6:	b29a      	uxth	r2, r3
 80066b8:	897b      	ldrh	r3, [r7, #10]
 80066ba:	b29b      	uxth	r3, r3
 80066bc:	4413      	add	r3, r2
 80066be:	b29b      	uxth	r3, r3
 80066c0:	817b      	strh	r3, [r7, #10]
	if (wnum > 123) {
 80066c2:	897b      	ldrh	r3, [r7, #10]
 80066c4:	b29b      	uxth	r3, r3
 80066c6:	2b7b      	cmp	r3, #123	; 0x7b
 80066c8:	d904      	bls.n	80066d4 <WriteNWords+0x58>
		return ErrorAddress(pxPack);
 80066ca:	6878      	ldr	r0, [r7, #4]
 80066cc:	4b13      	ldr	r3, [pc, #76]	; (800671c <WriteNWords+0xa0>)
 80066ce:	4798      	blx	r3
 80066d0:	4603      	mov	r3, r0
 80066d2:	e01f      	b.n	8006714 <WriteNWords+0x98>
	}
	SwapBuffer(pxPack + 5, wnum);
 80066d4:	687b      	ldr	r3, [r7, #4]
 80066d6:	3305      	adds	r3, #5
 80066d8:	897a      	ldrh	r2, [r7, #10]
 80066da:	b292      	uxth	r2, r2
 80066dc:	4611      	mov	r1, r2
 80066de:	4618      	mov	r0, r3
 80066e0:	4b0f      	ldr	r3, [pc, #60]	; (8006720 <WriteNWords+0xa4>)
 80066e2:	4798      	blx	r3
	portENTER_CRITICAL();
 80066e4:	4b0f      	ldr	r3, [pc, #60]	; (8006724 <WriteNWords+0xa8>)
 80066e6:	4798      	blx	r3
	bool x = MemSetWords(base, pxPack + 5, wnum);
 80066e8:	89bb      	ldrh	r3, [r7, #12]
 80066ea:	b298      	uxth	r0, r3
 80066ec:	687b      	ldr	r3, [r7, #4]
 80066ee:	3305      	adds	r3, #5
 80066f0:	897a      	ldrh	r2, [r7, #10]
 80066f2:	b292      	uxth	r2, r2
 80066f4:	4619      	mov	r1, r3
 80066f6:	4b0c      	ldr	r3, [pc, #48]	; (8006728 <WriteNWords+0xac>)
 80066f8:	4798      	blx	r3
 80066fa:	4603      	mov	r3, r0
 80066fc:	73fb      	strb	r3, [r7, #15]
	portEXIT_CRITICAL();
 80066fe:	4b0b      	ldr	r3, [pc, #44]	; (800672c <WriteNWords+0xb0>)
 8006700:	4798      	blx	r3
	if (x) {
 8006702:	7bfb      	ldrb	r3, [r7, #15]
 8006704:	2b00      	cmp	r3, #0
 8006706:	d001      	beq.n	800670c <WriteNWords+0x90>
		return 4;
 8006708:	2304      	movs	r3, #4
 800670a:	e003      	b.n	8006714 <WriteNWords+0x98>
	} else {
		return ErrorAddress(pxPack);
 800670c:	6878      	ldr	r0, [r7, #4]
 800670e:	4b03      	ldr	r3, [pc, #12]	; (800671c <WriteNWords+0xa0>)
 8006710:	4798      	blx	r3
 8006712:	4603      	mov	r3, r0
	}
}
 8006714:	4618      	mov	r0, r3
 8006716:	3710      	adds	r7, #16
 8006718:	46bd      	mov	sp, r7
 800671a:	bd80      	pop	{r7, pc}
 800671c:	080068ed 	.word	0x080068ed
 8006720:	080063f9 	.word	0x080063f9
 8006724:	080025f9 	.word	0x080025f9
 8006728:	08006ca1 	.word	0x08006ca1
 800672c:	0800261d 	.word	0x0800261d

08006730 <ReadNBits>:
//======================================================================
RVNET_DATATYPE ReadNBits(unsigned char *pxPack) {
 8006730:	b580      	push	{r7, lr}
 8006732:	b084      	sub	sp, #16
 8006734:	af00      	add	r7, sp, #0
 8006736:	6078      	str	r0, [r7, #4]
	volatile uint16 base, wnum;
	//      
	base = *(pxPack) << 8;
 8006738:	687b      	ldr	r3, [r7, #4]
 800673a:	781b      	ldrb	r3, [r3, #0]
 800673c:	b29b      	uxth	r3, r3
 800673e:	021b      	lsls	r3, r3, #8
 8006740:	b29b      	uxth	r3, r3
 8006742:	81fb      	strh	r3, [r7, #14]
	base += *(pxPack + 1);
 8006744:	687b      	ldr	r3, [r7, #4]
 8006746:	3301      	adds	r3, #1
 8006748:	781b      	ldrb	r3, [r3, #0]
 800674a:	b29a      	uxth	r2, r3
 800674c:	89fb      	ldrh	r3, [r7, #14]
 800674e:	b29b      	uxth	r3, r3
 8006750:	4413      	add	r3, r2
 8006752:	b29b      	uxth	r3, r3
 8006754:	81fb      	strh	r3, [r7, #14]
	wnum = *(pxPack + 2) << 8;
 8006756:	687b      	ldr	r3, [r7, #4]
 8006758:	3302      	adds	r3, #2
 800675a:	781b      	ldrb	r3, [r3, #0]
 800675c:	b29b      	uxth	r3, r3
 800675e:	021b      	lsls	r3, r3, #8
 8006760:	b29b      	uxth	r3, r3
 8006762:	81bb      	strh	r3, [r7, #12]
	wnum += *(pxPack + 3);
 8006764:	687b      	ldr	r3, [r7, #4]
 8006766:	3303      	adds	r3, #3
 8006768:	781b      	ldrb	r3, [r3, #0]
 800676a:	b29a      	uxth	r2, r3
 800676c:	89bb      	ldrh	r3, [r7, #12]
 800676e:	b29b      	uxth	r3, r3
 8006770:	4413      	add	r3, r2
 8006772:	b29b      	uxth	r3, r3
 8006774:	81bb      	strh	r3, [r7, #12]
	*pxPack = ((wnum / 8) & 0xff);
 8006776:	89bb      	ldrh	r3, [r7, #12]
 8006778:	b29b      	uxth	r3, r3
 800677a:	08db      	lsrs	r3, r3, #3
 800677c:	b29b      	uxth	r3, r3
 800677e:	b2da      	uxtb	r2, r3
 8006780:	687b      	ldr	r3, [r7, #4]
 8006782:	701a      	strb	r2, [r3, #0]
	base /= 16;
 8006784:	89fb      	ldrh	r3, [r7, #14]
 8006786:	b29b      	uxth	r3, r3
 8006788:	091b      	lsrs	r3, r3, #4
 800678a:	b29b      	uxth	r3, r3
 800678c:	81fb      	strh	r3, [r7, #14]
	wnum /= 16;
 800678e:	89bb      	ldrh	r3, [r7, #12]
 8006790:	b29b      	uxth	r3, r3
 8006792:	091b      	lsrs	r3, r3, #4
 8006794:	b29b      	uxth	r3, r3
 8006796:	81bb      	strh	r3, [r7, #12]
	if (wnum > 123) {
 8006798:	89bb      	ldrh	r3, [r7, #12]
 800679a:	b29b      	uxth	r3, r3
 800679c:	2b7b      	cmp	r3, #123	; 0x7b
 800679e:	d904      	bls.n	80067aa <ReadNBits+0x7a>
		return ErrorAddress(pxPack);
 80067a0:	6878      	ldr	r0, [r7, #4]
 80067a2:	4b11      	ldr	r3, [pc, #68]	; (80067e8 <ReadNBits+0xb8>)
 80067a4:	4798      	blx	r3
 80067a6:	4603      	mov	r3, r0
 80067a8:	e01a      	b.n	80067e0 <ReadNBits+0xb0>
	}
	//  
	// E   RAM    -------------------------------------------------

	if (MemGetWords(base, pxPack + 1, wnum) == 0) {
 80067aa:	89fb      	ldrh	r3, [r7, #14]
 80067ac:	b298      	uxth	r0, r3
 80067ae:	687b      	ldr	r3, [r7, #4]
 80067b0:	3301      	adds	r3, #1
 80067b2:	89ba      	ldrh	r2, [r7, #12]
 80067b4:	b292      	uxth	r2, r2
 80067b6:	4619      	mov	r1, r3
 80067b8:	4b0c      	ldr	r3, [pc, #48]	; (80067ec <ReadNBits+0xbc>)
 80067ba:	4798      	blx	r3
 80067bc:	4603      	mov	r3, r0
 80067be:	f083 0301 	eor.w	r3, r3, #1
 80067c2:	b2db      	uxtb	r3, r3
 80067c4:	2b00      	cmp	r3, #0
 80067c6:	d004      	beq.n	80067d2 <ReadNBits+0xa2>
		return ErrorAddress(pxPack);
 80067c8:	6878      	ldr	r0, [r7, #4]
 80067ca:	4b07      	ldr	r3, [pc, #28]	; (80067e8 <ReadNBits+0xb8>)
 80067cc:	4798      	blx	r3
 80067ce:	4603      	mov	r3, r0
 80067d0:	e006      	b.n	80067e0 <ReadNBits+0xb0>
	}
	return (RVNET_DATATYPE) (wnum * 2 + 1);
 80067d2:	89bb      	ldrh	r3, [r7, #12]
 80067d4:	b29b      	uxth	r3, r3
 80067d6:	b2db      	uxtb	r3, r3
 80067d8:	005b      	lsls	r3, r3, #1
 80067da:	b2db      	uxtb	r3, r3
 80067dc:	3301      	adds	r3, #1
 80067de:	b2db      	uxtb	r3, r3
}
 80067e0:	4618      	mov	r0, r3
 80067e2:	3710      	adds	r7, #16
 80067e4:	46bd      	mov	sp, r7
 80067e6:	bd80      	pop	{r7, pc}
 80067e8:	080068ed 	.word	0x080068ed
 80067ec:	08006bfd 	.word	0x08006bfd

080067f0 <WriteBit>:
//======================================================================
RVNET_DATATYPE WriteBit(unsigned char *pxPack) {
 80067f0:	b580      	push	{r7, lr}
 80067f2:	b084      	sub	sp, #16
 80067f4:	af00      	add	r7, sp, #0
 80067f6:	6078      	str	r0, [r7, #4]
	volatile uint16 base, wnum;
	uint16 temp_word;
	uint16 bit_shift;
	//      
	base = *(pxPack) << 8;
 80067f8:	687b      	ldr	r3, [r7, #4]
 80067fa:	781b      	ldrb	r3, [r3, #0]
 80067fc:	b29b      	uxth	r3, r3
 80067fe:	021b      	lsls	r3, r3, #8
 8006800:	b29b      	uxth	r3, r3
 8006802:	81bb      	strh	r3, [r7, #12]
	base += *(pxPack + 1);
 8006804:	687b      	ldr	r3, [r7, #4]
 8006806:	3301      	adds	r3, #1
 8006808:	781b      	ldrb	r3, [r3, #0]
 800680a:	b29a      	uxth	r2, r3
 800680c:	89bb      	ldrh	r3, [r7, #12]
 800680e:	b29b      	uxth	r3, r3
 8006810:	4413      	add	r3, r2
 8006812:	b29b      	uxth	r3, r3
 8006814:	81bb      	strh	r3, [r7, #12]
	wnum = *(pxPack + 2) << 8;
 8006816:	687b      	ldr	r3, [r7, #4]
 8006818:	3302      	adds	r3, #2
 800681a:	781b      	ldrb	r3, [r3, #0]
 800681c:	b29b      	uxth	r3, r3
 800681e:	021b      	lsls	r3, r3, #8
 8006820:	b29b      	uxth	r3, r3
 8006822:	817b      	strh	r3, [r7, #10]
	wnum += *(pxPack + 3);
 8006824:	687b      	ldr	r3, [r7, #4]
 8006826:	3303      	adds	r3, #3
 8006828:	781b      	ldrb	r3, [r3, #0]
 800682a:	b29a      	uxth	r2, r3
 800682c:	897b      	ldrh	r3, [r7, #10]
 800682e:	b29b      	uxth	r3, r3
 8006830:	4413      	add	r3, r2
 8006832:	b29b      	uxth	r3, r3
 8006834:	817b      	strh	r3, [r7, #10]
	bit_shift = base % 16;
 8006836:	89bb      	ldrh	r3, [r7, #12]
 8006838:	b29b      	uxth	r3, r3
 800683a:	f003 030f 	and.w	r3, r3, #15
 800683e:	81fb      	strh	r3, [r7, #14]
	base /= 16;
 8006840:	89bb      	ldrh	r3, [r7, #12]
 8006842:	b29b      	uxth	r3, r3
 8006844:	091b      	lsrs	r3, r3, #4
 8006846:	b29b      	uxth	r3, r3
 8006848:	81bb      	strh	r3, [r7, #12]
	//if(wnum >123){return ErrorAddress(pxPack);}
	// wnum.word /= 16;
	if (MemGetWords(base, &temp_word, 1) == 0) {
 800684a:	89bb      	ldrh	r3, [r7, #12]
 800684c:	b29b      	uxth	r3, r3
 800684e:	f107 0108 	add.w	r1, r7, #8
 8006852:	2201      	movs	r2, #1
 8006854:	4618      	mov	r0, r3
 8006856:	4b22      	ldr	r3, [pc, #136]	; (80068e0 <WriteBit+0xf0>)
 8006858:	4798      	blx	r3
 800685a:	4603      	mov	r3, r0
 800685c:	f083 0301 	eor.w	r3, r3, #1
 8006860:	b2db      	uxtb	r3, r3
 8006862:	2b00      	cmp	r3, #0
 8006864:	d004      	beq.n	8006870 <WriteBit+0x80>
		return ErrorAddress(pxPack);
 8006866:	6878      	ldr	r0, [r7, #4]
 8006868:	4b1e      	ldr	r3, [pc, #120]	; (80068e4 <WriteBit+0xf4>)
 800686a:	4798      	blx	r3
 800686c:	4603      	mov	r3, r0
 800686e:	e032      	b.n	80068d6 <WriteBit+0xe6>
	}
	if ((wnum & 0xFF00) == 0)
 8006870:	897b      	ldrh	r3, [r7, #10]
 8006872:	b29b      	uxth	r3, r3
 8006874:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 8006878:	2b00      	cmp	r3, #0
 800687a:	d10d      	bne.n	8006898 <WriteBit+0xa8>
		temp_word &= ~(1 << bit_shift);
 800687c:	89fb      	ldrh	r3, [r7, #14]
 800687e:	2201      	movs	r2, #1
 8006880:	fa02 f303 	lsl.w	r3, r2, r3
 8006884:	b21b      	sxth	r3, r3
 8006886:	43db      	mvns	r3, r3
 8006888:	b21a      	sxth	r2, r3
 800688a:	893b      	ldrh	r3, [r7, #8]
 800688c:	b21b      	sxth	r3, r3
 800688e:	4013      	ands	r3, r2
 8006890:	b21b      	sxth	r3, r3
 8006892:	b29b      	uxth	r3, r3
 8006894:	813b      	strh	r3, [r7, #8]
 8006896:	e00a      	b.n	80068ae <WriteBit+0xbe>
	else
		temp_word |= (1 << bit_shift);
 8006898:	89fb      	ldrh	r3, [r7, #14]
 800689a:	2201      	movs	r2, #1
 800689c:	fa02 f303 	lsl.w	r3, r2, r3
 80068a0:	b21a      	sxth	r2, r3
 80068a2:	893b      	ldrh	r3, [r7, #8]
 80068a4:	b21b      	sxth	r3, r3
 80068a6:	4313      	orrs	r3, r2
 80068a8:	b21b      	sxth	r3, r3
 80068aa:	b29b      	uxth	r3, r3
 80068ac:	813b      	strh	r3, [r7, #8]
	if (MemSetWords(base, &temp_word, 1) == 0) {
 80068ae:	89bb      	ldrh	r3, [r7, #12]
 80068b0:	b29b      	uxth	r3, r3
 80068b2:	f107 0108 	add.w	r1, r7, #8
 80068b6:	2201      	movs	r2, #1
 80068b8:	4618      	mov	r0, r3
 80068ba:	4b0b      	ldr	r3, [pc, #44]	; (80068e8 <WriteBit+0xf8>)
 80068bc:	4798      	blx	r3
 80068be:	4603      	mov	r3, r0
 80068c0:	f083 0301 	eor.w	r3, r3, #1
 80068c4:	b2db      	uxtb	r3, r3
 80068c6:	2b00      	cmp	r3, #0
 80068c8:	d004      	beq.n	80068d4 <WriteBit+0xe4>
		return ErrorAddress(pxPack);
 80068ca:	6878      	ldr	r0, [r7, #4]
 80068cc:	4b05      	ldr	r3, [pc, #20]	; (80068e4 <WriteBit+0xf4>)
 80068ce:	4798      	blx	r3
 80068d0:	4603      	mov	r3, r0
 80068d2:	e000      	b.n	80068d6 <WriteBit+0xe6>
	}
	return 4;
 80068d4:	2304      	movs	r3, #4
}
 80068d6:	4618      	mov	r0, r3
 80068d8:	3710      	adds	r7, #16
 80068da:	46bd      	mov	sp, r7
 80068dc:	bd80      	pop	{r7, pc}
 80068de:	bf00      	nop
 80068e0:	08006bfd 	.word	0x08006bfd
 80068e4:	080068ed 	.word	0x080068ed
 80068e8:	08006ca1 	.word	0x08006ca1

080068ec <ErrorAddress>:
//======================================================================

RVNET_DATATYPE ErrorAddress(unsigned char *pxPack) {
 80068ec:	b480      	push	{r7}
 80068ee:	b083      	sub	sp, #12
 80068f0:	af00      	add	r7, sp, #0
 80068f2:	6078      	str	r0, [r7, #4]
	*(pxPack - 1) |= 0x80;
 80068f4:	687b      	ldr	r3, [r7, #4]
 80068f6:	3b01      	subs	r3, #1
 80068f8:	781a      	ldrb	r2, [r3, #0]
 80068fa:	687b      	ldr	r3, [r7, #4]
 80068fc:	3b01      	subs	r3, #1
 80068fe:	f062 027f 	orn	r2, r2, #127	; 0x7f
 8006902:	b2d2      	uxtb	r2, r2
 8006904:	701a      	strb	r2, [r3, #0]
	return 0;
 8006906:	2300      	movs	r3, #0
}
 8006908:	4618      	mov	r0, r3
 800690a:	370c      	adds	r7, #12
 800690c:	46bd      	mov	sp, r7
 800690e:	bc80      	pop	{r7}
 8006910:	4770      	bx	lr
	...

08006914 <ErrorCreate>:
      i++;
    }

}
ErrorHandle ErrorCreate(char *eDescription)
{
 8006914:	b480      	push	{r7}
 8006916:	b085      	sub	sp, #20
 8006918:	af00      	add	r7, sp, #0
 800691a:	6078      	str	r0, [r7, #4]
  uint16 i = 0;
 800691c:	2300      	movs	r3, #0
 800691e:	81fb      	strh	r3, [r7, #14]
  ErrorHandle eHandle ;
  if((ErrorsAmount != ErrorsMaxAmount) && IsErrorInitialized)
 8006920:	4b23      	ldr	r3, [pc, #140]	; (80069b0 <ErrorCreate+0x9c>)
 8006922:	881a      	ldrh	r2, [r3, #0]
 8006924:	4b23      	ldr	r3, [pc, #140]	; (80069b4 <ErrorCreate+0xa0>)
 8006926:	881b      	ldrh	r3, [r3, #0]
 8006928:	429a      	cmp	r2, r3
 800692a:	d03a      	beq.n	80069a2 <ErrorCreate+0x8e>
 800692c:	4b22      	ldr	r3, [pc, #136]	; (80069b8 <ErrorCreate+0xa4>)
 800692e:	681b      	ldr	r3, [r3, #0]
 8006930:	2b00      	cmp	r3, #0
 8006932:	d036      	beq.n	80069a2 <ErrorCreate+0x8e>
  {
    eHandle = ErrorsAmount;
 8006934:	4b1e      	ldr	r3, [pc, #120]	; (80069b0 <ErrorCreate+0x9c>)
 8006936:	881b      	ldrh	r3, [r3, #0]
 8006938:	81bb      	strh	r3, [r7, #12]
    ErrorsAmount++;
 800693a:	4b1d      	ldr	r3, [pc, #116]	; (80069b0 <ErrorCreate+0x9c>)
 800693c:	881b      	ldrh	r3, [r3, #0]
 800693e:	3301      	adds	r3, #1
 8006940:	b29a      	uxth	r2, r3
 8006942:	4b1b      	ldr	r3, [pc, #108]	; (80069b0 <ErrorCreate+0x9c>)
 8006944:	801a      	strh	r2, [r3, #0]
    Errors[eHandle].EvetsCounter = 0;
 8006946:	4b1d      	ldr	r3, [pc, #116]	; (80069bc <ErrorCreate+0xa8>)
 8006948:	6819      	ldr	r1, [r3, #0]
 800694a:	89ba      	ldrh	r2, [r7, #12]
 800694c:	4613      	mov	r3, r2
 800694e:	00db      	lsls	r3, r3, #3
 8006950:	4413      	add	r3, r2
 8006952:	005b      	lsls	r3, r3, #1
 8006954:	440b      	add	r3, r1
 8006956:	2200      	movs	r2, #0
 8006958:	801a      	strh	r2, [r3, #0]
    Errors[0].EvetsCounter++;
 800695a:	4b18      	ldr	r3, [pc, #96]	; (80069bc <ErrorCreate+0xa8>)
 800695c:	681b      	ldr	r3, [r3, #0]
 800695e:	881a      	ldrh	r2, [r3, #0]
 8006960:	3201      	adds	r2, #1
 8006962:	b292      	uxth	r2, r2
 8006964:	801a      	strh	r2, [r3, #0]
    while( (i<ERROR_DESCRIPTOR_TEXT_SIZE) && (*eDescription))
 8006966:	e013      	b.n	8006990 <ErrorCreate+0x7c>
    {
      Errors[eHandle].Description[i] =  *eDescription;
 8006968:	4b14      	ldr	r3, [pc, #80]	; (80069bc <ErrorCreate+0xa8>)
 800696a:	6819      	ldr	r1, [r3, #0]
 800696c:	89ba      	ldrh	r2, [r7, #12]
 800696e:	4613      	mov	r3, r2
 8006970:	00db      	lsls	r3, r3, #3
 8006972:	4413      	add	r3, r2
 8006974:	005b      	lsls	r3, r3, #1
 8006976:	18ca      	adds	r2, r1, r3
 8006978:	89fb      	ldrh	r3, [r7, #14]
 800697a:	6879      	ldr	r1, [r7, #4]
 800697c:	7809      	ldrb	r1, [r1, #0]
 800697e:	4413      	add	r3, r2
 8006980:	460a      	mov	r2, r1
 8006982:	709a      	strb	r2, [r3, #2]
      eDescription++;
 8006984:	687b      	ldr	r3, [r7, #4]
 8006986:	3301      	adds	r3, #1
 8006988:	607b      	str	r3, [r7, #4]
      i++;
 800698a:	89fb      	ldrh	r3, [r7, #14]
 800698c:	3301      	adds	r3, #1
 800698e:	81fb      	strh	r3, [r7, #14]
    while( (i<ERROR_DESCRIPTOR_TEXT_SIZE) && (*eDescription))
 8006990:	89fb      	ldrh	r3, [r7, #14]
 8006992:	2b0f      	cmp	r3, #15
 8006994:	d803      	bhi.n	800699e <ErrorCreate+0x8a>
 8006996:	687b      	ldr	r3, [r7, #4]
 8006998:	781b      	ldrb	r3, [r3, #0]
 800699a:	2b00      	cmp	r3, #0
 800699c:	d1e4      	bne.n	8006968 <ErrorCreate+0x54>
    }
   return eHandle;
 800699e:	89bb      	ldrh	r3, [r7, #12]
 80069a0:	e000      	b.n	80069a4 <ErrorCreate+0x90>
  }
  return 0;
 80069a2:	2300      	movs	r3, #0
}
 80069a4:	4618      	mov	r0, r3
 80069a6:	3714      	adds	r7, #20
 80069a8:	46bd      	mov	sp, r7
 80069aa:	bc80      	pop	{r7}
 80069ac:	4770      	bx	lr
 80069ae:	bf00      	nop
 80069b0:	20000158 	.word	0x20000158
 80069b4:	2000015a 	.word	0x2000015a
 80069b8:	20007110 	.word	0x20007110
 80069bc:	20007114 	.word	0x20007114

080069c0 <RVnetTcpSlaveProcess>:
#define RVTCP_DATA	8

#define MB_TCP_PROTOCOL_ID  0

RVNET_DATATYPE RVnetTcpSlaveProcess(uint8 *buf, RVNET_DATATYPE pkSize,
		uint8 device_address) {
 80069c0:	b580      	push	{r7, lr}
 80069c2:	b084      	sub	sp, #16
 80069c4:	af00      	add	r7, sp, #0
 80069c6:	6078      	str	r0, [r7, #4]
 80069c8:	460b      	mov	r3, r1
 80069ca:	70fb      	strb	r3, [r7, #3]
 80069cc:	4613      	mov	r3, r2
 80069ce:	70bb      	strb	r3, [r7, #2]
	uint16 len, pid;

	len = buf[RVTCP_LEN] << 8U;
 80069d0:	687b      	ldr	r3, [r7, #4]
 80069d2:	3304      	adds	r3, #4
 80069d4:	781b      	ldrb	r3, [r3, #0]
 80069d6:	b29b      	uxth	r3, r3
 80069d8:	021b      	lsls	r3, r3, #8
 80069da:	81fb      	strh	r3, [r7, #14]
	len |= buf[RVTCP_LEN + 1];
 80069dc:	687b      	ldr	r3, [r7, #4]
 80069de:	3305      	adds	r3, #5
 80069e0:	781b      	ldrb	r3, [r3, #0]
 80069e2:	b29a      	uxth	r2, r3
 80069e4:	89fb      	ldrh	r3, [r7, #14]
 80069e6:	4313      	orrs	r3, r2
 80069e8:	81fb      	strh	r3, [r7, #14]

	pid = buf[RVTCP_PID] << 8U;
 80069ea:	687b      	ldr	r3, [r7, #4]
 80069ec:	3302      	adds	r3, #2
 80069ee:	781b      	ldrb	r3, [r3, #0]
 80069f0:	b29b      	uxth	r3, r3
 80069f2:	021b      	lsls	r3, r3, #8
 80069f4:	81bb      	strh	r3, [r7, #12]
	pid |= buf[RVTCP_PID + 1];
 80069f6:	687b      	ldr	r3, [r7, #4]
 80069f8:	3303      	adds	r3, #3
 80069fa:	781b      	ldrb	r3, [r3, #0]
 80069fc:	b29a      	uxth	r2, r3
 80069fe:	89bb      	ldrh	r3, [r7, #12]
 8006a00:	4313      	orrs	r3, r2
 8006a02:	81bb      	strh	r3, [r7, #12]

	switch (buf[RVTCP_FUNC]) {
 8006a04:	687b      	ldr	r3, [r7, #4]
 8006a06:	3307      	adds	r3, #7
 8006a08:	781b      	ldrb	r3, [r3, #0]
 8006a0a:	2b10      	cmp	r3, #16
 8006a0c:	d84c      	bhi.n	8006aa8 <RVnetTcpSlaveProcess+0xe8>
 8006a0e:	a201      	add	r2, pc, #4	; (adr r2, 8006a14 <RVnetTcpSlaveProcess+0x54>)
 8006a10:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8006a14:	08006a59 	.word	0x08006a59
 8006a18:	08006a69 	.word	0x08006a69
 8006a1c:	08006a69 	.word	0x08006a69
 8006a20:	08006a79 	.word	0x08006a79
 8006a24:	08006a79 	.word	0x08006a79
 8006a28:	08006a89 	.word	0x08006a89
 8006a2c:	08006aa9 	.word	0x08006aa9
 8006a30:	08006aa9 	.word	0x08006aa9
 8006a34:	08006aa9 	.word	0x08006aa9
 8006a38:	08006aa9 	.word	0x08006aa9
 8006a3c:	08006aa9 	.word	0x08006aa9
 8006a40:	08006aa9 	.word	0x08006aa9
 8006a44:	08006aa9 	.word	0x08006aa9
 8006a48:	08006aa9 	.word	0x08006aa9
 8006a4c:	08006aa9 	.word	0x08006aa9
 8006a50:	08006aa9 	.word	0x08006aa9
 8006a54:	08006a99 	.word	0x08006a99
	case 0x00:
		len = ReadDeviceID(&buf[RVTCP_DATA]);
 8006a58:	687b      	ldr	r3, [r7, #4]
 8006a5a:	3308      	adds	r3, #8
 8006a5c:	4618      	mov	r0, r3
 8006a5e:	4b23      	ldr	r3, [pc, #140]	; (8006aec <RVnetTcpSlaveProcess+0x12c>)
 8006a60:	4798      	blx	r3
 8006a62:	4603      	mov	r3, r0
 8006a64:	81fb      	strh	r3, [r7, #14]
		break;
 8006a66:	e027      	b.n	8006ab8 <RVnetTcpSlaveProcess+0xf8>
	case 0x01:
	case 0x02:
		len = ReadNBits(&buf[RVTCP_DATA]);
 8006a68:	687b      	ldr	r3, [r7, #4]
 8006a6a:	3308      	adds	r3, #8
 8006a6c:	4618      	mov	r0, r3
 8006a6e:	4b20      	ldr	r3, [pc, #128]	; (8006af0 <RVnetTcpSlaveProcess+0x130>)
 8006a70:	4798      	blx	r3
 8006a72:	4603      	mov	r3, r0
 8006a74:	81fb      	strh	r3, [r7, #14]
		break;
 8006a76:	e01f      	b.n	8006ab8 <RVnetTcpSlaveProcess+0xf8>
	case 0x03:
	case 0x04:
		len = ReadNWords(&buf[RVTCP_DATA]);
 8006a78:	687b      	ldr	r3, [r7, #4]
 8006a7a:	3308      	adds	r3, #8
 8006a7c:	4618      	mov	r0, r3
 8006a7e:	4b1d      	ldr	r3, [pc, #116]	; (8006af4 <RVnetTcpSlaveProcess+0x134>)
 8006a80:	4798      	blx	r3
 8006a82:	4603      	mov	r3, r0
 8006a84:	81fb      	strh	r3, [r7, #14]
		break;
 8006a86:	e017      	b.n	8006ab8 <RVnetTcpSlaveProcess+0xf8>
	case 0x05:
		len = WriteBit(&buf[RVTCP_DATA]);
 8006a88:	687b      	ldr	r3, [r7, #4]
 8006a8a:	3308      	adds	r3, #8
 8006a8c:	4618      	mov	r0, r3
 8006a8e:	4b1a      	ldr	r3, [pc, #104]	; (8006af8 <RVnetTcpSlaveProcess+0x138>)
 8006a90:	4798      	blx	r3
 8006a92:	4603      	mov	r3, r0
 8006a94:	81fb      	strh	r3, [r7, #14]
		break;
 8006a96:	e00f      	b.n	8006ab8 <RVnetTcpSlaveProcess+0xf8>
	case 0x10:
		//pkSize = WriteNWords(&buf[RVTCP_DATA]);
		len = WriteNWords(&buf[RVTCP_DATA]);
 8006a98:	687b      	ldr	r3, [r7, #4]
 8006a9a:	3308      	adds	r3, #8
 8006a9c:	4618      	mov	r0, r3
 8006a9e:	4b17      	ldr	r3, [pc, #92]	; (8006afc <RVnetTcpSlaveProcess+0x13c>)
 8006aa0:	4798      	blx	r3
 8006aa2:	4603      	mov	r3, r0
 8006aa4:	81fb      	strh	r3, [r7, #14]
		break;
 8006aa6:	e007      	b.n	8006ab8 <RVnetTcpSlaveProcess+0xf8>
	default:
		len = ErrorAddress(&buf[RVTCP_DATA]);
 8006aa8:	687b      	ldr	r3, [r7, #4]
 8006aaa:	3308      	adds	r3, #8
 8006aac:	4618      	mov	r0, r3
 8006aae:	4b14      	ldr	r3, [pc, #80]	; (8006b00 <RVnetTcpSlaveProcess+0x140>)
 8006ab0:	4798      	blx	r3
 8006ab2:	4603      	mov	r3, r0
 8006ab4:	81fb      	strh	r3, [r7, #14]
		break;
 8006ab6:	bf00      	nop
	}
	len += 1;
 8006ab8:	89fb      	ldrh	r3, [r7, #14]
 8006aba:	3301      	adds	r3, #1
 8006abc:	81fb      	strh	r3, [r7, #14]
	buf[RVTCP_LEN] = (len + 1) >> 8U;
 8006abe:	89fb      	ldrh	r3, [r7, #14]
 8006ac0:	3301      	adds	r3, #1
 8006ac2:	121a      	asrs	r2, r3, #8
 8006ac4:	687b      	ldr	r3, [r7, #4]
 8006ac6:	3304      	adds	r3, #4
 8006ac8:	b2d2      	uxtb	r2, r2
 8006aca:	701a      	strb	r2, [r3, #0]
	buf[RVTCP_LEN + 1] = (len + 1) & 0xFF;
 8006acc:	89fb      	ldrh	r3, [r7, #14]
 8006ace:	b2da      	uxtb	r2, r3
 8006ad0:	687b      	ldr	r3, [r7, #4]
 8006ad2:	3305      	adds	r3, #5
 8006ad4:	3201      	adds	r2, #1
 8006ad6:	b2d2      	uxtb	r2, r2
 8006ad8:	701a      	strb	r2, [r3, #0]
	return (len + RVTCP_FUNC);
 8006ada:	89fb      	ldrh	r3, [r7, #14]
 8006adc:	b2db      	uxtb	r3, r3
 8006ade:	3307      	adds	r3, #7
 8006ae0:	b2db      	uxtb	r3, r3
}
 8006ae2:	4618      	mov	r0, r3
 8006ae4:	3710      	adds	r7, #16
 8006ae6:	46bd      	mov	sp, r7
 8006ae8:	bd80      	pop	{r7, pc}
 8006aea:	bf00      	nop
 8006aec:	08006579 	.word	0x08006579
 8006af0:	08006731 	.word	0x08006731
 8006af4:	080065bd 	.word	0x080065bd
 8006af8:	080067f1 	.word	0x080067f1
 8006afc:	0800667d 	.word	0x0800667d
 8006b00:	080068ed 	.word	0x080068ed

08006b04 <MemManInit>:
MEMUNIT memunit[MEMUNITS_NUM];
int GetDefaultHandler( uint16, uint16*, uint16) ;
int SetDefaultHandler( uint16, uint16*, uint16);

bool MemManInit()
  {
 8006b04:	b580      	push	{r7, lr}
 8006b06:	b084      	sub	sp, #16
 8006b08:	af00      	add	r7, sp, #0
    int i = MEMUNITS_NUM;
 8006b0a:	2306      	movs	r3, #6
 8006b0c:	60fb      	str	r3, [r7, #12]
    bool rezult = false;
 8006b0e:	2300      	movs	r3, #0
 8006b10:	71fb      	strb	r3, [r7, #7]
    MEMUNIT *pxMemunit = &memunit[0];
 8006b12:	4b16      	ldr	r3, [pc, #88]	; (8006b6c <MemManInit+0x68>)
 8006b14:	60bb      	str	r3, [r7, #8]
    while (i--)
 8006b16:	e00e      	b.n	8006b36 <MemManInit+0x32>
      {
        pxMemunit->startaddr = 0x0;
 8006b18:	68bb      	ldr	r3, [r7, #8]
 8006b1a:	2200      	movs	r2, #0
 8006b1c:	601a      	str	r2, [r3, #0]
        pxMemunit->endaddr = 0x0;
 8006b1e:	68bb      	ldr	r3, [r7, #8]
 8006b20:	2200      	movs	r2, #0
 8006b22:	605a      	str	r2, [r3, #4]
        pxMemunit->GetMem = GetDefaultHandler;
 8006b24:	68bb      	ldr	r3, [r7, #8]
 8006b26:	4a12      	ldr	r2, [pc, #72]	; (8006b70 <MemManInit+0x6c>)
 8006b28:	60da      	str	r2, [r3, #12]
        pxMemunit->SetMem = SetDefaultHandler;
 8006b2a:	68bb      	ldr	r3, [r7, #8]
 8006b2c:	4a11      	ldr	r2, [pc, #68]	; (8006b74 <MemManInit+0x70>)
 8006b2e:	611a      	str	r2, [r3, #16]
       // pxMemunit->xMutex = xSemaphoreCreateMutex() ;
        pxMemunit++;
 8006b30:	68bb      	ldr	r3, [r7, #8]
 8006b32:	3314      	adds	r3, #20
 8006b34:	60bb      	str	r3, [r7, #8]
    while (i--)
 8006b36:	68fb      	ldr	r3, [r7, #12]
 8006b38:	1e5a      	subs	r2, r3, #1
 8006b3a:	60fa      	str	r2, [r7, #12]
 8006b3c:	2b00      	cmp	r3, #0
 8006b3e:	d1eb      	bne.n	8006b18 <MemManInit+0x14>
      }
    rezult = true;
 8006b40:	2301      	movs	r3, #1
 8006b42:	71fb      	strb	r3, [r7, #7]
    MemManReadAccessError = ErrorCreate("MM_ReadAccess");
 8006b44:	480c      	ldr	r0, [pc, #48]	; (8006b78 <MemManInit+0x74>)
 8006b46:	4b0d      	ldr	r3, [pc, #52]	; (8006b7c <MemManInit+0x78>)
 8006b48:	4798      	blx	r3
 8006b4a:	4603      	mov	r3, r0
 8006b4c:	461a      	mov	r2, r3
 8006b4e:	4b0c      	ldr	r3, [pc, #48]	; (8006b80 <MemManInit+0x7c>)
 8006b50:	801a      	strh	r2, [r3, #0]
    MemManWriteAccessError = ErrorCreate("MM_WriteAccess");
 8006b52:	480c      	ldr	r0, [pc, #48]	; (8006b84 <MemManInit+0x80>)
 8006b54:	4b09      	ldr	r3, [pc, #36]	; (8006b7c <MemManInit+0x78>)
 8006b56:	4798      	blx	r3
 8006b58:	4603      	mov	r3, r0
 8006b5a:	461a      	mov	r2, r3
 8006b5c:	4b0a      	ldr	r3, [pc, #40]	; (8006b88 <MemManInit+0x84>)
 8006b5e:	801a      	strh	r2, [r3, #0]
    return rezult;
 8006b60:	79fb      	ldrb	r3, [r7, #7]

  }
 8006b62:	4618      	mov	r0, r3
 8006b64:	3710      	adds	r7, #16
 8006b66:	46bd      	mov	sp, r7
 8006b68:	bd80      	pop	{r7, pc}
 8006b6a:	bf00      	nop
 8006b6c:	2000711c 	.word	0x2000711c
 8006b70:	08006bc3 	.word	0x08006bc3
 8006b74:	08006bdf 	.word	0x08006bdf
 8006b78:	0801495c 	.word	0x0801495c
 8006b7c:	08006915 	.word	0x08006915
 8006b80:	20007118 	.word	0x20007118
 8006b84:	0801496c 	.word	0x0801496c
 8006b88:	2000711a 	.word	0x2000711a

08006b8c <CopyDataBytes>:
void CopyDataBytes(uint8 *pxSRC, uint8 *pxDSN, uint16 BytesNum)
  {
 8006b8c:	b480      	push	{r7}
 8006b8e:	b085      	sub	sp, #20
 8006b90:	af00      	add	r7, sp, #0
 8006b92:	60f8      	str	r0, [r7, #12]
 8006b94:	60b9      	str	r1, [r7, #8]
 8006b96:	4613      	mov	r3, r2
 8006b98:	80fb      	strh	r3, [r7, #6]
    while (BytesNum--)
 8006b9a:	e007      	b.n	8006bac <CopyDataBytes+0x20>
      {
        *(pxDSN++) = *(pxSRC++);
 8006b9c:	68fa      	ldr	r2, [r7, #12]
 8006b9e:	1c53      	adds	r3, r2, #1
 8006ba0:	60fb      	str	r3, [r7, #12]
 8006ba2:	68bb      	ldr	r3, [r7, #8]
 8006ba4:	1c59      	adds	r1, r3, #1
 8006ba6:	60b9      	str	r1, [r7, #8]
 8006ba8:	7812      	ldrb	r2, [r2, #0]
 8006baa:	701a      	strb	r2, [r3, #0]
    while (BytesNum--)
 8006bac:	88fb      	ldrh	r3, [r7, #6]
 8006bae:	1e5a      	subs	r2, r3, #1
 8006bb0:	80fa      	strh	r2, [r7, #6]
 8006bb2:	2b00      	cmp	r3, #0
 8006bb4:	d1f2      	bne.n	8006b9c <CopyDataBytes+0x10>
      }
  }
 8006bb6:	bf00      	nop
 8006bb8:	bf00      	nop
 8006bba:	3714      	adds	r7, #20
 8006bbc:	46bd      	mov	sp, r7
 8006bbe:	bc80      	pop	{r7}
 8006bc0:	4770      	bx	lr

08006bc2 <GetDefaultHandler>:
//==============================================================================
int GetDefaultHandler(uint16 addr, uint16* pxDsn, uint16 len)
  {
 8006bc2:	b480      	push	{r7}
 8006bc4:	b083      	sub	sp, #12
 8006bc6:	af00      	add	r7, sp, #0
 8006bc8:	4603      	mov	r3, r0
 8006bca:	6039      	str	r1, [r7, #0]
 8006bcc:	80fb      	strh	r3, [r7, #6]
 8006bce:	4613      	mov	r3, r2
 8006bd0:	80bb      	strh	r3, [r7, #4]
    return false;
 8006bd2:	2300      	movs	r3, #0
  }
 8006bd4:	4618      	mov	r0, r3
 8006bd6:	370c      	adds	r7, #12
 8006bd8:	46bd      	mov	sp, r7
 8006bda:	bc80      	pop	{r7}
 8006bdc:	4770      	bx	lr

08006bde <SetDefaultHandler>:
int SetDefaultHandler(uint16 addr, uint16* pxDsn, uint16 len)
  {
 8006bde:	b480      	push	{r7}
 8006be0:	b083      	sub	sp, #12
 8006be2:	af00      	add	r7, sp, #0
 8006be4:	4603      	mov	r3, r0
 8006be6:	6039      	str	r1, [r7, #0]
 8006be8:	80fb      	strh	r3, [r7, #6]
 8006bea:	4613      	mov	r3, r2
 8006bec:	80bb      	strh	r3, [r7, #4]
    return false;
 8006bee:	2300      	movs	r3, #0
  }
 8006bf0:	4618      	mov	r0, r3
 8006bf2:	370c      	adds	r7, #12
 8006bf4:	46bd      	mov	sp, r7
 8006bf6:	bc80      	pop	{r7}
 8006bf8:	4770      	bx	lr
	...

08006bfc <MemGetWords>:

bool MemGetWords(uint16 addr, uint16* pxDsn, uint16 len)
  {
 8006bfc:	b590      	push	{r4, r7, lr}
 8006bfe:	b087      	sub	sp, #28
 8006c00:	af00      	add	r7, sp, #0
 8006c02:	4603      	mov	r3, r0
 8006c04:	6039      	str	r1, [r7, #0]
 8006c06:	80fb      	strh	r3, [r7, #6]
 8006c08:	4613      	mov	r3, r2
 8006c0a:	80bb      	strh	r3, [r7, #4]
    int i = MEMUNITS_NUM;
 8006c0c:	2306      	movs	r3, #6
 8006c0e:	617b      	str	r3, [r7, #20]
    bool rezult = false;
 8006c10:	2300      	movs	r3, #0
 8006c12:	74fb      	strb	r3, [r7, #19]
    MEMUNIT *pxMemunit = &memunit[0];
 8006c14:	4b1f      	ldr	r3, [pc, #124]	; (8006c94 <MemGetWords+0x98>)
 8006c16:	60fb      	str	r3, [r7, #12]
    while (i--)
 8006c18:	e032      	b.n	8006c80 <MemGetWords+0x84>
      {
        if ((addr >= pxMemunit->startaddr) && ((addr + len)
 8006c1a:	88fa      	ldrh	r2, [r7, #6]
 8006c1c:	68fb      	ldr	r3, [r7, #12]
 8006c1e:	681b      	ldr	r3, [r3, #0]
 8006c20:	429a      	cmp	r2, r3
 8006c22:	d32a      	bcc.n	8006c7a <MemGetWords+0x7e>
 8006c24:	88fa      	ldrh	r2, [r7, #6]
 8006c26:	88bb      	ldrh	r3, [r7, #4]
 8006c28:	4413      	add	r3, r2
 8006c2a:	461a      	mov	r2, r3
            < pxMemunit->endaddr))
 8006c2c:	68fb      	ldr	r3, [r7, #12]
 8006c2e:	685b      	ldr	r3, [r3, #4]
        if ((addr >= pxMemunit->startaddr) && ((addr + len)
 8006c30:	429a      	cmp	r2, r3
 8006c32:	d222      	bcs.n	8006c7a <MemGetWords+0x7e>
          {
            if (pxMemunit->xMutex != NULL)
 8006c34:	68fb      	ldr	r3, [r7, #12]
 8006c36:	689b      	ldr	r3, [r3, #8]
 8006c38:	2b00      	cmp	r3, #0
 8006c3a:	d01e      	beq.n	8006c7a <MemGetWords+0x7e>
              {
                if (xSemaphoreTake(pxMemunit->xMutex, (portTickType) 2000)
 8006c3c:	68fb      	ldr	r3, [r7, #12]
 8006c3e:	6898      	ldr	r0, [r3, #8]
 8006c40:	2300      	movs	r3, #0
 8006c42:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 8006c46:	2100      	movs	r1, #0
 8006c48:	4c13      	ldr	r4, [pc, #76]	; (8006c98 <MemGetWords+0x9c>)
 8006c4a:	47a0      	blx	r4
 8006c4c:	4603      	mov	r3, r0
 8006c4e:	2b01      	cmp	r3, #1
 8006c50:	d113      	bne.n	8006c7a <MemGetWords+0x7e>
                    == pdTRUE)
                  {
                    rezult = pxMemunit->GetMem(addr - pxMemunit->startaddr, pxDsn, len);
 8006c52:	68fb      	ldr	r3, [r7, #12]
 8006c54:	68db      	ldr	r3, [r3, #12]
 8006c56:	68fa      	ldr	r2, [r7, #12]
 8006c58:	6812      	ldr	r2, [r2, #0]
 8006c5a:	b292      	uxth	r2, r2
 8006c5c:	88f9      	ldrh	r1, [r7, #6]
 8006c5e:	1a8a      	subs	r2, r1, r2
 8006c60:	b290      	uxth	r0, r2
 8006c62:	88ba      	ldrh	r2, [r7, #4]
 8006c64:	6839      	ldr	r1, [r7, #0]
 8006c66:	4798      	blx	r3
 8006c68:	4603      	mov	r3, r0
 8006c6a:	74fb      	strb	r3, [r7, #19]
                    xSemaphoreGive(pxMemunit->xMutex);
 8006c6c:	68fb      	ldr	r3, [r7, #12]
 8006c6e:	6898      	ldr	r0, [r3, #8]
 8006c70:	2300      	movs	r3, #0
 8006c72:	2200      	movs	r2, #0
 8006c74:	2100      	movs	r1, #0
 8006c76:	4c09      	ldr	r4, [pc, #36]	; (8006c9c <MemGetWords+0xa0>)
 8006c78:	47a0      	blx	r4
                  }
              }
          }
        pxMemunit++;
 8006c7a:	68fb      	ldr	r3, [r7, #12]
 8006c7c:	3314      	adds	r3, #20
 8006c7e:	60fb      	str	r3, [r7, #12]
    while (i--)
 8006c80:	697b      	ldr	r3, [r7, #20]
 8006c82:	1e5a      	subs	r2, r3, #1
 8006c84:	617a      	str	r2, [r7, #20]
 8006c86:	2b00      	cmp	r3, #0
 8006c88:	d1c7      	bne.n	8006c1a <MemGetWords+0x1e>
      }
   return rezult;
 8006c8a:	7cfb      	ldrb	r3, [r7, #19]
  }
 8006c8c:	4618      	mov	r0, r3
 8006c8e:	371c      	adds	r7, #28
 8006c90:	46bd      	mov	sp, r7
 8006c92:	bd90      	pop	{r4, r7, pc}
 8006c94:	2000711c 	.word	0x2000711c
 8006c98:	08001ff1 	.word	0x08001ff1
 8006c9c:	08001eb9 	.word	0x08001eb9

08006ca0 <MemSetWords>:
//==============================================================================
bool MemSetWords(uint16 addr, uint16 *pxSrc, uint16 len)
  {
 8006ca0:	b590      	push	{r4, r7, lr}
 8006ca2:	b087      	sub	sp, #28
 8006ca4:	af00      	add	r7, sp, #0
 8006ca6:	4603      	mov	r3, r0
 8006ca8:	6039      	str	r1, [r7, #0]
 8006caa:	80fb      	strh	r3, [r7, #6]
 8006cac:	4613      	mov	r3, r2
 8006cae:	80bb      	strh	r3, [r7, #4]
    int i = MEMUNITS_NUM;
 8006cb0:	2306      	movs	r3, #6
 8006cb2:	617b      	str	r3, [r7, #20]
    bool rezult = false;
 8006cb4:	2300      	movs	r3, #0
 8006cb6:	74fb      	strb	r3, [r7, #19]
    MEMUNIT *pxMemunit = &memunit[0];
 8006cb8:	4b1f      	ldr	r3, [pc, #124]	; (8006d38 <MemSetWords+0x98>)
 8006cba:	60fb      	str	r3, [r7, #12]
    while (i--)
 8006cbc:	e032      	b.n	8006d24 <MemSetWords+0x84>
      {
        if ((addr >= pxMemunit->startaddr) && ((addr + len)
 8006cbe:	88fa      	ldrh	r2, [r7, #6]
 8006cc0:	68fb      	ldr	r3, [r7, #12]
 8006cc2:	681b      	ldr	r3, [r3, #0]
 8006cc4:	429a      	cmp	r2, r3
 8006cc6:	d32a      	bcc.n	8006d1e <MemSetWords+0x7e>
 8006cc8:	88fa      	ldrh	r2, [r7, #6]
 8006cca:	88bb      	ldrh	r3, [r7, #4]
 8006ccc:	4413      	add	r3, r2
 8006cce:	461a      	mov	r2, r3
            < pxMemunit->endaddr))
 8006cd0:	68fb      	ldr	r3, [r7, #12]
 8006cd2:	685b      	ldr	r3, [r3, #4]
        if ((addr >= pxMemunit->startaddr) && ((addr + len)
 8006cd4:	429a      	cmp	r2, r3
 8006cd6:	d222      	bcs.n	8006d1e <MemSetWords+0x7e>
          {
            if (pxMemunit->xMutex != NULL)
 8006cd8:	68fb      	ldr	r3, [r7, #12]
 8006cda:	689b      	ldr	r3, [r3, #8]
 8006cdc:	2b00      	cmp	r3, #0
 8006cde:	d01e      	beq.n	8006d1e <MemSetWords+0x7e>
              {
                if (xSemaphoreTake(pxMemunit->xMutex, (portTickType) 2000)
 8006ce0:	68fb      	ldr	r3, [r7, #12]
 8006ce2:	6898      	ldr	r0, [r3, #8]
 8006ce4:	2300      	movs	r3, #0
 8006ce6:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 8006cea:	2100      	movs	r1, #0
 8006cec:	4c13      	ldr	r4, [pc, #76]	; (8006d3c <MemSetWords+0x9c>)
 8006cee:	47a0      	blx	r4
 8006cf0:	4603      	mov	r3, r0
 8006cf2:	2b01      	cmp	r3, #1
 8006cf4:	d113      	bne.n	8006d1e <MemSetWords+0x7e>
                    == pdTRUE)
                  {
                    rezult = pxMemunit->SetMem(addr - pxMemunit->startaddr, pxSrc, len);
 8006cf6:	68fb      	ldr	r3, [r7, #12]
 8006cf8:	691b      	ldr	r3, [r3, #16]
 8006cfa:	68fa      	ldr	r2, [r7, #12]
 8006cfc:	6812      	ldr	r2, [r2, #0]
 8006cfe:	b292      	uxth	r2, r2
 8006d00:	88f9      	ldrh	r1, [r7, #6]
 8006d02:	1a8a      	subs	r2, r1, r2
 8006d04:	b290      	uxth	r0, r2
 8006d06:	88ba      	ldrh	r2, [r7, #4]
 8006d08:	6839      	ldr	r1, [r7, #0]
 8006d0a:	4798      	blx	r3
 8006d0c:	4603      	mov	r3, r0
 8006d0e:	74fb      	strb	r3, [r7, #19]
                    xSemaphoreGive(pxMemunit->xMutex);
 8006d10:	68fb      	ldr	r3, [r7, #12]
 8006d12:	6898      	ldr	r0, [r3, #8]
 8006d14:	2300      	movs	r3, #0
 8006d16:	2200      	movs	r2, #0
 8006d18:	2100      	movs	r1, #0
 8006d1a:	4c09      	ldr	r4, [pc, #36]	; (8006d40 <MemSetWords+0xa0>)
 8006d1c:	47a0      	blx	r4
                  }
              }
          }
        pxMemunit++;
 8006d1e:	68fb      	ldr	r3, [r7, #12]
 8006d20:	3314      	adds	r3, #20
 8006d22:	60fb      	str	r3, [r7, #12]
    while (i--)
 8006d24:	697b      	ldr	r3, [r7, #20]
 8006d26:	1e5a      	subs	r2, r3, #1
 8006d28:	617a      	str	r2, [r7, #20]
 8006d2a:	2b00      	cmp	r3, #0
 8006d2c:	d1c7      	bne.n	8006cbe <MemSetWords+0x1e>
      }
      return rezult;
 8006d2e:	7cfb      	ldrb	r3, [r7, #19]
  }
 8006d30:	4618      	mov	r0, r3
 8006d32:	371c      	adds	r7, #28
 8006d34:	46bd      	mov	sp, r7
 8006d36:	bd90      	pop	{r4, r7, pc}
 8006d38:	2000711c 	.word	0x2000711c
 8006d3c:	08001ff1 	.word	0x08001ff1
 8006d40:	08001eb9 	.word	0x08001eb9

08006d44 <CheckCRC>:
#define  GetCrcByte(crc,data) ((crc >> 8) ^ crc16_table[(crc ^ (data)) & 0xff])
//========================================================================
// 
//========================================================================
unsigned int CheckCRC(unsigned char *buf,unsigned int size)
{
 8006d44:	b480      	push	{r7}
 8006d46:	b085      	sub	sp, #20
 8006d48:	af00      	add	r7, sp, #0
 8006d4a:	6078      	str	r0, [r7, #4]
 8006d4c:	6039      	str	r1, [r7, #0]
  unsigned int crc = 0xFFFF;
 8006d4e:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8006d52:	60fb      	str	r3, [r7, #12]
  while(size)
 8006d54:	e012      	b.n	8006d7c <CheckCRC+0x38>
  {
    crc = GetCrcByte(crc,*buf); // size =   + 1  RC ;
 8006d56:	68fb      	ldr	r3, [r7, #12]
 8006d58:	0a1a      	lsrs	r2, r3, #8
 8006d5a:	687b      	ldr	r3, [r7, #4]
 8006d5c:	781b      	ldrb	r3, [r3, #0]
 8006d5e:	4619      	mov	r1, r3
 8006d60:	68fb      	ldr	r3, [r7, #12]
 8006d62:	404b      	eors	r3, r1
 8006d64:	b2db      	uxtb	r3, r3
 8006d66:	490c      	ldr	r1, [pc, #48]	; (8006d98 <CheckCRC+0x54>)
 8006d68:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8006d6c:	4053      	eors	r3, r2
 8006d6e:	60fb      	str	r3, [r7, #12]
    buf++;
 8006d70:	687b      	ldr	r3, [r7, #4]
 8006d72:	3301      	adds	r3, #1
 8006d74:	607b      	str	r3, [r7, #4]
    size--;
 8006d76:	683b      	ldr	r3, [r7, #0]
 8006d78:	3b01      	subs	r3, #1
 8006d7a:	603b      	str	r3, [r7, #0]
  while(size)
 8006d7c:	683b      	ldr	r3, [r7, #0]
 8006d7e:	2b00      	cmp	r3, #0
 8006d80:	d1e9      	bne.n	8006d56 <CheckCRC+0x12>
  }
  if(crc == 0x0) return 1;
 8006d82:	68fb      	ldr	r3, [r7, #12]
 8006d84:	2b00      	cmp	r3, #0
 8006d86:	d101      	bne.n	8006d8c <CheckCRC+0x48>
 8006d88:	2301      	movs	r3, #1
 8006d8a:	e000      	b.n	8006d8e <CheckCRC+0x4a>
  return 0;
 8006d8c:	2300      	movs	r3, #0
}
 8006d8e:	4618      	mov	r0, r3
 8006d90:	3714      	adds	r7, #20
 8006d92:	46bd      	mov	sp, r7
 8006d94:	bc80      	pop	{r7}
 8006d96:	4770      	bx	lr
 8006d98:	0801497c 	.word	0x0801497c

08006d9c <SetCRC>:
//========================================================================
void SetCRC  (unsigned char *buf,unsigned int size)
{
 8006d9c:	b480      	push	{r7}
 8006d9e:	b085      	sub	sp, #20
 8006da0:	af00      	add	r7, sp, #0
 8006da2:	6078      	str	r0, [r7, #4]
 8006da4:	6039      	str	r1, [r7, #0]
  unsigned int crc = 0xFFFF;
 8006da6:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8006daa:	60fb      	str	r3, [r7, #12]
  while(size)
 8006dac:	e012      	b.n	8006dd4 <SetCRC+0x38>
  {
    crc = GetCrcByte(crc,*buf); // size =   + 1  RC ;
 8006dae:	68fb      	ldr	r3, [r7, #12]
 8006db0:	0a1a      	lsrs	r2, r3, #8
 8006db2:	687b      	ldr	r3, [r7, #4]
 8006db4:	781b      	ldrb	r3, [r3, #0]
 8006db6:	4619      	mov	r1, r3
 8006db8:	68fb      	ldr	r3, [r7, #12]
 8006dba:	404b      	eors	r3, r1
 8006dbc:	b2db      	uxtb	r3, r3
 8006dbe:	490e      	ldr	r1, [pc, #56]	; (8006df8 <SetCRC+0x5c>)
 8006dc0:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
 8006dc4:	4053      	eors	r3, r2
 8006dc6:	60fb      	str	r3, [r7, #12]
    buf++;
 8006dc8:	687b      	ldr	r3, [r7, #4]
 8006dca:	3301      	adds	r3, #1
 8006dcc:	607b      	str	r3, [r7, #4]
    size--;
 8006dce:	683b      	ldr	r3, [r7, #0]
 8006dd0:	3b01      	subs	r3, #1
 8006dd2:	603b      	str	r3, [r7, #0]
  while(size)
 8006dd4:	683b      	ldr	r3, [r7, #0]
 8006dd6:	2b00      	cmp	r3, #0
 8006dd8:	d1e9      	bne.n	8006dae <SetCRC+0x12>
  }
  *buf     = crc;
 8006dda:	68fb      	ldr	r3, [r7, #12]
 8006ddc:	b2da      	uxtb	r2, r3
 8006dde:	687b      	ldr	r3, [r7, #4]
 8006de0:	701a      	strb	r2, [r3, #0]
  *(buf+1) = crc>>8;
 8006de2:	68fb      	ldr	r3, [r7, #12]
 8006de4:	0a1a      	lsrs	r2, r3, #8
 8006de6:	687b      	ldr	r3, [r7, #4]
 8006de8:	3301      	adds	r3, #1
 8006dea:	b2d2      	uxtb	r2, r2
 8006dec:	701a      	strb	r2, [r3, #0]
}
 8006dee:	bf00      	nop
 8006df0:	3714      	adds	r7, #20
 8006df2:	46bd      	mov	sp, r7
 8006df4:	bc80      	pop	{r7}
 8006df6:	4770      	bx	lr
 8006df8:	0801497c 	.word	0x0801497c

08006dfc <main>:
#define vLedTask_PRIORITY           ( tskIDLE_PRIORITY)
#define vClockTask_PRIORITY           ( tskIDLE_PRIORITY+2)
/////////////////////////////////////////////////////////////////
int counttick = 0;

int main(void) {
 8006dfc:	b590      	push	{r4, r7, lr}
 8006dfe:	b087      	sub	sp, #28
 8006e00:	af04      	add	r7, sp, #16
	manualwork = 0;
 8006e02:	4b4a      	ldr	r3, [pc, #296]	; (8006f2c <main+0x130>)
 8006e04:	2200      	movs	r2, #0
 8006e06:	601a      	str	r2, [r3, #0]
	// 
	uint8_t *TestByte;
	TestByte = (uint8_t*) 0xE00FFFD0;
 8006e08:	4b49      	ldr	r3, [pc, #292]	; (8006f30 <main+0x134>)
 8006e0a:	607b      	str	r3, [r7, #4]
	if (*TestByte == 7) {
 8006e0c:	687b      	ldr	r3, [r7, #4]
 8006e0e:	781b      	ldrb	r3, [r3, #0]
 8006e10:	2b07      	cmp	r3, #7
 8006e12:	d103      	bne.n	8006e1c <main+0x20>
		initMK = 1; //GD
 8006e14:	4b47      	ldr	r3, [pc, #284]	; (8006f34 <main+0x138>)
 8006e16:	2201      	movs	r2, #1
 8006e18:	601a      	str	r2, [r3, #0]
 8006e1a:	e002      	b.n	8006e22 <main+0x26>
	} else {
		initMK = 0; //STM32
 8006e1c:	4b45      	ldr	r3, [pc, #276]	; (8006f34 <main+0x138>)
 8006e1e:	2200      	movs	r2, #0
 8006e20:	601a      	str	r2, [r3, #0]
	}
	GPIO_Configuration();
 8006e22:	4b45      	ldr	r3, [pc, #276]	; (8006f38 <main+0x13c>)
 8006e24:	4798      	blx	r3
	hwInit();
 8006e26:	4b45      	ldr	r3, [pc, #276]	; (8006f3c <main+0x140>)
 8006e28:	4798      	blx	r3
	MemInit();
 8006e2a:	4b45      	ldr	r3, [pc, #276]	; (8006f40 <main+0x144>)
 8006e2c:	4798      	blx	r3
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE);
 8006e2e:	2101      	movs	r1, #1
 8006e30:	f04f 50c0 	mov.w	r0, #402653184	; 0x18000000
 8006e34:	4b43      	ldr	r3, [pc, #268]	; (8006f44 <main+0x148>)
 8006e36:	4798      	blx	r3
	PWR_BackupAccessCmd(ENABLE);
 8006e38:	2001      	movs	r0, #1
 8006e3a:	4b43      	ldr	r3, [pc, #268]	; (8006f48 <main+0x14c>)
 8006e3c:	4798      	blx	r3
	T1 = BKP_ReadBackupRegister(BKP_DR7);
 8006e3e:	201c      	movs	r0, #28
 8006e40:	4b42      	ldr	r3, [pc, #264]	; (8006f4c <main+0x150>)
 8006e42:	4798      	blx	r3
 8006e44:	4603      	mov	r3, r0
 8006e46:	461a      	mov	r2, r3
 8006e48:	4b41      	ldr	r3, [pc, #260]	; (8006f50 <main+0x154>)
 8006e4a:	801a      	strh	r2, [r3, #0]
	BKP_WriteBackupRegister(BKP_DR7, 2);
 8006e4c:	2102      	movs	r1, #2
 8006e4e:	201c      	movs	r0, #28
 8006e50:	4b40      	ldr	r3, [pc, #256]	; (8006f54 <main+0x158>)
 8006e52:	4798      	blx	r3
	IWD_Start();
 8006e54:	4b40      	ldr	r3, [pc, #256]	; (8006f58 <main+0x15c>)
 8006e56:	4798      	blx	r3

	// Turn on/off LED(s)
	xTaskCreate(vLogicaTask, (const signed portCHAR * const ) "Logica",
 8006e58:	2300      	movs	r3, #0
 8006e5a:	9303      	str	r3, [sp, #12]
 8006e5c:	2300      	movs	r3, #0
 8006e5e:	9302      	str	r3, [sp, #8]
 8006e60:	2300      	movs	r3, #0
 8006e62:	9301      	str	r3, [sp, #4]
 8006e64:	2304      	movs	r3, #4
 8006e66:	9300      	str	r3, [sp, #0]
 8006e68:	2300      	movs	r3, #0
 8006e6a:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8006e6e:	493b      	ldr	r1, [pc, #236]	; (8006f5c <main+0x160>)
 8006e70:	483b      	ldr	r0, [pc, #236]	; (8006f60 <main+0x164>)
 8006e72:	4c3c      	ldr	r4, [pc, #240]	; (8006f64 <main+0x168>)
 8006e74:	47a0      	blx	r4
			vLogicaTask_STACK_SIZE, NULL, vLogicaTask_PRIORITY,
			(xTaskHandle* ) NULL);

	xTaskCreate(vRs485Task, (const signed portCHAR * const ) "RS485",
 8006e76:	2300      	movs	r3, #0
 8006e78:	9303      	str	r3, [sp, #12]
 8006e7a:	2300      	movs	r3, #0
 8006e7c:	9302      	str	r3, [sp, #8]
 8006e7e:	2300      	movs	r3, #0
 8006e80:	9301      	str	r3, [sp, #4]
 8006e82:	2303      	movs	r3, #3
 8006e84:	9300      	str	r3, [sp, #0]
 8006e86:	2300      	movs	r3, #0
 8006e88:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8006e8c:	4936      	ldr	r1, [pc, #216]	; (8006f68 <main+0x16c>)
 8006e8e:	4837      	ldr	r0, [pc, #220]	; (8006f6c <main+0x170>)
 8006e90:	4c34      	ldr	r4, [pc, #208]	; (8006f64 <main+0x168>)
 8006e92:	47a0      	blx	r4
			vRs485Task_STACK_SIZE, NULL, vRs485Task_PRIORITY,
			(xTaskHandle* ) NULL);

	xTaskCreate(vReletestTask, (const signed portCHAR * const ) "Reletest",
 8006e94:	2300      	movs	r3, #0
 8006e96:	9303      	str	r3, [sp, #12]
 8006e98:	2300      	movs	r3, #0
 8006e9a:	9302      	str	r3, [sp, #8]
 8006e9c:	2300      	movs	r3, #0
 8006e9e:	9301      	str	r3, [sp, #4]
 8006ea0:	2305      	movs	r3, #5
 8006ea2:	9300      	str	r3, [sp, #0]
 8006ea4:	2300      	movs	r3, #0
 8006ea6:	22c8      	movs	r2, #200	; 0xc8
 8006ea8:	4931      	ldr	r1, [pc, #196]	; (8006f70 <main+0x174>)
 8006eaa:	4832      	ldr	r0, [pc, #200]	; (8006f74 <main+0x178>)
 8006eac:	4c2d      	ldr	r4, [pc, #180]	; (8006f64 <main+0x168>)
 8006eae:	47a0      	blx	r4
			vReletestTask_STACK_SIZE, NULL, vReletestTask_PRIORITY,
			(xTaskHandle* ) NULL);

	xTaskCreate(vUSBTask, (const signed portCHAR * const ) "USB",
 8006eb0:	2300      	movs	r3, #0
 8006eb2:	9303      	str	r3, [sp, #12]
 8006eb4:	2300      	movs	r3, #0
 8006eb6:	9302      	str	r3, [sp, #8]
 8006eb8:	2300      	movs	r3, #0
 8006eba:	9301      	str	r3, [sp, #4]
 8006ebc:	2301      	movs	r3, #1
 8006ebe:	9300      	str	r3, [sp, #0]
 8006ec0:	2300      	movs	r3, #0
 8006ec2:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8006ec6:	492c      	ldr	r1, [pc, #176]	; (8006f78 <main+0x17c>)
 8006ec8:	482c      	ldr	r0, [pc, #176]	; (8006f7c <main+0x180>)
 8006eca:	4c26      	ldr	r4, [pc, #152]	; (8006f64 <main+0x168>)
 8006ecc:	47a0      	blx	r4
			vUSBTask_STACK_SIZE, NULL, vUSBTask_PRIORITY, (xTaskHandle* ) NULL);

	xTaskCreate(vGprsConTask, (const signed portCHAR * const ) "GPRS",
 8006ece:	2300      	movs	r3, #0
 8006ed0:	9303      	str	r3, [sp, #12]
 8006ed2:	2300      	movs	r3, #0
 8006ed4:	9302      	str	r3, [sp, #8]
 8006ed6:	2300      	movs	r3, #0
 8006ed8:	9301      	str	r3, [sp, #4]
 8006eda:	2305      	movs	r3, #5
 8006edc:	9300      	str	r3, [sp, #0]
 8006ede:	2300      	movs	r3, #0
 8006ee0:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8006ee4:	4926      	ldr	r1, [pc, #152]	; (8006f80 <main+0x184>)
 8006ee6:	4827      	ldr	r0, [pc, #156]	; (8006f84 <main+0x188>)
 8006ee8:	4c1e      	ldr	r4, [pc, #120]	; (8006f64 <main+0x168>)
 8006eea:	47a0      	blx	r4
			vGprsConTask_STACK_SIZE, NULL, vGprsConTask_PRIORITY,
			(xTaskHandle* ) NULL);

	xTaskCreate(vLedTask, (const signed portCHAR * const ) "LED",
 8006eec:	2300      	movs	r3, #0
 8006eee:	9303      	str	r3, [sp, #12]
 8006ef0:	2300      	movs	r3, #0
 8006ef2:	9302      	str	r3, [sp, #8]
 8006ef4:	2300      	movs	r3, #0
 8006ef6:	9301      	str	r3, [sp, #4]
 8006ef8:	2300      	movs	r3, #0
 8006efa:	9300      	str	r3, [sp, #0]
 8006efc:	2300      	movs	r3, #0
 8006efe:	22c8      	movs	r2, #200	; 0xc8
 8006f00:	4921      	ldr	r1, [pc, #132]	; (8006f88 <main+0x18c>)
 8006f02:	4822      	ldr	r0, [pc, #136]	; (8006f8c <main+0x190>)
 8006f04:	4c17      	ldr	r4, [pc, #92]	; (8006f64 <main+0x168>)
 8006f06:	47a0      	blx	r4
			vLedTask_STACK_SIZE, NULL, vLedTask_PRIORITY, (xTaskHandle* ) NULL);

	xTaskCreate(vClockTask, (const signed portCHAR * const ) "CLOCK",
 8006f08:	2300      	movs	r3, #0
 8006f0a:	9303      	str	r3, [sp, #12]
 8006f0c:	2300      	movs	r3, #0
 8006f0e:	9302      	str	r3, [sp, #8]
 8006f10:	2300      	movs	r3, #0
 8006f12:	9301      	str	r3, [sp, #4]
 8006f14:	2302      	movs	r3, #2
 8006f16:	9300      	str	r3, [sp, #0]
 8006f18:	2300      	movs	r3, #0
 8006f1a:	22c8      	movs	r2, #200	; 0xc8
 8006f1c:	491c      	ldr	r1, [pc, #112]	; (8006f90 <main+0x194>)
 8006f1e:	481d      	ldr	r0, [pc, #116]	; (8006f94 <main+0x198>)
 8006f20:	4c10      	ldr	r4, [pc, #64]	; (8006f64 <main+0x168>)
 8006f22:	47a0      	blx	r4
			vClockTask_STACK_SIZE, NULL, vClockTask_PRIORITY,
			(xTaskHandle* ) NULL);

	//Start the scheduler.
	vTaskStartScheduler();
 8006f24:	4b1c      	ldr	r3, [pc, #112]	; (8006f98 <main+0x19c>)
 8006f26:	4798      	blx	r3

	while (1) {
 8006f28:	e7fe      	b.n	8006f28 <main+0x12c>
 8006f2a:	bf00      	nop
 8006f2c:	20009430 	.word	0x20009430
 8006f30:	e00fffd0 	.word	0xe00fffd0
 8006f34:	20007194 	.word	0x20007194
 8006f38:	08006fd1 	.word	0x08006fd1
 8006f3c:	08001399 	.word	0x08001399
 8006f40:	0800af41 	.word	0x0800af41
 8006f44:	080034f9 	.word	0x080034f9
 8006f48:	08003689 	.word	0x08003689
 8006f4c:	08003659 	.word	0x08003659
 8006f50:	20007198 	.word	0x20007198
 8006f54:	08003621 	.word	0x08003621
 8006f58:	08007129 	.word	0x08007129
 8006f5c:	08014d7c 	.word	0x08014d7c
 8006f60:	08007961 	.word	0x08007961
 8006f64:	080013c1 	.word	0x080013c1
 8006f68:	08014d84 	.word	0x08014d84
 8006f6c:	080088d5 	.word	0x080088d5
 8006f70:	08014d8c 	.word	0x08014d8c
 8006f74:	08008c79 	.word	0x08008c79
 8006f78:	08014d98 	.word	0x08014d98
 8006f7c:	08008b89 	.word	0x08008b89
 8006f80:	08014d9c 	.word	0x08014d9c
 8006f84:	08007211 	.word	0x08007211
 8006f88:	08014da4 	.word	0x08014da4
 8006f8c:	080076b5 	.word	0x080076b5
 8006f90:	08014da8 	.word	0x08014da8
 8006f94:	080078dd 	.word	0x080078dd
 8006f98:	080015c9 	.word	0x080015c9

08006f9c <vApplicationIdleHook>:
	};

	return 0;
}

void vApplicationIdleHook(void) {
 8006f9c:	b480      	push	{r7}
 8006f9e:	af00      	add	r7, sp, #0

}
 8006fa0:	bf00      	nop
 8006fa2:	46bd      	mov	sp, r7
 8006fa4:	bc80      	pop	{r7}
 8006fa6:	4770      	bx	lr

08006fa8 <vApplicationTickHook>:

void vApplicationTickHook(void) {
 8006fa8:	b580      	push	{r7, lr}
 8006faa:	af00      	add	r7, sp, #0
	counttick++;
 8006fac:	4b05      	ldr	r3, [pc, #20]	; (8006fc4 <vApplicationTickHook+0x1c>)
 8006fae:	681b      	ldr	r3, [r3, #0]
 8006fb0:	3301      	adds	r3, #1
 8006fb2:	4a04      	ldr	r2, [pc, #16]	; (8006fc4 <vApplicationTickHook+0x1c>)
 8006fb4:	6013      	str	r3, [r2, #0]
	GprsIdleIncMSec();
 8006fb6:	4b04      	ldr	r3, [pc, #16]	; (8006fc8 <vApplicationTickHook+0x20>)
 8006fb8:	4798      	blx	r3
	atcIncrementCounter();
 8006fba:	4b04      	ldr	r3, [pc, #16]	; (8006fcc <vApplicationTickHook+0x24>)
 8006fbc:	4798      	blx	r3
}
 8006fbe:	bf00      	nop
 8006fc0:	bd80      	pop	{r7, pc}
 8006fc2:	bf00      	nop
 8006fc4:	2000719c 	.word	0x2000719c
 8006fc8:	080071e9 	.word	0x080071e9
 8006fcc:	080063a5 	.word	0x080063a5

08006fd0 <GPIO_Configuration>:
	BKP_WriteBackupRegister(BKP_DR7, 1);
	while (1)
		;
}

void GPIO_Configuration(void) {
 8006fd0:	b580      	push	{r7, lr}
 8006fd2:	b082      	sub	sp, #8
 8006fd4:	af00      	add	r7, sp, #0

	GPIO_InitTypeDef GPIO_InitStructure;
	/* Enable GPIOA clock */
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
 8006fd6:	2101      	movs	r1, #1
 8006fd8:	2004      	movs	r0, #4
 8006fda:	4b4b      	ldr	r3, [pc, #300]	; (8007108 <GPIO_Configuration+0x138>)
 8006fdc:	4798      	blx	r3
	/* Enable GPIOC clock */
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);
 8006fde:	2101      	movs	r1, #1
 8006fe0:	2010      	movs	r0, #16
 8006fe2:	4b49      	ldr	r3, [pc, #292]	; (8007108 <GPIO_Configuration+0x138>)
 8006fe4:	4798      	blx	r3
	/* Enable GPIOB clock */
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
 8006fe6:	2101      	movs	r1, #1
 8006fe8:	2008      	movs	r0, #8
 8006fea:	4b47      	ldr	r3, [pc, #284]	; (8007108 <GPIO_Configuration+0x138>)
 8006fec:	4798      	blx	r3
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
 8006fee:	2101      	movs	r1, #1
 8006ff0:	2001      	movs	r0, #1
 8006ff2:	4b45      	ldr	r3, [pc, #276]	; (8007108 <GPIO_Configuration+0x138>)
 8006ff4:	4798      	blx	r3
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C1, ENABLE);
 8006ff6:	2101      	movs	r1, #1
 8006ff8:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 8006ffc:	4b43      	ldr	r3, [pc, #268]	; (800710c <GPIO_Configuration+0x13c>)
 8006ffe:	4798      	blx	r3
	GPIO_PinRemapConfig(GPIO_Remap_I2C1,ENABLE);
 8007000:	2101      	movs	r1, #1
 8007002:	2002      	movs	r0, #2
 8007004:	4b42      	ldr	r3, [pc, #264]	; (8007110 <GPIO_Configuration+0x140>)
 8007006:	4798      	blx	r3
	/* Configure I2C1 pins: SCL and SDA ----------------------------------------*/
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8 | GPIO_Pin_9;
 8007008:	f44f 7340 	mov.w	r3, #768	; 0x300
 800700c:	80bb      	strh	r3, [r7, #4]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 800700e:	2303      	movs	r3, #3
 8007010:	71bb      	strb	r3, [r7, #6]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;
 8007012:	231c      	movs	r3, #28
 8007014:	71fb      	strb	r3, [r7, #7]
	GPIO_Init(GPIOB, &GPIO_InitStructure);
 8007016:	1d3b      	adds	r3, r7, #4
 8007018:	4619      	mov	r1, r3
 800701a:	483e      	ldr	r0, [pc, #248]	; (8007114 <GPIO_Configuration+0x144>)
 800701c:	4b3e      	ldr	r3, [pc, #248]	; (8007118 <GPIO_Configuration+0x148>)
 800701e:	4798      	blx	r3

	//===================== RS232 =========================
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;
 8007020:	2301      	movs	r3, #1
 8007022:	80bb      	strh	r3, [r7, #4]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
 8007024:	2301      	movs	r3, #1
 8007026:	71bb      	strb	r3, [r7, #6]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
 8007028:	2310      	movs	r3, #16
 800702a:	71fb      	strb	r3, [r7, #7]
	GPIO_Init(GPIOB, &GPIO_InitStructure);
 800702c:	1d3b      	adds	r3, r7, #4
 800702e:	4619      	mov	r1, r3
 8007030:	4838      	ldr	r0, [pc, #224]	; (8007114 <GPIO_Configuration+0x144>)
 8007032:	4b39      	ldr	r3, [pc, #228]	; (8007118 <GPIO_Configuration+0x148>)
 8007034:	4798      	blx	r3

	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;
 8007036:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 800703a:	80bb      	strh	r3, [r7, #4]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
 800703c:	2301      	movs	r3, #1
 800703e:	71bb      	strb	r3, [r7, #6]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
 8007040:	2310      	movs	r3, #16
 8007042:	71fb      	strb	r3, [r7, #7]
	GPIO_Init(GPIOB, &GPIO_InitStructure);
 8007044:	1d3b      	adds	r3, r7, #4
 8007046:	4619      	mov	r1, r3
 8007048:	4832      	ldr	r0, [pc, #200]	; (8007114 <GPIO_Configuration+0x144>)
 800704a:	4b33      	ldr	r3, [pc, #204]	; (8007118 <GPIO_Configuration+0x148>)
 800704c:	4798      	blx	r3

	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
 800704e:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8007052:	80bb      	strh	r3, [r7, #4]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 8007054:	2303      	movs	r3, #3
 8007056:	71bb      	strb	r3, [r7, #6]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
 8007058:	2310      	movs	r3, #16
 800705a:	71fb      	strb	r3, [r7, #7]
	GPIO_Init(GPIOC, &GPIO_InitStructure);
 800705c:	1d3b      	adds	r3, r7, #4
 800705e:	4619      	mov	r1, r3
 8007060:	482e      	ldr	r0, [pc, #184]	; (800711c <GPIO_Configuration+0x14c>)
 8007062:	4b2d      	ldr	r3, [pc, #180]	; (8007118 <GPIO_Configuration+0x148>)
 8007064:	4798      	blx	r3

	//===================== End of RS232 =========================
	/* Relays and Led */
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_6
 8007066:	23f0      	movs	r3, #240	; 0xf0
 8007068:	80bb      	strh	r3, [r7, #4]
			| GPIO_Pin_7;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
 800706a:	2301      	movs	r3, #1
 800706c:	71bb      	strb	r3, [r7, #6]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
 800706e:	2310      	movs	r3, #16
 8007070:	71fb      	strb	r3, [r7, #7]
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 8007072:	1d3b      	adds	r3, r7, #4
 8007074:	4619      	mov	r1, r3
 8007076:	482a      	ldr	r0, [pc, #168]	; (8007120 <GPIO_Configuration+0x150>)
 8007078:	4b27      	ldr	r3, [pc, #156]	; (8007118 <GPIO_Configuration+0x148>)
 800707a:	4798      	blx	r3

	//DS1
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
 800707c:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8007080:	80bb      	strh	r3, [r7, #4]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
 8007082:	2301      	movs	r3, #1
 8007084:	71bb      	strb	r3, [r7, #6]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
 8007086:	2348      	movs	r3, #72	; 0x48
 8007088:	71fb      	strb	r3, [r7, #7]
	GPIO_Init(GPIOA, &GPIO_InitStructure);
 800708a:	1d3b      	adds	r3, r7, #4
 800708c:	4619      	mov	r1, r3
 800708e:	4824      	ldr	r0, [pc, #144]	; (8007120 <GPIO_Configuration+0x150>)
 8007090:	4b21      	ldr	r3, [pc, #132]	; (8007118 <GPIO_Configuration+0x148>)
 8007092:	4798      	blx	r3

	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
 8007094:	2304      	movs	r3, #4
 8007096:	80bb      	strh	r3, [r7, #4]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
 8007098:	2301      	movs	r3, #1
 800709a:	71bb      	strb	r3, [r7, #6]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;
 800709c:	2314      	movs	r3, #20
 800709e:	71fb      	strb	r3, [r7, #7]
	GPIO_Init(GPIOC, &GPIO_InitStructure);
 80070a0:	1d3b      	adds	r3, r7, #4
 80070a2:	4619      	mov	r1, r3
 80070a4:	481d      	ldr	r0, [pc, #116]	; (800711c <GPIO_Configuration+0x14c>)
 80070a6:	4b1c      	ldr	r3, [pc, #112]	; (8007118 <GPIO_Configuration+0x148>)
 80070a8:	4798      	blx	r3

	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
 80070aa:	2308      	movs	r3, #8
 80070ac:	80bb      	strh	r3, [r7, #4]
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
 80070ae:	2301      	movs	r3, #1
 80070b0:	71bb      	strb	r3, [r7, #6]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;
 80070b2:	2314      	movs	r3, #20
 80070b4:	71fb      	strb	r3, [r7, #7]
	GPIO_Init(GPIOC, &GPIO_InitStructure);
 80070b6:	1d3b      	adds	r3, r7, #4
 80070b8:	4619      	mov	r1, r3
 80070ba:	4818      	ldr	r0, [pc, #96]	; (800711c <GPIO_Configuration+0x14c>)
 80070bc:	4b16      	ldr	r3, [pc, #88]	; (8007118 <GPIO_Configuration+0x148>)
 80070be:	4798      	blx	r3

	//DS4 DS5 DS6 DS7
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9 | GPIO_Pin_8 | GPIO_Pin_7
 80070c0:	f44f 737c 	mov.w	r3, #1008	; 0x3f0
 80070c4:	80bb      	strh	r3, [r7, #4]
			| GPIO_Pin_6 | GPIO_Pin_4 | GPIO_Pin_5;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
 80070c6:	2301      	movs	r3, #1
 80070c8:	71bb      	strb	r3, [r7, #6]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
 80070ca:	2348      	movs	r3, #72	; 0x48
 80070cc:	71fb      	strb	r3, [r7, #7]
	GPIO_Init(GPIOC, &GPIO_InitStructure);
 80070ce:	1d3b      	adds	r3, r7, #4
 80070d0:	4619      	mov	r1, r3
 80070d2:	4812      	ldr	r0, [pc, #72]	; (800711c <GPIO_Configuration+0x14c>)
 80070d4:	4b10      	ldr	r3, [pc, #64]	; (8007118 <GPIO_Configuration+0x148>)
 80070d6:	4798      	blx	r3

	//DS8 DS9 DS10 DS11
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_15 | GPIO_Pin_12 | GPIO_Pin_2
 80070d8:	f249 0306 	movw	r3, #36870	; 0x9006
 80070dc:	80bb      	strh	r3, [r7, #4]
			| GPIO_Pin_1;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
 80070de:	2301      	movs	r3, #1
 80070e0:	71bb      	strb	r3, [r7, #6]
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
 80070e2:	2348      	movs	r3, #72	; 0x48
 80070e4:	71fb      	strb	r3, [r7, #7]
	GPIO_Init(GPIOB, &GPIO_InitStructure);
 80070e6:	1d3b      	adds	r3, r7, #4
 80070e8:	4619      	mov	r1, r3
 80070ea:	480a      	ldr	r0, [pc, #40]	; (8007114 <GPIO_Configuration+0x144>)
 80070ec:	4b0a      	ldr	r3, [pc, #40]	; (8007118 <GPIO_Configuration+0x148>)
 80070ee:	4798      	blx	r3

	GPIO_SetBits(GPIOC, GPIO_Pin_2);
 80070f0:	2104      	movs	r1, #4
 80070f2:	480a      	ldr	r0, [pc, #40]	; (800711c <GPIO_Configuration+0x14c>)
 80070f4:	4b0b      	ldr	r3, [pc, #44]	; (8007124 <GPIO_Configuration+0x154>)
 80070f6:	4798      	blx	r3
	GPIO_SetBits(GPIOC, GPIO_Pin_3);
 80070f8:	2108      	movs	r1, #8
 80070fa:	4808      	ldr	r0, [pc, #32]	; (800711c <GPIO_Configuration+0x14c>)
 80070fc:	4b09      	ldr	r3, [pc, #36]	; (8007124 <GPIO_Configuration+0x154>)
 80070fe:	4798      	blx	r3

}
 8007100:	bf00      	nop
 8007102:	3708      	adds	r7, #8
 8007104:	46bd      	mov	sp, r7
 8007106:	bd80      	pop	{r7, pc}
 8007108:	080034bd 	.word	0x080034bd
 800710c:	080034f9 	.word	0x080034f9
 8007110:	08002fa5 	.word	0x08002fa5
 8007114:	40010c00 	.word	0x40010c00
 8007118:	08002d9d 	.word	0x08002d9d
 800711c:	40011000 	.word	0x40011000
 8007120:	40010800 	.word	0x40010800
 8007124:	08002f6d 	.word	0x08002f6d

08007128 <IWD_Start>:

void IWD_Start(void) {
 8007128:	b580      	push	{r7, lr}
 800712a:	af00      	add	r7, sp, #0
//     IWDG
	IWDG_WriteAccessCmd(IWDG_WriteAccess_Enable);
 800712c:	f245 5055 	movw	r0, #21845	; 0x5555
 8007130:	4b07      	ldr	r3, [pc, #28]	; (8007150 <IWD_Start+0x28>)
 8007132:	4798      	blx	r3
//     
	IWDG_SetPrescaler(IWDG_Prescaler_256);
 8007134:	2006      	movs	r0, #6
 8007136:	4b07      	ldr	r3, [pc, #28]	; (8007154 <IWD_Start+0x2c>)
 8007138:	4798      	blx	r3
//  "  "
	IWDG_SetReload(0x0fff);
 800713a:	f640 70ff 	movw	r0, #4095	; 0xfff
 800713e:	4b06      	ldr	r3, [pc, #24]	; (8007158 <IWD_Start+0x30>)
 8007140:	4798      	blx	r3
//  IWDG
	IWDG_ReloadCounter();
 8007142:	4b06      	ldr	r3, [pc, #24]	; (800715c <IWD_Start+0x34>)
 8007144:	4798      	blx	r3
//  IWDG
	IWDG_Enable();
 8007146:	4b06      	ldr	r3, [pc, #24]	; (8007160 <IWD_Start+0x38>)
 8007148:	4798      	blx	r3
}
 800714a:	bf00      	nop
 800714c:	bd80      	pop	{r7, pc}
 800714e:	bf00      	nop
 8007150:	080036a9 	.word	0x080036a9
 8007154:	080036c9 	.word	0x080036c9
 8007158:	080036e9 	.word	0x080036e9
 800715c:	08003709 	.word	0x08003709
 8007160:	08003721 	.word	0x08003721

08007164 <__DSB>:
static __INLINE void __DSB()                      { __ASM volatile ("dsb"); }
 8007164:	b480      	push	{r7}
 8007166:	af00      	add	r7, sp, #0
 8007168:	f3bf 8f4f 	dsb	sy
 800716c:	bf00      	nop
 800716e:	46bd      	mov	sp, r7
 8007170:	bc80      	pop	{r7}
 8007172:	4770      	bx	lr

08007174 <NVIC_SystemReset>:
 * @return  none
 *
 * Initialize a system reset request to reset the MCU
 */
static __INLINE void NVIC_SystemReset(void)
{
 8007174:	b580      	push	{r7, lr}
 8007176:	af00      	add	r7, sp, #0
  SCB->AIRCR  = (NVIC_AIRCR_VECTKEY | (SCB->AIRCR & (0x700)) | (1<<NVIC_SYSRESETREQ)); /* Keep priority group unchanged */
 8007178:	4b05      	ldr	r3, [pc, #20]	; (8007190 <NVIC_SystemReset+0x1c>)
 800717a:	68db      	ldr	r3, [r3, #12]
 800717c:	f403 62e0 	and.w	r2, r3, #1792	; 0x700
 8007180:	4903      	ldr	r1, [pc, #12]	; (8007190 <NVIC_SystemReset+0x1c>)
 8007182:	4b04      	ldr	r3, [pc, #16]	; (8007194 <NVIC_SystemReset+0x20>)
 8007184:	4313      	orrs	r3, r2
 8007186:	60cb      	str	r3, [r1, #12]
  __DSB();                                                                             /* Ensure completion of memory access */              
 8007188:	4b03      	ldr	r3, [pc, #12]	; (8007198 <NVIC_SystemReset+0x24>)
 800718a:	4798      	blx	r3
  while(1);                                                                            /* wait until reset */
 800718c:	e7fe      	b.n	800718c <NVIC_SystemReset+0x18>
 800718e:	bf00      	nop
 8007190:	e000ed00 	.word	0xe000ed00
 8007194:	05fa0004 	.word	0x05fa0004
 8007198:	08007165 	.word	0x08007165

0800719c <NMI_Handler>:

extern __IO uint32_t I2CDirection;
extern uint8_t Address;
#endif

void NMI_Handler(void) {
 800719c:	b480      	push	{r7}
 800719e:	af00      	add	r7, sp, #0

}
 80071a0:	bf00      	nop
 80071a2:	46bd      	mov	sp, r7
 80071a4:	bc80      	pop	{r7}
 80071a6:	4770      	bx	lr

080071a8 <HardFault_Handler>:

void HardFault_Handler(void) {
 80071a8:	b580      	push	{r7, lr}
 80071aa:	af00      	add	r7, sp, #0

	NVIC_SystemReset();
 80071ac:	4b01      	ldr	r3, [pc, #4]	; (80071b4 <HardFault_Handler+0xc>)
 80071ae:	4798      	blx	r3

}
 80071b0:	bf00      	nop
 80071b2:	bd80      	pop	{r7, pc}
 80071b4:	08007175 	.word	0x08007175

080071b8 <USB_LP_CAN1_RX0_IRQHandler>:

void USB_LP_CAN1_RX0_IRQHandler() {
 80071b8:	b580      	push	{r7, lr}
 80071ba:	af00      	add	r7, sp, #0
	USB_Istr();
 80071bc:	4b01      	ldr	r3, [pc, #4]	; (80071c4 <USB_LP_CAN1_RX0_IRQHandler+0xc>)
 80071be:	4798      	blx	r3
}
 80071c0:	bf00      	nop
 80071c2:	bd80      	pop	{r7, pc}
 80071c4:	080126d1 	.word	0x080126d1

080071c8 <MemManage_Handler>:
;

void MemManage_Handler(void) {
 80071c8:	b480      	push	{r7}
 80071ca:	af00      	add	r7, sp, #0
	while (1) {
 80071cc:	e7fe      	b.n	80071cc <MemManage_Handler+0x4>

080071ce <BusFault_Handler>:
	}
}

void BusFault_Handler(void) {
 80071ce:	b480      	push	{r7}
 80071d0:	af00      	add	r7, sp, #0

	while (1) {
 80071d2:	e7fe      	b.n	80071d2 <BusFault_Handler+0x4>

080071d4 <UsageFault_Handler>:
	}
}

void UsageFault_Handler(void) {
 80071d4:	b480      	push	{r7}
 80071d6:	af00      	add	r7, sp, #0

	while (1) {
 80071d8:	e7fe      	b.n	80071d8 <UsageFault_Handler+0x4>

080071da <DebugMon_Handler>:
}

void SVC_Handler(void) {
}

void DebugMon_Handler(void) {
 80071da:	b480      	push	{r7}
 80071dc:	af00      	add	r7, sp, #0
}
 80071de:	bf00      	nop
 80071e0:	46bd      	mov	sp, r7
 80071e2:	bc80      	pop	{r7}
 80071e4:	4770      	bx	lr
	...

080071e8 <GprsIdleIncMSec>:
int gprssize;
bool restart;
int FlagNoModem_Journal;
uint8 gprsbuf[GPRS_BUF_SIZE];

void GprsIdleIncMSec() {
 80071e8:	b480      	push	{r7}
 80071ea:	af00      	add	r7, sp, #0
	GprsIdleMSec++;
 80071ec:	4b06      	ldr	r3, [pc, #24]	; (8007208 <GprsIdleIncMSec+0x20>)
 80071ee:	681b      	ldr	r3, [r3, #0]
 80071f0:	3301      	adds	r3, #1
 80071f2:	4a05      	ldr	r2, [pc, #20]	; (8007208 <GprsIdleIncMSec+0x20>)
 80071f4:	6013      	str	r3, [r2, #0]
	GprsIdleMSecCSQ++;
 80071f6:	4b05      	ldr	r3, [pc, #20]	; (800720c <GprsIdleIncMSec+0x24>)
 80071f8:	681b      	ldr	r3, [r3, #0]
 80071fa:	3301      	adds	r3, #1
 80071fc:	4a03      	ldr	r2, [pc, #12]	; (800720c <GprsIdleIncMSec+0x24>)
 80071fe:	6013      	str	r3, [r2, #0]
}
 8007200:	bf00      	nop
 8007202:	46bd      	mov	sp, r7
 8007204:	bc80      	pop	{r7}
 8007206:	4770      	bx	lr
 8007208:	200086dc 	.word	0x200086dc
 800720c:	200071a0 	.word	0x200071a0

08007210 <vGprsConTask>:

void vGprsConTask(void *pvParameters) {
	(void) pvParameters;

	//vTaskDelay(500);
	GprsConnectionsAttempt = 0;
 8007210:	4b92      	ldr	r3, [pc, #584]	; (800745c <vGprsConTask+0x24c>)
 8007212:	2200      	movs	r2, #0
 8007214:	601a      	str	r2, [r3, #0]
	int heapSize = 0;
	while (1) {
		GprsConnectionsAttempt++;
 8007216:	4b91      	ldr	r3, [pc, #580]	; (800745c <vGprsConTask+0x24c>)
 8007218:	681b      	ldr	r3, [r3, #0]
 800721a:	3301      	adds	r3, #1
 800721c:	4a8f      	ldr	r2, [pc, #572]	; (800745c <vGprsConTask+0x24c>)
 800721e:	6013      	str	r3, [r2, #0]
		LedConnect = 0;
 8007220:	4b8f      	ldr	r3, [pc, #572]	; (8007460 <vGprsConTask+0x250>)
 8007222:	2200      	movs	r2, #0
 8007224:	701a      	strb	r2, [r3, #0]
		/*else if (LedAPN)
		 {
		 LedNoModem = 0;

		 }*/
		if ((LedNoModem) || (LedSIM) || (LedAPN)) {
 8007226:	4b8f      	ldr	r3, [pc, #572]	; (8007464 <vGprsConTask+0x254>)
 8007228:	781b      	ldrb	r3, [r3, #0]
 800722a:	2b00      	cmp	r3, #0
 800722c:	d107      	bne.n	800723e <vGprsConTask+0x2e>
 800722e:	4b8e      	ldr	r3, [pc, #568]	; (8007468 <vGprsConTask+0x258>)
 8007230:	781b      	ldrb	r3, [r3, #0]
 8007232:	2b00      	cmp	r3, #0
 8007234:	d103      	bne.n	800723e <vGprsConTask+0x2e>
 8007236:	4b8d      	ldr	r3, [pc, #564]	; (800746c <vGprsConTask+0x25c>)
 8007238:	781b      	ldrb	r3, [r3, #0]
 800723a:	2b00      	cmp	r3, #0
 800723c:	d023      	beq.n	8007286 <vGprsConTask+0x76>
			//LedNoModem = 1;
			if (!LedNoModem_Journal) {
 800723e:	4b8c      	ldr	r3, [pc, #560]	; (8007470 <vGprsConTask+0x260>)
 8007240:	781b      	ldrb	r3, [r3, #0]
 8007242:	f083 0301 	eor.w	r3, r3, #1
 8007246:	b2db      	uxtb	r3, r3
 8007248:	2b00      	cmp	r3, #0
 800724a:	d005      	beq.n	8007258 <vGprsConTask+0x48>
				JrnlWrite("GSM: ");
 800724c:	4889      	ldr	r0, [pc, #548]	; (8007474 <vGprsConTask+0x264>)
 800724e:	4b8a      	ldr	r3, [pc, #552]	; (8007478 <vGprsConTask+0x268>)
 8007250:	4798      	blx	r3
				LedNoModem_Journal = 1;
 8007252:	4b87      	ldr	r3, [pc, #540]	; (8007470 <vGprsConTask+0x260>)
 8007254:	2201      	movs	r2, #1
 8007256:	701a      	strb	r2, [r3, #0]

			}

			GprsIdleMSec = 0;
 8007258:	4b88      	ldr	r3, [pc, #544]	; (800747c <vGprsConTask+0x26c>)
 800725a:	2200      	movs	r2, #0
 800725c:	601a      	str	r2, [r3, #0]
			LedNoModem = 0;
 800725e:	4b81      	ldr	r3, [pc, #516]	; (8007464 <vGprsConTask+0x254>)
 8007260:	2200      	movs	r2, #0
 8007262:	701a      	strb	r2, [r3, #0]
			LedSIM = 0;
 8007264:	4b80      	ldr	r3, [pc, #512]	; (8007468 <vGprsConTask+0x258>)
 8007266:	2200      	movs	r2, #0
 8007268:	701a      	strb	r2, [r3, #0]
			LedAPN = 0;
 800726a:	4b80      	ldr	r3, [pc, #512]	; (800746c <vGprsConTask+0x25c>)
 800726c:	2200      	movs	r2, #0
 800726e:	701a      	strb	r2, [r3, #0]

			RAM.CSQ = 0;
 8007270:	4b83      	ldr	r3, [pc, #524]	; (8007480 <vGprsConTask+0x270>)
 8007272:	2200      	movs	r2, #0
 8007274:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
 8007278:	2200      	movs	r2, #0
 800727a:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
			GprsIdleMSec = GPRS_IDLE_TIMEOUT_MS + 1;
 800727e:	4b7f      	ldr	r3, [pc, #508]	; (800747c <vGprsConTask+0x26c>)
 8007280:	4a80      	ldr	r2, [pc, #512]	; (8007484 <vGprsConTask+0x274>)
 8007282:	601a      	str	r2, [r3, #0]
 8007284:	e042      	b.n	800730c <vGprsConTask+0xfc>
			//MODEM_DISABLE;
		} else {
			//ModemInit();

			if (!LedNoModem) {
 8007286:	4b77      	ldr	r3, [pc, #476]	; (8007464 <vGprsConTask+0x254>)
 8007288:	781b      	ldrb	r3, [r3, #0]
 800728a:	f083 0301 	eor.w	r3, r3, #1
 800728e:	b2db      	uxtb	r3, r3
 8007290:	2b00      	cmp	r3, #0
 8007292:	d001      	beq.n	8007298 <vGprsConTask+0x88>
				ModemInit();
 8007294:	4b7c      	ldr	r3, [pc, #496]	; (8007488 <vGprsConTask+0x278>)
 8007296:	4798      	blx	r3
			}

			if ((!LedSIM) && (!LedAPN) && (!LedNoModem)
 8007298:	4b73      	ldr	r3, [pc, #460]	; (8007468 <vGprsConTask+0x258>)
 800729a:	781b      	ldrb	r3, [r3, #0]
 800729c:	f083 0301 	eor.w	r3, r3, #1
 80072a0:	b2db      	uxtb	r3, r3
 80072a2:	2b00      	cmp	r3, #0
 80072a4:	d01b      	beq.n	80072de <vGprsConTask+0xce>
 80072a6:	4b71      	ldr	r3, [pc, #452]	; (800746c <vGprsConTask+0x25c>)
 80072a8:	781b      	ldrb	r3, [r3, #0]
 80072aa:	f083 0301 	eor.w	r3, r3, #1
 80072ae:	b2db      	uxtb	r3, r3
 80072b0:	2b00      	cmp	r3, #0
 80072b2:	d014      	beq.n	80072de <vGprsConTask+0xce>
 80072b4:	4b6b      	ldr	r3, [pc, #428]	; (8007464 <vGprsConTask+0x254>)
 80072b6:	781b      	ldrb	r3, [r3, #0]
 80072b8:	f083 0301 	eor.w	r3, r3, #1
 80072bc:	b2db      	uxtb	r3, r3
 80072be:	2b00      	cmp	r3, #0
 80072c0:	d00d      	beq.n	80072de <vGprsConTask+0xce>
					&& (GprsIdleMSec < GPRS_IDLE_TIMEOUT_MS)) //   
 80072c2:	4b6e      	ldr	r3, [pc, #440]	; (800747c <vGprsConTask+0x26c>)
 80072c4:	681b      	ldr	r3, [r3, #0]
 80072c6:	4a71      	ldr	r2, [pc, #452]	; (800748c <vGprsConTask+0x27c>)
 80072c8:	4293      	cmp	r3, r2
 80072ca:	d808      	bhi.n	80072de <vGprsConTask+0xce>
					{
				LedConnect = 1;
 80072cc:	4b64      	ldr	r3, [pc, #400]	; (8007460 <vGprsConTask+0x250>)
 80072ce:	2201      	movs	r2, #1
 80072d0:	701a      	strb	r2, [r3, #0]
				LedReg = 0;
 80072d2:	4b6f      	ldr	r3, [pc, #444]	; (8007490 <vGprsConTask+0x280>)
 80072d4:	2200      	movs	r2, #0
 80072d6:	701a      	strb	r2, [r3, #0]
				LedNoModem_Journal = 0;
 80072d8:	4b65      	ldr	r3, [pc, #404]	; (8007470 <vGprsConTask+0x260>)
 80072da:	2200      	movs	r2, #0
 80072dc:	701a      	strb	r2, [r3, #0]

			}

			if (LedReg) {
 80072de:	4b6c      	ldr	r3, [pc, #432]	; (8007490 <vGprsConTask+0x280>)
 80072e0:	781b      	ldrb	r3, [r3, #0]
 80072e2:	2b00      	cmp	r3, #0
 80072e4:	f000 814d 	beq.w	8007582 <vGprsConTask+0x372>
				GprsIdleMSec = 0;
 80072e8:	4b64      	ldr	r3, [pc, #400]	; (800747c <vGprsConTask+0x26c>)
 80072ea:	2200      	movs	r2, #0
 80072ec:	601a      	str	r2, [r3, #0]
				LedNoModem = 0;
 80072ee:	4b5d      	ldr	r3, [pc, #372]	; (8007464 <vGprsConTask+0x254>)
 80072f0:	2200      	movs	r2, #0
 80072f2:	701a      	strb	r2, [r3, #0]

				RAM.CSQ = 0;
 80072f4:	4b62      	ldr	r3, [pc, #392]	; (8007480 <vGprsConTask+0x270>)
 80072f6:	2200      	movs	r2, #0
 80072f8:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
 80072fc:	2200      	movs	r2, #0
 80072fe:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f
				MODEM_DISABLE
 8007302:	2101      	movs	r1, #1
 8007304:	4863      	ldr	r0, [pc, #396]	; (8007494 <vGprsConTask+0x284>)
 8007306:	4b64      	ldr	r3, [pc, #400]	; (8007498 <vGprsConTask+0x288>)
 8007308:	4798      	blx	r3
				;

				break;
 800730a:	e1a3      	b.n	8007654 <vGprsConTask+0x444>
			}

		}
		while ((!LedSIM) && (!LedAPN) && (!LedNoModem)) {
 800730c:	e139      	b.n	8007582 <vGprsConTask+0x372>

			if (GprsIdleMSec <= GPRS_IDLE_TIMEOUT_MS) //  ,  
 800730e:	4b5b      	ldr	r3, [pc, #364]	; (800747c <vGprsConTask+0x26c>)
 8007310:	681b      	ldr	r3, [r3, #0]
 8007312:	4a62      	ldr	r2, [pc, #392]	; (800749c <vGprsConTask+0x28c>)
 8007314:	4293      	cmp	r3, r2
 8007316:	d848      	bhi.n	80073aa <vGprsConTask+0x19a>
			{
				BKP_WriteBackupRegister(BKP_DR7, 28);
 8007318:	211c      	movs	r1, #28
 800731a:	201c      	movs	r0, #28
 800731c:	4b60      	ldr	r3, [pc, #384]	; (80074a0 <vGprsConTask+0x290>)
 800731e:	4798      	blx	r3
				gprssize = ModemReceiveData(gprsbuf, GPRS_BUF_SIZE);
 8007320:	f44f 7180 	mov.w	r1, #256	; 0x100
 8007324:	485f      	ldr	r0, [pc, #380]	; (80074a4 <vGprsConTask+0x294>)
 8007326:	4b60      	ldr	r3, [pc, #384]	; (80074a8 <vGprsConTask+0x298>)
 8007328:	4798      	blx	r3
 800732a:	4603      	mov	r3, r0
 800732c:	4a5f      	ldr	r2, [pc, #380]	; (80074ac <vGprsConTask+0x29c>)
 800732e:	6013      	str	r3, [r2, #0]
				heapSize = xPortGetFreeHeapSize();
 8007330:	4b5f      	ldr	r3, [pc, #380]	; (80074b0 <vGprsConTask+0x2a0>)
 8007332:	4798      	blx	r3
				heapSize += 0;

				if (gprssize != 0) {
 8007334:	4b5d      	ldr	r3, [pc, #372]	; (80074ac <vGprsConTask+0x29c>)
 8007336:	681b      	ldr	r3, [r3, #0]
 8007338:	2b00      	cmp	r3, #0
 800733a:	d036      	beq.n	80073aa <vGprsConTask+0x19a>
					LedReceive = 1;
 800733c:	4b5d      	ldr	r3, [pc, #372]	; (80074b4 <vGprsConTask+0x2a4>)
 800733e:	2201      	movs	r2, #1
 8007340:	701a      	strb	r2, [r3, #0]
					gprssize = RVnetTcpSlaveProcess(gprsbuf, gprssize, 1);
 8007342:	4b5a      	ldr	r3, [pc, #360]	; (80074ac <vGprsConTask+0x29c>)
 8007344:	681b      	ldr	r3, [r3, #0]
 8007346:	b2db      	uxtb	r3, r3
 8007348:	2201      	movs	r2, #1
 800734a:	4619      	mov	r1, r3
 800734c:	4855      	ldr	r0, [pc, #340]	; (80074a4 <vGprsConTask+0x294>)
 800734e:	4b5a      	ldr	r3, [pc, #360]	; (80074b8 <vGprsConTask+0x2a8>)
 8007350:	4798      	blx	r3
 8007352:	4603      	mov	r3, r0
 8007354:	461a      	mov	r2, r3
 8007356:	4b55      	ldr	r3, [pc, #340]	; (80074ac <vGprsConTask+0x29c>)
 8007358:	601a      	str	r2, [r3, #0]
					if (DeviceID == 4) {
 800735a:	4b58      	ldr	r3, [pc, #352]	; (80074bc <vGprsConTask+0x2ac>)
 800735c:	681b      	ldr	r3, [r3, #0]
 800735e:	2b04      	cmp	r3, #4
 8007360:	d105      	bne.n	800736e <vGprsConTask+0x15e>
						gprsbuf[gprssize + 1] = '\r';
 8007362:	4b52      	ldr	r3, [pc, #328]	; (80074ac <vGprsConTask+0x29c>)
 8007364:	681b      	ldr	r3, [r3, #0]
 8007366:	3301      	adds	r3, #1
 8007368:	4a4e      	ldr	r2, [pc, #312]	; (80074a4 <vGprsConTask+0x294>)
 800736a:	210d      	movs	r1, #13
 800736c:	54d1      	strb	r1, [r2, r3]
					}
					heapSize = xPortGetFreeHeapSize();
 800736e:	4b50      	ldr	r3, [pc, #320]	; (80074b0 <vGprsConTask+0x2a0>)
 8007370:	4798      	blx	r3
					heapSize += 0;
					if (gprssize != 0) {
 8007372:	4b4e      	ldr	r3, [pc, #312]	; (80074ac <vGprsConTask+0x29c>)
 8007374:	681b      	ldr	r3, [r3, #0]
 8007376:	2b00      	cmp	r3, #0
 8007378:	d017      	beq.n	80073aa <vGprsConTask+0x19a>
						LedSend = 1;
 800737a:	4b51      	ldr	r3, [pc, #324]	; (80074c0 <vGprsConTask+0x2b0>)
 800737c:	2201      	movs	r2, #1
 800737e:	701a      	strb	r2, [r3, #0]
						ModemSendData(gprsbuf, gprssize, numRD);
 8007380:	4b4a      	ldr	r3, [pc, #296]	; (80074ac <vGprsConTask+0x29c>)
 8007382:	681b      	ldr	r3, [r3, #0]
 8007384:	b2db      	uxtb	r3, r3
 8007386:	4a4f      	ldr	r2, [pc, #316]	; (80074c4 <vGprsConTask+0x2b4>)
 8007388:	6812      	ldr	r2, [r2, #0]
 800738a:	4619      	mov	r1, r3
 800738c:	4845      	ldr	r0, [pc, #276]	; (80074a4 <vGprsConTask+0x294>)
 800738e:	4b4e      	ldr	r3, [pc, #312]	; (80074c8 <vGprsConTask+0x2b8>)
 8007390:	4798      	blx	r3
						heapSize = xPortGetFreeHeapSize();
 8007392:	4b47      	ldr	r3, [pc, #284]	; (80074b0 <vGprsConTask+0x2a0>)
 8007394:	4798      	blx	r3
						heapSize += 0;
						portENTER_CRITICAL();
 8007396:	4b4d      	ldr	r3, [pc, #308]	; (80074cc <vGprsConTask+0x2bc>)
 8007398:	4798      	blx	r3
						{
							GprsIdleMSec = 0;
 800739a:	4b38      	ldr	r3, [pc, #224]	; (800747c <vGprsConTask+0x26c>)
 800739c:	2200      	movs	r2, #0
 800739e:	601a      	str	r2, [r3, #0]
							GprsIdleMSecCSQ = 0;
 80073a0:	4b4b      	ldr	r3, [pc, #300]	; (80074d0 <vGprsConTask+0x2c0>)
 80073a2:	2200      	movs	r2, #0
 80073a4:	601a      	str	r2, [r3, #0]

						}
						portEXIT_CRITICAL();
 80073a6:	4b4b      	ldr	r3, [pc, #300]	; (80074d4 <vGprsConTask+0x2c4>)
 80073a8:	4798      	blx	r3
					}
				}
			}
			if (GprsIdleMSec > GPRS_IDLE_TIMEOUT_MS) // (    4 )
 80073aa:	4b34      	ldr	r3, [pc, #208]	; (800747c <vGprsConTask+0x26c>)
 80073ac:	681b      	ldr	r3, [r3, #0]
 80073ae:	4a3b      	ldr	r2, [pc, #236]	; (800749c <vGprsConTask+0x28c>)
 80073b0:	4293      	cmp	r3, r2
 80073b2:	f240 80d8 	bls.w	8007566 <vGprsConTask+0x356>
			{

				RAM.CSQ = 0;
 80073b6:	4b32      	ldr	r3, [pc, #200]	; (8007480 <vGprsConTask+0x270>)
 80073b8:	2200      	movs	r2, #0
 80073ba:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
 80073be:	2200      	movs	r2, #0
 80073c0:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f

				GprsIdleMSec = 0;
 80073c4:	4b2d      	ldr	r3, [pc, #180]	; (800747c <vGprsConTask+0x26c>)
 80073c6:	2200      	movs	r2, #0
 80073c8:	601a      	str	r2, [r3, #0]
				LedConnect = 0;
 80073ca:	4b25      	ldr	r3, [pc, #148]	; (8007460 <vGprsConTask+0x250>)
 80073cc:	2200      	movs	r2, #0
 80073ce:	701a      	strb	r2, [r3, #0]
				LedReg = 0;
 80073d0:	4b2f      	ldr	r3, [pc, #188]	; (8007490 <vGprsConTask+0x280>)
 80073d2:	2200      	movs	r2, #0
 80073d4:	701a      	strb	r2, [r3, #0]

				if (DeviceID == 1) {
 80073d6:	4b39      	ldr	r3, [pc, #228]	; (80074bc <vGprsConTask+0x2ac>)
 80073d8:	681b      	ldr	r3, [r3, #0]
 80073da:	2b01      	cmp	r3, #1
 80073dc:	d129      	bne.n	8007432 <vGprsConTask+0x222>
					//ATSTAT();

					if (numRD > 0) {
 80073de:	4b39      	ldr	r3, [pc, #228]	; (80074c4 <vGprsConTask+0x2b4>)
 80073e0:	681b      	ldr	r3, [r3, #0]
 80073e2:	2b00      	cmp	r3, #0
 80073e4:	dd1d      	ble.n	8007422 <vGprsConTask+0x212>
						if (!WaitClose(numRD))
 80073e6:	4b37      	ldr	r3, [pc, #220]	; (80074c4 <vGprsConTask+0x2b4>)
 80073e8:	681b      	ldr	r3, [r3, #0]
 80073ea:	4618      	mov	r0, r3
 80073ec:	4b3a      	ldr	r3, [pc, #232]	; (80074d8 <vGprsConTask+0x2c8>)
 80073ee:	4798      	blx	r3
 80073f0:	4603      	mov	r3, r0
 80073f2:	f083 0301 	eor.w	r3, r3, #1
 80073f6:	b2db      	uxtb	r3, r3
 80073f8:	2b00      	cmp	r3, #0
 80073fa:	d000      	beq.n	80073fe <vGprsConTask+0x1ee>
							continue;
 80073fc:	e0c1      	b.n	8007582 <vGprsConTask+0x372>
						numRD = 0;
 80073fe:	4b31      	ldr	r3, [pc, #196]	; (80074c4 <vGprsConTask+0x2b4>)
 8007400:	2200      	movs	r2, #0
 8007402:	601a      	str	r2, [r3, #0]
						vTaskDelay(10);
 8007404:	200a      	movs	r0, #10
 8007406:	4b35      	ldr	r3, [pc, #212]	; (80074dc <vGprsConTask+0x2cc>)
 8007408:	4798      	blx	r3

						if (!WaitCloseServer())
 800740a:	4b35      	ldr	r3, [pc, #212]	; (80074e0 <vGprsConTask+0x2d0>)
 800740c:	4798      	blx	r3
 800740e:	4603      	mov	r3, r0
 8007410:	f083 0301 	eor.w	r3, r3, #1
 8007414:	b2db      	uxtb	r3, r3
 8007416:	2b00      	cmp	r3, #0
 8007418:	d000      	beq.n	800741c <vGprsConTask+0x20c>
							continue;
 800741a:	e0b2      	b.n	8007582 <vGprsConTask+0x372>
						vTaskDelay(10);
 800741c:	200a      	movs	r0, #10
 800741e:	4b2f      	ldr	r3, [pc, #188]	; (80074dc <vGprsConTask+0x2cc>)
 8007420:	4798      	blx	r3
					}

					ModemWrite("AT+QPOWD\r\n");
 8007422:	4830      	ldr	r0, [pc, #192]	; (80074e4 <vGprsConTask+0x2d4>)
 8007424:	4b30      	ldr	r3, [pc, #192]	; (80074e8 <vGprsConTask+0x2d8>)
 8007426:	4798      	blx	r3
					vTaskDelay(1500);
 8007428:	f240 50dc 	movw	r0, #1500	; 0x5dc
 800742c:	4b2b      	ldr	r3, [pc, #172]	; (80074dc <vGprsConTask+0x2cc>)
 800742e:	4798      	blx	r3
 8007430:	e081      	b.n	8007536 <vGprsConTask+0x326>

				} else if (DeviceID == 3) {
 8007432:	4b22      	ldr	r3, [pc, #136]	; (80074bc <vGprsConTask+0x2ac>)
 8007434:	681b      	ldr	r3, [r3, #0]
 8007436:	2b03      	cmp	r3, #3
 8007438:	d172      	bne.n	8007520 <vGprsConTask+0x310>
					if (numRD > 0) {
 800743a:	4b22      	ldr	r3, [pc, #136]	; (80074c4 <vGprsConTask+0x2b4>)
 800743c:	681b      	ldr	r3, [r3, #0]
 800743e:	2b00      	cmp	r3, #0
 8007440:	dd66      	ble.n	8007510 <vGprsConTask+0x300>
						if (!WaitClose(numRD))
 8007442:	4b20      	ldr	r3, [pc, #128]	; (80074c4 <vGprsConTask+0x2b4>)
 8007444:	681b      	ldr	r3, [r3, #0]
 8007446:	4618      	mov	r0, r3
 8007448:	4b23      	ldr	r3, [pc, #140]	; (80074d8 <vGprsConTask+0x2c8>)
 800744a:	4798      	blx	r3
 800744c:	4603      	mov	r3, r0
 800744e:	f083 0301 	eor.w	r3, r3, #1
 8007452:	b2db      	uxtb	r3, r3
 8007454:	2b00      	cmp	r3, #0
 8007456:	d049      	beq.n	80074ec <vGprsConTask+0x2dc>
							continue;
 8007458:	e093      	b.n	8007582 <vGprsConTask+0x372>
 800745a:	bf00      	nop
 800745c:	200071a4 	.word	0x200071a4
 8007460:	200072b5 	.word	0x200072b5
 8007464:	200072b8 	.word	0x200072b8
 8007468:	200072b9 	.word	0x200072b9
 800746c:	200072ba 	.word	0x200072ba
 8007470:	200092f8 	.word	0x200092f8
 8007474:	08014db0 	.word	0x08014db0
 8007478:	0800edb5 	.word	0x0800edb5
 800747c:	200086dc 	.word	0x200086dc
 8007480:	2000745c 	.word	0x2000745c
 8007484:	0003a981 	.word	0x0003a981
 8007488:	0800d96d 	.word	0x0800d96d
 800748c:	0003a97f 	.word	0x0003a97f
 8007490:	200072b4 	.word	0x200072b4
 8007494:	40010c00 	.word	0x40010c00
 8007498:	08002f6d 	.word	0x08002f6d
 800749c:	0003a980 	.word	0x0003a980
 80074a0:	08003621 	.word	0x08003621
 80074a4:	200071b4 	.word	0x200071b4
 80074a8:	0800dbb5 	.word	0x0800dbb5
 80074ac:	200071a8 	.word	0x200071a8
 80074b0:	080028b5 	.word	0x080028b5
 80074b4:	200072b6 	.word	0x200072b6
 80074b8:	080069c1 	.word	0x080069c1
 80074bc:	20008468 	.word	0x20008468
 80074c0:	200072b7 	.word	0x200072b7
 80074c4:	200092ec 	.word	0x200092ec
 80074c8:	0800e5d5 	.word	0x0800e5d5
 80074cc:	080025f9 	.word	0x080025f9
 80074d0:	200071a0 	.word	0x200071a0
 80074d4:	0800261d 	.word	0x0800261d
 80074d8:	0800c851 	.word	0x0800c851
 80074dc:	08001529 	.word	0x08001529
 80074e0:	0800c8f5 	.word	0x0800c8f5
 80074e4:	08014dc4 	.word	0x08014dc4
 80074e8:	0800bfed 	.word	0x0800bfed
						numRD = 0;
 80074ec:	4b5a      	ldr	r3, [pc, #360]	; (8007658 <vGprsConTask+0x448>)
 80074ee:	2200      	movs	r2, #0
 80074f0:	601a      	str	r2, [r3, #0]
						vTaskDelay(10);
 80074f2:	200a      	movs	r0, #10
 80074f4:	4b59      	ldr	r3, [pc, #356]	; (800765c <vGprsConTask+0x44c>)
 80074f6:	4798      	blx	r3

						if (!WaitCloseServer())
 80074f8:	4b59      	ldr	r3, [pc, #356]	; (8007660 <vGprsConTask+0x450>)
 80074fa:	4798      	blx	r3
 80074fc:	4603      	mov	r3, r0
 80074fe:	f083 0301 	eor.w	r3, r3, #1
 8007502:	b2db      	uxtb	r3, r3
 8007504:	2b00      	cmp	r3, #0
 8007506:	d000      	beq.n	800750a <vGprsConTask+0x2fa>
							continue;
 8007508:	e03b      	b.n	8007582 <vGprsConTask+0x372>
						vTaskDelay(10);
 800750a:	200a      	movs	r0, #10
 800750c:	4b53      	ldr	r3, [pc, #332]	; (800765c <vGprsConTask+0x44c>)
 800750e:	4798      	blx	r3
					}

					ModemWrite("AT+QPOWD\r\n");
 8007510:	4854      	ldr	r0, [pc, #336]	; (8007664 <vGprsConTask+0x454>)
 8007512:	4b55      	ldr	r3, [pc, #340]	; (8007668 <vGprsConTask+0x458>)
 8007514:	4798      	blx	r3
					vTaskDelay(1500);
 8007516:	f240 50dc 	movw	r0, #1500	; 0x5dc
 800751a:	4b50      	ldr	r3, [pc, #320]	; (800765c <vGprsConTask+0x44c>)
 800751c:	4798      	blx	r3
 800751e:	e00a      	b.n	8007536 <vGprsConTask+0x326>

				}

				else if (DeviceID == 2) {
 8007520:	4b52      	ldr	r3, [pc, #328]	; (800766c <vGprsConTask+0x45c>)
 8007522:	681b      	ldr	r3, [r3, #0]
 8007524:	2b02      	cmp	r3, #2
 8007526:	d106      	bne.n	8007536 <vGprsConTask+0x326>
					ModemWrite("AT+QPOWD=0\r\n");
 8007528:	4851      	ldr	r0, [pc, #324]	; (8007670 <vGprsConTask+0x460>)
 800752a:	4b4f      	ldr	r3, [pc, #316]	; (8007668 <vGprsConTask+0x458>)
 800752c:	4798      	blx	r3
					vTaskDelay(1000);
 800752e:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8007532:	4b4a      	ldr	r3, [pc, #296]	; (800765c <vGprsConTask+0x44c>)
 8007534:	4798      	blx	r3
				}

				MODEM_DISABLE
 8007536:	2101      	movs	r1, #1
 8007538:	484e      	ldr	r0, [pc, #312]	; (8007674 <vGprsConTask+0x464>)
 800753a:	4b4f      	ldr	r3, [pc, #316]	; (8007678 <vGprsConTask+0x468>)
 800753c:	4798      	blx	r3
				;

				vTaskDelay(15000); //15
 800753e:	f643 2098 	movw	r0, #15000	; 0x3a98
 8007542:	4b46      	ldr	r3, [pc, #280]	; (800765c <vGprsConTask+0x44c>)
 8007544:	4798      	blx	r3

				GprsIdleMSec = 0;
 8007546:	4b4d      	ldr	r3, [pc, #308]	; (800767c <vGprsConTask+0x46c>)
 8007548:	2200      	movs	r2, #0
 800754a:	601a      	str	r2, [r3, #0]
				LedConnect = 0;
 800754c:	4b4c      	ldr	r3, [pc, #304]	; (8007680 <vGprsConTask+0x470>)
 800754e:	2200      	movs	r2, #0
 8007550:	701a      	strb	r2, [r3, #0]
				LedReg = 0;
 8007552:	4b4c      	ldr	r3, [pc, #304]	; (8007684 <vGprsConTask+0x474>)
 8007554:	2200      	movs	r2, #0
 8007556:	701a      	strb	r2, [r3, #0]
				LedSIM = 0;
 8007558:	4b4b      	ldr	r3, [pc, #300]	; (8007688 <vGprsConTask+0x478>)
 800755a:	2200      	movs	r2, #0
 800755c:	701a      	strb	r2, [r3, #0]
				LedAPN = 0;
 800755e:	4b4b      	ldr	r3, [pc, #300]	; (800768c <vGprsConTask+0x47c>)
 8007560:	2200      	movs	r2, #0
 8007562:	701a      	strb	r2, [r3, #0]

				break;
 8007564:	e023      	b.n	80075ae <vGprsConTask+0x39e>
			}
			if (GprsIdleMSecCSQ > CSQ_TIMEOUT_MS) //  
 8007566:	4b4a      	ldr	r3, [pc, #296]	; (8007690 <vGprsConTask+0x480>)
 8007568:	681b      	ldr	r3, [r3, #0]
 800756a:	f247 5230 	movw	r2, #30000	; 0x7530
 800756e:	4293      	cmp	r3, r2
 8007570:	d904      	bls.n	800757c <vGprsConTask+0x36c>
			{
				CSQ();
 8007572:	4b48      	ldr	r3, [pc, #288]	; (8007694 <vGprsConTask+0x484>)
 8007574:	4798      	blx	r3
				//ATSTAT();
				GprsIdleMSecCSQ = 0;
 8007576:	4b46      	ldr	r3, [pc, #280]	; (8007690 <vGprsConTask+0x480>)
 8007578:	2200      	movs	r2, #0
 800757a:	601a      	str	r2, [r3, #0]

			}
			vTaskDelay(1);
 800757c:	2001      	movs	r0, #1
 800757e:	4b37      	ldr	r3, [pc, #220]	; (800765c <vGprsConTask+0x44c>)
 8007580:	4798      	blx	r3
		while ((!LedSIM) && (!LedAPN) && (!LedNoModem)) {
 8007582:	4b41      	ldr	r3, [pc, #260]	; (8007688 <vGprsConTask+0x478>)
 8007584:	781b      	ldrb	r3, [r3, #0]
 8007586:	f083 0301 	eor.w	r3, r3, #1
 800758a:	b2db      	uxtb	r3, r3
 800758c:	2b00      	cmp	r3, #0
 800758e:	d00e      	beq.n	80075ae <vGprsConTask+0x39e>
 8007590:	4b3e      	ldr	r3, [pc, #248]	; (800768c <vGprsConTask+0x47c>)
 8007592:	781b      	ldrb	r3, [r3, #0]
 8007594:	f083 0301 	eor.w	r3, r3, #1
 8007598:	b2db      	uxtb	r3, r3
 800759a:	2b00      	cmp	r3, #0
 800759c:	d007      	beq.n	80075ae <vGprsConTask+0x39e>
 800759e:	4b3e      	ldr	r3, [pc, #248]	; (8007698 <vGprsConTask+0x488>)
 80075a0:	781b      	ldrb	r3, [r3, #0]
 80075a2:	f083 0301 	eor.w	r3, r3, #1
 80075a6:	b2db      	uxtb	r3, r3
 80075a8:	2b00      	cmp	r3, #0
 80075aa:	f47f aeb0 	bne.w	800730e <vGprsConTask+0xfe>
		}
		if ((LedNoModem) || (LedSIM) || (LedAPN)) {
 80075ae:	4b3a      	ldr	r3, [pc, #232]	; (8007698 <vGprsConTask+0x488>)
 80075b0:	781b      	ldrb	r3, [r3, #0]
 80075b2:	2b00      	cmp	r3, #0
 80075b4:	d107      	bne.n	80075c6 <vGprsConTask+0x3b6>
 80075b6:	4b34      	ldr	r3, [pc, #208]	; (8007688 <vGprsConTask+0x478>)
 80075b8:	781b      	ldrb	r3, [r3, #0]
 80075ba:	2b00      	cmp	r3, #0
 80075bc:	d103      	bne.n	80075c6 <vGprsConTask+0x3b6>
 80075be:	4b33      	ldr	r3, [pc, #204]	; (800768c <vGprsConTask+0x47c>)
 80075c0:	781b      	ldrb	r3, [r3, #0]
 80075c2:	2b00      	cmp	r3, #0
 80075c4:	d041      	beq.n	800764a <vGprsConTask+0x43a>

			if ((!LedNoModem_Journal) && (FlagNoModem_Journal == 2)) {
 80075c6:	4b35      	ldr	r3, [pc, #212]	; (800769c <vGprsConTask+0x48c>)
 80075c8:	781b      	ldrb	r3, [r3, #0]
 80075ca:	f083 0301 	eor.w	r3, r3, #1
 80075ce:	b2db      	uxtb	r3, r3
 80075d0:	2b00      	cmp	r3, #0
 80075d2:	d009      	beq.n	80075e8 <vGprsConTask+0x3d8>
 80075d4:	4b32      	ldr	r3, [pc, #200]	; (80076a0 <vGprsConTask+0x490>)
 80075d6:	681b      	ldr	r3, [r3, #0]
 80075d8:	2b02      	cmp	r3, #2
 80075da:	d105      	bne.n	80075e8 <vGprsConTask+0x3d8>

				JrnlWrite(" ");
 80075dc:	4831      	ldr	r0, [pc, #196]	; (80076a4 <vGprsConTask+0x494>)
 80075de:	4b32      	ldr	r3, [pc, #200]	; (80076a8 <vGprsConTask+0x498>)
 80075e0:	4798      	blx	r3
				LedNoModem_Journal = 1;
 80075e2:	4b2e      	ldr	r3, [pc, #184]	; (800769c <vGprsConTask+0x48c>)
 80075e4:	2201      	movs	r2, #1
 80075e6:	701a      	strb	r2, [r3, #0]
			}
			if (FlagNoModem_Journal < 2) {
 80075e8:	4b2d      	ldr	r3, [pc, #180]	; (80076a0 <vGprsConTask+0x490>)
 80075ea:	681b      	ldr	r3, [r3, #0]
 80075ec:	2b01      	cmp	r3, #1
 80075ee:	dc04      	bgt.n	80075fa <vGprsConTask+0x3ea>
				FlagNoModem_Journal++;
 80075f0:	4b2b      	ldr	r3, [pc, #172]	; (80076a0 <vGprsConTask+0x490>)
 80075f2:	681b      	ldr	r3, [r3, #0]
 80075f4:	3301      	adds	r3, #1
 80075f6:	4a2a      	ldr	r2, [pc, #168]	; (80076a0 <vGprsConTask+0x490>)
 80075f8:	6013      	str	r3, [r2, #0]
			}
			GprsIdleMSec = 0;
 80075fa:	4b20      	ldr	r3, [pc, #128]	; (800767c <vGprsConTask+0x46c>)
 80075fc:	2200      	movs	r2, #0
 80075fe:	601a      	str	r2, [r3, #0]
			LedNoModem = 0;
 8007600:	4b25      	ldr	r3, [pc, #148]	; (8007698 <vGprsConTask+0x488>)
 8007602:	2200      	movs	r2, #0
 8007604:	701a      	strb	r2, [r3, #0]
			LedReg = 0;
 8007606:	4b1f      	ldr	r3, [pc, #124]	; (8007684 <vGprsConTask+0x474>)
 8007608:	2200      	movs	r2, #0
 800760a:	701a      	strb	r2, [r3, #0]
			LedSIM = 0;
 800760c:	4b1e      	ldr	r3, [pc, #120]	; (8007688 <vGprsConTask+0x478>)
 800760e:	2200      	movs	r2, #0
 8007610:	701a      	strb	r2, [r3, #0]
			LedAPN = 0;
 8007612:	4b1e      	ldr	r3, [pc, #120]	; (800768c <vGprsConTask+0x47c>)
 8007614:	2200      	movs	r2, #0
 8007616:	701a      	strb	r2, [r3, #0]

			RAM.CSQ = 0;
 8007618:	4b24      	ldr	r3, [pc, #144]	; (80076ac <vGprsConTask+0x49c>)
 800761a:	2200      	movs	r2, #0
 800761c:	f883 203e 	strb.w	r2, [r3, #62]	; 0x3e
 8007620:	2200      	movs	r2, #0
 8007622:	f883 203f 	strb.w	r2, [r3, #63]	; 0x3f

			if (!restart) {
 8007626:	4b22      	ldr	r3, [pc, #136]	; (80076b0 <vGprsConTask+0x4a0>)
 8007628:	781b      	ldrb	r3, [r3, #0]
 800762a:	f083 0301 	eor.w	r3, r3, #1
 800762e:	b2db      	uxtb	r3, r3
 8007630:	2b00      	cmp	r3, #0
 8007632:	d007      	beq.n	8007644 <vGprsConTask+0x434>
				MODEM_DISABLE
 8007634:	2101      	movs	r1, #1
 8007636:	480f      	ldr	r0, [pc, #60]	; (8007674 <vGprsConTask+0x464>)
 8007638:	4b0f      	ldr	r3, [pc, #60]	; (8007678 <vGprsConTask+0x468>)
 800763a:	4798      	blx	r3
				;
				restart = 1;
 800763c:	4b1c      	ldr	r3, [pc, #112]	; (80076b0 <vGprsConTask+0x4a0>)
 800763e:	2201      	movs	r2, #1
 8007640:	701a      	strb	r2, [r3, #0]
 8007642:	e002      	b.n	800764a <vGprsConTask+0x43a>
			} else {
				restart = 0;
 8007644:	4b1a      	ldr	r3, [pc, #104]	; (80076b0 <vGprsConTask+0x4a0>)
 8007646:	2200      	movs	r2, #0
 8007648:	701a      	strb	r2, [r3, #0]

			//vTaskDelay(15000); //15
			//break; // try to Init modem again
		}

		vTaskDelay(1000);
 800764a:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800764e:	4b03      	ldr	r3, [pc, #12]	; (800765c <vGprsConTask+0x44c>)
 8007650:	4798      	blx	r3
		GprsConnectionsAttempt++;
 8007652:	e5e0      	b.n	8007216 <vGprsConTask+0x6>
	}
}
 8007654:	bf00      	nop
 8007656:	bf00      	nop
 8007658:	200092ec 	.word	0x200092ec
 800765c:	08001529 	.word	0x08001529
 8007660:	0800c8f5 	.word	0x0800c8f5
 8007664:	08014dc4 	.word	0x08014dc4
 8007668:	0800bfed 	.word	0x0800bfed
 800766c:	20008468 	.word	0x20008468
 8007670:	08014dd0 	.word	0x08014dd0
 8007674:	40010c00 	.word	0x40010c00
 8007678:	08002f6d 	.word	0x08002f6d
 800767c:	200086dc 	.word	0x200086dc
 8007680:	200072b5 	.word	0x200072b5
 8007684:	200072b4 	.word	0x200072b4
 8007688:	200072b9 	.word	0x200072b9
 800768c:	200072ba 	.word	0x200072ba
 8007690:	200071a0 	.word	0x200071a0
 8007694:	0800c0fd 	.word	0x0800c0fd
 8007698:	200072b8 	.word	0x200072b8
 800769c:	200092f8 	.word	0x200092f8
 80076a0:	200071b0 	.word	0x200071b0
 80076a4:	08014de0 	.word	0x08014de0
 80076a8:	0800edb5 	.word	0x0800edb5
 80076ac:	2000745c 	.word	0x2000745c
 80076b0:	200071ac 	.word	0x200071ac

080076b4 <vLedTask>:
#include "rtclock.h"
#include "board.h"
bool LedReg, LedConnect, LedReceive, LedSend;
bool LedNoModem, LedSIM, LedAPN;

void vLedTask(void *pvParameters) {
 80076b4:	b580      	push	{r7, lr}
 80076b6:	b084      	sub	sp, #16
 80076b8:	af00      	add	r7, sp, #0
 80076ba:	6078      	str	r0, [r7, #4]
	volatile int heapSize = 0;
 80076bc:	2300      	movs	r3, #0
 80076be:	60fb      	str	r3, [r7, #12]
	while (1) {
		//IWDG_SetReload(10000); 
		IWDG_ReloadCounter();
 80076c0:	4b76      	ldr	r3, [pc, #472]	; (800789c <vLedTask+0x1e8>)
 80076c2:	4798      	blx	r3

		heapSize = xPortGetFreeHeapSize();
 80076c4:	4b76      	ldr	r3, [pc, #472]	; (80078a0 <vLedTask+0x1ec>)
 80076c6:	4798      	blx	r3
 80076c8:	4603      	mov	r3, r0
 80076ca:	60fb      	str	r3, [r7, #12]
		heapSize += 0;
 80076cc:	68fb      	ldr	r3, [r7, #12]
 80076ce:	60fb      	str	r3, [r7, #12]
		GPIO_SetBits(GPIO_LEDWORK, LEDWORK);
 80076d0:	2180      	movs	r1, #128	; 0x80
 80076d2:	4874      	ldr	r0, [pc, #464]	; (80078a4 <vLedTask+0x1f0>)
 80076d4:	4b74      	ldr	r3, [pc, #464]	; (80078a8 <vLedTask+0x1f4>)
 80076d6:	4798      	blx	r3

		if ((ResetTime)/*&&(!LedConnect)*/) {
 80076d8:	4b74      	ldr	r3, [pc, #464]	; (80078ac <vLedTask+0x1f8>)
 80076da:	781b      	ldrb	r3, [r3, #0]
 80076dc:	2b00      	cmp	r3, #0
 80076de:	d027      	beq.n	8007730 <vLedTask+0x7c>
			if (manualwork == 1) {
 80076e0:	4b73      	ldr	r3, [pc, #460]	; (80078b0 <vLedTask+0x1fc>)
 80076e2:	681b      	ldr	r3, [r3, #0]
 80076e4:	2b01      	cmp	r3, #1
 80076e6:	d10e      	bne.n	8007706 <vLedTask+0x52>
				GPIO_SetBits(GPIO_LEDWORK, LEDWORK);
 80076e8:	2180      	movs	r1, #128	; 0x80
 80076ea:	486e      	ldr	r0, [pc, #440]	; (80078a4 <vLedTask+0x1f0>)
 80076ec:	4b6e      	ldr	r3, [pc, #440]	; (80078a8 <vLedTask+0x1f4>)
 80076ee:	4798      	blx	r3
				vTaskDelay(100);
 80076f0:	2064      	movs	r0, #100	; 0x64
 80076f2:	4b70      	ldr	r3, [pc, #448]	; (80078b4 <vLedTask+0x200>)
 80076f4:	4798      	blx	r3
				GPIO_ResetBits(GPIO_LEDWORK, LEDWORK);
 80076f6:	2180      	movs	r1, #128	; 0x80
 80076f8:	486a      	ldr	r0, [pc, #424]	; (80078a4 <vLedTask+0x1f0>)
 80076fa:	4b6f      	ldr	r3, [pc, #444]	; (80078b8 <vLedTask+0x204>)
 80076fc:	4798      	blx	r3
				vTaskDelay(300);
 80076fe:	f44f 7096 	mov.w	r0, #300	; 0x12c
 8007702:	4b6c      	ldr	r3, [pc, #432]	; (80078b4 <vLedTask+0x200>)
 8007704:	4798      	blx	r3
			}
			if (manualwork == 0) {
 8007706:	4b6a      	ldr	r3, [pc, #424]	; (80078b0 <vLedTask+0x1fc>)
 8007708:	681b      	ldr	r3, [r3, #0]
 800770a:	2b00      	cmp	r3, #0
 800770c:	d11c      	bne.n	8007748 <vLedTask+0x94>
				GPIO_SetBits(GPIO_LEDWORK, LEDWORK);
 800770e:	2180      	movs	r1, #128	; 0x80
 8007710:	4864      	ldr	r0, [pc, #400]	; (80078a4 <vLedTask+0x1f0>)
 8007712:	4b65      	ldr	r3, [pc, #404]	; (80078a8 <vLedTask+0x1f4>)
 8007714:	4798      	blx	r3
				vTaskDelay(2000);
 8007716:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 800771a:	4b66      	ldr	r3, [pc, #408]	; (80078b4 <vLedTask+0x200>)
 800771c:	4798      	blx	r3
				GPIO_ResetBits(GPIO_LEDWORK, LEDWORK);
 800771e:	2180      	movs	r1, #128	; 0x80
 8007720:	4860      	ldr	r0, [pc, #384]	; (80078a4 <vLedTask+0x1f0>)
 8007722:	4b65      	ldr	r3, [pc, #404]	; (80078b8 <vLedTask+0x204>)
 8007724:	4798      	blx	r3
				vTaskDelay(2000);
 8007726:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 800772a:	4b62      	ldr	r3, [pc, #392]	; (80078b4 <vLedTask+0x200>)
 800772c:	4798      	blx	r3
 800772e:	e00b      	b.n	8007748 <vLedTask+0x94>
			}

		} else /*if (!LedConnect)*/
		{
			vTaskDelay(1000);
 8007730:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8007734:	4b5f      	ldr	r3, [pc, #380]	; (80078b4 <vLedTask+0x200>)
 8007736:	4798      	blx	r3
			GPIO_ResetBits(GPIO_LEDWORK, LEDWORK);
 8007738:	2180      	movs	r1, #128	; 0x80
 800773a:	485a      	ldr	r0, [pc, #360]	; (80078a4 <vLedTask+0x1f0>)
 800773c:	4b5e      	ldr	r3, [pc, #376]	; (80078b8 <vLedTask+0x204>)
 800773e:	4798      	blx	r3
			vTaskDelay(3000);
 8007740:	f640 30b8 	movw	r0, #3000	; 0xbb8
 8007744:	4b5b      	ldr	r3, [pc, #364]	; (80078b4 <vLedTask+0x200>)
 8007746:	4798      	blx	r3

		}
		if (LedReg) {
 8007748:	4b5c      	ldr	r3, [pc, #368]	; (80078bc <vLedTask+0x208>)
 800774a:	781b      	ldrb	r3, [r3, #0]
 800774c:	2b00      	cmp	r3, #0
 800774e:	d019      	beq.n	8007784 <vLedTask+0xd0>
			GPIO_SetBits(GPIO_LED, LEDRED);
 8007750:	2108      	movs	r1, #8
 8007752:	485b      	ldr	r0, [pc, #364]	; (80078c0 <vLedTask+0x20c>)
 8007754:	4b54      	ldr	r3, [pc, #336]	; (80078a8 <vLedTask+0x1f4>)
 8007756:	4798      	blx	r3
			GPIO_ResetBits(GPIO_LED, LEDGREEN);
 8007758:	2104      	movs	r1, #4
 800775a:	4859      	ldr	r0, [pc, #356]	; (80078c0 <vLedTask+0x20c>)
 800775c:	4b56      	ldr	r3, [pc, #344]	; (80078b8 <vLedTask+0x204>)
 800775e:	4798      	blx	r3
			GPIO_ResetBits(GPIO_LEDWORK, LEDWORK); //   4.49.0
 8007760:	2180      	movs	r1, #128	; 0x80
 8007762:	4850      	ldr	r0, [pc, #320]	; (80078a4 <vLedTask+0x1f0>)
 8007764:	4b54      	ldr	r3, [pc, #336]	; (80078b8 <vLedTask+0x204>)
 8007766:	4798      	blx	r3
			vTaskDelay(100);
 8007768:	2064      	movs	r0, #100	; 0x64
 800776a:	4b52      	ldr	r3, [pc, #328]	; (80078b4 <vLedTask+0x200>)
 800776c:	4798      	blx	r3
			GPIO_SetBits(GPIO_LED, LEDGREEN);
 800776e:	2104      	movs	r1, #4
 8007770:	4853      	ldr	r0, [pc, #332]	; (80078c0 <vLedTask+0x20c>)
 8007772:	4b4d      	ldr	r3, [pc, #308]	; (80078a8 <vLedTask+0x1f4>)
 8007774:	4798      	blx	r3
			GPIO_SetBits(GPIO_LEDWORK, LEDWORK); //   4.49.0
 8007776:	2180      	movs	r1, #128	; 0x80
 8007778:	484a      	ldr	r0, [pc, #296]	; (80078a4 <vLedTask+0x1f0>)
 800777a:	4b4b      	ldr	r3, [pc, #300]	; (80078a8 <vLedTask+0x1f4>)
 800777c:	4798      	blx	r3
			vTaskDelay(100);
 800777e:	2064      	movs	r0, #100	; 0x64
 8007780:	4b4c      	ldr	r3, [pc, #304]	; (80078b4 <vLedTask+0x200>)
 8007782:	4798      	blx	r3
		}

		if (LedConnect) {
 8007784:	4b4f      	ldr	r3, [pc, #316]	; (80078c4 <vLedTask+0x210>)
 8007786:	781b      	ldrb	r3, [r3, #0]
 8007788:	2b00      	cmp	r3, #0
 800778a:	d042      	beq.n	8007812 <vLedTask+0x15e>
			if (LedSend) {
 800778c:	4b4e      	ldr	r3, [pc, #312]	; (80078c8 <vLedTask+0x214>)
 800778e:	781b      	ldrb	r3, [r3, #0]
 8007790:	2b00      	cmp	r3, #0
 8007792:	d01a      	beq.n	80077ca <vLedTask+0x116>

				GPIO_ResetBits(GPIO_LED, LEDRED);
 8007794:	2108      	movs	r1, #8
 8007796:	484a      	ldr	r0, [pc, #296]	; (80078c0 <vLedTask+0x20c>)
 8007798:	4b47      	ldr	r3, [pc, #284]	; (80078b8 <vLedTask+0x204>)
 800779a:	4798      	blx	r3
				GPIO_SetBits(GPIO_LED, LEDGREEN);
 800779c:	2104      	movs	r1, #4
 800779e:	4848      	ldr	r0, [pc, #288]	; (80078c0 <vLedTask+0x20c>)
 80077a0:	4b41      	ldr	r3, [pc, #260]	; (80078a8 <vLedTask+0x1f4>)
 80077a2:	4798      	blx	r3
				vTaskDelay(150);
 80077a4:	2096      	movs	r0, #150	; 0x96
 80077a6:	4b43      	ldr	r3, [pc, #268]	; (80078b4 <vLedTask+0x200>)
 80077a8:	4798      	blx	r3
				GPIO_ResetBits(GPIO_LED, LEDGREEN);
 80077aa:	2104      	movs	r1, #4
 80077ac:	4844      	ldr	r0, [pc, #272]	; (80078c0 <vLedTask+0x20c>)
 80077ae:	4b42      	ldr	r3, [pc, #264]	; (80078b8 <vLedTask+0x204>)
 80077b0:	4798      	blx	r3
				GPIO_SetBits(GPIO_LED, LEDRED);
 80077b2:	2108      	movs	r1, #8
 80077b4:	4842      	ldr	r0, [pc, #264]	; (80078c0 <vLedTask+0x20c>)
 80077b6:	4b3c      	ldr	r3, [pc, #240]	; (80078a8 <vLedTask+0x1f4>)
 80077b8:	4798      	blx	r3
				GPIO_ResetBits(GPIO_LEDWORK, LEDWORK);
 80077ba:	2180      	movs	r1, #128	; 0x80
 80077bc:	4839      	ldr	r0, [pc, #228]	; (80078a4 <vLedTask+0x1f0>)
 80077be:	4b3e      	ldr	r3, [pc, #248]	; (80078b8 <vLedTask+0x204>)
 80077c0:	4798      	blx	r3
				LedSend = 0;
 80077c2:	4b41      	ldr	r3, [pc, #260]	; (80078c8 <vLedTask+0x214>)
 80077c4:	2200      	movs	r2, #0
 80077c6:	701a      	strb	r2, [r3, #0]
 80077c8:	e77a      	b.n	80076c0 <vLedTask+0xc>
			} else if (LedReceive) {
 80077ca:	4b40      	ldr	r3, [pc, #256]	; (80078cc <vLedTask+0x218>)
 80077cc:	781b      	ldrb	r3, [r3, #0]
 80077ce:	2b00      	cmp	r3, #0
 80077d0:	d016      	beq.n	8007800 <vLedTask+0x14c>
				GPIO_ResetBits(GPIO_LED, LEDGREEN);
 80077d2:	2104      	movs	r1, #4
 80077d4:	483a      	ldr	r0, [pc, #232]	; (80078c0 <vLedTask+0x20c>)
 80077d6:	4b38      	ldr	r3, [pc, #224]	; (80078b8 <vLedTask+0x204>)
 80077d8:	4798      	blx	r3
				GPIO_SetBits(GPIO_LED, LEDRED);
 80077da:	2108      	movs	r1, #8
 80077dc:	4838      	ldr	r0, [pc, #224]	; (80078c0 <vLedTask+0x20c>)
 80077de:	4b32      	ldr	r3, [pc, #200]	; (80078a8 <vLedTask+0x1f4>)
 80077e0:	4798      	blx	r3
				vTaskDelay(150);
 80077e2:	2096      	movs	r0, #150	; 0x96
 80077e4:	4b33      	ldr	r3, [pc, #204]	; (80078b4 <vLedTask+0x200>)
 80077e6:	4798      	blx	r3
				GPIO_ResetBits(GPIO_LED, LEDGREEN);
 80077e8:	2104      	movs	r1, #4
 80077ea:	4835      	ldr	r0, [pc, #212]	; (80078c0 <vLedTask+0x20c>)
 80077ec:	4b32      	ldr	r3, [pc, #200]	; (80078b8 <vLedTask+0x204>)
 80077ee:	4798      	blx	r3
				GPIO_SetBits(GPIO_LED, LEDRED);
 80077f0:	2108      	movs	r1, #8
 80077f2:	4833      	ldr	r0, [pc, #204]	; (80078c0 <vLedTask+0x20c>)
 80077f4:	4b2c      	ldr	r3, [pc, #176]	; (80078a8 <vLedTask+0x1f4>)
 80077f6:	4798      	blx	r3
				LedReceive = 0;
 80077f8:	4b34      	ldr	r3, [pc, #208]	; (80078cc <vLedTask+0x218>)
 80077fa:	2200      	movs	r2, #0
 80077fc:	701a      	strb	r2, [r3, #0]
 80077fe:	e75f      	b.n	80076c0 <vLedTask+0xc>

			} else {
				GPIO_ResetBits(GPIO_LED, LEDGREEN);
 8007800:	2104      	movs	r1, #4
 8007802:	482f      	ldr	r0, [pc, #188]	; (80078c0 <vLedTask+0x20c>)
 8007804:	4b2c      	ldr	r3, [pc, #176]	; (80078b8 <vLedTask+0x204>)
 8007806:	4798      	blx	r3
				GPIO_SetBits(GPIO_LED, LEDRED);
 8007808:	2108      	movs	r1, #8
 800780a:	482d      	ldr	r0, [pc, #180]	; (80078c0 <vLedTask+0x20c>)
 800780c:	4b26      	ldr	r3, [pc, #152]	; (80078a8 <vLedTask+0x1f4>)
 800780e:	4798      	blx	r3
 8007810:	e756      	b.n	80076c0 <vLedTask+0xc>

		}

		else {

			if (LedNoModem) {
 8007812:	4b2f      	ldr	r3, [pc, #188]	; (80078d0 <vLedTask+0x21c>)
 8007814:	781b      	ldrb	r3, [r3, #0]
 8007816:	2b00      	cmp	r3, #0
 8007818:	d00f      	beq.n	800783a <vLedTask+0x186>
				GPIO_SetBits(GPIO_LED, LEDRED);
 800781a:	2108      	movs	r1, #8
 800781c:	4828      	ldr	r0, [pc, #160]	; (80078c0 <vLedTask+0x20c>)
 800781e:	4b22      	ldr	r3, [pc, #136]	; (80078a8 <vLedTask+0x1f4>)
 8007820:	4798      	blx	r3
				vTaskDelay(1000);
 8007822:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8007826:	4b23      	ldr	r3, [pc, #140]	; (80078b4 <vLedTask+0x200>)
 8007828:	4798      	blx	r3
				GPIO_ResetBits(GPIO_LED, LEDRED);
 800782a:	2108      	movs	r1, #8
 800782c:	4824      	ldr	r0, [pc, #144]	; (80078c0 <vLedTask+0x20c>)
 800782e:	4b22      	ldr	r3, [pc, #136]	; (80078b8 <vLedTask+0x204>)
 8007830:	4798      	blx	r3
				vTaskDelay(250);
 8007832:	20fa      	movs	r0, #250	; 0xfa
 8007834:	4b1f      	ldr	r3, [pc, #124]	; (80078b4 <vLedTask+0x200>)
 8007836:	4798      	blx	r3
 8007838:	e742      	b.n	80076c0 <vLedTask+0xc>
			} else if (LedSIM) {
 800783a:	4b26      	ldr	r3, [pc, #152]	; (80078d4 <vLedTask+0x220>)
 800783c:	781b      	ldrb	r3, [r3, #0]
 800783e:	2b00      	cmp	r3, #0
 8007840:	d00f      	beq.n	8007862 <vLedTask+0x1ae>
				GPIO_SetBits(GPIO_LED, LEDRED);
 8007842:	2108      	movs	r1, #8
 8007844:	481e      	ldr	r0, [pc, #120]	; (80078c0 <vLedTask+0x20c>)
 8007846:	4b18      	ldr	r3, [pc, #96]	; (80078a8 <vLedTask+0x1f4>)
 8007848:	4798      	blx	r3
				vTaskDelay(250);
 800784a:	20fa      	movs	r0, #250	; 0xfa
 800784c:	4b19      	ldr	r3, [pc, #100]	; (80078b4 <vLedTask+0x200>)
 800784e:	4798      	blx	r3
				GPIO_ResetBits(GPIO_LED, LEDRED);
 8007850:	2108      	movs	r1, #8
 8007852:	481b      	ldr	r0, [pc, #108]	; (80078c0 <vLedTask+0x20c>)
 8007854:	4b18      	ldr	r3, [pc, #96]	; (80078b8 <vLedTask+0x204>)
 8007856:	4798      	blx	r3
				vTaskDelay(1000);
 8007858:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800785c:	4b15      	ldr	r3, [pc, #84]	; (80078b4 <vLedTask+0x200>)
 800785e:	4798      	blx	r3
 8007860:	e72e      	b.n	80076c0 <vLedTask+0xc>
			} else if (LedAPN) {
 8007862:	4b1d      	ldr	r3, [pc, #116]	; (80078d8 <vLedTask+0x224>)
 8007864:	781b      	ldrb	r3, [r3, #0]
 8007866:	2b00      	cmp	r3, #0
 8007868:	d00e      	beq.n	8007888 <vLedTask+0x1d4>
				GPIO_SetBits(GPIO_LED, LEDRED);
 800786a:	2108      	movs	r1, #8
 800786c:	4814      	ldr	r0, [pc, #80]	; (80078c0 <vLedTask+0x20c>)
 800786e:	4b0e      	ldr	r3, [pc, #56]	; (80078a8 <vLedTask+0x1f4>)
 8007870:	4798      	blx	r3
				vTaskDelay(250);
 8007872:	20fa      	movs	r0, #250	; 0xfa
 8007874:	4b0f      	ldr	r3, [pc, #60]	; (80078b4 <vLedTask+0x200>)
 8007876:	4798      	blx	r3
				GPIO_ResetBits(GPIO_LED, LEDRED);
 8007878:	2108      	movs	r1, #8
 800787a:	4811      	ldr	r0, [pc, #68]	; (80078c0 <vLedTask+0x20c>)
 800787c:	4b0e      	ldr	r3, [pc, #56]	; (80078b8 <vLedTask+0x204>)
 800787e:	4798      	blx	r3
				vTaskDelay(250);
 8007880:	20fa      	movs	r0, #250	; 0xfa
 8007882:	4b0c      	ldr	r3, [pc, #48]	; (80078b4 <vLedTask+0x200>)
 8007884:	4798      	blx	r3
 8007886:	e71b      	b.n	80076c0 <vLedTask+0xc>

			} else {
				GPIO_SetBits(GPIO_LED, LEDRED);
 8007888:	2108      	movs	r1, #8
 800788a:	480d      	ldr	r0, [pc, #52]	; (80078c0 <vLedTask+0x20c>)
 800788c:	4b06      	ldr	r3, [pc, #24]	; (80078a8 <vLedTask+0x1f4>)
 800788e:	4798      	blx	r3
				GPIO_SetBits(GPIO_LED, LEDGREEN);
 8007890:	2104      	movs	r1, #4
 8007892:	480b      	ldr	r0, [pc, #44]	; (80078c0 <vLedTask+0x20c>)
 8007894:	4b04      	ldr	r3, [pc, #16]	; (80078a8 <vLedTask+0x1f4>)
 8007896:	4798      	blx	r3
		IWDG_ReloadCounter();
 8007898:	e712      	b.n	80076c0 <vLedTask+0xc>
 800789a:	bf00      	nop
 800789c:	08003709 	.word	0x08003709
 80078a0:	080028b5 	.word	0x080028b5
 80078a4:	40010800 	.word	0x40010800
 80078a8:	08002f6d 	.word	0x08002f6d
 80078ac:	200072bc 	.word	0x200072bc
 80078b0:	20009430 	.word	0x20009430
 80078b4:	08001529 	.word	0x08001529
 80078b8:	08002f89 	.word	0x08002f89
 80078bc:	200072b4 	.word	0x200072b4
 80078c0:	40011000 	.word	0x40011000
 80078c4:	200072b5 	.word	0x200072b5
 80078c8:	200072b7 	.word	0x200072b7
 80078cc:	200072b6 	.word	0x200072b6
 80078d0:	200072b8 	.word	0x200072b8
 80078d4:	200072b9 	.word	0x200072b9
 80078d8:	200072ba 	.word	0x200072ba

080078dc <vClockTask>:
extern int counttick;
bool JrnlTime;
bool ResetTime;
bool ResetTimeEnd;

void vClockTask(void *pvParameters) {
 80078dc:	b580      	push	{r7, lr}
 80078de:	b084      	sub	sp, #16
 80078e0:	af00      	add	r7, sp, #0
 80078e2:	6078      	str	r0, [r7, #4]
	volatile int heapSize = 0;
 80078e4:	2300      	movs	r3, #0
 80078e6:	60fb      	str	r3, [r7, #12]
	heapSize = xPortGetFreeHeapSize();
 80078e8:	4b14      	ldr	r3, [pc, #80]	; (800793c <vClockTask+0x60>)
 80078ea:	4798      	blx	r3
 80078ec:	4603      	mov	r3, r0
 80078ee:	60fb      	str	r3, [r7, #12]
	heapSize += 0;
 80078f0:	68fb      	ldr	r3, [r7, #12]
 80078f2:	60fb      	str	r3, [r7, #12]
	while (1) {
		if (counttick >= 1000) {
 80078f4:	4b12      	ldr	r3, [pc, #72]	; (8007940 <vClockTask+0x64>)
 80078f6:	681b      	ldr	r3, [r3, #0]
 80078f8:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 80078fc:	db08      	blt.n	8007910 <vClockTask+0x34>
			BKP_WriteBackupRegister(BKP_DR7, 3);
 80078fe:	2103      	movs	r1, #3
 8007900:	201c      	movs	r0, #28
 8007902:	4b10      	ldr	r3, [pc, #64]	; (8007944 <vClockTask+0x68>)
 8007904:	4798      	blx	r3
			UpdateTime();
 8007906:	4b10      	ldr	r3, [pc, #64]	; (8007948 <vClockTask+0x6c>)
 8007908:	4798      	blx	r3
			counttick = 0;
 800790a:	4b0d      	ldr	r3, [pc, #52]	; (8007940 <vClockTask+0x64>)
 800790c:	2200      	movs	r2, #0
 800790e:	601a      	str	r2, [r3, #0]
		}


		if ((JrnlTime)&&(!ResetTimeEnd))
 8007910:	4b0e      	ldr	r3, [pc, #56]	; (800794c <vClockTask+0x70>)
 8007912:	781b      	ldrb	r3, [r3, #0]
 8007914:	2b00      	cmp	r3, #0
 8007916:	d00c      	beq.n	8007932 <vClockTask+0x56>
 8007918:	4b0d      	ldr	r3, [pc, #52]	; (8007950 <vClockTask+0x74>)
 800791a:	781b      	ldrb	r3, [r3, #0]
 800791c:	f083 0301 	eor.w	r3, r3, #1
 8007920:	b2db      	uxtb	r3, r3
 8007922:	2b00      	cmp	r3, #0
 8007924:	d005      	beq.n	8007932 <vClockTask+0x56>
			{
				JrnlWrite(" ");
 8007926:	480b      	ldr	r0, [pc, #44]	; (8007954 <vClockTask+0x78>)
 8007928:	4b0b      	ldr	r3, [pc, #44]	; (8007958 <vClockTask+0x7c>)
 800792a:	4798      	blx	r3
				JrnlTime = 0;
 800792c:	4b07      	ldr	r3, [pc, #28]	; (800794c <vClockTask+0x70>)
 800792e:	2200      	movs	r2, #0
 8007930:	701a      	strb	r2, [r3, #0]

			}


		vTaskDelay(700);
 8007932:	f44f 702f 	mov.w	r0, #700	; 0x2bc
 8007936:	4b09      	ldr	r3, [pc, #36]	; (800795c <vClockTask+0x80>)
 8007938:	4798      	blx	r3
		if (counttick >= 1000) {
 800793a:	e7db      	b.n	80078f4 <vClockTask+0x18>
 800793c:	080028b5 	.word	0x080028b5
 8007940:	2000719c 	.word	0x2000719c
 8007944:	08003621 	.word	0x08003621
 8007948:	08005059 	.word	0x08005059
 800794c:	200072bb 	.word	0x200072bb
 8007950:	200072bd 	.word	0x200072bd
 8007954:	08014df0 	.word	0x08014df0
 8007958:	0800edb5 	.word	0x0800edb5
 800795c:	08001529 	.word	0x08001529

08007960 <vLogicaTask>:
#include "gprscon.h"
#include "stm32f10x_flash.h"
#include "usermemory.h"
#include "rtclock.h"

void vLogicaTask(void *pvParameters) {
 8007960:	b580      	push	{r7, lr}
 8007962:	b084      	sub	sp, #16
 8007964:	af00      	add	r7, sp, #0
 8007966:	6078      	str	r0, [r7, #4]

	int heapSize = 0;
 8007968:	2300      	movs	r3, #0
 800796a:	60fb      	str	r3, [r7, #12]
	rtcInit();
 800796c:	4b0a      	ldr	r3, [pc, #40]	; (8007998 <vLogicaTask+0x38>)
 800796e:	4798      	blx	r3
	vTaskDelay(500);
 8007970:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8007974:	4b09      	ldr	r3, [pc, #36]	; (800799c <vLogicaTask+0x3c>)
 8007976:	4798      	blx	r3
	while (1) {
		heapSize = xPortGetFreeHeapSize();
 8007978:	4b09      	ldr	r3, [pc, #36]	; (80079a0 <vLogicaTask+0x40>)
 800797a:	4798      	blx	r3
 800797c:	4603      	mov	r3, r0
 800797e:	60fb      	str	r3, [r7, #12]
		heapSize += 0;
		BKP_WriteBackupRegister(BKP_DR7, 50);
 8007980:	2132      	movs	r1, #50	; 0x32
 8007982:	201c      	movs	r0, #28
 8007984:	4b07      	ldr	r3, [pc, #28]	; (80079a4 <vLogicaTask+0x44>)
 8007986:	4798      	blx	r3
		//JrnlClear();
		IWDG_ReloadCounter();
 8007988:	4b07      	ldr	r3, [pc, #28]	; (80079a8 <vLogicaTask+0x48>)
 800798a:	4798      	blx	r3
		DoProgram();
 800798c:	4b07      	ldr	r3, [pc, #28]	; (80079ac <vLogicaTask+0x4c>)
 800798e:	4798      	blx	r3
		vTaskDelay(20);
 8007990:	2014      	movs	r0, #20
 8007992:	4b02      	ldr	r3, [pc, #8]	; (800799c <vLogicaTask+0x3c>)
 8007994:	4798      	blx	r3
		heapSize = xPortGetFreeHeapSize();
 8007996:	e7ef      	b.n	8007978 <vLogicaTask+0x18>
 8007998:	08005229 	.word	0x08005229
 800799c:	08001529 	.word	0x08001529
 80079a0:	080028b5 	.word	0x080028b5
 80079a4:	08003621 	.word	0x08003621
 80079a8:	08003709 	.word	0x08003709
 80079ac:	080100c9 	.word	0x080100c9

080079b0 <ClearUIPData>:

bool AskConunter();
bool AskConunter318();

void ClearUIPData()
{
 80079b0:	b480      	push	{r7}
 80079b2:	b083      	sub	sp, #12
 80079b4:	af00      	add	r7, sp, #0
	for(int i=0;i<16;i++)
 80079b6:	2300      	movs	r3, #0
 80079b8:	607b      	str	r3, [r7, #4]
 80079ba:	e01e      	b.n	80079fa <ClearUIPData+0x4a>
	{
		RAM.UIPparams[i] = 0;
 80079bc:	4a13      	ldr	r2, [pc, #76]	; (8007a0c <ClearUIPData+0x5c>)
 80079be:	687b      	ldr	r3, [r7, #4]
 80079c0:	330c      	adds	r3, #12
 80079c2:	005b      	lsls	r3, r3, #1
 80079c4:	4413      	add	r3, r2
 80079c6:	2200      	movs	r2, #0
 80079c8:	711a      	strb	r2, [r3, #4]
 80079ca:	2200      	movs	r2, #0
 80079cc:	715a      	strb	r2, [r3, #5]
		for(int j=0;j<16;j++)
 80079ce:	2300      	movs	r3, #0
 80079d0:	603b      	str	r3, [r7, #0]
 80079d2:	e00c      	b.n	80079ee <ClearUIPData+0x3e>
			{
				RAM.strings[i][j] = 0;
 80079d4:	4a0d      	ldr	r2, [pc, #52]	; (8007a0c <ClearUIPData+0x5c>)
 80079d6:	687b      	ldr	r3, [r7, #4]
 80079d8:	011b      	lsls	r3, r3, #4
 80079da:	441a      	add	r2, r3
 80079dc:	683b      	ldr	r3, [r7, #0]
 80079de:	4413      	add	r3, r2
 80079e0:	f503 6382 	add.w	r3, r3, #1040	; 0x410
 80079e4:	2200      	movs	r2, #0
 80079e6:	701a      	strb	r2, [r3, #0]
		for(int j=0;j<16;j++)
 80079e8:	683b      	ldr	r3, [r7, #0]
 80079ea:	3301      	adds	r3, #1
 80079ec:	603b      	str	r3, [r7, #0]
 80079ee:	683b      	ldr	r3, [r7, #0]
 80079f0:	2b0f      	cmp	r3, #15
 80079f2:	ddef      	ble.n	80079d4 <ClearUIPData+0x24>
	for(int i=0;i<16;i++)
 80079f4:	687b      	ldr	r3, [r7, #4]
 80079f6:	3301      	adds	r3, #1
 80079f8:	607b      	str	r3, [r7, #4]
 80079fa:	687b      	ldr	r3, [r7, #4]
 80079fc:	2b0f      	cmp	r3, #15
 80079fe:	dddd      	ble.n	80079bc <ClearUIPData+0xc>
			}
	}
}
 8007a00:	bf00      	nop
 8007a02:	bf00      	nop
 8007a04:	370c      	adds	r7, #12
 8007a06:	46bd      	mov	sp, r7
 8007a08:	bc80      	pop	{r7}
 8007a0a:	4770      	bx	lr
 8007a0c:	2000745c 	.word	0x2000745c

08007a10 <new_atof>:
    return (atof(string) / 400) * 65536;
    }


double new_atof(char* s)
{
 8007a10:	b590      	push	{r4, r7, lr}
 8007a12:	b08b      	sub	sp, #44	; 0x2c
 8007a14:	af00      	add	r7, sp, #0
 8007a16:	6078      	str	r0, [r7, #4]
 double sign = 1;
 8007a18:	f04f 0200 	mov.w	r2, #0
 8007a1c:	4b6a      	ldr	r3, [pc, #424]	; (8007bc8 <new_atof+0x1b8>)
 8007a1e:	e9c7 2302 	strd	r2, r3, [r7, #8]
 double val = 0;
 8007a22:	f04f 0200 	mov.w	r2, #0
 8007a26:	f04f 0300 	mov.w	r3, #0
 8007a2a:	e9c7 2308 	strd	r2, r3, [r7, #32]
 int d = 0;
 8007a2e:	2300      	movs	r3, #0
 8007a30:	61fb      	str	r3, [r7, #28]
 if (s) while (((*s<'0' || *s>'9') && *s!='-' && *s!='+' && *s!='.') && *(++s));
 8007a32:	687b      	ldr	r3, [r7, #4]
 8007a34:	2b00      	cmp	r3, #0
 8007a36:	d01c      	beq.n	8007a72 <new_atof+0x62>
 8007a38:	bf00      	nop
 8007a3a:	687b      	ldr	r3, [r7, #4]
 8007a3c:	781b      	ldrb	r3, [r3, #0]
 8007a3e:	2b2f      	cmp	r3, #47	; 0x2f
 8007a40:	d903      	bls.n	8007a4a <new_atof+0x3a>
 8007a42:	687b      	ldr	r3, [r7, #4]
 8007a44:	781b      	ldrb	r3, [r3, #0]
 8007a46:	2b39      	cmp	r3, #57	; 0x39
 8007a48:	d918      	bls.n	8007a7c <new_atof+0x6c>
 8007a4a:	687b      	ldr	r3, [r7, #4]
 8007a4c:	781b      	ldrb	r3, [r3, #0]
 8007a4e:	2b2d      	cmp	r3, #45	; 0x2d
 8007a50:	d014      	beq.n	8007a7c <new_atof+0x6c>
 8007a52:	687b      	ldr	r3, [r7, #4]
 8007a54:	781b      	ldrb	r3, [r3, #0]
 8007a56:	2b2b      	cmp	r3, #43	; 0x2b
 8007a58:	d010      	beq.n	8007a7c <new_atof+0x6c>
 8007a5a:	687b      	ldr	r3, [r7, #4]
 8007a5c:	781b      	ldrb	r3, [r3, #0]
 8007a5e:	2b2e      	cmp	r3, #46	; 0x2e
 8007a60:	d00c      	beq.n	8007a7c <new_atof+0x6c>
 8007a62:	687b      	ldr	r3, [r7, #4]
 8007a64:	3301      	adds	r3, #1
 8007a66:	607b      	str	r3, [r7, #4]
 8007a68:	687b      	ldr	r3, [r7, #4]
 8007a6a:	781b      	ldrb	r3, [r3, #0]
 8007a6c:	2b00      	cmp	r3, #0
 8007a6e:	d1e4      	bne.n	8007a3a <new_atof+0x2a>
 8007a70:	e004      	b.n	8007a7c <new_atof+0x6c>
 else return 0.0;
 8007a72:	f04f 0200 	mov.w	r2, #0
 8007a76:	f04f 0300 	mov.w	r3, #0
 8007a7a:	e09f      	b.n	8007bbc <new_atof+0x1ac>
 sign*=(*s == '-' && ++s) ? -1.0 : ((*s == '+' && ++s),1.0);
 8007a7c:	687b      	ldr	r3, [r7, #4]
 8007a7e:	781b      	ldrb	r3, [r3, #0]
 8007a80:	2b2d      	cmp	r3, #45	; 0x2d
 8007a82:	d105      	bne.n	8007a90 <new_atof+0x80>
 8007a84:	687b      	ldr	r3, [r7, #4]
 8007a86:	3301      	adds	r3, #1
 8007a88:	607b      	str	r3, [r7, #4]
 8007a8a:	687b      	ldr	r3, [r7, #4]
 8007a8c:	2b00      	cmp	r3, #0
 8007a8e:	d10c      	bne.n	8007aaa <new_atof+0x9a>
 8007a90:	687b      	ldr	r3, [r7, #4]
 8007a92:	781b      	ldrb	r3, [r3, #0]
 8007a94:	2b2b      	cmp	r3, #43	; 0x2b
 8007a96:	d104      	bne.n	8007aa2 <new_atof+0x92>
 8007a98:	687b      	ldr	r3, [r7, #4]
 8007a9a:	3301      	adds	r3, #1
 8007a9c:	607b      	str	r3, [r7, #4]
 8007a9e:	687b      	ldr	r3, [r7, #4]
 8007aa0:	2b00      	cmp	r3, #0
 8007aa2:	f04f 0200 	mov.w	r2, #0
 8007aa6:	4b48      	ldr	r3, [pc, #288]	; (8007bc8 <new_atof+0x1b8>)
 8007aa8:	e002      	b.n	8007ab0 <new_atof+0xa0>
 8007aaa:	f04f 0200 	mov.w	r2, #0
 8007aae:	4b47      	ldr	r3, [pc, #284]	; (8007bcc <new_atof+0x1bc>)
 8007ab0:	4c47      	ldr	r4, [pc, #284]	; (8007bd0 <new_atof+0x1c0>)
 8007ab2:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
 8007ab6:	47a0      	blx	r4
 8007ab8:	4602      	mov	r2, r0
 8007aba:	460b      	mov	r3, r1
 8007abc:	e9c7 2302 	strd	r2, r3, [r7, #8]
 while ((*s >= '0' && *s <= '9') || (*s == '.' && d < 1))
 8007ac0:	e043      	b.n	8007b4a <new_atof+0x13a>
 {
   val += *s == '.' ? (++d, 0.0) : d > 0 ? ((++d, val*=10.0), *s-'0') :(val*=10.0, *s-'0');
 8007ac2:	687b      	ldr	r3, [r7, #4]
 8007ac4:	781b      	ldrb	r3, [r3, #0]
 8007ac6:	2b2e      	cmp	r3, #46	; 0x2e
 8007ac8:	d107      	bne.n	8007ada <new_atof+0xca>
 8007aca:	69fb      	ldr	r3, [r7, #28]
 8007acc:	3301      	adds	r3, #1
 8007ace:	61fb      	str	r3, [r7, #28]
 8007ad0:	f04f 0200 	mov.w	r2, #0
 8007ad4:	f04f 0300 	mov.w	r3, #0
 8007ad8:	e02c      	b.n	8007b34 <new_atof+0x124>
 8007ada:	69fb      	ldr	r3, [r7, #28]
 8007adc:	2b00      	cmp	r3, #0
 8007ade:	dd16      	ble.n	8007b0e <new_atof+0xfe>
 8007ae0:	69fb      	ldr	r3, [r7, #28]
 8007ae2:	3301      	adds	r3, #1
 8007ae4:	61fb      	str	r3, [r7, #28]
 8007ae6:	4c3a      	ldr	r4, [pc, #232]	; (8007bd0 <new_atof+0x1c0>)
 8007ae8:	f04f 0200 	mov.w	r2, #0
 8007aec:	4b39      	ldr	r3, [pc, #228]	; (8007bd4 <new_atof+0x1c4>)
 8007aee:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
 8007af2:	47a0      	blx	r4
 8007af4:	4602      	mov	r2, r0
 8007af6:	460b      	mov	r3, r1
 8007af8:	e9c7 2308 	strd	r2, r3, [r7, #32]
 8007afc:	687b      	ldr	r3, [r7, #4]
 8007afe:	781b      	ldrb	r3, [r3, #0]
 8007b00:	3b30      	subs	r3, #48	; 0x30
 8007b02:	4a35      	ldr	r2, [pc, #212]	; (8007bd8 <new_atof+0x1c8>)
 8007b04:	4618      	mov	r0, r3
 8007b06:	4790      	blx	r2
 8007b08:	4602      	mov	r2, r0
 8007b0a:	460b      	mov	r3, r1
 8007b0c:	e012      	b.n	8007b34 <new_atof+0x124>
 8007b0e:	4c30      	ldr	r4, [pc, #192]	; (8007bd0 <new_atof+0x1c0>)
 8007b10:	f04f 0200 	mov.w	r2, #0
 8007b14:	4b2f      	ldr	r3, [pc, #188]	; (8007bd4 <new_atof+0x1c4>)
 8007b16:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
 8007b1a:	47a0      	blx	r4
 8007b1c:	4602      	mov	r2, r0
 8007b1e:	460b      	mov	r3, r1
 8007b20:	e9c7 2308 	strd	r2, r3, [r7, #32]
 8007b24:	687b      	ldr	r3, [r7, #4]
 8007b26:	781b      	ldrb	r3, [r3, #0]
 8007b28:	3b30      	subs	r3, #48	; 0x30
 8007b2a:	4a2b      	ldr	r2, [pc, #172]	; (8007bd8 <new_atof+0x1c8>)
 8007b2c:	4618      	mov	r0, r3
 8007b2e:	4790      	blx	r2
 8007b30:	4602      	mov	r2, r0
 8007b32:	460b      	mov	r3, r1
 8007b34:	4c29      	ldr	r4, [pc, #164]	; (8007bdc <new_atof+0x1cc>)
 8007b36:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
 8007b3a:	47a0      	blx	r4
 8007b3c:	4602      	mov	r2, r0
 8007b3e:	460b      	mov	r3, r1
 8007b40:	e9c7 2308 	strd	r2, r3, [r7, #32]
   ++s;
 8007b44:	687b      	ldr	r3, [r7, #4]
 8007b46:	3301      	adds	r3, #1
 8007b48:	607b      	str	r3, [r7, #4]
 while ((*s >= '0' && *s <= '9') || (*s == '.' && d < 1))
 8007b4a:	687b      	ldr	r3, [r7, #4]
 8007b4c:	781b      	ldrb	r3, [r3, #0]
 8007b4e:	2b2f      	cmp	r3, #47	; 0x2f
 8007b50:	d903      	bls.n	8007b5a <new_atof+0x14a>
 8007b52:	687b      	ldr	r3, [r7, #4]
 8007b54:	781b      	ldrb	r3, [r3, #0]
 8007b56:	2b39      	cmp	r3, #57	; 0x39
 8007b58:	d9b3      	bls.n	8007ac2 <new_atof+0xb2>
 8007b5a:	687b      	ldr	r3, [r7, #4]
 8007b5c:	781b      	ldrb	r3, [r3, #0]
 8007b5e:	2b2e      	cmp	r3, #46	; 0x2e
 8007b60:	d102      	bne.n	8007b68 <new_atof+0x158>
 8007b62:	69fb      	ldr	r3, [r7, #28]
 8007b64:	2b00      	cmp	r3, #0
 8007b66:	ddac      	ble.n	8007ac2 <new_atof+0xb2>
 }
 double den = 1;
 8007b68:	f04f 0200 	mov.w	r2, #0
 8007b6c:	4b16      	ldr	r3, [pc, #88]	; (8007bc8 <new_atof+0x1b8>)
 8007b6e:	e9c7 2304 	strd	r2, r3, [r7, #16]
 if(d > 0) while(--d) den*=10.0;
 8007b72:	69fb      	ldr	r3, [r7, #28]
 8007b74:	2b00      	cmp	r3, #0
 8007b76:	dd11      	ble.n	8007b9c <new_atof+0x18c>
 8007b78:	e00a      	b.n	8007b90 <new_atof+0x180>
 8007b7a:	4c15      	ldr	r4, [pc, #84]	; (8007bd0 <new_atof+0x1c0>)
 8007b7c:	f04f 0200 	mov.w	r2, #0
 8007b80:	4b14      	ldr	r3, [pc, #80]	; (8007bd4 <new_atof+0x1c4>)
 8007b82:	e9d7 0104 	ldrd	r0, r1, [r7, #16]
 8007b86:	47a0      	blx	r4
 8007b88:	4602      	mov	r2, r0
 8007b8a:	460b      	mov	r3, r1
 8007b8c:	e9c7 2304 	strd	r2, r3, [r7, #16]
 8007b90:	69fb      	ldr	r3, [r7, #28]
 8007b92:	3b01      	subs	r3, #1
 8007b94:	61fb      	str	r3, [r7, #28]
 8007b96:	69fb      	ldr	r3, [r7, #28]
 8007b98:	2b00      	cmp	r3, #0
 8007b9a:	d1ee      	bne.n	8007b7a <new_atof+0x16a>
 return (val*sign)/den;
 8007b9c:	4c0c      	ldr	r4, [pc, #48]	; (8007bd0 <new_atof+0x1c0>)
 8007b9e:	e9d7 2302 	ldrd	r2, r3, [r7, #8]
 8007ba2:	e9d7 0108 	ldrd	r0, r1, [r7, #32]
 8007ba6:	47a0      	blx	r4
 8007ba8:	4602      	mov	r2, r0
 8007baa:	460b      	mov	r3, r1
 8007bac:	4610      	mov	r0, r2
 8007bae:	4619      	mov	r1, r3
 8007bb0:	4c0b      	ldr	r4, [pc, #44]	; (8007be0 <new_atof+0x1d0>)
 8007bb2:	e9d7 2304 	ldrd	r2, r3, [r7, #16]
 8007bb6:	47a0      	blx	r4
 8007bb8:	4602      	mov	r2, r0
 8007bba:	460b      	mov	r3, r1
}
 8007bbc:	4610      	mov	r0, r2
 8007bbe:	4619      	mov	r1, r3
 8007bc0:	372c      	adds	r7, #44	; 0x2c
 8007bc2:	46bd      	mov	sp, r7
 8007bc4:	bd90      	pop	{r4, r7, pc}
 8007bc6:	bf00      	nop
 8007bc8:	3ff00000 	.word	0x3ff00000
 8007bcc:	bff00000 	.word	0xbff00000
 8007bd0:	08000791 	.word	0x08000791
 8007bd4:	40240000 	.word	0x40240000
 8007bd8:	080006bd 	.word	0x080006bd
 8007bdc:	08000425 	.word	0x08000425
 8007be0:	080009e5 	.word	0x080009e5
 8007be4:	00000000 	.word	0x00000000

08007be8 <MakeiFixUIP>:

void MakeiFixUIP()
    {
 8007be8:	b598      	push	{r3, r4, r7, lr}
 8007bea:	af00      	add	r7, sp, #0

    RAM.UIPparams[0] = (uint16) (new_atof(&RAM.strings[8][0]) * 65535 / 400);
 8007bec:	48ac      	ldr	r0, [pc, #688]	; (8007ea0 <MakeiFixUIP+0x2b8>)
 8007bee:	4bad      	ldr	r3, [pc, #692]	; (8007ea4 <MakeiFixUIP+0x2bc>)
 8007bf0:	4798      	blx	r3
 8007bf2:	4cad      	ldr	r4, [pc, #692]	; (8007ea8 <MakeiFixUIP+0x2c0>)
 8007bf4:	a3a6      	add	r3, pc, #664	; (adr r3, 8007e90 <MakeiFixUIP+0x2a8>)
 8007bf6:	e9d3 2300 	ldrd	r2, r3, [r3]
 8007bfa:	47a0      	blx	r4
 8007bfc:	4602      	mov	r2, r0
 8007bfe:	460b      	mov	r3, r1
 8007c00:	4610      	mov	r0, r2
 8007c02:	4619      	mov	r1, r3
 8007c04:	4ca9      	ldr	r4, [pc, #676]	; (8007eac <MakeiFixUIP+0x2c4>)
 8007c06:	f04f 0200 	mov.w	r2, #0
 8007c0a:	4ba9      	ldr	r3, [pc, #676]	; (8007eb0 <MakeiFixUIP+0x2c8>)
 8007c0c:	47a0      	blx	r4
 8007c0e:	4602      	mov	r2, r0
 8007c10:	460b      	mov	r3, r1
 8007c12:	4ca8      	ldr	r4, [pc, #672]	; (8007eb4 <MakeiFixUIP+0x2cc>)
 8007c14:	4610      	mov	r0, r2
 8007c16:	4619      	mov	r1, r3
 8007c18:	47a0      	blx	r4
 8007c1a:	4603      	mov	r3, r0
 8007c1c:	b29a      	uxth	r2, r3
 8007c1e:	4ba6      	ldr	r3, [pc, #664]	; (8007eb8 <MakeiFixUIP+0x2d0>)
 8007c20:	839a      	strh	r2, [r3, #28]
    RAM.UIPparams[1] = (uint16) (new_atof(&RAM.strings[9][0]) * 65535 / 400);
 8007c22:	48a6      	ldr	r0, [pc, #664]	; (8007ebc <MakeiFixUIP+0x2d4>)
 8007c24:	4b9f      	ldr	r3, [pc, #636]	; (8007ea4 <MakeiFixUIP+0x2bc>)
 8007c26:	4798      	blx	r3
 8007c28:	4c9f      	ldr	r4, [pc, #636]	; (8007ea8 <MakeiFixUIP+0x2c0>)
 8007c2a:	a399      	add	r3, pc, #612	; (adr r3, 8007e90 <MakeiFixUIP+0x2a8>)
 8007c2c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8007c30:	47a0      	blx	r4
 8007c32:	4602      	mov	r2, r0
 8007c34:	460b      	mov	r3, r1
 8007c36:	4610      	mov	r0, r2
 8007c38:	4619      	mov	r1, r3
 8007c3a:	4c9c      	ldr	r4, [pc, #624]	; (8007eac <MakeiFixUIP+0x2c4>)
 8007c3c:	f04f 0200 	mov.w	r2, #0
 8007c40:	4b9b      	ldr	r3, [pc, #620]	; (8007eb0 <MakeiFixUIP+0x2c8>)
 8007c42:	47a0      	blx	r4
 8007c44:	4602      	mov	r2, r0
 8007c46:	460b      	mov	r3, r1
 8007c48:	4c9a      	ldr	r4, [pc, #616]	; (8007eb4 <MakeiFixUIP+0x2cc>)
 8007c4a:	4610      	mov	r0, r2
 8007c4c:	4619      	mov	r1, r3
 8007c4e:	47a0      	blx	r4
 8007c50:	4603      	mov	r3, r0
 8007c52:	b29a      	uxth	r2, r3
 8007c54:	4b98      	ldr	r3, [pc, #608]	; (8007eb8 <MakeiFixUIP+0x2d0>)
 8007c56:	83da      	strh	r2, [r3, #30]
    RAM.UIPparams[2] = (uint16) (new_atof(&RAM.strings[10][0]) * 65535 / 400);
 8007c58:	4899      	ldr	r0, [pc, #612]	; (8007ec0 <MakeiFixUIP+0x2d8>)
 8007c5a:	4b92      	ldr	r3, [pc, #584]	; (8007ea4 <MakeiFixUIP+0x2bc>)
 8007c5c:	4798      	blx	r3
 8007c5e:	4c92      	ldr	r4, [pc, #584]	; (8007ea8 <MakeiFixUIP+0x2c0>)
 8007c60:	a38b      	add	r3, pc, #556	; (adr r3, 8007e90 <MakeiFixUIP+0x2a8>)
 8007c62:	e9d3 2300 	ldrd	r2, r3, [r3]
 8007c66:	47a0      	blx	r4
 8007c68:	4602      	mov	r2, r0
 8007c6a:	460b      	mov	r3, r1
 8007c6c:	4610      	mov	r0, r2
 8007c6e:	4619      	mov	r1, r3
 8007c70:	4c8e      	ldr	r4, [pc, #568]	; (8007eac <MakeiFixUIP+0x2c4>)
 8007c72:	f04f 0200 	mov.w	r2, #0
 8007c76:	4b8e      	ldr	r3, [pc, #568]	; (8007eb0 <MakeiFixUIP+0x2c8>)
 8007c78:	47a0      	blx	r4
 8007c7a:	4602      	mov	r2, r0
 8007c7c:	460b      	mov	r3, r1
 8007c7e:	4c8d      	ldr	r4, [pc, #564]	; (8007eb4 <MakeiFixUIP+0x2cc>)
 8007c80:	4610      	mov	r0, r2
 8007c82:	4619      	mov	r1, r3
 8007c84:	47a0      	blx	r4
 8007c86:	4603      	mov	r3, r0
 8007c88:	b29a      	uxth	r2, r3
 8007c8a:	4b8b      	ldr	r3, [pc, #556]	; (8007eb8 <MakeiFixUIP+0x2d0>)
 8007c8c:	841a      	strh	r2, [r3, #32]

    //current
    RAM.UIPparams[3] = (uint16) (new_atof(&RAM.strings[11][0]) * 65535 / 100);
 8007c8e:	488d      	ldr	r0, [pc, #564]	; (8007ec4 <MakeiFixUIP+0x2dc>)
 8007c90:	4b84      	ldr	r3, [pc, #528]	; (8007ea4 <MakeiFixUIP+0x2bc>)
 8007c92:	4798      	blx	r3
 8007c94:	4c84      	ldr	r4, [pc, #528]	; (8007ea8 <MakeiFixUIP+0x2c0>)
 8007c96:	a37e      	add	r3, pc, #504	; (adr r3, 8007e90 <MakeiFixUIP+0x2a8>)
 8007c98:	e9d3 2300 	ldrd	r2, r3, [r3]
 8007c9c:	47a0      	blx	r4
 8007c9e:	4602      	mov	r2, r0
 8007ca0:	460b      	mov	r3, r1
 8007ca2:	4610      	mov	r0, r2
 8007ca4:	4619      	mov	r1, r3
 8007ca6:	4c81      	ldr	r4, [pc, #516]	; (8007eac <MakeiFixUIP+0x2c4>)
 8007ca8:	f04f 0200 	mov.w	r2, #0
 8007cac:	4b86      	ldr	r3, [pc, #536]	; (8007ec8 <MakeiFixUIP+0x2e0>)
 8007cae:	47a0      	blx	r4
 8007cb0:	4602      	mov	r2, r0
 8007cb2:	460b      	mov	r3, r1
 8007cb4:	4c7f      	ldr	r4, [pc, #508]	; (8007eb4 <MakeiFixUIP+0x2cc>)
 8007cb6:	4610      	mov	r0, r2
 8007cb8:	4619      	mov	r1, r3
 8007cba:	47a0      	blx	r4
 8007cbc:	4603      	mov	r3, r0
 8007cbe:	b29a      	uxth	r2, r3
 8007cc0:	4b7d      	ldr	r3, [pc, #500]	; (8007eb8 <MakeiFixUIP+0x2d0>)
 8007cc2:	845a      	strh	r2, [r3, #34]	; 0x22
    RAM.UIPparams[4] = (uint16) (new_atof(&RAM.strings[12][0]) * 65535 / 100);
 8007cc4:	4881      	ldr	r0, [pc, #516]	; (8007ecc <MakeiFixUIP+0x2e4>)
 8007cc6:	4b77      	ldr	r3, [pc, #476]	; (8007ea4 <MakeiFixUIP+0x2bc>)
 8007cc8:	4798      	blx	r3
 8007cca:	4c77      	ldr	r4, [pc, #476]	; (8007ea8 <MakeiFixUIP+0x2c0>)
 8007ccc:	a370      	add	r3, pc, #448	; (adr r3, 8007e90 <MakeiFixUIP+0x2a8>)
 8007cce:	e9d3 2300 	ldrd	r2, r3, [r3]
 8007cd2:	47a0      	blx	r4
 8007cd4:	4602      	mov	r2, r0
 8007cd6:	460b      	mov	r3, r1
 8007cd8:	4610      	mov	r0, r2
 8007cda:	4619      	mov	r1, r3
 8007cdc:	4c73      	ldr	r4, [pc, #460]	; (8007eac <MakeiFixUIP+0x2c4>)
 8007cde:	f04f 0200 	mov.w	r2, #0
 8007ce2:	4b79      	ldr	r3, [pc, #484]	; (8007ec8 <MakeiFixUIP+0x2e0>)
 8007ce4:	47a0      	blx	r4
 8007ce6:	4602      	mov	r2, r0
 8007ce8:	460b      	mov	r3, r1
 8007cea:	4c72      	ldr	r4, [pc, #456]	; (8007eb4 <MakeiFixUIP+0x2cc>)
 8007cec:	4610      	mov	r0, r2
 8007cee:	4619      	mov	r1, r3
 8007cf0:	47a0      	blx	r4
 8007cf2:	4603      	mov	r3, r0
 8007cf4:	b29a      	uxth	r2, r3
 8007cf6:	4b70      	ldr	r3, [pc, #448]	; (8007eb8 <MakeiFixUIP+0x2d0>)
 8007cf8:	849a      	strh	r2, [r3, #36]	; 0x24
    RAM.UIPparams[5] = (uint16) (new_atof(&RAM.strings[13][0]) * 65535 / 100);
 8007cfa:	4875      	ldr	r0, [pc, #468]	; (8007ed0 <MakeiFixUIP+0x2e8>)
 8007cfc:	4b69      	ldr	r3, [pc, #420]	; (8007ea4 <MakeiFixUIP+0x2bc>)
 8007cfe:	4798      	blx	r3
 8007d00:	4c69      	ldr	r4, [pc, #420]	; (8007ea8 <MakeiFixUIP+0x2c0>)
 8007d02:	a363      	add	r3, pc, #396	; (adr r3, 8007e90 <MakeiFixUIP+0x2a8>)
 8007d04:	e9d3 2300 	ldrd	r2, r3, [r3]
 8007d08:	47a0      	blx	r4
 8007d0a:	4602      	mov	r2, r0
 8007d0c:	460b      	mov	r3, r1
 8007d0e:	4610      	mov	r0, r2
 8007d10:	4619      	mov	r1, r3
 8007d12:	4c66      	ldr	r4, [pc, #408]	; (8007eac <MakeiFixUIP+0x2c4>)
 8007d14:	f04f 0200 	mov.w	r2, #0
 8007d18:	4b6b      	ldr	r3, [pc, #428]	; (8007ec8 <MakeiFixUIP+0x2e0>)
 8007d1a:	47a0      	blx	r4
 8007d1c:	4602      	mov	r2, r0
 8007d1e:	460b      	mov	r3, r1
 8007d20:	4c64      	ldr	r4, [pc, #400]	; (8007eb4 <MakeiFixUIP+0x2cc>)
 8007d22:	4610      	mov	r0, r2
 8007d24:	4619      	mov	r1, r3
 8007d26:	47a0      	blx	r4
 8007d28:	4603      	mov	r3, r0
 8007d2a:	b29a      	uxth	r2, r3
 8007d2c:	4b62      	ldr	r3, [pc, #392]	; (8007eb8 <MakeiFixUIP+0x2d0>)
 8007d2e:	84da      	strh	r2, [r3, #38]	; 0x26
    //Power
    RAM.UIPparams[6] = (uint16) (new_atof(&RAM.strings[5][0]) * 65535 / 40);
 8007d30:	4868      	ldr	r0, [pc, #416]	; (8007ed4 <MakeiFixUIP+0x2ec>)
 8007d32:	4b5c      	ldr	r3, [pc, #368]	; (8007ea4 <MakeiFixUIP+0x2bc>)
 8007d34:	4798      	blx	r3
 8007d36:	4c5c      	ldr	r4, [pc, #368]	; (8007ea8 <MakeiFixUIP+0x2c0>)
 8007d38:	a355      	add	r3, pc, #340	; (adr r3, 8007e90 <MakeiFixUIP+0x2a8>)
 8007d3a:	e9d3 2300 	ldrd	r2, r3, [r3]
 8007d3e:	47a0      	blx	r4
 8007d40:	4602      	mov	r2, r0
 8007d42:	460b      	mov	r3, r1
 8007d44:	4610      	mov	r0, r2
 8007d46:	4619      	mov	r1, r3
 8007d48:	4c58      	ldr	r4, [pc, #352]	; (8007eac <MakeiFixUIP+0x2c4>)
 8007d4a:	f04f 0200 	mov.w	r2, #0
 8007d4e:	4b62      	ldr	r3, [pc, #392]	; (8007ed8 <MakeiFixUIP+0x2f0>)
 8007d50:	47a0      	blx	r4
 8007d52:	4602      	mov	r2, r0
 8007d54:	460b      	mov	r3, r1
 8007d56:	4c57      	ldr	r4, [pc, #348]	; (8007eb4 <MakeiFixUIP+0x2cc>)
 8007d58:	4610      	mov	r0, r2
 8007d5a:	4619      	mov	r1, r3
 8007d5c:	47a0      	blx	r4
 8007d5e:	4603      	mov	r3, r0
 8007d60:	b29a      	uxth	r2, r3
 8007d62:	4b55      	ldr	r3, [pc, #340]	; (8007eb8 <MakeiFixUIP+0x2d0>)
 8007d64:	851a      	strh	r2, [r3, #40]	; 0x28
    RAM.UIPparams[7] = (uint16) (new_atof(&RAM.strings[6][0]) * 65535 / 40);
 8007d66:	485d      	ldr	r0, [pc, #372]	; (8007edc <MakeiFixUIP+0x2f4>)
 8007d68:	4b4e      	ldr	r3, [pc, #312]	; (8007ea4 <MakeiFixUIP+0x2bc>)
 8007d6a:	4798      	blx	r3
 8007d6c:	4c4e      	ldr	r4, [pc, #312]	; (8007ea8 <MakeiFixUIP+0x2c0>)
 8007d6e:	a348      	add	r3, pc, #288	; (adr r3, 8007e90 <MakeiFixUIP+0x2a8>)
 8007d70:	e9d3 2300 	ldrd	r2, r3, [r3]
 8007d74:	47a0      	blx	r4
 8007d76:	4602      	mov	r2, r0
 8007d78:	460b      	mov	r3, r1
 8007d7a:	4610      	mov	r0, r2
 8007d7c:	4619      	mov	r1, r3
 8007d7e:	4c4b      	ldr	r4, [pc, #300]	; (8007eac <MakeiFixUIP+0x2c4>)
 8007d80:	f04f 0200 	mov.w	r2, #0
 8007d84:	4b54      	ldr	r3, [pc, #336]	; (8007ed8 <MakeiFixUIP+0x2f0>)
 8007d86:	47a0      	blx	r4
 8007d88:	4602      	mov	r2, r0
 8007d8a:	460b      	mov	r3, r1
 8007d8c:	4c49      	ldr	r4, [pc, #292]	; (8007eb4 <MakeiFixUIP+0x2cc>)
 8007d8e:	4610      	mov	r0, r2
 8007d90:	4619      	mov	r1, r3
 8007d92:	47a0      	blx	r4
 8007d94:	4603      	mov	r3, r0
 8007d96:	b29a      	uxth	r2, r3
 8007d98:	4b47      	ldr	r3, [pc, #284]	; (8007eb8 <MakeiFixUIP+0x2d0>)
 8007d9a:	855a      	strh	r2, [r3, #42]	; 0x2a
    RAM.UIPparams[8] = (uint16) (new_atof(&RAM.strings[7][0]) * 65535 / 40);
 8007d9c:	4850      	ldr	r0, [pc, #320]	; (8007ee0 <MakeiFixUIP+0x2f8>)
 8007d9e:	4b41      	ldr	r3, [pc, #260]	; (8007ea4 <MakeiFixUIP+0x2bc>)
 8007da0:	4798      	blx	r3
 8007da2:	4c41      	ldr	r4, [pc, #260]	; (8007ea8 <MakeiFixUIP+0x2c0>)
 8007da4:	a33a      	add	r3, pc, #232	; (adr r3, 8007e90 <MakeiFixUIP+0x2a8>)
 8007da6:	e9d3 2300 	ldrd	r2, r3, [r3]
 8007daa:	47a0      	blx	r4
 8007dac:	4602      	mov	r2, r0
 8007dae:	460b      	mov	r3, r1
 8007db0:	4610      	mov	r0, r2
 8007db2:	4619      	mov	r1, r3
 8007db4:	4c3d      	ldr	r4, [pc, #244]	; (8007eac <MakeiFixUIP+0x2c4>)
 8007db6:	f04f 0200 	mov.w	r2, #0
 8007dba:	4b47      	ldr	r3, [pc, #284]	; (8007ed8 <MakeiFixUIP+0x2f0>)
 8007dbc:	47a0      	blx	r4
 8007dbe:	4602      	mov	r2, r0
 8007dc0:	460b      	mov	r3, r1
 8007dc2:	4c3c      	ldr	r4, [pc, #240]	; (8007eb4 <MakeiFixUIP+0x2cc>)
 8007dc4:	4610      	mov	r0, r2
 8007dc6:	4619      	mov	r1, r3
 8007dc8:	47a0      	blx	r4
 8007dca:	4603      	mov	r3, r0
 8007dcc:	b29a      	uxth	r2, r3
 8007dce:	4b3a      	ldr	r3, [pc, #232]	; (8007eb8 <MakeiFixUIP+0x2d0>)
 8007dd0:	859a      	strh	r2, [r3, #44]	; 0x2c

    RAM.UIPparams[9] = ((uint32)(new_atof(&RAM.strings[4][0])*4294967296/999999))&0xFFFF;
 8007dd2:	4844      	ldr	r0, [pc, #272]	; (8007ee4 <MakeiFixUIP+0x2fc>)
 8007dd4:	4b33      	ldr	r3, [pc, #204]	; (8007ea4 <MakeiFixUIP+0x2bc>)
 8007dd6:	4798      	blx	r3
 8007dd8:	4c33      	ldr	r4, [pc, #204]	; (8007ea8 <MakeiFixUIP+0x2c0>)
 8007dda:	f04f 0200 	mov.w	r2, #0
 8007dde:	4b42      	ldr	r3, [pc, #264]	; (8007ee8 <MakeiFixUIP+0x300>)
 8007de0:	47a0      	blx	r4
 8007de2:	4602      	mov	r2, r0
 8007de4:	460b      	mov	r3, r1
 8007de6:	4610      	mov	r0, r2
 8007de8:	4619      	mov	r1, r3
 8007dea:	4c30      	ldr	r4, [pc, #192]	; (8007eac <MakeiFixUIP+0x2c4>)
 8007dec:	a32a      	add	r3, pc, #168	; (adr r3, 8007e98 <MakeiFixUIP+0x2b0>)
 8007dee:	e9d3 2300 	ldrd	r2, r3, [r3]
 8007df2:	47a0      	blx	r4
 8007df4:	4602      	mov	r2, r0
 8007df6:	460b      	mov	r3, r1
 8007df8:	4c2e      	ldr	r4, [pc, #184]	; (8007eb4 <MakeiFixUIP+0x2cc>)
 8007dfa:	4610      	mov	r0, r2
 8007dfc:	4619      	mov	r1, r3
 8007dfe:	47a0      	blx	r4
 8007e00:	4603      	mov	r3, r0
 8007e02:	b29a      	uxth	r2, r3
 8007e04:	4b2c      	ldr	r3, [pc, #176]	; (8007eb8 <MakeiFixUIP+0x2d0>)
 8007e06:	85da      	strh	r2, [r3, #46]	; 0x2e
    RAM.UIPparams[10] = (((uint32)(new_atof(&RAM.strings[4][0])*4294967296/999999))>>16)&0xFFFF;
 8007e08:	4836      	ldr	r0, [pc, #216]	; (8007ee4 <MakeiFixUIP+0x2fc>)
 8007e0a:	4b26      	ldr	r3, [pc, #152]	; (8007ea4 <MakeiFixUIP+0x2bc>)
 8007e0c:	4798      	blx	r3
 8007e0e:	4c26      	ldr	r4, [pc, #152]	; (8007ea8 <MakeiFixUIP+0x2c0>)
 8007e10:	f04f 0200 	mov.w	r2, #0
 8007e14:	4b34      	ldr	r3, [pc, #208]	; (8007ee8 <MakeiFixUIP+0x300>)
 8007e16:	47a0      	blx	r4
 8007e18:	4602      	mov	r2, r0
 8007e1a:	460b      	mov	r3, r1
 8007e1c:	4610      	mov	r0, r2
 8007e1e:	4619      	mov	r1, r3
 8007e20:	4c22      	ldr	r4, [pc, #136]	; (8007eac <MakeiFixUIP+0x2c4>)
 8007e22:	a31d      	add	r3, pc, #116	; (adr r3, 8007e98 <MakeiFixUIP+0x2b0>)
 8007e24:	e9d3 2300 	ldrd	r2, r3, [r3]
 8007e28:	47a0      	blx	r4
 8007e2a:	4602      	mov	r2, r0
 8007e2c:	460b      	mov	r3, r1
 8007e2e:	4c21      	ldr	r4, [pc, #132]	; (8007eb4 <MakeiFixUIP+0x2cc>)
 8007e30:	4610      	mov	r0, r2
 8007e32:	4619      	mov	r1, r3
 8007e34:	47a0      	blx	r4
 8007e36:	4603      	mov	r3, r0
 8007e38:	0c1b      	lsrs	r3, r3, #16
 8007e3a:	b29a      	uxth	r2, r3
 8007e3c:	4b1e      	ldr	r3, [pc, #120]	; (8007eb8 <MakeiFixUIP+0x2d0>)
 8007e3e:	861a      	strh	r2, [r3, #48]	; 0x30

    RAM.UIPparams[11] = ((uint32)(new_atof(&RAM.strings[15][0])*4294967296/999999))&0xFFFF;
 8007e40:	482a      	ldr	r0, [pc, #168]	; (8007eec <MakeiFixUIP+0x304>)
 8007e42:	4b18      	ldr	r3, [pc, #96]	; (8007ea4 <MakeiFixUIP+0x2bc>)
 8007e44:	4798      	blx	r3
 8007e46:	4c18      	ldr	r4, [pc, #96]	; (8007ea8 <MakeiFixUIP+0x2c0>)
 8007e48:	f04f 0200 	mov.w	r2, #0
 8007e4c:	4b26      	ldr	r3, [pc, #152]	; (8007ee8 <MakeiFixUIP+0x300>)
 8007e4e:	47a0      	blx	r4
 8007e50:	4602      	mov	r2, r0
 8007e52:	460b      	mov	r3, r1
 8007e54:	4610      	mov	r0, r2
 8007e56:	4619      	mov	r1, r3
 8007e58:	4c14      	ldr	r4, [pc, #80]	; (8007eac <MakeiFixUIP+0x2c4>)
 8007e5a:	a30f      	add	r3, pc, #60	; (adr r3, 8007e98 <MakeiFixUIP+0x2b0>)
 8007e5c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8007e60:	47a0      	blx	r4
 8007e62:	4602      	mov	r2, r0
 8007e64:	460b      	mov	r3, r1
 8007e66:	4c13      	ldr	r4, [pc, #76]	; (8007eb4 <MakeiFixUIP+0x2cc>)
 8007e68:	4610      	mov	r0, r2
 8007e6a:	4619      	mov	r1, r3
 8007e6c:	47a0      	blx	r4
 8007e6e:	4603      	mov	r3, r0
 8007e70:	b29a      	uxth	r2, r3
 8007e72:	4b11      	ldr	r3, [pc, #68]	; (8007eb8 <MakeiFixUIP+0x2d0>)
 8007e74:	865a      	strh	r2, [r3, #50]	; 0x32
    RAM.UIPparams[12] = (((uint32)(new_atof(&RAM.strings[15][0])*4294967296/999999))>>16)&0xFFFF;
 8007e76:	481d      	ldr	r0, [pc, #116]	; (8007eec <MakeiFixUIP+0x304>)
 8007e78:	4b0a      	ldr	r3, [pc, #40]	; (8007ea4 <MakeiFixUIP+0x2bc>)
 8007e7a:	4798      	blx	r3
 8007e7c:	4c0a      	ldr	r4, [pc, #40]	; (8007ea8 <MakeiFixUIP+0x2c0>)
 8007e7e:	f04f 0200 	mov.w	r2, #0
 8007e82:	4b19      	ldr	r3, [pc, #100]	; (8007ee8 <MakeiFixUIP+0x300>)
 8007e84:	47a0      	blx	r4
 8007e86:	4602      	mov	r2, r0
 8007e88:	460b      	mov	r3, r1
 8007e8a:	4610      	mov	r0, r2
 8007e8c:	e030      	b.n	8007ef0 <MakeiFixUIP+0x308>
 8007e8e:	bf00      	nop
 8007e90:	00000000 	.word	0x00000000
 8007e94:	40efffe0 	.word	0x40efffe0
 8007e98:	00000000 	.word	0x00000000
 8007e9c:	412e847e 	.word	0x412e847e
 8007ea0:	200078ec 	.word	0x200078ec
 8007ea4:	08007a11 	.word	0x08007a11
 8007ea8:	08000791 	.word	0x08000791
 8007eac:	080009e5 	.word	0x080009e5
 8007eb0:	40790000 	.word	0x40790000
 8007eb4:	08000cc5 	.word	0x08000cc5
 8007eb8:	2000745c 	.word	0x2000745c
 8007ebc:	200078fc 	.word	0x200078fc
 8007ec0:	2000790c 	.word	0x2000790c
 8007ec4:	2000791c 	.word	0x2000791c
 8007ec8:	40590000 	.word	0x40590000
 8007ecc:	2000792c 	.word	0x2000792c
 8007ed0:	2000793c 	.word	0x2000793c
 8007ed4:	200078bc 	.word	0x200078bc
 8007ed8:	40440000 	.word	0x40440000
 8007edc:	200078cc 	.word	0x200078cc
 8007ee0:	200078dc 	.word	0x200078dc
 8007ee4:	200078ac 	.word	0x200078ac
 8007ee8:	41f00000 	.word	0x41f00000
 8007eec:	2000795c 	.word	0x2000795c
 8007ef0:	4619      	mov	r1, r3
 8007ef2:	4c0b      	ldr	r4, [pc, #44]	; (8007f20 <MakeiFixUIP+0x338>)
 8007ef4:	a308      	add	r3, pc, #32	; (adr r3, 8007f18 <MakeiFixUIP+0x330>)
 8007ef6:	e9d3 2300 	ldrd	r2, r3, [r3]
 8007efa:	47a0      	blx	r4
 8007efc:	4602      	mov	r2, r0
 8007efe:	460b      	mov	r3, r1
 8007f00:	4c08      	ldr	r4, [pc, #32]	; (8007f24 <MakeiFixUIP+0x33c>)
 8007f02:	4610      	mov	r0, r2
 8007f04:	4619      	mov	r1, r3
 8007f06:	47a0      	blx	r4
 8007f08:	4603      	mov	r3, r0
 8007f0a:	0c1b      	lsrs	r3, r3, #16
 8007f0c:	b29a      	uxth	r2, r3
 8007f0e:	4b06      	ldr	r3, [pc, #24]	; (8007f28 <MakeiFixUIP+0x340>)
 8007f10:	869a      	strh	r2, [r3, #52]	; 0x34
//
//   // RAM.UIPparams[15] = ((uint32)(new_atof(&RAM.strings[17][0])*65535/2000));
//    RAM.UIPparams[15] = ((uint32)(new_atof(&RAM.strings[17][0])*4294967296/999999))&0xFFFF;
//    RAM.UIPparams[16] = (((uint32)(new_atof(&RAM.strings[17][0])*4294967296/999999))>>16)&0xFFFF;

    }
 8007f12:	bf00      	nop
 8007f14:	bd98      	pop	{r3, r4, r7, pc}
 8007f16:	bf00      	nop
 8007f18:	00000000 	.word	0x00000000
 8007f1c:	412e847e 	.word	0x412e847e
 8007f20:	080009e5 	.word	0x080009e5
 8007f24:	08000cc5 	.word	0x08000cc5
 8007f28:	2000745c 	.word	0x2000745c

08007f2c <processBuffer7to8>:
		USART_SendData (uart4, buffer++);
	}
}*/

void processBuffer7to8(char* buf,uint16 size)
{
 8007f2c:	b480      	push	{r7}
 8007f2e:	b085      	sub	sp, #20
 8007f30:	af00      	add	r7, sp, #0
 8007f32:	6078      	str	r0, [r7, #4]
 8007f34:	460b      	mov	r3, r1
 8007f36:	807b      	strh	r3, [r7, #2]
	for(int i=0;i<size;i++)
 8007f38:	2300      	movs	r3, #0
 8007f3a:	60fb      	str	r3, [r7, #12]
 8007f3c:	e00d      	b.n	8007f5a <processBuffer7to8+0x2e>
	{
		buf[i]=buf[i]&0x7F;
 8007f3e:	68fb      	ldr	r3, [r7, #12]
 8007f40:	687a      	ldr	r2, [r7, #4]
 8007f42:	4413      	add	r3, r2
 8007f44:	781a      	ldrb	r2, [r3, #0]
 8007f46:	68fb      	ldr	r3, [r7, #12]
 8007f48:	6879      	ldr	r1, [r7, #4]
 8007f4a:	440b      	add	r3, r1
 8007f4c:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 8007f50:	b2d2      	uxtb	r2, r2
 8007f52:	701a      	strb	r2, [r3, #0]
	for(int i=0;i<size;i++)
 8007f54:	68fb      	ldr	r3, [r7, #12]
 8007f56:	3301      	adds	r3, #1
 8007f58:	60fb      	str	r3, [r7, #12]
 8007f5a:	887b      	ldrh	r3, [r7, #2]
 8007f5c:	68fa      	ldr	r2, [r7, #12]
 8007f5e:	429a      	cmp	r2, r3
 8007f60:	dbed      	blt.n	8007f3e <processBuffer7to8+0x12>
	}
}
 8007f62:	bf00      	nop
 8007f64:	bf00      	nop
 8007f66:	3714      	adds	r7, #20
 8007f68:	46bd      	mov	sp, r7
 8007f6a:	bc80      	pop	{r7}
 8007f6c:	4770      	bx	lr

08007f6e <processBuffer8to7>:

void processBuffer8to7(char* buf,uint16 size)
{
 8007f6e:	b480      	push	{r7}
 8007f70:	b085      	sub	sp, #20
 8007f72:	af00      	add	r7, sp, #0
 8007f74:	6078      	str	r0, [r7, #4]
 8007f76:	460b      	mov	r3, r1
 8007f78:	807b      	strh	r3, [r7, #2]
	int count=0;
 8007f7a:	2300      	movs	r3, #0
 8007f7c:	60bb      	str	r3, [r7, #8]
	for(int i=0;i<size;i++)
 8007f7e:	2300      	movs	r3, #0
 8007f80:	60fb      	str	r3, [r7, #12]
 8007f82:	e05d      	b.n	8008040 <processBuffer8to7+0xd2>
	{
		count = 0;
 8007f84:	2300      	movs	r3, #0
 8007f86:	60bb      	str	r3, [r7, #8]
		count += (buf[i]&0x01) ? 1 : 0;
 8007f88:	68fb      	ldr	r3, [r7, #12]
 8007f8a:	687a      	ldr	r2, [r7, #4]
 8007f8c:	4413      	add	r3, r2
 8007f8e:	781b      	ldrb	r3, [r3, #0]
 8007f90:	f003 0301 	and.w	r3, r3, #1
 8007f94:	68ba      	ldr	r2, [r7, #8]
 8007f96:	4413      	add	r3, r2
 8007f98:	60bb      	str	r3, [r7, #8]
		count += (buf[i]&0x02) ? 1 : 0;
 8007f9a:	68fb      	ldr	r3, [r7, #12]
 8007f9c:	687a      	ldr	r2, [r7, #4]
 8007f9e:	4413      	add	r3, r2
 8007fa0:	781b      	ldrb	r3, [r3, #0]
 8007fa2:	105b      	asrs	r3, r3, #1
 8007fa4:	f003 0301 	and.w	r3, r3, #1
 8007fa8:	68ba      	ldr	r2, [r7, #8]
 8007faa:	4413      	add	r3, r2
 8007fac:	60bb      	str	r3, [r7, #8]
		count += (buf[i]&0x04) ? 1 : 0;
 8007fae:	68fb      	ldr	r3, [r7, #12]
 8007fb0:	687a      	ldr	r2, [r7, #4]
 8007fb2:	4413      	add	r3, r2
 8007fb4:	781b      	ldrb	r3, [r3, #0]
 8007fb6:	109b      	asrs	r3, r3, #2
 8007fb8:	f003 0301 	and.w	r3, r3, #1
 8007fbc:	68ba      	ldr	r2, [r7, #8]
 8007fbe:	4413      	add	r3, r2
 8007fc0:	60bb      	str	r3, [r7, #8]
		count += (buf[i]&0x08) ? 1 : 0;
 8007fc2:	68fb      	ldr	r3, [r7, #12]
 8007fc4:	687a      	ldr	r2, [r7, #4]
 8007fc6:	4413      	add	r3, r2
 8007fc8:	781b      	ldrb	r3, [r3, #0]
 8007fca:	10db      	asrs	r3, r3, #3
 8007fcc:	f003 0301 	and.w	r3, r3, #1
 8007fd0:	68ba      	ldr	r2, [r7, #8]
 8007fd2:	4413      	add	r3, r2
 8007fd4:	60bb      	str	r3, [r7, #8]
		count += (buf[i]&0x10) ? 1 : 0;
 8007fd6:	68fb      	ldr	r3, [r7, #12]
 8007fd8:	687a      	ldr	r2, [r7, #4]
 8007fda:	4413      	add	r3, r2
 8007fdc:	781b      	ldrb	r3, [r3, #0]
 8007fde:	111b      	asrs	r3, r3, #4
 8007fe0:	f003 0301 	and.w	r3, r3, #1
 8007fe4:	68ba      	ldr	r2, [r7, #8]
 8007fe6:	4413      	add	r3, r2
 8007fe8:	60bb      	str	r3, [r7, #8]
		count += (buf[i]&0x20) ? 1 : 0;
 8007fea:	68fb      	ldr	r3, [r7, #12]
 8007fec:	687a      	ldr	r2, [r7, #4]
 8007fee:	4413      	add	r3, r2
 8007ff0:	781b      	ldrb	r3, [r3, #0]
 8007ff2:	115b      	asrs	r3, r3, #5
 8007ff4:	f003 0301 	and.w	r3, r3, #1
 8007ff8:	68ba      	ldr	r2, [r7, #8]
 8007ffa:	4413      	add	r3, r2
 8007ffc:	60bb      	str	r3, [r7, #8]
		count += (buf[i]&0x40) ? 1 : 0;
 8007ffe:	68fb      	ldr	r3, [r7, #12]
 8008000:	687a      	ldr	r2, [r7, #4]
 8008002:	4413      	add	r3, r2
 8008004:	781b      	ldrb	r3, [r3, #0]
 8008006:	119b      	asrs	r3, r3, #6
 8008008:	f003 0301 	and.w	r3, r3, #1
 800800c:	68ba      	ldr	r2, [r7, #8]
 800800e:	4413      	add	r3, r2
 8008010:	60bb      	str	r3, [r7, #8]

		buf[i]=buf[i]|(count%2)<<7;
 8008012:	68fb      	ldr	r3, [r7, #12]
 8008014:	687a      	ldr	r2, [r7, #4]
 8008016:	4413      	add	r3, r2
 8008018:	781b      	ldrb	r3, [r3, #0]
 800801a:	b25a      	sxtb	r2, r3
 800801c:	68bb      	ldr	r3, [r7, #8]
 800801e:	2b00      	cmp	r3, #0
 8008020:	f003 0301 	and.w	r3, r3, #1
 8008024:	bfb8      	it	lt
 8008026:	425b      	neglt	r3, r3
 8008028:	01db      	lsls	r3, r3, #7
 800802a:	b25b      	sxtb	r3, r3
 800802c:	4313      	orrs	r3, r2
 800802e:	b259      	sxtb	r1, r3
 8008030:	68fb      	ldr	r3, [r7, #12]
 8008032:	687a      	ldr	r2, [r7, #4]
 8008034:	4413      	add	r3, r2
 8008036:	b2ca      	uxtb	r2, r1
 8008038:	701a      	strb	r2, [r3, #0]
	for(int i=0;i<size;i++)
 800803a:	68fb      	ldr	r3, [r7, #12]
 800803c:	3301      	adds	r3, #1
 800803e:	60fb      	str	r3, [r7, #12]
 8008040:	887b      	ldrh	r3, [r7, #2]
 8008042:	68fa      	ldr	r2, [r7, #12]
 8008044:	429a      	cmp	r2, r3
 8008046:	db9d      	blt.n	8007f84 <processBuffer8to7+0x16>
	}
}
 8008048:	bf00      	nop
 800804a:	bf00      	nop
 800804c:	3714      	adds	r7, #20
 800804e:	46bd      	mov	sp, r7
 8008050:	bc80      	pop	{r7}
 8008052:	4770      	bx	lr

08008054 <SendReseive>:

bool SendReseive()
    {
 8008054:	b580      	push	{r7, lr}
 8008056:	b082      	sub	sp, #8
 8008058:	af00      	add	r7, sp, #0
	int exit_counter = 0;
 800805a:	2300      	movs	r3, #0
 800805c:	607b      	str	r3, [r7, #4]
    //  vTaskDelay(50);
	int sendsize = rs485size;
 800805e:	4b29      	ldr	r3, [pc, #164]	; (8008104 <SendReseive+0xb0>)
 8008060:	781b      	ldrb	r3, [r3, #0]
 8008062:	603b      	str	r3, [r7, #0]
	while(exit_counter++ <5)
 8008064:	e02b      	b.n	80080be <SendReseive+0x6a>
	{
		GPIO_SetBits(GPIOC, GPIO_Pin_12);
 8008066:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 800806a:	4827      	ldr	r0, [pc, #156]	; (8008108 <SendReseive+0xb4>)
 800806c:	4b27      	ldr	r3, [pc, #156]	; (800810c <SendReseive+0xb8>)
 800806e:	4798      	blx	r3
	   // AT91F_PIO_SetOutput(AT91C_BASE_PIOA, LED_485);
		vTaskDelay(5);
 8008070:	2005      	movs	r0, #5
 8008072:	4b27      	ldr	r3, [pc, #156]	; (8008110 <SendReseive+0xbc>)
 8008074:	4798      	blx	r3

		processBuffer8to7(rs485buf,sendsize);
 8008076:	683b      	ldr	r3, [r7, #0]
 8008078:	b29b      	uxth	r3, r3
 800807a:	4619      	mov	r1, r3
 800807c:	4825      	ldr	r0, [pc, #148]	; (8008114 <SendReseive+0xc0>)
 800807e:	4b26      	ldr	r3, [pc, #152]	; (8008118 <SendReseive+0xc4>)
 8008080:	4798      	blx	r3
		uart3Write ((uint8*) rs485buf, sendsize);
 8008082:	683b      	ldr	r3, [r7, #0]
 8008084:	4619      	mov	r1, r3
 8008086:	4823      	ldr	r0, [pc, #140]	; (8008114 <SendReseive+0xc0>)
 8008088:	4b24      	ldr	r3, [pc, #144]	; (800811c <SendReseive+0xc8>)
 800808a:	4798      	blx	r3
		vTaskDelay(30);
 800808c:	201e      	movs	r0, #30
 800808e:	4b20      	ldr	r3, [pc, #128]	; (8008110 <SendReseive+0xbc>)
 8008090:	4798      	blx	r3

		//AT91F_PIO_ClearOutput(AT91C_BASE_PIOA, LED_485);

		GPIO_ResetBits(GPIOC, GPIO_Pin_12);
 8008092:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8008096:	481c      	ldr	r0, [pc, #112]	; (8008108 <SendReseive+0xb4>)
 8008098:	4b21      	ldr	r3, [pc, #132]	; (8008120 <SendReseive+0xcc>)
 800809a:	4798      	blx	r3

		vTaskDelay(1000);
 800809c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80080a0:	4b1b      	ldr	r3, [pc, #108]	; (8008110 <SendReseive+0xbc>)
 80080a2:	4798      	blx	r3

		rs485size = uart3Read((uint8*) rs485buf, 256/*, 3000*/);
 80080a4:	f44f 7180 	mov.w	r1, #256	; 0x100
 80080a8:	481a      	ldr	r0, [pc, #104]	; (8008114 <SendReseive+0xc0>)
 80080aa:	4b1e      	ldr	r3, [pc, #120]	; (8008124 <SendReseive+0xd0>)
 80080ac:	4798      	blx	r3
 80080ae:	4603      	mov	r3, r0
 80080b0:	b2da      	uxtb	r2, r3
 80080b2:	4b14      	ldr	r3, [pc, #80]	; (8008104 <SendReseive+0xb0>)
 80080b4:	701a      	strb	r2, [r3, #0]

    if (rs485size != 0) break;
 80080b6:	4b13      	ldr	r3, [pc, #76]	; (8008104 <SendReseive+0xb0>)
 80080b8:	781b      	ldrb	r3, [r3, #0]
 80080ba:	2b00      	cmp	r3, #0
 80080bc:	d105      	bne.n	80080ca <SendReseive+0x76>
	while(exit_counter++ <5)
 80080be:	687b      	ldr	r3, [r7, #4]
 80080c0:	1c5a      	adds	r2, r3, #1
 80080c2:	607a      	str	r2, [r7, #4]
 80080c4:	2b04      	cmp	r3, #4
 80080c6:	ddce      	ble.n	8008066 <SendReseive+0x12>
 80080c8:	e000      	b.n	80080cc <SendReseive+0x78>
    if (rs485size != 0) break;
 80080ca:	bf00      	nop
    }
    if (rs485size == 0)
 80080cc:	4b0d      	ldr	r3, [pc, #52]	; (8008104 <SendReseive+0xb0>)
 80080ce:	781b      	ldrb	r3, [r3, #0]
 80080d0:	2b00      	cmp	r3, #0
 80080d2:	d105      	bne.n	80080e0 <SendReseive+0x8c>
    {   vTaskDelay(2500);
 80080d4:	f640 10c4 	movw	r0, #2500	; 0x9c4
 80080d8:	4b0d      	ldr	r3, [pc, #52]	; (8008110 <SendReseive+0xbc>)
 80080da:	4798      	blx	r3
    	return false;
 80080dc:	2300      	movs	r3, #0
 80080de:	e00d      	b.n	80080fc <SendReseive+0xa8>
    }

    processBuffer7to8(rs485buf,rs485size);
 80080e0:	4b08      	ldr	r3, [pc, #32]	; (8008104 <SendReseive+0xb0>)
 80080e2:	781b      	ldrb	r3, [r3, #0]
 80080e4:	b29b      	uxth	r3, r3
 80080e6:	4619      	mov	r1, r3
 80080e8:	480a      	ldr	r0, [pc, #40]	; (8008114 <SendReseive+0xc0>)
 80080ea:	4b0f      	ldr	r3, [pc, #60]	; (8008128 <SendReseive+0xd4>)
 80080ec:	4798      	blx	r3
    vTaskDelay(50);
 80080ee:	2032      	movs	r0, #50	; 0x32
 80080f0:	4b07      	ldr	r3, [pc, #28]	; (8008110 <SendReseive+0xbc>)
 80080f2:	4798      	blx	r3
  //  AT91F_PIO_SetOutput(AT91C_BASE_PIOA, LED_485);
    vTaskDelay(100);
 80080f4:	2064      	movs	r0, #100	; 0x64
 80080f6:	4b06      	ldr	r3, [pc, #24]	; (8008110 <SendReseive+0xbc>)
 80080f8:	4798      	blx	r3
    //

    return true;
 80080fa:	2301      	movs	r3, #1
    }
 80080fc:	4618      	mov	r0, r3
 80080fe:	3708      	adds	r7, #8
 8008100:	46bd      	mov	sp, r7
 8008102:	bd80      	pop	{r7, pc}
 8008104:	20007440 	.word	0x20007440
 8008108:	40011000 	.word	0x40011000
 800810c:	08002f6d 	.word	0x08002f6d
 8008110:	08001529 	.word	0x08001529
 8008114:	200072c0 	.word	0x200072c0
 8008118:	08007f6f 	.word	0x08007f6f
 800811c:	08004ccd 	.word	0x08004ccd
 8008120:	08002f89 	.word	0x08002f89
 8008124:	08004c71 	.word	0x08004c71
 8008128:	08007f2d 	.word	0x08007f2d

0800812c <AskParam>:

bool AskParam(char *paramName, char *value)
    {
 800812c:	b580      	push	{r7, lr}
 800812e:	b084      	sub	sp, #16
 8008130:	af00      	add	r7, sp, #0
 8008132:	6078      	str	r0, [r7, #4]
 8008134:	6039      	str	r1, [r7, #0]
    value[0] = 0;
 8008136:	683b      	ldr	r3, [r7, #0]
 8008138:	2200      	movs	r2, #0
 800813a:	701a      	strb	r2, [r3, #0]
    rs485size = iecProcVarReqPacket(rs485buf, paramName, 32);
 800813c:	2220      	movs	r2, #32
 800813e:	6879      	ldr	r1, [r7, #4]
 8008140:	4810      	ldr	r0, [pc, #64]	; (8008184 <AskParam+0x58>)
 8008142:	4b11      	ldr	r3, [pc, #68]	; (8008188 <AskParam+0x5c>)
 8008144:	4798      	blx	r3
 8008146:	4603      	mov	r3, r0
 8008148:	b2da      	uxtb	r2, r3
 800814a:	4b10      	ldr	r3, [pc, #64]	; (800818c <AskParam+0x60>)
 800814c:	701a      	strb	r2, [r3, #0]
    if (!SendReseive())
 800814e:	4b10      	ldr	r3, [pc, #64]	; (8008190 <AskParam+0x64>)
 8008150:	4798      	blx	r3
 8008152:	4603      	mov	r3, r0
 8008154:	f083 0301 	eor.w	r3, r3, #1
 8008158:	b2db      	uxtb	r3, r3
 800815a:	2b00      	cmp	r3, #0
 800815c:	d001      	beq.n	8008162 <AskParam+0x36>
	return false;
 800815e:	2300      	movs	r3, #0
 8008160:	e00c      	b.n	800817c <AskParam+0x50>

    uint8 boolX = iecProcVarAnswerPacket(rs485buf, value, 128);
 8008162:	2280      	movs	r2, #128	; 0x80
 8008164:	6839      	ldr	r1, [r7, #0]
 8008166:	4807      	ldr	r0, [pc, #28]	; (8008184 <AskParam+0x58>)
 8008168:	4b0a      	ldr	r3, [pc, #40]	; (8008194 <AskParam+0x68>)
 800816a:	4798      	blx	r3
 800816c:	4603      	mov	r3, r0
 800816e:	73fb      	strb	r3, [r7, #15]
    if(boolX == false)
 8008170:	7bfb      	ldrb	r3, [r7, #15]
 8008172:	2b00      	cmp	r3, #0
 8008174:	d101      	bne.n	800817a <AskParam+0x4e>
	{
    	return false;
 8008176:	2300      	movs	r3, #0
 8008178:	e000      	b.n	800817c <AskParam+0x50>
	}

    return true;
 800817a:	2301      	movs	r3, #1
    }
 800817c:	4618      	mov	r0, r3
 800817e:	3710      	adds	r7, #16
 8008180:	46bd      	mov	sp, r7
 8008182:	bd80      	pop	{r7, pc}
 8008184:	200072c0 	.word	0x200072c0
 8008188:	0800915d 	.word	0x0800915d
 800818c:	20007440 	.word	0x20007440
 8008190:	08008055 	.word	0x08008055
 8008194:	08009229 	.word	0x08009229

08008198 <ParseAnswer>:
       	return false;
   	}
    return true;
    }
char* ParseAnswer(char *buf, char *dsn)
    {
 8008198:	b480      	push	{r7}
 800819a:	b083      	sub	sp, #12
 800819c:	af00      	add	r7, sp, #0
 800819e:	6078      	str	r0, [r7, #4]
 80081a0:	6039      	str	r1, [r7, #0]
    while ( *buf != '(')
 80081a2:	e002      	b.n	80081aa <ParseAnswer+0x12>
	buf++;
 80081a4:	687b      	ldr	r3, [r7, #4]
 80081a6:	3301      	adds	r3, #1
 80081a8:	607b      	str	r3, [r7, #4]
    while ( *buf != '(')
 80081aa:	687b      	ldr	r3, [r7, #4]
 80081ac:	781b      	ldrb	r3, [r3, #0]
 80081ae:	2b28      	cmp	r3, #40	; 0x28
 80081b0:	d1f8      	bne.n	80081a4 <ParseAnswer+0xc>
    buf++;
 80081b2:	687b      	ldr	r3, [r7, #4]
 80081b4:	3301      	adds	r3, #1
 80081b6:	607b      	str	r3, [r7, #4]
    while (*buf && *buf != ')')
 80081b8:	e009      	b.n	80081ce <ParseAnswer+0x36>
	{
	*dsn = *buf;
 80081ba:	687b      	ldr	r3, [r7, #4]
 80081bc:	781a      	ldrb	r2, [r3, #0]
 80081be:	683b      	ldr	r3, [r7, #0]
 80081c0:	701a      	strb	r2, [r3, #0]
	dsn++;
 80081c2:	683b      	ldr	r3, [r7, #0]
 80081c4:	3301      	adds	r3, #1
 80081c6:	603b      	str	r3, [r7, #0]
	buf++;
 80081c8:	687b      	ldr	r3, [r7, #4]
 80081ca:	3301      	adds	r3, #1
 80081cc:	607b      	str	r3, [r7, #4]
    while (*buf && *buf != ')')
 80081ce:	687b      	ldr	r3, [r7, #4]
 80081d0:	781b      	ldrb	r3, [r3, #0]
 80081d2:	2b00      	cmp	r3, #0
 80081d4:	d003      	beq.n	80081de <ParseAnswer+0x46>
 80081d6:	687b      	ldr	r3, [r7, #4]
 80081d8:	781b      	ldrb	r3, [r3, #0]
 80081da:	2b29      	cmp	r3, #41	; 0x29
 80081dc:	d1ed      	bne.n	80081ba <ParseAnswer+0x22>
	}
    *dsn = 0;
 80081de:	683b      	ldr	r3, [r7, #0]
 80081e0:	2200      	movs	r2, #0
 80081e2:	701a      	strb	r2, [r3, #0]
    return buf;
 80081e4:	687b      	ldr	r3, [r7, #4]
    }
 80081e6:	4618      	mov	r0, r3
 80081e8:	370c      	adds	r7, #12
 80081ea:	46bd      	mov	sp, r7
 80081ec:	bc80      	pop	{r7}
 80081ee:	4770      	bx	lr

080081f0 <AskConunter>:
bool AskConunter()
    {
 80081f0:	b590      	push	{r4, r7, lr}
 80081f2:	b083      	sub	sp, #12
 80081f4:	af00      	add	r7, sp, #0
	MakeiFixUIP();
 80081f6:	4b7b      	ldr	r3, [pc, #492]	; (80083e4 <AskConunter+0x1f4>)
 80081f8:	4798      	blx	r3
    char *pxBuf;
    char *tmpbuffX;
    // Find Device
    rs485size = iecProcReqPacket(rs485buf, "", 10);
 80081fa:	220a      	movs	r2, #10
 80081fc:	497a      	ldr	r1, [pc, #488]	; (80083e8 <AskConunter+0x1f8>)
 80081fe:	487b      	ldr	r0, [pc, #492]	; (80083ec <AskConunter+0x1fc>)
 8008200:	4b7b      	ldr	r3, [pc, #492]	; (80083f0 <AskConunter+0x200>)
 8008202:	4798      	blx	r3
 8008204:	4603      	mov	r3, r0
 8008206:	b2da      	uxtb	r2, r3
 8008208:	4b7a      	ldr	r3, [pc, #488]	; (80083f4 <AskConunter+0x204>)
 800820a:	701a      	strb	r2, [r3, #0]
    if (!SendReseive())
 800820c:	4b7a      	ldr	r3, [pc, #488]	; (80083f8 <AskConunter+0x208>)
 800820e:	4798      	blx	r3
 8008210:	4603      	mov	r3, r0
 8008212:	f083 0301 	eor.w	r3, r3, #1
 8008216:	b2db      	uxtb	r3, r3
 8008218:	2b00      	cmp	r3, #0
 800821a:	d001      	beq.n	8008220 <AskConunter+0x30>
    	return false;
 800821c:	2300      	movs	r3, #0
 800821e:	e158      	b.n	80084d2 <AskConunter+0x2e2>
    uint8 boolX = iecIndProc(rs485buf, &id);
 8008220:	4976      	ldr	r1, [pc, #472]	; (80083fc <AskConunter+0x20c>)
 8008222:	4872      	ldr	r0, [pc, #456]	; (80083ec <AskConunter+0x1fc>)
 8008224:	4b76      	ldr	r3, [pc, #472]	; (8008400 <AskConunter+0x210>)
 8008226:	4798      	blx	r3
 8008228:	4603      	mov	r3, r0
 800822a:	71fb      	strb	r3, [r7, #7]
    if (false==boolX)
 800822c:	79fb      	ldrb	r3, [r7, #7]
 800822e:	2b00      	cmp	r3, #0
 8008230:	d101      	bne.n	8008236 <AskConunter+0x46>
    {
    	return false;
 8008232:	2300      	movs	r3, #0
 8008234:	e14d      	b.n	80084d2 <AskConunter+0x2e2>
    }

    // Password & security

	rs485size = iecOptionsAckPacket(rs485buf, '0', '5', '1');
 8008236:	2331      	movs	r3, #49	; 0x31
 8008238:	2235      	movs	r2, #53	; 0x35
 800823a:	2130      	movs	r1, #48	; 0x30
 800823c:	486b      	ldr	r0, [pc, #428]	; (80083ec <AskConunter+0x1fc>)
 800823e:	4c71      	ldr	r4, [pc, #452]	; (8008404 <AskConunter+0x214>)
 8008240:	47a0      	blx	r4
 8008242:	4603      	mov	r3, r0
 8008244:	b2da      	uxtb	r2, r3
 8008246:	4b6b      	ldr	r3, [pc, #428]	; (80083f4 <AskConunter+0x204>)
 8008248:	701a      	strb	r2, [r3, #0]
	if (!SendReseive())
 800824a:	4b6b      	ldr	r3, [pc, #428]	; (80083f8 <AskConunter+0x208>)
 800824c:	4798      	blx	r3
 800824e:	4603      	mov	r3, r0
 8008250:	f083 0301 	eor.w	r3, r3, #1
 8008254:	b2db      	uxtb	r3, r3
 8008256:	2b00      	cmp	r3, #0
 8008258:	d001      	beq.n	800825e <AskConunter+0x6e>
		return false;
 800825a:	2300      	movs	r3, #0
 800825c:	e139      	b.n	80084d2 <AskConunter+0x2e2>

	boolX = iecProcAddrAnswer(rs485buf, &RAM.strings[0][0], 128);
 800825e:	2280      	movs	r2, #128	; 0x80
 8008260:	4969      	ldr	r1, [pc, #420]	; (8008408 <AskConunter+0x218>)
 8008262:	4862      	ldr	r0, [pc, #392]	; (80083ec <AskConunter+0x1fc>)
 8008264:	4b69      	ldr	r3, [pc, #420]	; (800840c <AskConunter+0x21c>)
 8008266:	4798      	blx	r3
 8008268:	4603      	mov	r3, r0
 800826a:	71fb      	strb	r3, [r7, #7]
	if (false==boolX)
 800826c:	79fb      	ldrb	r3, [r7, #7]
 800826e:	2b00      	cmp	r3, #0
 8008270:	d101      	bne.n	8008276 <AskConunter+0x86>
	{
		return false;
 8008272:	2300      	movs	r3, #0
 8008274:	e12d      	b.n	80084d2 <AskConunter+0x2e2>
	}

    if (!AskParam("DATE_", tmpbuff))
 8008276:	4966      	ldr	r1, [pc, #408]	; (8008410 <AskConunter+0x220>)
 8008278:	4866      	ldr	r0, [pc, #408]	; (8008414 <AskConunter+0x224>)
 800827a:	4b67      	ldr	r3, [pc, #412]	; (8008418 <AskConunter+0x228>)
 800827c:	4798      	blx	r3
 800827e:	4603      	mov	r3, r0
 8008280:	f083 0301 	eor.w	r3, r3, #1
 8008284:	b2db      	uxtb	r3, r3
 8008286:	2b00      	cmp	r3, #0
 8008288:	d001      	beq.n	800828e <AskConunter+0x9e>
    		return false;
 800828a:	2300      	movs	r3, #0
 800828c:	e121      	b.n	80084d2 <AskConunter+0x2e2>
    ParseAnswer(tmpbuff, &RAM.strings[1][0]);
 800828e:	4963      	ldr	r1, [pc, #396]	; (800841c <AskConunter+0x22c>)
 8008290:	485f      	ldr	r0, [pc, #380]	; (8008410 <AskConunter+0x220>)
 8008292:	4b63      	ldr	r3, [pc, #396]	; (8008420 <AskConunter+0x230>)
 8008294:	4798      	blx	r3

    if (!AskParam("TIME_", tmpbuff))
 8008296:	495e      	ldr	r1, [pc, #376]	; (8008410 <AskConunter+0x220>)
 8008298:	4862      	ldr	r0, [pc, #392]	; (8008424 <AskConunter+0x234>)
 800829a:	4b5f      	ldr	r3, [pc, #380]	; (8008418 <AskConunter+0x228>)
 800829c:	4798      	blx	r3
 800829e:	4603      	mov	r3, r0
 80082a0:	f083 0301 	eor.w	r3, r3, #1
 80082a4:	b2db      	uxtb	r3, r3
 80082a6:	2b00      	cmp	r3, #0
 80082a8:	d001      	beq.n	80082ae <AskConunter+0xbe>
    		return false;
 80082aa:	2300      	movs	r3, #0
 80082ac:	e111      	b.n	80084d2 <AskConunter+0x2e2>
    ParseAnswer(tmpbuff, &RAM.strings[2][0]);
 80082ae:	495e      	ldr	r1, [pc, #376]	; (8008428 <AskConunter+0x238>)
 80082b0:	4857      	ldr	r0, [pc, #348]	; (8008410 <AskConunter+0x220>)
 80082b2:	4b5b      	ldr	r3, [pc, #364]	; (8008420 <AskConunter+0x230>)
 80082b4:	4798      	blx	r3


	if (!AskParam("SNUMB", tmpbuff))
 80082b6:	4956      	ldr	r1, [pc, #344]	; (8008410 <AskConunter+0x220>)
 80082b8:	485c      	ldr	r0, [pc, #368]	; (800842c <AskConunter+0x23c>)
 80082ba:	4b57      	ldr	r3, [pc, #348]	; (8008418 <AskConunter+0x228>)
 80082bc:	4798      	blx	r3
 80082be:	4603      	mov	r3, r0
 80082c0:	f083 0301 	eor.w	r3, r3, #1
 80082c4:	b2db      	uxtb	r3, r3
 80082c6:	2b00      	cmp	r3, #0
 80082c8:	d001      	beq.n	80082ce <AskConunter+0xde>
			return false;
 80082ca:	2300      	movs	r3, #0
 80082cc:	e101      	b.n	80084d2 <AskConunter+0x2e2>
	ParseAnswer(tmpbuff, &RAM.strings[3][0]);
 80082ce:	4958      	ldr	r1, [pc, #352]	; (8008430 <AskConunter+0x240>)
 80082d0:	484f      	ldr	r0, [pc, #316]	; (8008410 <AskConunter+0x220>)
 80082d2:	4b53      	ldr	r3, [pc, #332]	; (8008420 <AskConunter+0x230>)
 80082d4:	4798      	blx	r3

    if (!AskParam("ET0PE", tmpbuff))
 80082d6:	494e      	ldr	r1, [pc, #312]	; (8008410 <AskConunter+0x220>)
 80082d8:	4856      	ldr	r0, [pc, #344]	; (8008434 <AskConunter+0x244>)
 80082da:	4b4f      	ldr	r3, [pc, #316]	; (8008418 <AskConunter+0x228>)
 80082dc:	4798      	blx	r3
 80082de:	4603      	mov	r3, r0
 80082e0:	f083 0301 	eor.w	r3, r3, #1
 80082e4:	b2db      	uxtb	r3, r3
 80082e6:	2b00      	cmp	r3, #0
 80082e8:	d001      	beq.n	80082ee <AskConunter+0xfe>
    		return false;
 80082ea:	2300      	movs	r3, #0
 80082ec:	e0f1      	b.n	80084d2 <AskConunter+0x2e2>
    ParseAnswer(tmpbuff, &RAM.strings[4][0]);
 80082ee:	4952      	ldr	r1, [pc, #328]	; (8008438 <AskConunter+0x248>)
 80082f0:	4847      	ldr	r0, [pc, #284]	; (8008410 <AskConunter+0x220>)
 80082f2:	4b4b      	ldr	r3, [pc, #300]	; (8008420 <AskConunter+0x230>)
 80082f4:	4798      	blx	r3

    if (!AskParam("POWPP", tmpbuff))
 80082f6:	4946      	ldr	r1, [pc, #280]	; (8008410 <AskConunter+0x220>)
 80082f8:	4850      	ldr	r0, [pc, #320]	; (800843c <AskConunter+0x24c>)
 80082fa:	4b47      	ldr	r3, [pc, #284]	; (8008418 <AskConunter+0x228>)
 80082fc:	4798      	blx	r3
 80082fe:	4603      	mov	r3, r0
 8008300:	f083 0301 	eor.w	r3, r3, #1
 8008304:	b2db      	uxtb	r3, r3
 8008306:	2b00      	cmp	r3, #0
 8008308:	d001      	beq.n	800830e <AskConunter+0x11e>
    		return false;
 800830a:	2300      	movs	r3, #0
 800830c:	e0e1      	b.n	80084d2 <AskConunter+0x2e2>
    pxBuf = tmpbuff;
 800830e:	4b40      	ldr	r3, [pc, #256]	; (8008410 <AskConunter+0x220>)
 8008310:	603b      	str	r3, [r7, #0]
    pxBuf = ParseAnswer(pxBuf, &RAM.strings[5][0]);
 8008312:	494b      	ldr	r1, [pc, #300]	; (8008440 <AskConunter+0x250>)
 8008314:	6838      	ldr	r0, [r7, #0]
 8008316:	4b42      	ldr	r3, [pc, #264]	; (8008420 <AskConunter+0x230>)
 8008318:	4798      	blx	r3
 800831a:	6038      	str	r0, [r7, #0]
    pxBuf = ParseAnswer(pxBuf, &RAM.strings[6][0]);
 800831c:	4949      	ldr	r1, [pc, #292]	; (8008444 <AskConunter+0x254>)
 800831e:	6838      	ldr	r0, [r7, #0]
 8008320:	4b3f      	ldr	r3, [pc, #252]	; (8008420 <AskConunter+0x230>)
 8008322:	4798      	blx	r3
 8008324:	6038      	str	r0, [r7, #0]
    pxBuf = ParseAnswer(pxBuf, &RAM.strings[7][0]);
 8008326:	4948      	ldr	r1, [pc, #288]	; (8008448 <AskConunter+0x258>)
 8008328:	6838      	ldr	r0, [r7, #0]
 800832a:	4b3d      	ldr	r3, [pc, #244]	; (8008420 <AskConunter+0x230>)
 800832c:	4798      	blx	r3
 800832e:	6038      	str	r0, [r7, #0]

    if (!AskParam("VOLTA", tmpbuff))
 8008330:	4937      	ldr	r1, [pc, #220]	; (8008410 <AskConunter+0x220>)
 8008332:	4846      	ldr	r0, [pc, #280]	; (800844c <AskConunter+0x25c>)
 8008334:	4b38      	ldr	r3, [pc, #224]	; (8008418 <AskConunter+0x228>)
 8008336:	4798      	blx	r3
 8008338:	4603      	mov	r3, r0
 800833a:	f083 0301 	eor.w	r3, r3, #1
 800833e:	b2db      	uxtb	r3, r3
 8008340:	2b00      	cmp	r3, #0
 8008342:	d001      	beq.n	8008348 <AskConunter+0x158>
    		return false;
 8008344:	2300      	movs	r3, #0
 8008346:	e0c4      	b.n	80084d2 <AskConunter+0x2e2>
    pxBuf = tmpbuff;
 8008348:	4b31      	ldr	r3, [pc, #196]	; (8008410 <AskConunter+0x220>)
 800834a:	603b      	str	r3, [r7, #0]
    pxBuf = ParseAnswer(pxBuf, &RAM.strings[8][0]);
 800834c:	4940      	ldr	r1, [pc, #256]	; (8008450 <AskConunter+0x260>)
 800834e:	6838      	ldr	r0, [r7, #0]
 8008350:	4b33      	ldr	r3, [pc, #204]	; (8008420 <AskConunter+0x230>)
 8008352:	4798      	blx	r3
 8008354:	6038      	str	r0, [r7, #0]
    pxBuf = ParseAnswer(pxBuf, &RAM.strings[9][0]);
 8008356:	493f      	ldr	r1, [pc, #252]	; (8008454 <AskConunter+0x264>)
 8008358:	6838      	ldr	r0, [r7, #0]
 800835a:	4b31      	ldr	r3, [pc, #196]	; (8008420 <AskConunter+0x230>)
 800835c:	4798      	blx	r3
 800835e:	6038      	str	r0, [r7, #0]
    pxBuf = ParseAnswer(pxBuf, &RAM.strings[10][0]);
 8008360:	493d      	ldr	r1, [pc, #244]	; (8008458 <AskConunter+0x268>)
 8008362:	6838      	ldr	r0, [r7, #0]
 8008364:	4b2e      	ldr	r3, [pc, #184]	; (8008420 <AskConunter+0x230>)
 8008366:	4798      	blx	r3
 8008368:	6038      	str	r0, [r7, #0]

    if (!AskParam("CURRE", tmpbuff))
 800836a:	4929      	ldr	r1, [pc, #164]	; (8008410 <AskConunter+0x220>)
 800836c:	483b      	ldr	r0, [pc, #236]	; (800845c <AskConunter+0x26c>)
 800836e:	4b2a      	ldr	r3, [pc, #168]	; (8008418 <AskConunter+0x228>)
 8008370:	4798      	blx	r3
 8008372:	4603      	mov	r3, r0
 8008374:	f083 0301 	eor.w	r3, r3, #1
 8008378:	b2db      	uxtb	r3, r3
 800837a:	2b00      	cmp	r3, #0
 800837c:	d001      	beq.n	8008382 <AskConunter+0x192>
    		return false;
 800837e:	2300      	movs	r3, #0
 8008380:	e0a7      	b.n	80084d2 <AskConunter+0x2e2>
    pxBuf = tmpbuff;
 8008382:	4b23      	ldr	r3, [pc, #140]	; (8008410 <AskConunter+0x220>)
 8008384:	603b      	str	r3, [r7, #0]
    pxBuf = ParseAnswer(pxBuf, &RAM.strings[11][0]);
 8008386:	4936      	ldr	r1, [pc, #216]	; (8008460 <AskConunter+0x270>)
 8008388:	6838      	ldr	r0, [r7, #0]
 800838a:	4b25      	ldr	r3, [pc, #148]	; (8008420 <AskConunter+0x230>)
 800838c:	4798      	blx	r3
 800838e:	6038      	str	r0, [r7, #0]
    pxBuf = ParseAnswer(pxBuf, &RAM.strings[12][0]);
 8008390:	4934      	ldr	r1, [pc, #208]	; (8008464 <AskConunter+0x274>)
 8008392:	6838      	ldr	r0, [r7, #0]
 8008394:	4b22      	ldr	r3, [pc, #136]	; (8008420 <AskConunter+0x230>)
 8008396:	4798      	blx	r3
 8008398:	6038      	str	r0, [r7, #0]
    pxBuf = ParseAnswer(pxBuf, &RAM.strings[13][0]);
 800839a:	4933      	ldr	r1, [pc, #204]	; (8008468 <AskConunter+0x278>)
 800839c:	6838      	ldr	r0, [r7, #0]
 800839e:	4b20      	ldr	r3, [pc, #128]	; (8008420 <AskConunter+0x230>)
 80083a0:	4798      	blx	r3
 80083a2:	6038      	str	r0, [r7, #0]

    if (!AskParam("FREQU", tmpbuff))
 80083a4:	491a      	ldr	r1, [pc, #104]	; (8008410 <AskConunter+0x220>)
 80083a6:	4831      	ldr	r0, [pc, #196]	; (800846c <AskConunter+0x27c>)
 80083a8:	4b1b      	ldr	r3, [pc, #108]	; (8008418 <AskConunter+0x228>)
 80083aa:	4798      	blx	r3
 80083ac:	4603      	mov	r3, r0
 80083ae:	f083 0301 	eor.w	r3, r3, #1
 80083b2:	b2db      	uxtb	r3, r3
 80083b4:	2b00      	cmp	r3, #0
 80083b6:	d001      	beq.n	80083bc <AskConunter+0x1cc>
    		return false;
 80083b8:	2300      	movs	r3, #0
 80083ba:	e08a      	b.n	80084d2 <AskConunter+0x2e2>
    pxBuf = tmpbuff;
 80083bc:	4b14      	ldr	r3, [pc, #80]	; (8008410 <AskConunter+0x220>)
 80083be:	603b      	str	r3, [r7, #0]
    pxBuf = ParseAnswer(pxBuf, &RAM.strings[14][0]);
 80083c0:	492b      	ldr	r1, [pc, #172]	; (8008470 <AskConunter+0x280>)
 80083c2:	6838      	ldr	r0, [r7, #0]
 80083c4:	4b16      	ldr	r3, [pc, #88]	; (8008420 <AskConunter+0x230>)
 80083c6:	4798      	blx	r3
 80083c8:	6038      	str	r0, [r7, #0]

    if (!AskParam("ET0PE", tmpbuff))
 80083ca:	4911      	ldr	r1, [pc, #68]	; (8008410 <AskConunter+0x220>)
 80083cc:	4819      	ldr	r0, [pc, #100]	; (8008434 <AskConunter+0x244>)
 80083ce:	4b12      	ldr	r3, [pc, #72]	; (8008418 <AskConunter+0x228>)
 80083d0:	4798      	blx	r3
 80083d2:	4603      	mov	r3, r0
 80083d4:	f083 0301 	eor.w	r3, r3, #1
 80083d8:	b2db      	uxtb	r3, r3
 80083da:	2b00      	cmp	r3, #0
 80083dc:	d04a      	beq.n	8008474 <AskConunter+0x284>
    		return false;
 80083de:	2300      	movs	r3, #0
 80083e0:	e077      	b.n	80084d2 <AskConunter+0x2e2>
 80083e2:	bf00      	nop
 80083e4:	08007be9 	.word	0x08007be9
 80083e8:	08014e00 	.word	0x08014e00
 80083ec:	200072c0 	.word	0x200072c0
 80083f0:	08008ebd 	.word	0x08008ebd
 80083f4:	20007440 	.word	0x20007440
 80083f8:	08008055 	.word	0x08008055
 80083fc:	20007444 	.word	0x20007444
 8008400:	08008f4f 	.word	0x08008f4f
 8008404:	08008ff7 	.word	0x08008ff7
 8008408:	2000786c 	.word	0x2000786c
 800840c:	08009061 	.word	0x08009061
 8008410:	200073c0 	.word	0x200073c0
 8008414:	08014e04 	.word	0x08014e04
 8008418:	0800812d 	.word	0x0800812d
 800841c:	2000787c 	.word	0x2000787c
 8008420:	08008199 	.word	0x08008199
 8008424:	08014e0c 	.word	0x08014e0c
 8008428:	2000788c 	.word	0x2000788c
 800842c:	08014e14 	.word	0x08014e14
 8008430:	2000789c 	.word	0x2000789c
 8008434:	08014e1c 	.word	0x08014e1c
 8008438:	200078ac 	.word	0x200078ac
 800843c:	08014e24 	.word	0x08014e24
 8008440:	200078bc 	.word	0x200078bc
 8008444:	200078cc 	.word	0x200078cc
 8008448:	200078dc 	.word	0x200078dc
 800844c:	08014e2c 	.word	0x08014e2c
 8008450:	200078ec 	.word	0x200078ec
 8008454:	200078fc 	.word	0x200078fc
 8008458:	2000790c 	.word	0x2000790c
 800845c:	08014e34 	.word	0x08014e34
 8008460:	2000791c 	.word	0x2000791c
 8008464:	2000792c 	.word	0x2000792c
 8008468:	2000793c 	.word	0x2000793c
 800846c:	08014e3c 	.word	0x08014e3c
 8008470:	2000794c 	.word	0x2000794c
    ParseAnswer(tmpbuff, &RAM.strings[15][0]);
 8008474:	4919      	ldr	r1, [pc, #100]	; (80084dc <AskConunter+0x2ec>)
 8008476:	481a      	ldr	r0, [pc, #104]	; (80084e0 <AskConunter+0x2f0>)
 8008478:	4b1a      	ldr	r3, [pc, #104]	; (80084e4 <AskConunter+0x2f4>)
 800847a:	4798      	blx	r3
    GetDateStringLD(tmpbuffX);
    if (!AskParamArg("ENDPE", tmpbuff,tmpbuffX))
          	return false;
    ParseAnswer(tmpbuff, &RAM.strings[17][0]);*/

    MakeiFixUIP();
 800847c:	4b1a      	ldr	r3, [pc, #104]	; (80084e8 <AskConunter+0x2f8>)
 800847e:	4798      	blx	r3

    rs485size = iecProcExitPacket(rs485buf);
 8008480:	481a      	ldr	r0, [pc, #104]	; (80084ec <AskConunter+0x2fc>)
 8008482:	4b1b      	ldr	r3, [pc, #108]	; (80084f0 <AskConunter+0x300>)
 8008484:	4798      	blx	r3
 8008486:	4603      	mov	r3, r0
 8008488:	b2da      	uxtb	r2, r3
 800848a:	4b1a      	ldr	r3, [pc, #104]	; (80084f4 <AskConunter+0x304>)
 800848c:	701a      	strb	r2, [r3, #0]
    GPIO_SetBits(GPIOC, GPIO_Pin_12);
 800848e:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8008492:	4819      	ldr	r0, [pc, #100]	; (80084f8 <AskConunter+0x308>)
 8008494:	4b19      	ldr	r3, [pc, #100]	; (80084fc <AskConunter+0x30c>)
 8008496:	4798      	blx	r3
    vTaskDelay(5);
 8008498:	2005      	movs	r0, #5
 800849a:	4b19      	ldr	r3, [pc, #100]	; (8008500 <AskConunter+0x310>)
 800849c:	4798      	blx	r3
    processBuffer8to7(rs485buf,rs485size);
 800849e:	4b15      	ldr	r3, [pc, #84]	; (80084f4 <AskConunter+0x304>)
 80084a0:	781b      	ldrb	r3, [r3, #0]
 80084a2:	b29b      	uxth	r3, r3
 80084a4:	4619      	mov	r1, r3
 80084a6:	4811      	ldr	r0, [pc, #68]	; (80084ec <AskConunter+0x2fc>)
 80084a8:	4b16      	ldr	r3, [pc, #88]	; (8008504 <AskConunter+0x314>)
 80084aa:	4798      	blx	r3
    uart3Write ((uint8*) rs485buf, rs485size);
 80084ac:	4b11      	ldr	r3, [pc, #68]	; (80084f4 <AskConunter+0x304>)
 80084ae:	781b      	ldrb	r3, [r3, #0]
 80084b0:	4619      	mov	r1, r3
 80084b2:	480e      	ldr	r0, [pc, #56]	; (80084ec <AskConunter+0x2fc>)
 80084b4:	4b14      	ldr	r3, [pc, #80]	; (8008508 <AskConunter+0x318>)
 80084b6:	4798      	blx	r3
    vTaskDelay(10);
 80084b8:	200a      	movs	r0, #10
 80084ba:	4b11      	ldr	r3, [pc, #68]	; (8008500 <AskConunter+0x310>)
 80084bc:	4798      	blx	r3
    GPIO_ResetBits(GPIOC, GPIO_Pin_12);
 80084be:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 80084c2:	480d      	ldr	r0, [pc, #52]	; (80084f8 <AskConunter+0x308>)
 80084c4:	4b11      	ldr	r3, [pc, #68]	; (800850c <AskConunter+0x31c>)
 80084c6:	4798      	blx	r3
    vTaskDelay(500);
 80084c8:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 80084cc:	4b0c      	ldr	r3, [pc, #48]	; (8008500 <AskConunter+0x310>)
 80084ce:	4798      	blx	r3

    return true;
 80084d0:	2301      	movs	r3, #1
    }
 80084d2:	4618      	mov	r0, r3
 80084d4:	370c      	adds	r7, #12
 80084d6:	46bd      	mov	sp, r7
 80084d8:	bd90      	pop	{r4, r7, pc}
 80084da:	bf00      	nop
 80084dc:	2000795c 	.word	0x2000795c
 80084e0:	200073c0 	.word	0x200073c0
 80084e4:	08008199 	.word	0x08008199
 80084e8:	08007be9 	.word	0x08007be9
 80084ec:	200072c0 	.word	0x200072c0
 80084f0:	080092bd 	.word	0x080092bd
 80084f4:	20007440 	.word	0x20007440
 80084f8:	40011000 	.word	0x40011000
 80084fc:	08002f6d 	.word	0x08002f6d
 8008500:	08001529 	.word	0x08001529
 8008504:	08007f6f 	.word	0x08007f6f
 8008508:	08004ccd 	.word	0x08004ccd
 800850c:	08002f89 	.word	0x08002f89

08008510 <SendReseive318>:

//------------------------------------------
bool SendReseive318(uint8* buffer, uint16 buffersize)
{
 8008510:	b580      	push	{r7, lr}
 8008512:	b084      	sub	sp, #16
 8008514:	af00      	add	r7, sp, #0
 8008516:	6078      	str	r0, [r7, #4]
 8008518:	460b      	mov	r3, r1
 800851a:	807b      	strh	r3, [r7, #2]
	//int bufsize318 = 0;
	//uint8 buffer318[bufsize318];
	int exit_counter = 0;
 800851c:	2300      	movs	r3, #0
 800851e:	60fb      	str	r3, [r7, #12]
	rs485size = 0;
 8008520:	4b1b      	ldr	r3, [pc, #108]	; (8008590 <SendReseive318+0x80>)
 8008522:	2200      	movs	r2, #0
 8008524:	701a      	strb	r2, [r3, #0]

		/*while(exit_counter++ <5)
		{*/
		if  (rs485size == 0)
 8008526:	4b1a      	ldr	r3, [pc, #104]	; (8008590 <SendReseive318+0x80>)
 8008528:	781b      	ldrb	r3, [r3, #0]
 800852a:	2b00      	cmp	r3, #0
 800852c:	d12c      	bne.n	8008588 <SendReseive318+0x78>
		{

			GPIO_SetBits(GPIOC, GPIO_Pin_12);
 800852e:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8008532:	4818      	ldr	r0, [pc, #96]	; (8008594 <SendReseive318+0x84>)
 8008534:	4b18      	ldr	r3, [pc, #96]	; (8008598 <SendReseive318+0x88>)
 8008536:	4798      	blx	r3
			vTaskDelay(5);
 8008538:	2005      	movs	r0, #5
 800853a:	4b18      	ldr	r3, [pc, #96]	; (800859c <SendReseive318+0x8c>)
 800853c:	4798      	blx	r3

		    uart3Write (buffer, buffersize);
 800853e:	887b      	ldrh	r3, [r7, #2]
 8008540:	4619      	mov	r1, r3
 8008542:	6878      	ldr	r0, [r7, #4]
 8008544:	4b16      	ldr	r3, [pc, #88]	; (80085a0 <SendReseive318+0x90>)
 8008546:	4798      	blx	r3

		    vTaskDelay(30);
 8008548:	201e      	movs	r0, #30
 800854a:	4b14      	ldr	r3, [pc, #80]	; (800859c <SendReseive318+0x8c>)
 800854c:	4798      	blx	r3

		    //AT91F_PIO_ClearOutput(AT91C_BASE_PIOA, LED_485);

		    GPIO_ResetBits(GPIOC, GPIO_Pin_12);
 800854e:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8008552:	4810      	ldr	r0, [pc, #64]	; (8008594 <SendReseive318+0x84>)
 8008554:	4b13      	ldr	r3, [pc, #76]	; (80085a4 <SendReseive318+0x94>)
 8008556:	4798      	blx	r3

		    vTaskDelay(100);
 8008558:	2064      	movs	r0, #100	; 0x64
 800855a:	4b10      	ldr	r3, [pc, #64]	; (800859c <SendReseive318+0x8c>)
 800855c:	4798      	blx	r3

			rs485size = uart3Read((uint8*) rs485buf, 256/*, 3000*/);
 800855e:	f44f 7180 	mov.w	r1, #256	; 0x100
 8008562:	4811      	ldr	r0, [pc, #68]	; (80085a8 <SendReseive318+0x98>)
 8008564:	4b11      	ldr	r3, [pc, #68]	; (80085ac <SendReseive318+0x9c>)
 8008566:	4798      	blx	r3
 8008568:	4603      	mov	r3, r0
 800856a:	b2da      	uxtb	r2, r3
 800856c:	4b08      	ldr	r3, [pc, #32]	; (8008590 <SendReseive318+0x80>)
 800856e:	701a      	strb	r2, [r3, #0]


		   if (rs485size != 0)
 8008570:	4b07      	ldr	r3, [pc, #28]	; (8008590 <SendReseive318+0x80>)
 8008572:	781b      	ldrb	r3, [r3, #0]
 8008574:	2b00      	cmp	r3, #0
 8008576:	d001      	beq.n	800857c <SendReseive318+0x6c>
		   {  //vTaskDelay(200);
			   return true;
 8008578:	2301      	movs	r3, #1
 800857a:	e005      	b.n	8008588 <SendReseive318+0x78>
		   	   }
		   else
			   {	vTaskDelay(2500);
 800857c:	f640 10c4 	movw	r0, #2500	; 0x9c4
 8008580:	4b06      	ldr	r3, [pc, #24]	; (800859c <SendReseive318+0x8c>)
 8008582:	4798      	blx	r3
			   	   return false;
 8008584:	2300      	movs	r3, #0
 8008586:	e7ff      	b.n	8008588 <SendReseive318+0x78>
			   }
			}


}
 8008588:	4618      	mov	r0, r3
 800858a:	3710      	adds	r7, #16
 800858c:	46bd      	mov	sp, r7
 800858e:	bd80      	pop	{r7, pc}
 8008590:	20007440 	.word	0x20007440
 8008594:	40011000 	.word	0x40011000
 8008598:	08002f6d 	.word	0x08002f6d
 800859c:	08001529 	.word	0x08001529
 80085a0:	08004ccd 	.word	0x08004ccd
 80085a4:	08002f89 	.word	0x08002f89
 80085a8:	200072c0 	.word	0x200072c0
 80085ac:	08004c71 	.word	0x08004c71

080085b0 <AskConunter318>:


bool AskConunter318()
{
 80085b0:	b580      	push	{r7, lr}
 80085b2:	b084      	sub	sp, #16
 80085b4:	af00      	add	r7, sp, #0
	FLASHMEM *pxConfig = (FLASHMEM*) DEVICE_FLASHMEM_LOCATION;
 80085b6:	4b8a      	ldr	r3, [pc, #552]	; (80087e0 <AskConunter318+0x230>)
 80085b8:	60bb      	str	r3, [r7, #8]
	uint8* buffer318;
	uint16 buffersize318;

	//MakeiFixUIP();

	MeterNumber = pxConfig->devcfg.MeterNum;
 80085ba:	68bb      	ldr	r3, [r7, #8]
 80085bc:	f8d3 3122 	ldr.w	r3, [r3, #290]	; 0x122
 80085c0:	4a88      	ldr	r2, [pc, #544]	; (80087e4 <AskConunter318+0x234>)
 80085c2:	6013      	str	r3, [r2, #0]

	for(int i=0;i<6;i++)
 80085c4:	2300      	movs	r3, #0
 80085c6:	60fb      	str	r3, [r7, #12]
 80085c8:	e009      	b.n	80085de <AskConunter318+0x2e>
					{
				    RAM.strings[0][i] = '7';
 80085ca:	4a87      	ldr	r2, [pc, #540]	; (80087e8 <AskConunter318+0x238>)
 80085cc:	68fb      	ldr	r3, [r7, #12]
 80085ce:	4413      	add	r3, r2
 80085d0:	f503 6382 	add.w	r3, r3, #1040	; 0x410
 80085d4:	2237      	movs	r2, #55	; 0x37
 80085d6:	701a      	strb	r2, [r3, #0]
	for(int i=0;i<6;i++)
 80085d8:	68fb      	ldr	r3, [r7, #12]
 80085da:	3301      	adds	r3, #1
 80085dc:	60fb      	str	r3, [r7, #12]
 80085de:	68fb      	ldr	r3, [r7, #12]
 80085e0:	2b05      	cmp	r3, #5
 80085e2:	ddf2      	ble.n	80085ca <AskConunter318+0x1a>
	if (!SendReseive318(rs485buf, buffersize318))
		return false;

	ParseAnswerNum(rs485buf, &RAM.strings[3][0]);*/

	itoa1(MeterNumber, &RAM.strings[3][0]); //  
 80085e4:	4b7f      	ldr	r3, [pc, #508]	; (80087e4 <AskConunter318+0x234>)
 80085e6:	681b      	ldr	r3, [r3, #0]
 80085e8:	4980      	ldr	r1, [pc, #512]	; (80087ec <AskConunter318+0x23c>)
 80085ea:	4618      	mov	r0, r3
 80085ec:	4b80      	ldr	r3, [pc, #512]	; (80087f0 <AskConunter318+0x240>)
 80085ee:	4798      	blx	r3


	buffersize318 = AskTime(rs485buf,MeterNumber);
 80085f0:	4b7c      	ldr	r3, [pc, #496]	; (80087e4 <AskConunter318+0x234>)
 80085f2:	681b      	ldr	r3, [r3, #0]
 80085f4:	4619      	mov	r1, r3
 80085f6:	487f      	ldr	r0, [pc, #508]	; (80087f4 <AskConunter318+0x244>)
 80085f8:	4b7f      	ldr	r3, [pc, #508]	; (80087f8 <AskConunter318+0x248>)
 80085fa:	4798      	blx	r3
 80085fc:	4603      	mov	r3, r0
 80085fe:	80fb      	strh	r3, [r7, #6]
		if (!SendReseive318(rs485buf, buffersize318))
 8008600:	88fb      	ldrh	r3, [r7, #6]
 8008602:	4619      	mov	r1, r3
 8008604:	487b      	ldr	r0, [pc, #492]	; (80087f4 <AskConunter318+0x244>)
 8008606:	4b7d      	ldr	r3, [pc, #500]	; (80087fc <AskConunter318+0x24c>)
 8008608:	4798      	blx	r3
 800860a:	4603      	mov	r3, r0
 800860c:	f083 0301 	eor.w	r3, r3, #1
 8008610:	b2db      	uxtb	r3, r3
 8008612:	2b00      	cmp	r3, #0
 8008614:	d001      	beq.n	800861a <AskConunter318+0x6a>
				return false;
 8008616:	2300      	movs	r3, #0
 8008618:	e144      	b.n	80088a4 <AskConunter318+0x2f4>

	ParseAnswerData(rs485buf, &RAM.strings[1][0], &RAM.strings[2][0]);
 800861a:	4a79      	ldr	r2, [pc, #484]	; (8008800 <AskConunter318+0x250>)
 800861c:	4979      	ldr	r1, [pc, #484]	; (8008804 <AskConunter318+0x254>)
 800861e:	4875      	ldr	r0, [pc, #468]	; (80087f4 <AskConunter318+0x244>)
 8008620:	4b79      	ldr	r3, [pc, #484]	; (8008808 <AskConunter318+0x258>)
 8008622:	4798      	blx	r3
//
	buffersize318 = AskVoltA(rs485buf,MeterNumber);
 8008624:	4b6f      	ldr	r3, [pc, #444]	; (80087e4 <AskConunter318+0x234>)
 8008626:	681b      	ldr	r3, [r3, #0]
 8008628:	4619      	mov	r1, r3
 800862a:	4872      	ldr	r0, [pc, #456]	; (80087f4 <AskConunter318+0x244>)
 800862c:	4b77      	ldr	r3, [pc, #476]	; (800880c <AskConunter318+0x25c>)
 800862e:	4798      	blx	r3
 8008630:	4603      	mov	r3, r0
 8008632:	80fb      	strh	r3, [r7, #6]
	if (!SendReseive318(rs485buf, buffersize318))
 8008634:	88fb      	ldrh	r3, [r7, #6]
 8008636:	4619      	mov	r1, r3
 8008638:	486e      	ldr	r0, [pc, #440]	; (80087f4 <AskConunter318+0x244>)
 800863a:	4b70      	ldr	r3, [pc, #448]	; (80087fc <AskConunter318+0x24c>)
 800863c:	4798      	blx	r3
 800863e:	4603      	mov	r3, r0
 8008640:	f083 0301 	eor.w	r3, r3, #1
 8008644:	b2db      	uxtb	r3, r3
 8008646:	2b00      	cmp	r3, #0
 8008648:	d001      	beq.n	800864e <AskConunter318+0x9e>
			return false;
 800864a:	2300      	movs	r3, #0
 800864c:	e12a      	b.n	80088a4 <AskConunter318+0x2f4>

	ParseAnswerVolt(rs485buf, &RAM.strings[8][0]);
 800864e:	4970      	ldr	r1, [pc, #448]	; (8008810 <AskConunter318+0x260>)
 8008650:	4868      	ldr	r0, [pc, #416]	; (80087f4 <AskConunter318+0x244>)
 8008652:	4b70      	ldr	r3, [pc, #448]	; (8008814 <AskConunter318+0x264>)
 8008654:	4798      	blx	r3

	buffersize318 = AskVoltB(rs485buf,MeterNumber);
 8008656:	4b63      	ldr	r3, [pc, #396]	; (80087e4 <AskConunter318+0x234>)
 8008658:	681b      	ldr	r3, [r3, #0]
 800865a:	4619      	mov	r1, r3
 800865c:	4865      	ldr	r0, [pc, #404]	; (80087f4 <AskConunter318+0x244>)
 800865e:	4b6e      	ldr	r3, [pc, #440]	; (8008818 <AskConunter318+0x268>)
 8008660:	4798      	blx	r3
 8008662:	4603      	mov	r3, r0
 8008664:	80fb      	strh	r3, [r7, #6]
	if (!SendReseive318(rs485buf, buffersize318))
 8008666:	88fb      	ldrh	r3, [r7, #6]
 8008668:	4619      	mov	r1, r3
 800866a:	4862      	ldr	r0, [pc, #392]	; (80087f4 <AskConunter318+0x244>)
 800866c:	4b63      	ldr	r3, [pc, #396]	; (80087fc <AskConunter318+0x24c>)
 800866e:	4798      	blx	r3
 8008670:	4603      	mov	r3, r0
 8008672:	f083 0301 	eor.w	r3, r3, #1
 8008676:	b2db      	uxtb	r3, r3
 8008678:	2b00      	cmp	r3, #0
 800867a:	d001      	beq.n	8008680 <AskConunter318+0xd0>
			return false;
 800867c:	2300      	movs	r3, #0
 800867e:	e111      	b.n	80088a4 <AskConunter318+0x2f4>

	ParseAnswerVolt(rs485buf, &RAM.strings[9][0]);
 8008680:	4966      	ldr	r1, [pc, #408]	; (800881c <AskConunter318+0x26c>)
 8008682:	485c      	ldr	r0, [pc, #368]	; (80087f4 <AskConunter318+0x244>)
 8008684:	4b63      	ldr	r3, [pc, #396]	; (8008814 <AskConunter318+0x264>)
 8008686:	4798      	blx	r3

	buffersize318 = AskVoltC(rs485buf,MeterNumber);
 8008688:	4b56      	ldr	r3, [pc, #344]	; (80087e4 <AskConunter318+0x234>)
 800868a:	681b      	ldr	r3, [r3, #0]
 800868c:	4619      	mov	r1, r3
 800868e:	4859      	ldr	r0, [pc, #356]	; (80087f4 <AskConunter318+0x244>)
 8008690:	4b63      	ldr	r3, [pc, #396]	; (8008820 <AskConunter318+0x270>)
 8008692:	4798      	blx	r3
 8008694:	4603      	mov	r3, r0
 8008696:	80fb      	strh	r3, [r7, #6]
	if (!SendReseive318(rs485buf, buffersize318))
 8008698:	88fb      	ldrh	r3, [r7, #6]
 800869a:	4619      	mov	r1, r3
 800869c:	4855      	ldr	r0, [pc, #340]	; (80087f4 <AskConunter318+0x244>)
 800869e:	4b57      	ldr	r3, [pc, #348]	; (80087fc <AskConunter318+0x24c>)
 80086a0:	4798      	blx	r3
 80086a2:	4603      	mov	r3, r0
 80086a4:	f083 0301 	eor.w	r3, r3, #1
 80086a8:	b2db      	uxtb	r3, r3
 80086aa:	2b00      	cmp	r3, #0
 80086ac:	d001      	beq.n	80086b2 <AskConunter318+0x102>
			return false;
 80086ae:	2300      	movs	r3, #0
 80086b0:	e0f8      	b.n	80088a4 <AskConunter318+0x2f4>

	ParseAnswerVolt(rs485buf,  &RAM.strings[10][0]);
 80086b2:	495c      	ldr	r1, [pc, #368]	; (8008824 <AskConunter318+0x274>)
 80086b4:	484f      	ldr	r0, [pc, #316]	; (80087f4 <AskConunter318+0x244>)
 80086b6:	4b57      	ldr	r3, [pc, #348]	; (8008814 <AskConunter318+0x264>)
 80086b8:	4798      	blx	r3
//
	buffersize318 = AskCurA(rs485buf,MeterNumber);
 80086ba:	4b4a      	ldr	r3, [pc, #296]	; (80087e4 <AskConunter318+0x234>)
 80086bc:	681b      	ldr	r3, [r3, #0]
 80086be:	4619      	mov	r1, r3
 80086c0:	484c      	ldr	r0, [pc, #304]	; (80087f4 <AskConunter318+0x244>)
 80086c2:	4b59      	ldr	r3, [pc, #356]	; (8008828 <AskConunter318+0x278>)
 80086c4:	4798      	blx	r3
 80086c6:	4603      	mov	r3, r0
 80086c8:	80fb      	strh	r3, [r7, #6]
	if (!SendReseive318(rs485buf, buffersize318))
 80086ca:	88fb      	ldrh	r3, [r7, #6]
 80086cc:	4619      	mov	r1, r3
 80086ce:	4849      	ldr	r0, [pc, #292]	; (80087f4 <AskConunter318+0x244>)
 80086d0:	4b4a      	ldr	r3, [pc, #296]	; (80087fc <AskConunter318+0x24c>)
 80086d2:	4798      	blx	r3
 80086d4:	4603      	mov	r3, r0
 80086d6:	f083 0301 	eor.w	r3, r3, #1
 80086da:	b2db      	uxtb	r3, r3
 80086dc:	2b00      	cmp	r3, #0
 80086de:	d001      	beq.n	80086e4 <AskConunter318+0x134>
			return false;
 80086e0:	2300      	movs	r3, #0
 80086e2:	e0df      	b.n	80088a4 <AskConunter318+0x2f4>

	ParseAnswerCur(rs485buf, &RAM.strings[11][0]);
 80086e4:	4951      	ldr	r1, [pc, #324]	; (800882c <AskConunter318+0x27c>)
 80086e6:	4843      	ldr	r0, [pc, #268]	; (80087f4 <AskConunter318+0x244>)
 80086e8:	4b51      	ldr	r3, [pc, #324]	; (8008830 <AskConunter318+0x280>)
 80086ea:	4798      	blx	r3

	buffersize318 = AskCurB(rs485buf,MeterNumber);
 80086ec:	4b3d      	ldr	r3, [pc, #244]	; (80087e4 <AskConunter318+0x234>)
 80086ee:	681b      	ldr	r3, [r3, #0]
 80086f0:	4619      	mov	r1, r3
 80086f2:	4840      	ldr	r0, [pc, #256]	; (80087f4 <AskConunter318+0x244>)
 80086f4:	4b4f      	ldr	r3, [pc, #316]	; (8008834 <AskConunter318+0x284>)
 80086f6:	4798      	blx	r3
 80086f8:	4603      	mov	r3, r0
 80086fa:	80fb      	strh	r3, [r7, #6]
	if (!SendReseive318(rs485buf, buffersize318))
 80086fc:	88fb      	ldrh	r3, [r7, #6]
 80086fe:	4619      	mov	r1, r3
 8008700:	483c      	ldr	r0, [pc, #240]	; (80087f4 <AskConunter318+0x244>)
 8008702:	4b3e      	ldr	r3, [pc, #248]	; (80087fc <AskConunter318+0x24c>)
 8008704:	4798      	blx	r3
 8008706:	4603      	mov	r3, r0
 8008708:	f083 0301 	eor.w	r3, r3, #1
 800870c:	b2db      	uxtb	r3, r3
 800870e:	2b00      	cmp	r3, #0
 8008710:	d001      	beq.n	8008716 <AskConunter318+0x166>
			return false;
 8008712:	2300      	movs	r3, #0
 8008714:	e0c6      	b.n	80088a4 <AskConunter318+0x2f4>

	ParseAnswerCur(rs485buf, &RAM.strings[12][0]);
 8008716:	4948      	ldr	r1, [pc, #288]	; (8008838 <AskConunter318+0x288>)
 8008718:	4836      	ldr	r0, [pc, #216]	; (80087f4 <AskConunter318+0x244>)
 800871a:	4b45      	ldr	r3, [pc, #276]	; (8008830 <AskConunter318+0x280>)
 800871c:	4798      	blx	r3

	buffersize318 = AskCurC(rs485buf,MeterNumber);
 800871e:	4b31      	ldr	r3, [pc, #196]	; (80087e4 <AskConunter318+0x234>)
 8008720:	681b      	ldr	r3, [r3, #0]
 8008722:	4619      	mov	r1, r3
 8008724:	4833      	ldr	r0, [pc, #204]	; (80087f4 <AskConunter318+0x244>)
 8008726:	4b45      	ldr	r3, [pc, #276]	; (800883c <AskConunter318+0x28c>)
 8008728:	4798      	blx	r3
 800872a:	4603      	mov	r3, r0
 800872c:	80fb      	strh	r3, [r7, #6]
	if (!SendReseive318(rs485buf, buffersize318))
 800872e:	88fb      	ldrh	r3, [r7, #6]
 8008730:	4619      	mov	r1, r3
 8008732:	4830      	ldr	r0, [pc, #192]	; (80087f4 <AskConunter318+0x244>)
 8008734:	4b31      	ldr	r3, [pc, #196]	; (80087fc <AskConunter318+0x24c>)
 8008736:	4798      	blx	r3
 8008738:	4603      	mov	r3, r0
 800873a:	f083 0301 	eor.w	r3, r3, #1
 800873e:	b2db      	uxtb	r3, r3
 8008740:	2b00      	cmp	r3, #0
 8008742:	d001      	beq.n	8008748 <AskConunter318+0x198>
			return false;
 8008744:	2300      	movs	r3, #0
 8008746:	e0ad      	b.n	80088a4 <AskConunter318+0x2f4>

	ParseAnswerCur(rs485buf,  &RAM.strings[13][0]);
 8008748:	493d      	ldr	r1, [pc, #244]	; (8008840 <AskConunter318+0x290>)
 800874a:	482a      	ldr	r0, [pc, #168]	; (80087f4 <AskConunter318+0x244>)
 800874c:	4b38      	ldr	r3, [pc, #224]	; (8008830 <AskConunter318+0x280>)
 800874e:	4798      	blx	r3

//
	buffersize318 = AskPowA(rs485buf,MeterNumber);
 8008750:	4b24      	ldr	r3, [pc, #144]	; (80087e4 <AskConunter318+0x234>)
 8008752:	681b      	ldr	r3, [r3, #0]
 8008754:	4619      	mov	r1, r3
 8008756:	4827      	ldr	r0, [pc, #156]	; (80087f4 <AskConunter318+0x244>)
 8008758:	4b3a      	ldr	r3, [pc, #232]	; (8008844 <AskConunter318+0x294>)
 800875a:	4798      	blx	r3
 800875c:	4603      	mov	r3, r0
 800875e:	80fb      	strh	r3, [r7, #6]
	if (!SendReseive318(rs485buf, buffersize318))
 8008760:	88fb      	ldrh	r3, [r7, #6]
 8008762:	4619      	mov	r1, r3
 8008764:	4823      	ldr	r0, [pc, #140]	; (80087f4 <AskConunter318+0x244>)
 8008766:	4b25      	ldr	r3, [pc, #148]	; (80087fc <AskConunter318+0x24c>)
 8008768:	4798      	blx	r3
 800876a:	4603      	mov	r3, r0
 800876c:	f083 0301 	eor.w	r3, r3, #1
 8008770:	b2db      	uxtb	r3, r3
 8008772:	2b00      	cmp	r3, #0
 8008774:	d001      	beq.n	800877a <AskConunter318+0x1ca>
			return false;
 8008776:	2300      	movs	r3, #0
 8008778:	e094      	b.n	80088a4 <AskConunter318+0x2f4>

	ParseAnswerPow(rs485buf, &RAM.strings[5][0]);
 800877a:	4933      	ldr	r1, [pc, #204]	; (8008848 <AskConunter318+0x298>)
 800877c:	481d      	ldr	r0, [pc, #116]	; (80087f4 <AskConunter318+0x244>)
 800877e:	4b33      	ldr	r3, [pc, #204]	; (800884c <AskConunter318+0x29c>)
 8008780:	4798      	blx	r3

	buffersize318 = AskPowB(rs485buf,MeterNumber);
 8008782:	4b18      	ldr	r3, [pc, #96]	; (80087e4 <AskConunter318+0x234>)
 8008784:	681b      	ldr	r3, [r3, #0]
 8008786:	4619      	mov	r1, r3
 8008788:	481a      	ldr	r0, [pc, #104]	; (80087f4 <AskConunter318+0x244>)
 800878a:	4b31      	ldr	r3, [pc, #196]	; (8008850 <AskConunter318+0x2a0>)
 800878c:	4798      	blx	r3
 800878e:	4603      	mov	r3, r0
 8008790:	80fb      	strh	r3, [r7, #6]
	if (!SendReseive318(rs485buf, buffersize318))
 8008792:	88fb      	ldrh	r3, [r7, #6]
 8008794:	4619      	mov	r1, r3
 8008796:	4817      	ldr	r0, [pc, #92]	; (80087f4 <AskConunter318+0x244>)
 8008798:	4b18      	ldr	r3, [pc, #96]	; (80087fc <AskConunter318+0x24c>)
 800879a:	4798      	blx	r3
 800879c:	4603      	mov	r3, r0
 800879e:	f083 0301 	eor.w	r3, r3, #1
 80087a2:	b2db      	uxtb	r3, r3
 80087a4:	2b00      	cmp	r3, #0
 80087a6:	d001      	beq.n	80087ac <AskConunter318+0x1fc>
			return false;
 80087a8:	2300      	movs	r3, #0
 80087aa:	e07b      	b.n	80088a4 <AskConunter318+0x2f4>

	ParseAnswerPow(rs485buf, &RAM.strings[6][0]);
 80087ac:	4929      	ldr	r1, [pc, #164]	; (8008854 <AskConunter318+0x2a4>)
 80087ae:	4811      	ldr	r0, [pc, #68]	; (80087f4 <AskConunter318+0x244>)
 80087b0:	4b26      	ldr	r3, [pc, #152]	; (800884c <AskConunter318+0x29c>)
 80087b2:	4798      	blx	r3

	buffersize318 = AskPowC(rs485buf,MeterNumber);
 80087b4:	4b0b      	ldr	r3, [pc, #44]	; (80087e4 <AskConunter318+0x234>)
 80087b6:	681b      	ldr	r3, [r3, #0]
 80087b8:	4619      	mov	r1, r3
 80087ba:	480e      	ldr	r0, [pc, #56]	; (80087f4 <AskConunter318+0x244>)
 80087bc:	4b26      	ldr	r3, [pc, #152]	; (8008858 <AskConunter318+0x2a8>)
 80087be:	4798      	blx	r3
 80087c0:	4603      	mov	r3, r0
 80087c2:	80fb      	strh	r3, [r7, #6]
	if (!SendReseive318(rs485buf, buffersize318))
 80087c4:	88fb      	ldrh	r3, [r7, #6]
 80087c6:	4619      	mov	r1, r3
 80087c8:	480a      	ldr	r0, [pc, #40]	; (80087f4 <AskConunter318+0x244>)
 80087ca:	4b0c      	ldr	r3, [pc, #48]	; (80087fc <AskConunter318+0x24c>)
 80087cc:	4798      	blx	r3
 80087ce:	4603      	mov	r3, r0
 80087d0:	f083 0301 	eor.w	r3, r3, #1
 80087d4:	b2db      	uxtb	r3, r3
 80087d6:	2b00      	cmp	r3, #0
 80087d8:	d040      	beq.n	800885c <AskConunter318+0x2ac>
			return false;
 80087da:	2300      	movs	r3, #0
 80087dc:	e062      	b.n	80088a4 <AskConunter318+0x2f4>
 80087de:	bf00      	nop
 80087e0:	0802b000 	.word	0x0802b000
 80087e4:	20007458 	.word	0x20007458
 80087e8:	2000745c 	.word	0x2000745c
 80087ec:	2000789c 	.word	0x2000789c
 80087f0:	0800e895 	.word	0x0800e895
 80087f4:	200072c0 	.word	0x200072c0
 80087f8:	0800a46d 	.word	0x0800a46d
 80087fc:	08008511 	.word	0x08008511
 8008800:	2000788c 	.word	0x2000788c
 8008804:	2000787c 	.word	0x2000787c
 8008808:	0800a8c5 	.word	0x0800a8c5
 800880c:	08009371 	.word	0x08009371
 8008810:	200078ec 	.word	0x200078ec
 8008814:	0800ab11 	.word	0x0800ab11
 8008818:	08009521 	.word	0x08009521
 800881c:	200078fc 	.word	0x200078fc
 8008820:	080096d1 	.word	0x080096d1
 8008824:	2000790c 	.word	0x2000790c
 8008828:	08009881 	.word	0x08009881
 800882c:	2000791c 	.word	0x2000791c
 8008830:	0800ac29 	.word	0x0800ac29
 8008834:	08009a31 	.word	0x08009a31
 8008838:	2000792c 	.word	0x2000792c
 800883c:	08009be1 	.word	0x08009be1
 8008840:	2000793c 	.word	0x2000793c
 8008844:	08009d91 	.word	0x08009d91
 8008848:	200078bc 	.word	0x200078bc
 800884c:	0800ad41 	.word	0x0800ad41
 8008850:	08009f41 	.word	0x08009f41
 8008854:	200078cc 	.word	0x200078cc
 8008858:	0800a0f1 	.word	0x0800a0f1

	ParseAnswerPow(rs485buf, &RAM.strings[7][0]);
 800885c:	4913      	ldr	r1, [pc, #76]	; (80088ac <AskConunter318+0x2fc>)
 800885e:	4814      	ldr	r0, [pc, #80]	; (80088b0 <AskConunter318+0x300>)
 8008860:	4b14      	ldr	r3, [pc, #80]	; (80088b4 <AskConunter318+0x304>)
 8008862:	4798      	blx	r3
//

	buffersize318 = AskEnerge(rs485buf,MeterNumber);
 8008864:	4b14      	ldr	r3, [pc, #80]	; (80088b8 <AskConunter318+0x308>)
 8008866:	681b      	ldr	r3, [r3, #0]
 8008868:	4619      	mov	r1, r3
 800886a:	4811      	ldr	r0, [pc, #68]	; (80088b0 <AskConunter318+0x300>)
 800886c:	4b13      	ldr	r3, [pc, #76]	; (80088bc <AskConunter318+0x30c>)
 800886e:	4798      	blx	r3
 8008870:	4603      	mov	r3, r0
 8008872:	80fb      	strh	r3, [r7, #6]
	if (!SendReseive318(rs485buf, buffersize318))
 8008874:	88fb      	ldrh	r3, [r7, #6]
 8008876:	4619      	mov	r1, r3
 8008878:	480d      	ldr	r0, [pc, #52]	; (80088b0 <AskConunter318+0x300>)
 800887a:	4b11      	ldr	r3, [pc, #68]	; (80088c0 <AskConunter318+0x310>)
 800887c:	4798      	blx	r3
 800887e:	4603      	mov	r3, r0
 8008880:	f083 0301 	eor.w	r3, r3, #1
 8008884:	b2db      	uxtb	r3, r3
 8008886:	2b00      	cmp	r3, #0
 8008888:	d001      	beq.n	800888e <AskConunter318+0x2de>
			return false;
 800888a:	2300      	movs	r3, #0
 800888c:	e00a      	b.n	80088a4 <AskConunter318+0x2f4>

	ParseAnswerEnerge(rs485buf,  &RAM.strings[15][0]);
 800888e:	490d      	ldr	r1, [pc, #52]	; (80088c4 <AskConunter318+0x314>)
 8008890:	4807      	ldr	r0, [pc, #28]	; (80088b0 <AskConunter318+0x300>)
 8008892:	4b0d      	ldr	r3, [pc, #52]	; (80088c8 <AskConunter318+0x318>)
 8008894:	4798      	blx	r3
	ParseAnswerEnerge(rs485buf,  &RAM.strings[4][0]);
 8008896:	490d      	ldr	r1, [pc, #52]	; (80088cc <AskConunter318+0x31c>)
 8008898:	4805      	ldr	r0, [pc, #20]	; (80088b0 <AskConunter318+0x300>)
 800889a:	4b0b      	ldr	r3, [pc, #44]	; (80088c8 <AskConunter318+0x318>)
 800889c:	4798      	blx	r3

	MakeiFixUIP();
 800889e:	4b0c      	ldr	r3, [pc, #48]	; (80088d0 <AskConunter318+0x320>)
 80088a0:	4798      	blx	r3
	return true;
 80088a2:	2301      	movs	r3, #1
}
 80088a4:	4618      	mov	r0, r3
 80088a6:	3710      	adds	r7, #16
 80088a8:	46bd      	mov	sp, r7
 80088aa:	bd80      	pop	{r7, pc}
 80088ac:	200078dc 	.word	0x200078dc
 80088b0:	200072c0 	.word	0x200072c0
 80088b4:	0800ad41 	.word	0x0800ad41
 80088b8:	20007458 	.word	0x20007458
 80088bc:	0800a2a1 	.word	0x0800a2a1
 80088c0:	08008511 	.word	0x08008511
 80088c4:	2000795c 	.word	0x2000795c
 80088c8:	0800ae59 	.word	0x0800ae59
 80088cc:	200078ac 	.word	0x200078ac
 80088d0:	08007be9 	.word	0x08007be9

080088d4 <vRs485Task>:


void vRs485Task(void *pvParameters)
{
 80088d4:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
 80088d8:	b08a      	sub	sp, #40	; 0x28
 80088da:	af00      	add	r7, sp, #0
 80088dc:	6078      	str	r0, [r7, #4]
	FLASHMEM *pxConfig = (FLASHMEM*) DEVICE_FLASHMEM_LOCATION;
 80088de:	4b97      	ldr	r3, [pc, #604]	; (8008b3c <vRs485Task+0x268>)
 80088e0:	61bb      	str	r3, [r7, #24]
	//vTaskDelay(500);
	int bufsize = 512;
 80088e2:	f44f 7300 	mov.w	r3, #512	; 0x200
 80088e6:	617b      	str	r3, [r7, #20]
	uint8 buffer[bufsize];
 80088e8:	6979      	ldr	r1, [r7, #20]
 80088ea:	1e4b      	subs	r3, r1, #1
 80088ec:	613b      	str	r3, [r7, #16]
 80088ee:	460a      	mov	r2, r1
 80088f0:	2300      	movs	r3, #0
 80088f2:	4690      	mov	r8, r2
 80088f4:	4699      	mov	r9, r3
 80088f6:	f04f 0200 	mov.w	r2, #0
 80088fa:	f04f 0300 	mov.w	r3, #0
 80088fe:	ea4f 03c9 	mov.w	r3, r9, lsl #3
 8008902:	ea43 7358 	orr.w	r3, r3, r8, lsr #29
 8008906:	ea4f 02c8 	mov.w	r2, r8, lsl #3
 800890a:	460a      	mov	r2, r1
 800890c:	2300      	movs	r3, #0
 800890e:	4614      	mov	r4, r2
 8008910:	461d      	mov	r5, r3
 8008912:	f04f 0200 	mov.w	r2, #0
 8008916:	f04f 0300 	mov.w	r3, #0
 800891a:	00eb      	lsls	r3, r5, #3
 800891c:	ea43 7354 	orr.w	r3, r3, r4, lsr #29
 8008920:	00e2      	lsls	r2, r4, #3
 8008922:	460b      	mov	r3, r1
 8008924:	3307      	adds	r3, #7
 8008926:	08db      	lsrs	r3, r3, #3
 8008928:	00db      	lsls	r3, r3, #3
 800892a:	ebad 0d03 	sub.w	sp, sp, r3
 800892e:	466b      	mov	r3, sp
 8008930:	3300      	adds	r3, #0
 8008932:	60fb      	str	r3, [r7, #12]
	int MeterType = 0;
 8008934:	2300      	movs	r3, #0
 8008936:	627b      	str	r3, [r7, #36]	; 0x24
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
	GPIO_Init(GPIOC, &GPIO_InitStructure);*/

	MeterType = pxConfig->devcfg.MeterType;
 8008938:	69bb      	ldr	r3, [r7, #24]
 800893a:	f8b3 3120 	ldrh.w	r3, [r3, #288]	; 0x120
 800893e:	b29b      	uxth	r3, r3
 8008940:	627b      	str	r3, [r7, #36]	; 0x24

	if ((MeterType == 1)||(MeterType == 0xFFFF)) // CE301BY
 8008942:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8008944:	2b01      	cmp	r3, #1
 8008946:	d004      	beq.n	8008952 <vRs485Task+0x7e>
 8008948:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800894a:	f64f 72ff 	movw	r2, #65535	; 0xffff
 800894e:	4293      	cmp	r3, r2
 8008950:	d104      	bne.n	800895c <vRs485Task+0x88>
	{
		/*uart3Init(4800);*/uart3Init(9600);
 8008952:	f44f 5016 	mov.w	r0, #9600	; 0x2580
 8008956:	4b7a      	ldr	r3, [pc, #488]	; (8008b40 <vRs485Task+0x26c>)
 8008958:	4798      	blx	r3
 800895a:	e01a      	b.n	8008992 <vRs485Task+0xbe>
	} else
		if (MeterType == 2) // CE318BY
 800895c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800895e:	2b02      	cmp	r3, #2
 8008960:	d114      	bne.n	800898c <vRs485Task+0xb8>
			{
			for(int i=0;i<6;i++)
 8008962:	2300      	movs	r3, #0
 8008964:	623b      	str	r3, [r7, #32]
 8008966:	e009      	b.n	800897c <vRs485Task+0xa8>
				{
			    RAM.strings[0][i] = '7';
 8008968:	4a76      	ldr	r2, [pc, #472]	; (8008b44 <vRs485Task+0x270>)
 800896a:	6a3b      	ldr	r3, [r7, #32]
 800896c:	4413      	add	r3, r2
 800896e:	f503 6382 	add.w	r3, r3, #1040	; 0x410
 8008972:	2237      	movs	r2, #55	; 0x37
 8008974:	701a      	strb	r2, [r3, #0]
			for(int i=0;i<6;i++)
 8008976:	6a3b      	ldr	r3, [r7, #32]
 8008978:	3301      	adds	r3, #1
 800897a:	623b      	str	r3, [r7, #32]
 800897c:	6a3b      	ldr	r3, [r7, #32]
 800897e:	2b05      	cmp	r3, #5
 8008980:	ddf2      	ble.n	8008968 <vRs485Task+0x94>
				}
				uart3Init(4800);
 8008982:	f44f 5096 	mov.w	r0, #4800	; 0x12c0
 8008986:	4b6e      	ldr	r3, [pc, #440]	; (8008b40 <vRs485Task+0x26c>)
 8008988:	4798      	blx	r3
 800898a:	e002      	b.n	8008992 <vRs485Task+0xbe>
			}
		else
		{
			USART_DeInit(UART4);
 800898c:	486e      	ldr	r0, [pc, #440]	; (8008b48 <vRs485Task+0x274>)
 800898e:	4b6f      	ldr	r3, [pc, #444]	; (8008b4c <vRs485Task+0x278>)
 8008990:	4798      	blx	r3
	buffer[1]='A';
	buffer[2]='R';
	buffer[3]='E';
	buffer[4]='F';*/

	GPIO_ResetBits(GPIOC, GPIO_Pin_12);
 8008992:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8008996:	486e      	ldr	r0, [pc, #440]	; (8008b50 <vRs485Task+0x27c>)
 8008998:	4b6e      	ldr	r3, [pc, #440]	; (8008b54 <vRs485Task+0x280>)
 800899a:	4798      	blx	r3
	int heapSize = 0;
 800899c:	2300      	movs	r3, #0
 800899e:	60bb      	str	r3, [r7, #8]

		while (1)
			{

			heapSize = xPortGetFreeHeapSize();
 80089a0:	4b6d      	ldr	r3, [pc, #436]	; (8008b58 <vRs485Task+0x284>)
 80089a2:	4798      	blx	r3
 80089a4:	4603      	mov	r3, r0
 80089a6:	60bb      	str	r3, [r7, #8]
			heapSize +=0;


			while ((pxConfig->devcfg.MeterType == 1)||(pxConfig->devcfg.MeterType == 0xFFFF)) // CE301BY
 80089a8:	e055      	b.n	8008a56 <vRs485Task+0x182>
				{

				IWDG_ReloadCounter();
 80089aa:	4b6c      	ldr	r3, [pc, #432]	; (8008b5c <vRs485Task+0x288>)
 80089ac:	4798      	blx	r3

				if (MeterType != pxConfig->devcfg.MeterType) //  
 80089ae:	69bb      	ldr	r3, [r7, #24]
 80089b0:	f8b3 3120 	ldrh.w	r3, [r3, #288]	; 0x120
 80089b4:	b29b      	uxth	r3, r3
 80089b6:	461a      	mov	r2, r3
 80089b8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80089ba:	4293      	cmp	r3, r2
 80089bc:	d018      	beq.n	80089f0 <vRs485Task+0x11c>
							{
								MeterType = pxConfig->devcfg.MeterType;
 80089be:	69bb      	ldr	r3, [r7, #24]
 80089c0:	f8b3 3120 	ldrh.w	r3, [r3, #288]	; 0x120
 80089c4:	b29b      	uxth	r3, r3
 80089c6:	627b      	str	r3, [r7, #36]	; 0x24

									if ((MeterType == 1)||(MeterType == 0xFFFF)) // CE301BY
 80089c8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80089ca:	2b01      	cmp	r3, #1
 80089cc:	d005      	beq.n	80089da <vRs485Task+0x106>
 80089ce:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80089d0:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80089d4:	4293      	cmp	r3, r2
 80089d6:	f040 8088 	bne.w	8008aea <vRs485Task+0x216>
									{
										ClearUIPData();
 80089da:	4b61      	ldr	r3, [pc, #388]	; (8008b60 <vRs485Task+0x28c>)
 80089dc:	4798      	blx	r3

										/*uart3Init(4800);*/uart3Init(9600);
 80089de:	f44f 5016 	mov.w	r0, #9600	; 0x2580
 80089e2:	4b57      	ldr	r3, [pc, #348]	; (8008b40 <vRs485Task+0x26c>)
 80089e4:	4798      	blx	r3

									}
										else break;
									GPIO_ResetBits(GPIOC, GPIO_Pin_12);
 80089e6:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 80089ea:	4859      	ldr	r0, [pc, #356]	; (8008b50 <vRs485Task+0x27c>)
 80089ec:	4b59      	ldr	r3, [pc, #356]	; (8008b54 <vRs485Task+0x280>)
 80089ee:	4798      	blx	r3

							}
				if (AskConunter())
 80089f0:	4b5c      	ldr	r3, [pc, #368]	; (8008b64 <vRs485Task+0x290>)
 80089f2:	4798      	blx	r3
 80089f4:	4603      	mov	r3, r0
 80089f6:	2b00      	cmp	r3, #0
 80089f8:	d003      	beq.n	8008a02 <vRs485Task+0x12e>
			    	{
					vTaskDelay(100);
 80089fa:	2064      	movs	r0, #100	; 0x64
 80089fc:	4b5a      	ldr	r3, [pc, #360]	; (8008b68 <vRs485Task+0x294>)
 80089fe:	4798      	blx	r3
 8008a00:	e029      	b.n	8008a56 <vRs485Task+0x182>

			    	}
				else
					{
				//ClearUIPData();
					IWDG_ReloadCounter();
 8008a02:	4b56      	ldr	r3, [pc, #344]	; (8008b5c <vRs485Task+0x288>)
 8008a04:	4798      	blx	r3
					rs485size = iecProcExitPacket(rs485buf);
 8008a06:	4859      	ldr	r0, [pc, #356]	; (8008b6c <vRs485Task+0x298>)
 8008a08:	4b59      	ldr	r3, [pc, #356]	; (8008b70 <vRs485Task+0x29c>)
 8008a0a:	4798      	blx	r3
 8008a0c:	4603      	mov	r3, r0
 8008a0e:	b2da      	uxtb	r2, r3
 8008a10:	4b58      	ldr	r3, [pc, #352]	; (8008b74 <vRs485Task+0x2a0>)
 8008a12:	701a      	strb	r2, [r3, #0]
					GPIO_SetBits(GPIOC, GPIO_Pin_12);
 8008a14:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8008a18:	484d      	ldr	r0, [pc, #308]	; (8008b50 <vRs485Task+0x27c>)
 8008a1a:	4b57      	ldr	r3, [pc, #348]	; (8008b78 <vRs485Task+0x2a4>)
 8008a1c:	4798      	blx	r3
					vTaskDelay(5);
 8008a1e:	2005      	movs	r0, #5
 8008a20:	4b51      	ldr	r3, [pc, #324]	; (8008b68 <vRs485Task+0x294>)
 8008a22:	4798      	blx	r3
					processBuffer8to7(rs485buf,rs485size);
 8008a24:	4b53      	ldr	r3, [pc, #332]	; (8008b74 <vRs485Task+0x2a0>)
 8008a26:	781b      	ldrb	r3, [r3, #0]
 8008a28:	b29b      	uxth	r3, r3
 8008a2a:	4619      	mov	r1, r3
 8008a2c:	484f      	ldr	r0, [pc, #316]	; (8008b6c <vRs485Task+0x298>)
 8008a2e:	4b53      	ldr	r3, [pc, #332]	; (8008b7c <vRs485Task+0x2a8>)
 8008a30:	4798      	blx	r3
					uart3Write ((uint8*) rs485buf, rs485size);
 8008a32:	4b50      	ldr	r3, [pc, #320]	; (8008b74 <vRs485Task+0x2a0>)
 8008a34:	781b      	ldrb	r3, [r3, #0]
 8008a36:	4619      	mov	r1, r3
 8008a38:	484c      	ldr	r0, [pc, #304]	; (8008b6c <vRs485Task+0x298>)
 8008a3a:	4b51      	ldr	r3, [pc, #324]	; (8008b80 <vRs485Task+0x2ac>)
 8008a3c:	4798      	blx	r3
					vTaskDelay(30);
 8008a3e:	201e      	movs	r0, #30
 8008a40:	4b49      	ldr	r3, [pc, #292]	; (8008b68 <vRs485Task+0x294>)
 8008a42:	4798      	blx	r3
					GPIO_ResetBits(GPIOC, GPIO_Pin_12);
 8008a44:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8008a48:	4841      	ldr	r0, [pc, #260]	; (8008b50 <vRs485Task+0x27c>)
 8008a4a:	4b42      	ldr	r3, [pc, #264]	; (8008b54 <vRs485Task+0x280>)
 8008a4c:	4798      	blx	r3
					vTaskDelay(500);
 8008a4e:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8008a52:	4b45      	ldr	r3, [pc, #276]	; (8008b68 <vRs485Task+0x294>)
 8008a54:	4798      	blx	r3
			while ((pxConfig->devcfg.MeterType == 1)||(pxConfig->devcfg.MeterType == 0xFFFF)) // CE301BY
 8008a56:	69bb      	ldr	r3, [r7, #24]
 8008a58:	f8b3 3120 	ldrh.w	r3, [r3, #288]	; 0x120
 8008a5c:	b29b      	uxth	r3, r3
 8008a5e:	2b01      	cmp	r3, #1
 8008a60:	d0a3      	beq.n	80089aa <vRs485Task+0xd6>
 8008a62:	69bb      	ldr	r3, [r7, #24]
 8008a64:	f8b3 3120 	ldrh.w	r3, [r3, #288]	; 0x120
 8008a68:	b29b      	uxth	r3, r3
 8008a6a:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8008a6e:	4293      	cmp	r3, r2
 8008a70:	d09b      	beq.n	80089aa <vRs485Task+0xd6>
					}
				}

					while (pxConfig->devcfg.MeterType == 2) // CE318BY
 8008a72:	e03a      	b.n	8008aea <vRs485Task+0x216>
									{
						IWDG_ReloadCounter();
 8008a74:	4b39      	ldr	r3, [pc, #228]	; (8008b5c <vRs485Task+0x288>)
 8008a76:	4798      	blx	r3

						if (MeterType != pxConfig->devcfg.MeterType) //  
 8008a78:	69bb      	ldr	r3, [r7, #24]
 8008a7a:	f8b3 3120 	ldrh.w	r3, [r3, #288]	; 0x120
 8008a7e:	b29b      	uxth	r3, r3
 8008a80:	461a      	mov	r2, r3
 8008a82:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8008a84:	4293      	cmp	r3, r2
 8008a86:	d022      	beq.n	8008ace <vRs485Task+0x1fa>
									{
										MeterType = pxConfig->devcfg.MeterType;
 8008a88:	69bb      	ldr	r3, [r7, #24]
 8008a8a:	f8b3 3120 	ldrh.w	r3, [r3, #288]	; 0x120
 8008a8e:	b29b      	uxth	r3, r3
 8008a90:	627b      	str	r3, [r7, #36]	; 0x24

												if (MeterType == 2) // CE318BY
 8008a92:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8008a94:	2b02      	cmp	r3, #2
 8008a96:	d12f      	bne.n	8008af8 <vRs485Task+0x224>
													{
													    ClearUIPData();
 8008a98:	4b31      	ldr	r3, [pc, #196]	; (8008b60 <vRs485Task+0x28c>)
 8008a9a:	4798      	blx	r3
													    for(int i=0;i<6;i++)
 8008a9c:	2300      	movs	r3, #0
 8008a9e:	61fb      	str	r3, [r7, #28]
 8008aa0:	e009      	b.n	8008ab6 <vRs485Task+0x1e2>
													    				{
													    			    RAM.strings[0][i] = '7';
 8008aa2:	4a28      	ldr	r2, [pc, #160]	; (8008b44 <vRs485Task+0x270>)
 8008aa4:	69fb      	ldr	r3, [r7, #28]
 8008aa6:	4413      	add	r3, r2
 8008aa8:	f503 6382 	add.w	r3, r3, #1040	; 0x410
 8008aac:	2237      	movs	r2, #55	; 0x37
 8008aae:	701a      	strb	r2, [r3, #0]
													    for(int i=0;i<6;i++)
 8008ab0:	69fb      	ldr	r3, [r7, #28]
 8008ab2:	3301      	adds	r3, #1
 8008ab4:	61fb      	str	r3, [r7, #28]
 8008ab6:	69fb      	ldr	r3, [r7, #28]
 8008ab8:	2b05      	cmp	r3, #5
 8008aba:	ddf2      	ble.n	8008aa2 <vRs485Task+0x1ce>
													    				}
														uart3Init(4800);
 8008abc:	f44f 5096 	mov.w	r0, #4800	; 0x12c0
 8008ac0:	4b1f      	ldr	r3, [pc, #124]	; (8008b40 <vRs485Task+0x26c>)
 8008ac2:	4798      	blx	r3
													}
												else break;
											GPIO_ResetBits(GPIOC, GPIO_Pin_12);
 8008ac4:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8008ac8:	4821      	ldr	r0, [pc, #132]	; (8008b50 <vRs485Task+0x27c>)
 8008aca:	4b22      	ldr	r3, [pc, #136]	; (8008b54 <vRs485Task+0x280>)
 8008acc:	4798      	blx	r3
									}
										if (AskConunter318())
 8008ace:	4b2d      	ldr	r3, [pc, #180]	; (8008b84 <vRs485Task+0x2b0>)
 8008ad0:	4798      	blx	r3
 8008ad2:	4603      	mov	r3, r0
 8008ad4:	2b00      	cmp	r3, #0
 8008ad6:	d004      	beq.n	8008ae2 <vRs485Task+0x20e>
									    	{
											vTaskDelay(1000);
 8008ad8:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8008adc:	4b22      	ldr	r3, [pc, #136]	; (8008b68 <vRs485Task+0x294>)
 8008ade:	4798      	blx	r3
 8008ae0:	e003      	b.n	8008aea <vRs485Task+0x216>
									    	}else
									    	{vTaskDelay(1000);}
 8008ae2:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8008ae6:	4b20      	ldr	r3, [pc, #128]	; (8008b68 <vRs485Task+0x294>)
 8008ae8:	4798      	blx	r3
					while (pxConfig->devcfg.MeterType == 2) // CE318BY
 8008aea:	69bb      	ldr	r3, [r7, #24]
 8008aec:	f8b3 3120 	ldrh.w	r3, [r3, #288]	; 0x120
 8008af0:	b29b      	uxth	r3, r3
 8008af2:	2b02      	cmp	r3, #2
 8008af4:	d0be      	beq.n	8008a74 <vRs485Task+0x1a0>
 8008af6:	e013      	b.n	8008b20 <vRs485Task+0x24c>
												else break;
 8008af8:	bf00      	nop

									}
			while ((pxConfig->devcfg.MeterType != 1)&&(pxConfig->devcfg.MeterType != 2)) // CE318BY
 8008afa:	e011      	b.n	8008b20 <vRs485Task+0x24c>
				{
				if (MeterType != pxConfig->devcfg.MeterType) //  
 8008afc:	69bb      	ldr	r3, [r7, #24]
 8008afe:	f8b3 3120 	ldrh.w	r3, [r3, #288]	; 0x120
 8008b02:	b29b      	uxth	r3, r3
 8008b04:	461a      	mov	r2, r3
 8008b06:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8008b08:	4293      	cmp	r3, r2
 8008b0a:	d006      	beq.n	8008b1a <vRs485Task+0x246>
												{
													MeterType = pxConfig->devcfg.MeterType;
 8008b0c:	69bb      	ldr	r3, [r7, #24]
 8008b0e:	f8b3 3120 	ldrh.w	r3, [r3, #288]	; 0x120
 8008b12:	b29b      	uxth	r3, r3
 8008b14:	627b      	str	r3, [r7, #36]	; 0x24
													ClearUIPData();
 8008b16:	4b12      	ldr	r3, [pc, #72]	; (8008b60 <vRs485Task+0x28c>)
 8008b18:	4798      	blx	r3
												}

				vTaskDelay(10);
 8008b1a:	200a      	movs	r0, #10
 8008b1c:	4b12      	ldr	r3, [pc, #72]	; (8008b68 <vRs485Task+0x294>)
 8008b1e:	4798      	blx	r3
			while ((pxConfig->devcfg.MeterType != 1)&&(pxConfig->devcfg.MeterType != 2)) // CE318BY
 8008b20:	69bb      	ldr	r3, [r7, #24]
 8008b22:	f8b3 3120 	ldrh.w	r3, [r3, #288]	; 0x120
 8008b26:	b29b      	uxth	r3, r3
 8008b28:	2b01      	cmp	r3, #1
 8008b2a:	f43f af39 	beq.w	80089a0 <vRs485Task+0xcc>
 8008b2e:	69bb      	ldr	r3, [r7, #24]
 8008b30:	f8b3 3120 	ldrh.w	r3, [r3, #288]	; 0x120
 8008b34:	b29b      	uxth	r3, r3
 8008b36:	2b02      	cmp	r3, #2
 8008b38:	d1e0      	bne.n	8008afc <vRs485Task+0x228>
			heapSize = xPortGetFreeHeapSize();
 8008b3a:	e731      	b.n	80089a0 <vRs485Task+0xcc>
 8008b3c:	0802b000 	.word	0x0802b000
 8008b40:	080049fd 	.word	0x080049fd
 8008b44:	2000745c 	.word	0x2000745c
 8008b48:	40004c00 	.word	0x40004c00
 8008b4c:	080028c9 	.word	0x080028c9
 8008b50:	40011000 	.word	0x40011000
 8008b54:	08002f89 	.word	0x08002f89
 8008b58:	080028b5 	.word	0x080028b5
 8008b5c:	08003709 	.word	0x08003709
 8008b60:	080079b1 	.word	0x080079b1
 8008b64:	080081f1 	.word	0x080081f1
 8008b68:	08001529 	.word	0x08001529
 8008b6c:	200072c0 	.word	0x200072c0
 8008b70:	080092bd 	.word	0x080092bd
 8008b74:	20007440 	.word	0x20007440
 8008b78:	08002f6d 	.word	0x08002f6d
 8008b7c:	08007f6f 	.word	0x08007f6f
 8008b80:	08004ccd 	.word	0x08004ccd
 8008b84:	080085b1 	.word	0x080085b1

08008b88 <vUSBTask>:
	uint16 size;
};


void vUSBTask(void *pvParameters)
{
 8008b88:	e92d 43b0 	stmdb	sp!, {r4, r5, r7, r8, r9, lr}
 8008b8c:	b086      	sub	sp, #24
 8008b8e:	af00      	add	r7, sp, #0
 8008b90:	6078      	str	r0, [r7, #4]
	//usb
	vTaskDelay(100);
 8008b92:	2064      	movs	r0, #100	; 0x64
 8008b94:	4b30      	ldr	r3, [pc, #192]	; (8008c58 <vUSBTask+0xd0>)
 8008b96:	4798      	blx	r3
	uint16 usbsize = 256;
 8008b98:	f44f 7380 	mov.w	r3, #256	; 0x100
 8008b9c:	82fb      	strh	r3, [r7, #22]
	uint8 usbbuf[usbsize];
 8008b9e:	8af9      	ldrh	r1, [r7, #22]
 8008ba0:	460b      	mov	r3, r1
 8008ba2:	3b01      	subs	r3, #1
 8008ba4:	613b      	str	r3, [r7, #16]
 8008ba6:	b28b      	uxth	r3, r1
 8008ba8:	2200      	movs	r2, #0
 8008baa:	4698      	mov	r8, r3
 8008bac:	4691      	mov	r9, r2
 8008bae:	f04f 0200 	mov.w	r2, #0
 8008bb2:	f04f 0300 	mov.w	r3, #0
 8008bb6:	ea4f 03c9 	mov.w	r3, r9, lsl #3
 8008bba:	ea43 7358 	orr.w	r3, r3, r8, lsr #29
 8008bbe:	ea4f 02c8 	mov.w	r2, r8, lsl #3
 8008bc2:	b28b      	uxth	r3, r1
 8008bc4:	2200      	movs	r2, #0
 8008bc6:	461c      	mov	r4, r3
 8008bc8:	4615      	mov	r5, r2
 8008bca:	f04f 0200 	mov.w	r2, #0
 8008bce:	f04f 0300 	mov.w	r3, #0
 8008bd2:	00eb      	lsls	r3, r5, #3
 8008bd4:	ea43 7354 	orr.w	r3, r3, r4, lsr #29
 8008bd8:	00e2      	lsls	r2, r4, #3
 8008bda:	460b      	mov	r3, r1
 8008bdc:	3307      	adds	r3, #7
 8008bde:	08db      	lsrs	r3, r3, #3
 8008be0:	00db      	lsls	r3, r3, #3
 8008be2:	ebad 0d03 	sub.w	sp, sp, r3
 8008be6:	466b      	mov	r3, sp
 8008be8:	3300      	adds	r3, #0
 8008bea:	60fb      	str	r3, [r7, #12]

	int heapSize = 0;
 8008bec:	2300      	movs	r3, #0
 8008bee:	60bb      	str	r3, [r7, #8]
	/* The parameters are not used. */
	(void) pvParameters;

	uart1Init(115200);
 8008bf0:	f44f 30e1 	mov.w	r0, #115200	; 0x1c200
 8008bf4:	4b19      	ldr	r3, [pc, #100]	; (8008c5c <vUSBTask+0xd4>)
 8008bf6:	4798      	blx	r3
	vTaskDelay(50);
 8008bf8:	2032      	movs	r0, #50	; 0x32
 8008bfa:	4b17      	ldr	r3, [pc, #92]	; (8008c58 <vUSBTask+0xd0>)
 8008bfc:	4798      	blx	r3

	while (1) {
		heapSize = xPortGetFreeHeapSize();
 8008bfe:	4b18      	ldr	r3, [pc, #96]	; (8008c60 <vUSBTask+0xd8>)
 8008c00:	4798      	blx	r3
 8008c02:	4603      	mov	r3, r0
 8008c04:	60bb      	str	r3, [r7, #8]
		heapSize += 0;

		usbsize = uart1Read(usbbuf, 256);
 8008c06:	f44f 7180 	mov.w	r1, #256	; 0x100
 8008c0a:	68f8      	ldr	r0, [r7, #12]
 8008c0c:	4b15      	ldr	r3, [pc, #84]	; (8008c64 <vUSBTask+0xdc>)
 8008c0e:	4798      	blx	r3
 8008c10:	4603      	mov	r3, r0
 8008c12:	82fb      	strh	r3, [r7, #22]
		vTaskDelay(50);
 8008c14:	2032      	movs	r0, #50	; 0x32
 8008c16:	4b10      	ldr	r3, [pc, #64]	; (8008c58 <vUSBTask+0xd0>)
 8008c18:	4798      	blx	r3

		if (usbsize > 0) {
 8008c1a:	8afb      	ldrh	r3, [r7, #22]
 8008c1c:	2b00      	cmp	r3, #0
 8008c1e:	d0ee      	beq.n	8008bfe <vUSBTask+0x76>
			portENTER_CRITICAL();
 8008c20:	4b11      	ldr	r3, [pc, #68]	; (8008c68 <vUSBTask+0xe0>)
 8008c22:	4798      	blx	r3
			usbsize = RVnetSlaveProcess(usbbuf, usbsize, 1);
 8008c24:	8afb      	ldrh	r3, [r7, #22]
 8008c26:	b2db      	uxtb	r3, r3
 8008c28:	2201      	movs	r2, #1
 8008c2a:	4619      	mov	r1, r3
 8008c2c:	68f8      	ldr	r0, [r7, #12]
 8008c2e:	4b0f      	ldr	r3, [pc, #60]	; (8008c6c <vUSBTask+0xe4>)
 8008c30:	4798      	blx	r3
 8008c32:	4603      	mov	r3, r0
 8008c34:	82fb      	strh	r3, [r7, #22]
			portEXIT_CRITICAL();
 8008c36:	4b0e      	ldr	r3, [pc, #56]	; (8008c70 <vUSBTask+0xe8>)
 8008c38:	4798      	blx	r3
			vTaskDelay(15); //    usb
 8008c3a:	200f      	movs	r0, #15
 8008c3c:	4b06      	ldr	r3, [pc, #24]	; (8008c58 <vUSBTask+0xd0>)
 8008c3e:	4798      	blx	r3

			if (usbsize > 0) {
 8008c40:	8afb      	ldrh	r3, [r7, #22]
 8008c42:	2b00      	cmp	r3, #0
 8008c44:	d0db      	beq.n	8008bfe <vUSBTask+0x76>
				uart1Write(usbbuf, usbsize);
 8008c46:	8afb      	ldrh	r3, [r7, #22]
 8008c48:	4619      	mov	r1, r3
 8008c4a:	68f8      	ldr	r0, [r7, #12]
 8008c4c:	4b09      	ldr	r3, [pc, #36]	; (8008c74 <vUSBTask+0xec>)
 8008c4e:	4798      	blx	r3
				vTaskDelay(15);
 8008c50:	200f      	movs	r0, #15
 8008c52:	4b01      	ldr	r3, [pc, #4]	; (8008c58 <vUSBTask+0xd0>)
 8008c54:	4798      	blx	r3
	while (1) {
 8008c56:	e7d2      	b.n	8008bfe <vUSBTask+0x76>
 8008c58:	08001529 	.word	0x08001529
 8008c5c:	08004351 	.word	0x08004351
 8008c60:	080028b5 	.word	0x080028b5
 8008c64:	0800459d 	.word	0x0800459d
 8008c68:	080025f9 	.word	0x080025f9
 8008c6c:	08006439 	.word	0x08006439
 8008c70:	0800261d 	.word	0x0800261d
 8008c74:	080045f9 	.word	0x080045f9

08008c78 <vReletestTask>:
#include "task.h"

#include "stm32f10x_flash.h"
#include "usermemory.h"

void vReletestTask(void *pvParameters) {
 8008c78:	b580      	push	{r7, lr}
 8008c7a:	b084      	sub	sp, #16
 8008c7c:	af00      	add	r7, sp, #0
 8008c7e:	6078      	str	r0, [r7, #4]

	int heapSize = 0;
 8008c80:	2300      	movs	r3, #0
 8008c82:	60fb      	str	r3, [r7, #12]

	while (1) {
		BKP_WriteBackupRegister(BKP_DR7, 70);
 8008c84:	2146      	movs	r1, #70	; 0x46
 8008c86:	201c      	movs	r0, #28
 8008c88:	4b70      	ldr	r3, [pc, #448]	; (8008e4c <vReletestTask+0x1d4>)
 8008c8a:	4798      	blx	r3
		heapSize = xPortGetFreeHeapSize();
 8008c8c:	4b70      	ldr	r3, [pc, #448]	; (8008e50 <vReletestTask+0x1d8>)
 8008c8e:	4798      	blx	r3
 8008c90:	4603      	mov	r3, r0
 8008c92:	60fb      	str	r3, [r7, #12]
		heapSize += 0;
		if ((RAM.relays[0] & 1) != 0) {
 8008c94:	4b6f      	ldr	r3, [pc, #444]	; (8008e54 <vReletestTask+0x1dc>)
 8008c96:	f8b3 3408 	ldrh.w	r3, [r3, #1032]	; 0x408
 8008c9a:	b29b      	uxth	r3, r3
 8008c9c:	f003 0301 	and.w	r3, r3, #1
 8008ca0:	2b00      	cmp	r3, #0
 8008ca2:	d004      	beq.n	8008cae <vReletestTask+0x36>
			GPIO_SetBits(GPIO_RELE, P1);
 8008ca4:	2110      	movs	r1, #16
 8008ca6:	486c      	ldr	r0, [pc, #432]	; (8008e58 <vReletestTask+0x1e0>)
 8008ca8:	4b6c      	ldr	r3, [pc, #432]	; (8008e5c <vReletestTask+0x1e4>)
 8008caa:	4798      	blx	r3
 8008cac:	e003      	b.n	8008cb6 <vReletestTask+0x3e>
		} else {
			GPIO_ResetBits(GPIO_RELE, P1);
 8008cae:	2110      	movs	r1, #16
 8008cb0:	4869      	ldr	r0, [pc, #420]	; (8008e58 <vReletestTask+0x1e0>)
 8008cb2:	4b6b      	ldr	r3, [pc, #428]	; (8008e60 <vReletestTask+0x1e8>)
 8008cb4:	4798      	blx	r3
		}
		if ((RAM.relays[0] & 2) != 0) {
 8008cb6:	4b67      	ldr	r3, [pc, #412]	; (8008e54 <vReletestTask+0x1dc>)
 8008cb8:	f8b3 3408 	ldrh.w	r3, [r3, #1032]	; 0x408
 8008cbc:	b29b      	uxth	r3, r3
 8008cbe:	f003 0302 	and.w	r3, r3, #2
 8008cc2:	2b00      	cmp	r3, #0
 8008cc4:	d004      	beq.n	8008cd0 <vReletestTask+0x58>
			GPIO_SetBits(GPIO_RELE, P2);
 8008cc6:	2120      	movs	r1, #32
 8008cc8:	4863      	ldr	r0, [pc, #396]	; (8008e58 <vReletestTask+0x1e0>)
 8008cca:	4b64      	ldr	r3, [pc, #400]	; (8008e5c <vReletestTask+0x1e4>)
 8008ccc:	4798      	blx	r3
 8008cce:	e003      	b.n	8008cd8 <vReletestTask+0x60>
		} else {
			GPIO_ResetBits(GPIO_RELE, P2);
 8008cd0:	2120      	movs	r1, #32
 8008cd2:	4861      	ldr	r0, [pc, #388]	; (8008e58 <vReletestTask+0x1e0>)
 8008cd4:	4b62      	ldr	r3, [pc, #392]	; (8008e60 <vReletestTask+0x1e8>)
 8008cd6:	4798      	blx	r3
		}
		if ((RAM.relays[0] & 4) != 0) {
 8008cd8:	4b5e      	ldr	r3, [pc, #376]	; (8008e54 <vReletestTask+0x1dc>)
 8008cda:	f8b3 3408 	ldrh.w	r3, [r3, #1032]	; 0x408
 8008cde:	b29b      	uxth	r3, r3
 8008ce0:	f003 0304 	and.w	r3, r3, #4
 8008ce4:	2b00      	cmp	r3, #0
 8008ce6:	d004      	beq.n	8008cf2 <vReletestTask+0x7a>
			GPIO_SetBits(GPIO_RELE, P3);
 8008ce8:	2140      	movs	r1, #64	; 0x40
 8008cea:	485b      	ldr	r0, [pc, #364]	; (8008e58 <vReletestTask+0x1e0>)
 8008cec:	4b5b      	ldr	r3, [pc, #364]	; (8008e5c <vReletestTask+0x1e4>)
 8008cee:	4798      	blx	r3
 8008cf0:	e003      	b.n	8008cfa <vReletestTask+0x82>
		} else {
			GPIO_ResetBits(GPIO_RELE, P3);
 8008cf2:	2140      	movs	r1, #64	; 0x40
 8008cf4:	4858      	ldr	r0, [pc, #352]	; (8008e58 <vReletestTask+0x1e0>)
 8008cf6:	4b5a      	ldr	r3, [pc, #360]	; (8008e60 <vReletestTask+0x1e8>)
 8008cf8:	4798      	blx	r3
		}


		DiskretSet(7, !(GPIO_ReadInputDataBit(GPIO_D6toD9, D8)));
 8008cfa:	2104      	movs	r1, #4
 8008cfc:	4859      	ldr	r0, [pc, #356]	; (8008e64 <vReletestTask+0x1ec>)
 8008cfe:	4b5a      	ldr	r3, [pc, #360]	; (8008e68 <vReletestTask+0x1f0>)
 8008d00:	4798      	blx	r3
 8008d02:	4603      	mov	r3, r0
 8008d04:	2b00      	cmp	r3, #0
 8008d06:	bf0c      	ite	eq
 8008d08:	2301      	moveq	r3, #1
 8008d0a:	2300      	movne	r3, #0
 8008d0c:	b2db      	uxtb	r3, r3
 8008d0e:	4619      	mov	r1, r3
 8008d10:	2007      	movs	r0, #7
 8008d12:	4b56      	ldr	r3, [pc, #344]	; (8008e6c <vReletestTask+0x1f4>)
 8008d14:	4798      	blx	r3
		DiskretSet(6, !(GPIO_ReadInputDataBit(GPIO_D6toD9, D7)));
 8008d16:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 8008d1a:	4852      	ldr	r0, [pc, #328]	; (8008e64 <vReletestTask+0x1ec>)
 8008d1c:	4b52      	ldr	r3, [pc, #328]	; (8008e68 <vReletestTask+0x1f0>)
 8008d1e:	4798      	blx	r3
 8008d20:	4603      	mov	r3, r0
 8008d22:	2b00      	cmp	r3, #0
 8008d24:	bf0c      	ite	eq
 8008d26:	2301      	moveq	r3, #1
 8008d28:	2300      	movne	r3, #0
 8008d2a:	b2db      	uxtb	r3, r3
 8008d2c:	4619      	mov	r1, r3
 8008d2e:	2006      	movs	r0, #6
 8008d30:	4b4e      	ldr	r3, [pc, #312]	; (8008e6c <vReletestTask+0x1f4>)
 8008d32:	4798      	blx	r3
		DiskretSet(5, !(GPIO_ReadInputDataBit(GPIO_D6toD9, D6)));
 8008d34:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8008d38:	484a      	ldr	r0, [pc, #296]	; (8008e64 <vReletestTask+0x1ec>)
 8008d3a:	4b4b      	ldr	r3, [pc, #300]	; (8008e68 <vReletestTask+0x1f0>)
 8008d3c:	4798      	blx	r3
 8008d3e:	4603      	mov	r3, r0
 8008d40:	2b00      	cmp	r3, #0
 8008d42:	bf0c      	ite	eq
 8008d44:	2301      	moveq	r3, #1
 8008d46:	2300      	movne	r3, #0
 8008d48:	b2db      	uxtb	r3, r3
 8008d4a:	4619      	mov	r1, r3
 8008d4c:	2005      	movs	r0, #5
 8008d4e:	4b47      	ldr	r3, [pc, #284]	; (8008e6c <vReletestTask+0x1f4>)
 8008d50:	4798      	blx	r3
		DiskretSet(4, !(GPIO_ReadInputDataBit(GPIO_D2toD5, D5)));
 8008d52:	2140      	movs	r1, #64	; 0x40
 8008d54:	4846      	ldr	r0, [pc, #280]	; (8008e70 <vReletestTask+0x1f8>)
 8008d56:	4b44      	ldr	r3, [pc, #272]	; (8008e68 <vReletestTask+0x1f0>)
 8008d58:	4798      	blx	r3
 8008d5a:	4603      	mov	r3, r0
 8008d5c:	2b00      	cmp	r3, #0
 8008d5e:	bf0c      	ite	eq
 8008d60:	2301      	moveq	r3, #1
 8008d62:	2300      	movne	r3, #0
 8008d64:	b2db      	uxtb	r3, r3
 8008d66:	4619      	mov	r1, r3
 8008d68:	2004      	movs	r0, #4
 8008d6a:	4b40      	ldr	r3, [pc, #256]	; (8008e6c <vReletestTask+0x1f4>)
 8008d6c:	4798      	blx	r3
		DiskretSet(3, !(GPIO_ReadInputDataBit(GPIO_D2toD5, D4)));
 8008d6e:	2180      	movs	r1, #128	; 0x80
 8008d70:	483f      	ldr	r0, [pc, #252]	; (8008e70 <vReletestTask+0x1f8>)
 8008d72:	4b3d      	ldr	r3, [pc, #244]	; (8008e68 <vReletestTask+0x1f0>)
 8008d74:	4798      	blx	r3
 8008d76:	4603      	mov	r3, r0
 8008d78:	2b00      	cmp	r3, #0
 8008d7a:	bf0c      	ite	eq
 8008d7c:	2301      	moveq	r3, #1
 8008d7e:	2300      	movne	r3, #0
 8008d80:	b2db      	uxtb	r3, r3
 8008d82:	4619      	mov	r1, r3
 8008d84:	2003      	movs	r0, #3
 8008d86:	4b39      	ldr	r3, [pc, #228]	; (8008e6c <vReletestTask+0x1f4>)
 8008d88:	4798      	blx	r3
		DiskretSet(2, !(GPIO_ReadInputDataBit(GPIO_D2toD5, D3)));
 8008d8a:	f44f 7180 	mov.w	r1, #256	; 0x100
 8008d8e:	4838      	ldr	r0, [pc, #224]	; (8008e70 <vReletestTask+0x1f8>)
 8008d90:	4b35      	ldr	r3, [pc, #212]	; (8008e68 <vReletestTask+0x1f0>)
 8008d92:	4798      	blx	r3
 8008d94:	4603      	mov	r3, r0
 8008d96:	2b00      	cmp	r3, #0
 8008d98:	bf0c      	ite	eq
 8008d9a:	2301      	moveq	r3, #1
 8008d9c:	2300      	movne	r3, #0
 8008d9e:	b2db      	uxtb	r3, r3
 8008da0:	4619      	mov	r1, r3
 8008da2:	2002      	movs	r0, #2
 8008da4:	4b31      	ldr	r3, [pc, #196]	; (8008e6c <vReletestTask+0x1f4>)
 8008da6:	4798      	blx	r3
		DiskretSet(1, !(GPIO_ReadInputDataBit(GPIO_D2toD5, D2)));
 8008da8:	f44f 7100 	mov.w	r1, #512	; 0x200
 8008dac:	4830      	ldr	r0, [pc, #192]	; (8008e70 <vReletestTask+0x1f8>)
 8008dae:	4b2e      	ldr	r3, [pc, #184]	; (8008e68 <vReletestTask+0x1f0>)
 8008db0:	4798      	blx	r3
 8008db2:	4603      	mov	r3, r0
 8008db4:	2b00      	cmp	r3, #0
 8008db6:	bf0c      	ite	eq
 8008db8:	2301      	moveq	r3, #1
 8008dba:	2300      	movne	r3, #0
 8008dbc:	b2db      	uxtb	r3, r3
 8008dbe:	4619      	mov	r1, r3
 8008dc0:	2001      	movs	r0, #1
 8008dc2:	4b2a      	ldr	r3, [pc, #168]	; (8008e6c <vReletestTask+0x1f4>)
 8008dc4:	4798      	blx	r3
		DiskretSet(0, !(GPIO_ReadInputDataBit(GPIO_D1, D1)));
 8008dc6:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8008dca:	4823      	ldr	r0, [pc, #140]	; (8008e58 <vReletestTask+0x1e0>)
 8008dcc:	4b26      	ldr	r3, [pc, #152]	; (8008e68 <vReletestTask+0x1f0>)
 8008dce:	4798      	blx	r3
 8008dd0:	4603      	mov	r3, r0
 8008dd2:	2b00      	cmp	r3, #0
 8008dd4:	bf0c      	ite	eq
 8008dd6:	2301      	moveq	r3, #1
 8008dd8:	2300      	movne	r3, #0
 8008dda:	b2db      	uxtb	r3, r3
 8008ddc:	4619      	mov	r1, r3
 8008dde:	2000      	movs	r0, #0
 8008de0:	4b22      	ldr	r3, [pc, #136]	; (8008e6c <vReletestTask+0x1f4>)
 8008de2:	4798      	blx	r3
		DiskretSet(10, !(GPIO_ReadInputDataBit(GPIO_D10toD11, D11)));
 8008de4:	2110      	movs	r1, #16
 8008de6:	4822      	ldr	r0, [pc, #136]	; (8008e70 <vReletestTask+0x1f8>)
 8008de8:	4b1f      	ldr	r3, [pc, #124]	; (8008e68 <vReletestTask+0x1f0>)
 8008dea:	4798      	blx	r3
 8008dec:	4603      	mov	r3, r0
 8008dee:	2b00      	cmp	r3, #0
 8008df0:	bf0c      	ite	eq
 8008df2:	2301      	moveq	r3, #1
 8008df4:	2300      	movne	r3, #0
 8008df6:	b2db      	uxtb	r3, r3
 8008df8:	4619      	mov	r1, r3
 8008dfa:	200a      	movs	r0, #10
 8008dfc:	4b1b      	ldr	r3, [pc, #108]	; (8008e6c <vReletestTask+0x1f4>)
 8008dfe:	4798      	blx	r3
		DiskretSet(9, !(GPIO_ReadInputDataBit(GPIO_D10toD11, D10)));
 8008e00:	2120      	movs	r1, #32
 8008e02:	481b      	ldr	r0, [pc, #108]	; (8008e70 <vReletestTask+0x1f8>)
 8008e04:	4b18      	ldr	r3, [pc, #96]	; (8008e68 <vReletestTask+0x1f0>)
 8008e06:	4798      	blx	r3
 8008e08:	4603      	mov	r3, r0
 8008e0a:	2b00      	cmp	r3, #0
 8008e0c:	bf0c      	ite	eq
 8008e0e:	2301      	moveq	r3, #1
 8008e10:	2300      	movne	r3, #0
 8008e12:	b2db      	uxtb	r3, r3
 8008e14:	4619      	mov	r1, r3
 8008e16:	2009      	movs	r0, #9
 8008e18:	4b14      	ldr	r3, [pc, #80]	; (8008e6c <vReletestTask+0x1f4>)
 8008e1a:	4798      	blx	r3
		DiskretSet(8, !(GPIO_ReadInputDataBit(GPIO_D6toD9, D9)));
 8008e1c:	2102      	movs	r1, #2
 8008e1e:	4811      	ldr	r0, [pc, #68]	; (8008e64 <vReletestTask+0x1ec>)
 8008e20:	4b11      	ldr	r3, [pc, #68]	; (8008e68 <vReletestTask+0x1f0>)
 8008e22:	4798      	blx	r3
 8008e24:	4603      	mov	r3, r0
 8008e26:	2b00      	cmp	r3, #0
 8008e28:	bf0c      	ite	eq
 8008e2a:	2301      	moveq	r3, #1
 8008e2c:	2300      	movne	r3, #0
 8008e2e:	b2db      	uxtb	r3, r3
 8008e30:	4619      	mov	r1, r3
 8008e32:	2008      	movs	r0, #8
 8008e34:	4b0d      	ldr	r3, [pc, #52]	; (8008e6c <vReletestTask+0x1f4>)
 8008e36:	4798      	blx	r3

		DiskretsProcess();
 8008e38:	4b0e      	ldr	r3, [pc, #56]	; (8008e74 <vReletestTask+0x1fc>)
 8008e3a:	4798      	blx	r3
		BKP_WriteBackupRegister(BKP_DR7, 72);
 8008e3c:	2148      	movs	r1, #72	; 0x48
 8008e3e:	201c      	movs	r0, #28
 8008e40:	4b02      	ldr	r3, [pc, #8]	; (8008e4c <vReletestTask+0x1d4>)
 8008e42:	4798      	blx	r3
		vTaskDelay(2);
 8008e44:	2002      	movs	r0, #2
 8008e46:	4b0c      	ldr	r3, [pc, #48]	; (8008e78 <vReletestTask+0x200>)
 8008e48:	4798      	blx	r3
	while (1) {
 8008e4a:	e71b      	b.n	8008c84 <vReletestTask+0xc>
 8008e4c:	08003621 	.word	0x08003621
 8008e50:	080028b5 	.word	0x080028b5
 8008e54:	2000745c 	.word	0x2000745c
 8008e58:	40010800 	.word	0x40010800
 8008e5c:	08002f6d 	.word	0x08002f6d
 8008e60:	08002f89 	.word	0x08002f89
 8008e64:	40010c00 	.word	0x40010c00
 8008e68:	08002f3b 	.word	0x08002f3b
 8008e6c:	0800baa5 	.word	0x0800baa5
 8008e70:	40011000 	.word	0x40011000
 8008e74:	0800bc15 	.word	0x0800bc15
 8008e78:	08001529 	.word	0x08001529

08008e7c <iecClaculateBCC>:
#include "iec61107.h"

char iecClaculateBCC(char *pxBuf, uint16 size)
{
 8008e7c:	b480      	push	{r7}
 8008e7e:	b085      	sub	sp, #20
 8008e80:	af00      	add	r7, sp, #0
 8008e82:	6078      	str	r0, [r7, #4]
 8008e84:	460b      	mov	r3, r1
 8008e86:	807b      	strh	r3, [r7, #2]
	char bcc = 0;
 8008e88:	2300      	movs	r3, #0
 8008e8a:	73fb      	strb	r3, [r7, #15]
	while (size)
 8008e8c:	e00a      	b.n	8008ea4 <iecClaculateBCC+0x28>
	{
		bcc += *pxBuf;
 8008e8e:	687b      	ldr	r3, [r7, #4]
 8008e90:	781a      	ldrb	r2, [r3, #0]
 8008e92:	7bfb      	ldrb	r3, [r7, #15]
 8008e94:	4413      	add	r3, r2
 8008e96:	73fb      	strb	r3, [r7, #15]
		pxBuf++;
 8008e98:	687b      	ldr	r3, [r7, #4]
 8008e9a:	3301      	adds	r3, #1
 8008e9c:	607b      	str	r3, [r7, #4]
		size--;
 8008e9e:	887b      	ldrh	r3, [r7, #2]
 8008ea0:	3b01      	subs	r3, #1
 8008ea2:	807b      	strh	r3, [r7, #2]
	while (size)
 8008ea4:	887b      	ldrh	r3, [r7, #2]
 8008ea6:	2b00      	cmp	r3, #0
 8008ea8:	d1f1      	bne.n	8008e8e <iecClaculateBCC+0x12>
	}
	return (bcc & 0x7F);
 8008eaa:	7bfb      	ldrb	r3, [r7, #15]
 8008eac:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8008eb0:	b2db      	uxtb	r3, r3
}
 8008eb2:	4618      	mov	r0, r3
 8008eb4:	3714      	adds	r7, #20
 8008eb6:	46bd      	mov	sp, r7
 8008eb8:	bc80      	pop	{r7}
 8008eba:	4770      	bx	lr

08008ebc <iecProcReqPacket>:
uint16 iecProcReqPacket(char *pxBuf, char *addr, uint8 limit)
{
 8008ebc:	b480      	push	{r7}
 8008ebe:	b087      	sub	sp, #28
 8008ec0:	af00      	add	r7, sp, #0
 8008ec2:	60f8      	str	r0, [r7, #12]
 8008ec4:	60b9      	str	r1, [r7, #8]
 8008ec6:	4613      	mov	r3, r2
 8008ec8:	71fb      	strb	r3, [r7, #7]
	uint16 size = 0;
 8008eca:	2300      	movs	r3, #0
 8008ecc:	82fb      	strh	r3, [r7, #22]
	*pxBuf = '/';
 8008ece:	68fb      	ldr	r3, [r7, #12]
 8008ed0:	222f      	movs	r2, #47	; 0x2f
 8008ed2:	701a      	strb	r2, [r3, #0]
	pxBuf++;
 8008ed4:	68fb      	ldr	r3, [r7, #12]
 8008ed6:	3301      	adds	r3, #1
 8008ed8:	60fb      	str	r3, [r7, #12]
	*pxBuf = '?';
 8008eda:	68fb      	ldr	r3, [r7, #12]
 8008edc:	223f      	movs	r2, #63	; 0x3f
 8008ede:	701a      	strb	r2, [r3, #0]
	pxBuf++;
 8008ee0:	68fb      	ldr	r3, [r7, #12]
 8008ee2:	3301      	adds	r3, #1
 8008ee4:	60fb      	str	r3, [r7, #12]
	while (*addr)
 8008ee6:	e014      	b.n	8008f12 <iecProcReqPacket+0x56>
	{
		if (limit == 0)
 8008ee8:	79fb      	ldrb	r3, [r7, #7]
 8008eea:	2b00      	cmp	r3, #0
 8008eec:	d101      	bne.n	8008ef2 <iecProcReqPacket+0x36>
			return 0;
 8008eee:	2300      	movs	r3, #0
 8008ef0:	e028      	b.n	8008f44 <iecProcReqPacket+0x88>
		*pxBuf = (*addr);
 8008ef2:	68bb      	ldr	r3, [r7, #8]
 8008ef4:	781a      	ldrb	r2, [r3, #0]
 8008ef6:	68fb      	ldr	r3, [r7, #12]
 8008ef8:	701a      	strb	r2, [r3, #0]
		pxBuf++;
 8008efa:	68fb      	ldr	r3, [r7, #12]
 8008efc:	3301      	adds	r3, #1
 8008efe:	60fb      	str	r3, [r7, #12]
		addr++;
 8008f00:	68bb      	ldr	r3, [r7, #8]
 8008f02:	3301      	adds	r3, #1
 8008f04:	60bb      	str	r3, [r7, #8]
		limit--;
 8008f06:	79fb      	ldrb	r3, [r7, #7]
 8008f08:	3b01      	subs	r3, #1
 8008f0a:	71fb      	strb	r3, [r7, #7]
		size++;
 8008f0c:	8afb      	ldrh	r3, [r7, #22]
 8008f0e:	3301      	adds	r3, #1
 8008f10:	82fb      	strh	r3, [r7, #22]
	while (*addr)
 8008f12:	68bb      	ldr	r3, [r7, #8]
 8008f14:	781b      	ldrb	r3, [r3, #0]
 8008f16:	2b00      	cmp	r3, #0
 8008f18:	d1e6      	bne.n	8008ee8 <iecProcReqPacket+0x2c>
	}
	*pxBuf = '!';
 8008f1a:	68fb      	ldr	r3, [r7, #12]
 8008f1c:	2221      	movs	r2, #33	; 0x21
 8008f1e:	701a      	strb	r2, [r3, #0]
	pxBuf++;
 8008f20:	68fb      	ldr	r3, [r7, #12]
 8008f22:	3301      	adds	r3, #1
 8008f24:	60fb      	str	r3, [r7, #12]
	*pxBuf = SYM_CR;
 8008f26:	68fb      	ldr	r3, [r7, #12]
 8008f28:	220d      	movs	r2, #13
 8008f2a:	701a      	strb	r2, [r3, #0]
	pxBuf++;
 8008f2c:	68fb      	ldr	r3, [r7, #12]
 8008f2e:	3301      	adds	r3, #1
 8008f30:	60fb      	str	r3, [r7, #12]
	*pxBuf = SYM_LF;
 8008f32:	68fb      	ldr	r3, [r7, #12]
 8008f34:	220a      	movs	r2, #10
 8008f36:	701a      	strb	r2, [r3, #0]
	pxBuf++;
 8008f38:	68fb      	ldr	r3, [r7, #12]
 8008f3a:	3301      	adds	r3, #1
 8008f3c:	60fb      	str	r3, [r7, #12]
	return (2 + size + 3);
 8008f3e:	8afb      	ldrh	r3, [r7, #22]
 8008f40:	3305      	adds	r3, #5
 8008f42:	b29b      	uxth	r3, r3
}
 8008f44:	4618      	mov	r0, r3
 8008f46:	371c      	adds	r7, #28
 8008f48:	46bd      	mov	sp, r7
 8008f4a:	bc80      	pop	{r7}
 8008f4c:	4770      	bx	lr

08008f4e <iecIndProc>:
bool iecIndProc(char *pxBuf, IDENTIFIER *idStr)
{
 8008f4e:	b480      	push	{r7}
 8008f50:	b085      	sub	sp, #20
 8008f52:	af00      	add	r7, sp, #0
 8008f54:	6078      	str	r0, [r7, #4]
 8008f56:	6039      	str	r1, [r7, #0]
	int i;
	if (*pxBuf != '/')
 8008f58:	687b      	ldr	r3, [r7, #4]
 8008f5a:	781b      	ldrb	r3, [r3, #0]
 8008f5c:	2b2f      	cmp	r3, #47	; 0x2f
 8008f5e:	d001      	beq.n	8008f64 <iecIndProc+0x16>
		return false;
 8008f60:	2300      	movs	r3, #0
 8008f62:	e043      	b.n	8008fec <iecIndProc+0x9e>
	pxBuf++;
 8008f64:	687b      	ldr	r3, [r7, #4]
 8008f66:	3301      	adds	r3, #1
 8008f68:	607b      	str	r3, [r7, #4]
	for (i = 0; i < 3; i++)
 8008f6a:	2300      	movs	r3, #0
 8008f6c:	60fb      	str	r3, [r7, #12]
 8008f6e:	e00c      	b.n	8008f8a <iecIndProc+0x3c>
	{
		idStr->manufator[i] = *pxBuf;
 8008f70:	687b      	ldr	r3, [r7, #4]
 8008f72:	7819      	ldrb	r1, [r3, #0]
 8008f74:	683a      	ldr	r2, [r7, #0]
 8008f76:	68fb      	ldr	r3, [r7, #12]
 8008f78:	4413      	add	r3, r2
 8008f7a:	460a      	mov	r2, r1
 8008f7c:	701a      	strb	r2, [r3, #0]
		pxBuf++;
 8008f7e:	687b      	ldr	r3, [r7, #4]
 8008f80:	3301      	adds	r3, #1
 8008f82:	607b      	str	r3, [r7, #4]
	for (i = 0; i < 3; i++)
 8008f84:	68fb      	ldr	r3, [r7, #12]
 8008f86:	3301      	adds	r3, #1
 8008f88:	60fb      	str	r3, [r7, #12]
 8008f8a:	68fb      	ldr	r3, [r7, #12]
 8008f8c:	2b02      	cmp	r3, #2
 8008f8e:	ddef      	ble.n	8008f70 <iecIndProc+0x22>
	}
	idStr->speed = *pxBuf;
 8008f90:	687b      	ldr	r3, [r7, #4]
 8008f92:	781a      	ldrb	r2, [r3, #0]
 8008f94:	683b      	ldr	r3, [r7, #0]
 8008f96:	70da      	strb	r2, [r3, #3]
	pxBuf++;
 8008f98:	687b      	ldr	r3, [r7, #4]
 8008f9a:	3301      	adds	r3, #1
 8008f9c:	607b      	str	r3, [r7, #4]
	for (i = 0; i < 16; i++)
 8008f9e:	2300      	movs	r3, #0
 8008fa0:	60fb      	str	r3, [r7, #12]
 8008fa2:	e011      	b.n	8008fc8 <iecIndProc+0x7a>
	{
		if (*pxBuf == SYM_CR)
 8008fa4:	687b      	ldr	r3, [r7, #4]
 8008fa6:	781b      	ldrb	r3, [r3, #0]
 8008fa8:	2b0d      	cmp	r3, #13
 8008faa:	d011      	beq.n	8008fd0 <iecIndProc+0x82>
			break;
		idStr->ident[i] = *pxBuf;
 8008fac:	687b      	ldr	r3, [r7, #4]
 8008fae:	7819      	ldrb	r1, [r3, #0]
 8008fb0:	683a      	ldr	r2, [r7, #0]
 8008fb2:	68fb      	ldr	r3, [r7, #12]
 8008fb4:	4413      	add	r3, r2
 8008fb6:	3304      	adds	r3, #4
 8008fb8:	460a      	mov	r2, r1
 8008fba:	701a      	strb	r2, [r3, #0]
		pxBuf++;
 8008fbc:	687b      	ldr	r3, [r7, #4]
 8008fbe:	3301      	adds	r3, #1
 8008fc0:	607b      	str	r3, [r7, #4]
	for (i = 0; i < 16; i++)
 8008fc2:	68fb      	ldr	r3, [r7, #12]
 8008fc4:	3301      	adds	r3, #1
 8008fc6:	60fb      	str	r3, [r7, #12]
 8008fc8:	68fb      	ldr	r3, [r7, #12]
 8008fca:	2b0f      	cmp	r3, #15
 8008fcc:	ddea      	ble.n	8008fa4 <iecIndProc+0x56>
 8008fce:	e000      	b.n	8008fd2 <iecIndProc+0x84>
			break;
 8008fd0:	bf00      	nop
	}
	if ((*pxBuf != SYM_CR) && (*(pxBuf + 1) != SYM_LF))
 8008fd2:	687b      	ldr	r3, [r7, #4]
 8008fd4:	781b      	ldrb	r3, [r3, #0]
 8008fd6:	2b0d      	cmp	r3, #13
 8008fd8:	d006      	beq.n	8008fe8 <iecIndProc+0x9a>
 8008fda:	687b      	ldr	r3, [r7, #4]
 8008fdc:	3301      	adds	r3, #1
 8008fde:	781b      	ldrb	r3, [r3, #0]
 8008fe0:	2b0a      	cmp	r3, #10
 8008fe2:	d001      	beq.n	8008fe8 <iecIndProc+0x9a>
		return false;
 8008fe4:	2300      	movs	r3, #0
 8008fe6:	e001      	b.n	8008fec <iecIndProc+0x9e>
	return true;
 8008fe8:	f04f 33ff 	mov.w	r3, #4294967295
}
 8008fec:	4618      	mov	r0, r3
 8008fee:	3714      	adds	r7, #20
 8008ff0:	46bd      	mov	sp, r7
 8008ff2:	bc80      	pop	{r7}
 8008ff4:	4770      	bx	lr

08008ff6 <iecOptionsAckPacket>:
uint16 iecOptionsAckPacket(char *pxBuf, char V, char Z, char Y)
{
 8008ff6:	b480      	push	{r7}
 8008ff8:	b083      	sub	sp, #12
 8008ffa:	af00      	add	r7, sp, #0
 8008ffc:	6078      	str	r0, [r7, #4]
 8008ffe:	4608      	mov	r0, r1
 8009000:	4611      	mov	r1, r2
 8009002:	461a      	mov	r2, r3
 8009004:	4603      	mov	r3, r0
 8009006:	70fb      	strb	r3, [r7, #3]
 8009008:	460b      	mov	r3, r1
 800900a:	70bb      	strb	r3, [r7, #2]
 800900c:	4613      	mov	r3, r2
 800900e:	707b      	strb	r3, [r7, #1]
	*pxBuf = ACK;
 8009010:	687b      	ldr	r3, [r7, #4]
 8009012:	2206      	movs	r2, #6
 8009014:	701a      	strb	r2, [r3, #0]
	pxBuf++;
 8009016:	687b      	ldr	r3, [r7, #4]
 8009018:	3301      	adds	r3, #1
 800901a:	607b      	str	r3, [r7, #4]
	*pxBuf = V;
 800901c:	687b      	ldr	r3, [r7, #4]
 800901e:	78fa      	ldrb	r2, [r7, #3]
 8009020:	701a      	strb	r2, [r3, #0]
	pxBuf++;
 8009022:	687b      	ldr	r3, [r7, #4]
 8009024:	3301      	adds	r3, #1
 8009026:	607b      	str	r3, [r7, #4]
	*pxBuf = Z;
 8009028:	687b      	ldr	r3, [r7, #4]
 800902a:	78ba      	ldrb	r2, [r7, #2]
 800902c:	701a      	strb	r2, [r3, #0]
	pxBuf++;
 800902e:	687b      	ldr	r3, [r7, #4]
 8009030:	3301      	adds	r3, #1
 8009032:	607b      	str	r3, [r7, #4]
	*pxBuf = Y;
 8009034:	687b      	ldr	r3, [r7, #4]
 8009036:	787a      	ldrb	r2, [r7, #1]
 8009038:	701a      	strb	r2, [r3, #0]
	pxBuf++;
 800903a:	687b      	ldr	r3, [r7, #4]
 800903c:	3301      	adds	r3, #1
 800903e:	607b      	str	r3, [r7, #4]
	*pxBuf = SYM_CR;
 8009040:	687b      	ldr	r3, [r7, #4]
 8009042:	220d      	movs	r2, #13
 8009044:	701a      	strb	r2, [r3, #0]
	pxBuf++;
 8009046:	687b      	ldr	r3, [r7, #4]
 8009048:	3301      	adds	r3, #1
 800904a:	607b      	str	r3, [r7, #4]
	*pxBuf = SYM_LF;
 800904c:	687b      	ldr	r3, [r7, #4]
 800904e:	220a      	movs	r2, #10
 8009050:	701a      	strb	r2, [r3, #0]
	return 6;
 8009052:	2306      	movs	r3, #6
}
 8009054:	4618      	mov	r0, r3
 8009056:	370c      	adds	r7, #12
 8009058:	46bd      	mov	sp, r7
 800905a:	bc80      	pop	{r7}
 800905c:	4770      	bx	lr
	...

08009060 <iecProcAddrAnswer>:
		break;
	}
	return true;
}
bool iecProcAddrAnswer(char *pxBuf, char *addrStr, uint8 limit)
{
 8009060:	b580      	push	{r7, lr}
 8009062:	b088      	sub	sp, #32
 8009064:	af00      	add	r7, sp, #0
 8009066:	60f8      	str	r0, [r7, #12]
 8009068:	60b9      	str	r1, [r7, #8]
 800906a:	4613      	mov	r3, r2
 800906c:	71fb      	strb	r3, [r7, #7]
	int i;
	uint8 *tmpbuff = pxBuf;
 800906e:	68fb      	ldr	r3, [r7, #12]
 8009070:	61bb      	str	r3, [r7, #24]
	if (*pxBuf != SOH)
 8009072:	68fb      	ldr	r3, [r7, #12]
 8009074:	781b      	ldrb	r3, [r3, #0]
 8009076:	2b01      	cmp	r3, #1
 8009078:	d001      	beq.n	800907e <iecProcAddrAnswer+0x1e>
		return false;
 800907a:	2300      	movs	r3, #0
 800907c:	e067      	b.n	800914e <iecProcAddrAnswer+0xee>
	pxBuf++;
 800907e:	68fb      	ldr	r3, [r7, #12]
 8009080:	3301      	adds	r3, #1
 8009082:	60fb      	str	r3, [r7, #12]
	if (*pxBuf != 'P')
 8009084:	68fb      	ldr	r3, [r7, #12]
 8009086:	781b      	ldrb	r3, [r3, #0]
 8009088:	2b50      	cmp	r3, #80	; 0x50
 800908a:	d001      	beq.n	8009090 <iecProcAddrAnswer+0x30>
		return false;
 800908c:	2300      	movs	r3, #0
 800908e:	e05e      	b.n	800914e <iecProcAddrAnswer+0xee>
	pxBuf++;
 8009090:	68fb      	ldr	r3, [r7, #12]
 8009092:	3301      	adds	r3, #1
 8009094:	60fb      	str	r3, [r7, #12]
	if (*pxBuf != '0')
 8009096:	68fb      	ldr	r3, [r7, #12]
 8009098:	781b      	ldrb	r3, [r3, #0]
 800909a:	2b30      	cmp	r3, #48	; 0x30
 800909c:	d001      	beq.n	80090a2 <iecProcAddrAnswer+0x42>
		return false;
 800909e:	2300      	movs	r3, #0
 80090a0:	e055      	b.n	800914e <iecProcAddrAnswer+0xee>
	pxBuf++;
 80090a2:	68fb      	ldr	r3, [r7, #12]
 80090a4:	3301      	adds	r3, #1
 80090a6:	60fb      	str	r3, [r7, #12]
	if (*pxBuf != STX)
 80090a8:	68fb      	ldr	r3, [r7, #12]
 80090aa:	781b      	ldrb	r3, [r3, #0]
 80090ac:	2b02      	cmp	r3, #2
 80090ae:	d001      	beq.n	80090b4 <iecProcAddrAnswer+0x54>
		return false;
 80090b0:	2300      	movs	r3, #0
 80090b2:	e04c      	b.n	800914e <iecProcAddrAnswer+0xee>
	pxBuf++;
 80090b4:	68fb      	ldr	r3, [r7, #12]
 80090b6:	3301      	adds	r3, #1
 80090b8:	60fb      	str	r3, [r7, #12]
	if (*pxBuf != '(')
 80090ba:	68fb      	ldr	r3, [r7, #12]
 80090bc:	781b      	ldrb	r3, [r3, #0]
 80090be:	2b28      	cmp	r3, #40	; 0x28
 80090c0:	d001      	beq.n	80090c6 <iecProcAddrAnswer+0x66>
		return false;
 80090c2:	2300      	movs	r3, #0
 80090c4:	e043      	b.n	800914e <iecProcAddrAnswer+0xee>
	pxBuf++;
 80090c6:	68fb      	ldr	r3, [r7, #12]
 80090c8:	3301      	adds	r3, #1
 80090ca:	60fb      	str	r3, [r7, #12]
	i = 0;
 80090cc:	2300      	movs	r3, #0
 80090ce:	61fb      	str	r3, [r7, #28]
	while ((*pxBuf != ')') && (limit > 0))
 80090d0:	e012      	b.n	80090f8 <iecProcAddrAnswer+0x98>
	{
		if (i >= limit)
 80090d2:	79fb      	ldrb	r3, [r7, #7]
 80090d4:	69fa      	ldr	r2, [r7, #28]
 80090d6:	429a      	cmp	r2, r3
 80090d8:	db01      	blt.n	80090de <iecProcAddrAnswer+0x7e>
			return false;
 80090da:	2300      	movs	r3, #0
 80090dc:	e037      	b.n	800914e <iecProcAddrAnswer+0xee>
		*addrStr = (char) *pxBuf;
 80090de:	68fb      	ldr	r3, [r7, #12]
 80090e0:	781a      	ldrb	r2, [r3, #0]
 80090e2:	68bb      	ldr	r3, [r7, #8]
 80090e4:	701a      	strb	r2, [r3, #0]
		i++;
 80090e6:	69fb      	ldr	r3, [r7, #28]
 80090e8:	3301      	adds	r3, #1
 80090ea:	61fb      	str	r3, [r7, #28]
		addrStr++;
 80090ec:	68bb      	ldr	r3, [r7, #8]
 80090ee:	3301      	adds	r3, #1
 80090f0:	60bb      	str	r3, [r7, #8]
		pxBuf++;
 80090f2:	68fb      	ldr	r3, [r7, #12]
 80090f4:	3301      	adds	r3, #1
 80090f6:	60fb      	str	r3, [r7, #12]
	while ((*pxBuf != ')') && (limit > 0))
 80090f8:	68fb      	ldr	r3, [r7, #12]
 80090fa:	781b      	ldrb	r3, [r3, #0]
 80090fc:	2b29      	cmp	r3, #41	; 0x29
 80090fe:	d002      	beq.n	8009106 <iecProcAddrAnswer+0xa6>
 8009100:	79fb      	ldrb	r3, [r7, #7]
 8009102:	2b00      	cmp	r3, #0
 8009104:	d1e5      	bne.n	80090d2 <iecProcAddrAnswer+0x72>
	}
	*addrStr = 0; // end of string
 8009106:	68bb      	ldr	r3, [r7, #8]
 8009108:	2200      	movs	r2, #0
 800910a:	701a      	strb	r2, [r3, #0]
	pxBuf++;
 800910c:	68fb      	ldr	r3, [r7, #12]
 800910e:	3301      	adds	r3, #1
 8009110:	60fb      	str	r3, [r7, #12]
	if (*pxBuf != ETX)
 8009112:	68fb      	ldr	r3, [r7, #12]
 8009114:	781b      	ldrb	r3, [r3, #0]
 8009116:	2b03      	cmp	r3, #3
 8009118:	d001      	beq.n	800911e <iecProcAddrAnswer+0xbe>
		return false;
 800911a:	2300      	movs	r3, #0
 800911c:	e017      	b.n	800914e <iecProcAddrAnswer+0xee>
	pxBuf++;
 800911e:	68fb      	ldr	r3, [r7, #12]
 8009120:	3301      	adds	r3, #1
 8009122:	60fb      	str	r3, [r7, #12]
	uint8 bcc = iecClaculateBCC((tmpbuff + 1), 3 + 1 + i + 1 + 1);
 8009124:	69bb      	ldr	r3, [r7, #24]
 8009126:	1c5a      	adds	r2, r3, #1
 8009128:	69fb      	ldr	r3, [r7, #28]
 800912a:	b29b      	uxth	r3, r3
 800912c:	3306      	adds	r3, #6
 800912e:	b29b      	uxth	r3, r3
 8009130:	4619      	mov	r1, r3
 8009132:	4610      	mov	r0, r2
 8009134:	4b08      	ldr	r3, [pc, #32]	; (8009158 <iecProcAddrAnswer+0xf8>)
 8009136:	4798      	blx	r3
 8009138:	4603      	mov	r3, r0
 800913a:	75fb      	strb	r3, [r7, #23]
	if (bcc != *pxBuf)
 800913c:	68fb      	ldr	r3, [r7, #12]
 800913e:	781b      	ldrb	r3, [r3, #0]
 8009140:	7dfa      	ldrb	r2, [r7, #23]
 8009142:	429a      	cmp	r2, r3
 8009144:	d001      	beq.n	800914a <iecProcAddrAnswer+0xea>
	{
		return false;
 8009146:	2300      	movs	r3, #0
 8009148:	e001      	b.n	800914e <iecProcAddrAnswer+0xee>
	}
	return true;
 800914a:	f04f 33ff 	mov.w	r3, #4294967295
}
 800914e:	4618      	mov	r0, r3
 8009150:	3720      	adds	r7, #32
 8009152:	46bd      	mov	sp, r7
 8009154:	bd80      	pop	{r7, pc}
 8009156:	bf00      	nop
 8009158:	08008e7d 	.word	0x08008e7d

0800915c <iecProcVarReqPacket>:
	pxBuf++;
	*pxBuf = iecClaculateBCC(tmpbuff + 1, 4 + i + 1 + 1);
	return (5 + i + 2 + 1);
}
uint16 iecProcVarReqPacket(char *pxBuf, char *var, uint8 limit)
{
 800915c:	b580      	push	{r7, lr}
 800915e:	b086      	sub	sp, #24
 8009160:	af00      	add	r7, sp, #0
 8009162:	60f8      	str	r0, [r7, #12]
 8009164:	60b9      	str	r1, [r7, #8]
 8009166:	4613      	mov	r3, r2
 8009168:	71fb      	strb	r3, [r7, #7]
	uint8 *tmpbuff = pxBuf;
 800916a:	68fb      	ldr	r3, [r7, #12]
 800916c:	613b      	str	r3, [r7, #16]
	*pxBuf = SOH;
 800916e:	68fb      	ldr	r3, [r7, #12]
 8009170:	2201      	movs	r2, #1
 8009172:	701a      	strb	r2, [r3, #0]
	pxBuf++;
 8009174:	68fb      	ldr	r3, [r7, #12]
 8009176:	3301      	adds	r3, #1
 8009178:	60fb      	str	r3, [r7, #12]
	*pxBuf = 'R';
 800917a:	68fb      	ldr	r3, [r7, #12]
 800917c:	2252      	movs	r2, #82	; 0x52
 800917e:	701a      	strb	r2, [r3, #0]
	pxBuf++;
 8009180:	68fb      	ldr	r3, [r7, #12]
 8009182:	3301      	adds	r3, #1
 8009184:	60fb      	str	r3, [r7, #12]
	*pxBuf = '1';
 8009186:	68fb      	ldr	r3, [r7, #12]
 8009188:	2231      	movs	r2, #49	; 0x31
 800918a:	701a      	strb	r2, [r3, #0]
	pxBuf++;
 800918c:	68fb      	ldr	r3, [r7, #12]
 800918e:	3301      	adds	r3, #1
 8009190:	60fb      	str	r3, [r7, #12]
	*pxBuf = STX;
 8009192:	68fb      	ldr	r3, [r7, #12]
 8009194:	2202      	movs	r2, #2
 8009196:	701a      	strb	r2, [r3, #0]
	pxBuf++;
 8009198:	68fb      	ldr	r3, [r7, #12]
 800919a:	3301      	adds	r3, #1
 800919c:	60fb      	str	r3, [r7, #12]
	int i = 0;
 800919e:	2300      	movs	r3, #0
 80091a0:	617b      	str	r3, [r7, #20]
	while (*var)
 80091a2:	e012      	b.n	80091ca <iecProcVarReqPacket+0x6e>
	{
		if (i >= limit)
 80091a4:	79fb      	ldrb	r3, [r7, #7]
 80091a6:	697a      	ldr	r2, [r7, #20]
 80091a8:	429a      	cmp	r2, r3
 80091aa:	db01      	blt.n	80091b0 <iecProcVarReqPacket+0x54>
			return 0;
 80091ac:	2300      	movs	r3, #0
 80091ae:	e034      	b.n	800921a <iecProcVarReqPacket+0xbe>
		*pxBuf = *var;
 80091b0:	68bb      	ldr	r3, [r7, #8]
 80091b2:	781a      	ldrb	r2, [r3, #0]
 80091b4:	68fb      	ldr	r3, [r7, #12]
 80091b6:	701a      	strb	r2, [r3, #0]
		pxBuf++;
 80091b8:	68fb      	ldr	r3, [r7, #12]
 80091ba:	3301      	adds	r3, #1
 80091bc:	60fb      	str	r3, [r7, #12]
		var++;
 80091be:	68bb      	ldr	r3, [r7, #8]
 80091c0:	3301      	adds	r3, #1
 80091c2:	60bb      	str	r3, [r7, #8]
		i++;
 80091c4:	697b      	ldr	r3, [r7, #20]
 80091c6:	3301      	adds	r3, #1
 80091c8:	617b      	str	r3, [r7, #20]
	while (*var)
 80091ca:	68bb      	ldr	r3, [r7, #8]
 80091cc:	781b      	ldrb	r3, [r3, #0]
 80091ce:	2b00      	cmp	r3, #0
 80091d0:	d1e8      	bne.n	80091a4 <iecProcVarReqPacket+0x48>
	}

	*pxBuf = '(';
 80091d2:	68fb      	ldr	r3, [r7, #12]
 80091d4:	2228      	movs	r2, #40	; 0x28
 80091d6:	701a      	strb	r2, [r3, #0]
	pxBuf++;
 80091d8:	68fb      	ldr	r3, [r7, #12]
 80091da:	3301      	adds	r3, #1
 80091dc:	60fb      	str	r3, [r7, #12]

	*pxBuf = ')';
 80091de:	68fb      	ldr	r3, [r7, #12]
 80091e0:	2229      	movs	r2, #41	; 0x29
 80091e2:	701a      	strb	r2, [r3, #0]
	pxBuf++;
 80091e4:	68fb      	ldr	r3, [r7, #12]
 80091e6:	3301      	adds	r3, #1
 80091e8:	60fb      	str	r3, [r7, #12]
	*pxBuf = ETX;
 80091ea:	68fb      	ldr	r3, [r7, #12]
 80091ec:	2203      	movs	r2, #3
 80091ee:	701a      	strb	r2, [r3, #0]
	pxBuf++;
 80091f0:	68fb      	ldr	r3, [r7, #12]
 80091f2:	3301      	adds	r3, #1
 80091f4:	60fb      	str	r3, [r7, #12]
	*pxBuf = iecClaculateBCC(tmpbuff + 1, 3 + i + 2 + 1);
 80091f6:	693b      	ldr	r3, [r7, #16]
 80091f8:	1c5a      	adds	r2, r3, #1
 80091fa:	697b      	ldr	r3, [r7, #20]
 80091fc:	b29b      	uxth	r3, r3
 80091fe:	3306      	adds	r3, #6
 8009200:	b29b      	uxth	r3, r3
 8009202:	4619      	mov	r1, r3
 8009204:	4610      	mov	r0, r2
 8009206:	4b07      	ldr	r3, [pc, #28]	; (8009224 <iecProcVarReqPacket+0xc8>)
 8009208:	4798      	blx	r3
 800920a:	4603      	mov	r3, r0
 800920c:	461a      	mov	r2, r3
 800920e:	68fb      	ldr	r3, [r7, #12]
 8009210:	701a      	strb	r2, [r3, #0]
	return (4 + i + 2 + 2);
 8009212:	697b      	ldr	r3, [r7, #20]
 8009214:	b29b      	uxth	r3, r3
 8009216:	3308      	adds	r3, #8
 8009218:	b29b      	uxth	r3, r3
}
 800921a:	4618      	mov	r0, r3
 800921c:	3718      	adds	r7, #24
 800921e:	46bd      	mov	sp, r7
 8009220:	bd80      	pop	{r7, pc}
 8009222:	bf00      	nop
 8009224:	08008e7d 	.word	0x08008e7d

08009228 <iecProcVarAnswerPacket>:
	*pxBuf = iecClaculateBCC(tmpbuff + 1, 3 + i + j + 2 + 1);
	return (4 + i +j + 2 + 2);
}

bool iecProcVarAnswerPacket(char *pxBuf, char *value, uint8 limit)
{
 8009228:	b580      	push	{r7, lr}
 800922a:	b088      	sub	sp, #32
 800922c:	af00      	add	r7, sp, #0
 800922e:	60f8      	str	r0, [r7, #12]
 8009230:	60b9      	str	r1, [r7, #8]
 8009232:	4613      	mov	r3, r2
 8009234:	71fb      	strb	r3, [r7, #7]
	int i = 0;
 8009236:	2300      	movs	r3, #0
 8009238:	61fb      	str	r3, [r7, #28]
	uint8 *tmpbuff = pxBuf;
 800923a:	68fb      	ldr	r3, [r7, #12]
 800923c:	61bb      	str	r3, [r7, #24]
	if (*pxBuf != STX)
 800923e:	68fb      	ldr	r3, [r7, #12]
 8009240:	781b      	ldrb	r3, [r3, #0]
 8009242:	2b02      	cmp	r3, #2
 8009244:	d001      	beq.n	800924a <iecProcVarAnswerPacket+0x22>
		return false;
 8009246:	2300      	movs	r3, #0
 8009248:	e032      	b.n	80092b0 <iecProcVarAnswerPacket+0x88>
	pxBuf++;
 800924a:	68fb      	ldr	r3, [r7, #12]
 800924c:	3301      	adds	r3, #1
 800924e:	60fb      	str	r3, [r7, #12]
	while (*pxBuf != ETX)
 8009250:	e012      	b.n	8009278 <iecProcVarAnswerPacket+0x50>
	{
		if (i >= limit)
 8009252:	79fb      	ldrb	r3, [r7, #7]
 8009254:	69fa      	ldr	r2, [r7, #28]
 8009256:	429a      	cmp	r2, r3
 8009258:	db01      	blt.n	800925e <iecProcVarAnswerPacket+0x36>
			return false;
 800925a:	2300      	movs	r3, #0
 800925c:	e028      	b.n	80092b0 <iecProcVarAnswerPacket+0x88>
		*value = (char) *pxBuf;
 800925e:	68fb      	ldr	r3, [r7, #12]
 8009260:	781a      	ldrb	r2, [r3, #0]
 8009262:	68bb      	ldr	r3, [r7, #8]
 8009264:	701a      	strb	r2, [r3, #0]
		i++;
 8009266:	69fb      	ldr	r3, [r7, #28]
 8009268:	3301      	adds	r3, #1
 800926a:	61fb      	str	r3, [r7, #28]
		value++;
 800926c:	68bb      	ldr	r3, [r7, #8]
 800926e:	3301      	adds	r3, #1
 8009270:	60bb      	str	r3, [r7, #8]
		pxBuf++;
 8009272:	68fb      	ldr	r3, [r7, #12]
 8009274:	3301      	adds	r3, #1
 8009276:	60fb      	str	r3, [r7, #12]
	while (*pxBuf != ETX)
 8009278:	68fb      	ldr	r3, [r7, #12]
 800927a:	781b      	ldrb	r3, [r3, #0]
 800927c:	2b03      	cmp	r3, #3
 800927e:	d1e8      	bne.n	8009252 <iecProcVarAnswerPacket+0x2a>
	};

	pxBuf++;
 8009280:	68fb      	ldr	r3, [r7, #12]
 8009282:	3301      	adds	r3, #1
 8009284:	60fb      	str	r3, [r7, #12]
	uint8 bcc = iecClaculateBCC((tmpbuff + 1), i + 1);
 8009286:	69bb      	ldr	r3, [r7, #24]
 8009288:	1c5a      	adds	r2, r3, #1
 800928a:	69fb      	ldr	r3, [r7, #28]
 800928c:	b29b      	uxth	r3, r3
 800928e:	3301      	adds	r3, #1
 8009290:	b29b      	uxth	r3, r3
 8009292:	4619      	mov	r1, r3
 8009294:	4610      	mov	r0, r2
 8009296:	4b08      	ldr	r3, [pc, #32]	; (80092b8 <iecProcVarAnswerPacket+0x90>)
 8009298:	4798      	blx	r3
 800929a:	4603      	mov	r3, r0
 800929c:	75fb      	strb	r3, [r7, #23]
	if (bcc != *pxBuf)
 800929e:	68fb      	ldr	r3, [r7, #12]
 80092a0:	781b      	ldrb	r3, [r3, #0]
 80092a2:	7dfa      	ldrb	r2, [r7, #23]
 80092a4:	429a      	cmp	r2, r3
 80092a6:	d001      	beq.n	80092ac <iecProcVarAnswerPacket+0x84>
	{
		return false;
 80092a8:	2300      	movs	r3, #0
 80092aa:	e001      	b.n	80092b0 <iecProcVarAnswerPacket+0x88>
	}
	return true;
 80092ac:	f04f 33ff 	mov.w	r3, #4294967295
}
 80092b0:	4618      	mov	r0, r3
 80092b2:	3720      	adds	r7, #32
 80092b4:	46bd      	mov	sp, r7
 80092b6:	bd80      	pop	{r7, pc}
 80092b8:	08008e7d 	.word	0x08008e7d

080092bc <iecProcExitPacket>:

uint16 iecProcExitPacket(char *pxBuf)
{
 80092bc:	b480      	push	{r7}
 80092be:	b083      	sub	sp, #12
 80092c0:	af00      	add	r7, sp, #0
 80092c2:	6078      	str	r0, [r7, #4]
	*pxBuf = 0x01;
 80092c4:	687b      	ldr	r3, [r7, #4]
 80092c6:	2201      	movs	r2, #1
 80092c8:	701a      	strb	r2, [r3, #0]
	pxBuf++;
 80092ca:	687b      	ldr	r3, [r7, #4]
 80092cc:	3301      	adds	r3, #1
 80092ce:	607b      	str	r3, [r7, #4]
	*pxBuf = 0x42;
 80092d0:	687b      	ldr	r3, [r7, #4]
 80092d2:	2242      	movs	r2, #66	; 0x42
 80092d4:	701a      	strb	r2, [r3, #0]
	pxBuf++;
 80092d6:	687b      	ldr	r3, [r7, #4]
 80092d8:	3301      	adds	r3, #1
 80092da:	607b      	str	r3, [r7, #4]
	*pxBuf = 0x30;
 80092dc:	687b      	ldr	r3, [r7, #4]
 80092de:	2230      	movs	r2, #48	; 0x30
 80092e0:	701a      	strb	r2, [r3, #0]
	pxBuf++;
 80092e2:	687b      	ldr	r3, [r7, #4]
 80092e4:	3301      	adds	r3, #1
 80092e6:	607b      	str	r3, [r7, #4]
	*pxBuf = 0x03;
 80092e8:	687b      	ldr	r3, [r7, #4]
 80092ea:	2203      	movs	r2, #3
 80092ec:	701a      	strb	r2, [r3, #0]
	pxBuf++;
 80092ee:	687b      	ldr	r3, [r7, #4]
 80092f0:	3301      	adds	r3, #1
 80092f2:	607b      	str	r3, [r7, #4]
	*pxBuf = 0x75;
 80092f4:	687b      	ldr	r3, [r7, #4]
 80092f6:	2275      	movs	r2, #117	; 0x75
 80092f8:	701a      	strb	r2, [r3, #0]
	return 5;
 80092fa:	2305      	movs	r3, #5
}
 80092fc:	4618      	mov	r0, r3
 80092fe:	370c      	adds	r7, #12
 8009300:	46bd      	mov	sp, r7
 8009302:	bc80      	pop	{r7}
 8009304:	4770      	bx	lr
	...

08009308 <SetCRC16>:
		0x0220, 0x8225, 0x822F, 0x022A, 0x823B, 0x023E, 0x0234, 0x8231, 0x8213,
		0x0216, 0x021C, 0x8219, 0x0208, 0x820D, 0x8207, 0x0202

};

uint16 SetCRC16(uint8 *pcBlock, uint16 len) {
 8009308:	b480      	push	{r7}
 800930a:	b085      	sub	sp, #20
 800930c:	af00      	add	r7, sp, #0
 800930e:	6078      	str	r0, [r7, #4]
 8009310:	460b      	mov	r3, r1
 8009312:	807b      	strh	r3, [r7, #2]
	uint16 crc = 0x0000;
 8009314:	2300      	movs	r3, #0
 8009316:	81fb      	strh	r3, [r7, #14]

	while (len--)
 8009318:	e012      	b.n	8009340 <SetCRC16+0x38>
		crc = (crc << 8) ^ Crc16Tabl[(crc >> 8) ^ *pcBlock++];
 800931a:	89fb      	ldrh	r3, [r7, #14]
 800931c:	021b      	lsls	r3, r3, #8
 800931e:	b21a      	sxth	r2, r3
 8009320:	89fb      	ldrh	r3, [r7, #14]
 8009322:	0a1b      	lsrs	r3, r3, #8
 8009324:	b29b      	uxth	r3, r3
 8009326:	4618      	mov	r0, r3
 8009328:	687b      	ldr	r3, [r7, #4]
 800932a:	1c59      	adds	r1, r3, #1
 800932c:	6079      	str	r1, [r7, #4]
 800932e:	781b      	ldrb	r3, [r3, #0]
 8009330:	4043      	eors	r3, r0
 8009332:	490e      	ldr	r1, [pc, #56]	; (800936c <SetCRC16+0x64>)
 8009334:	f831 3013 	ldrh.w	r3, [r1, r3, lsl #1]
 8009338:	b21b      	sxth	r3, r3
 800933a:	4053      	eors	r3, r2
 800933c:	b21b      	sxth	r3, r3
 800933e:	81fb      	strh	r3, [r7, #14]
	while (len--)
 8009340:	887b      	ldrh	r3, [r7, #2]
 8009342:	1e5a      	subs	r2, r3, #1
 8009344:	807a      	strh	r2, [r7, #2]
 8009346:	2b00      	cmp	r3, #0
 8009348:	d1e7      	bne.n	800931a <SetCRC16+0x12>

	*pcBlock = crc >> 8;
 800934a:	89fb      	ldrh	r3, [r7, #14]
 800934c:	0a1b      	lsrs	r3, r3, #8
 800934e:	b29b      	uxth	r3, r3
 8009350:	b2da      	uxtb	r2, r3
 8009352:	687b      	ldr	r3, [r7, #4]
 8009354:	701a      	strb	r2, [r3, #0]
	*(pcBlock + 1) = crc;
 8009356:	687b      	ldr	r3, [r7, #4]
 8009358:	3301      	adds	r3, #1
 800935a:	89fa      	ldrh	r2, [r7, #14]
 800935c:	b2d2      	uxtb	r2, r2
 800935e:	701a      	strb	r2, [r3, #0]

	return crc;
 8009360:	89fb      	ldrh	r3, [r7, #14]
}
 8009362:	4618      	mov	r0, r3
 8009364:	3714      	adds	r7, #20
 8009366:	46bd      	mov	sp, r7
 8009368:	bc80      	pop	{r7}
 800936a:	4770      	bx	lr
 800936c:	08014e44 	.word	0x08014e44

08009370 <AskVoltA>:

//  
uint16 AskVoltA(uint8 *pxBuf318, uint32 MeterNumber)

{
 8009370:	b580      	push	{r7, lr}
 8009372:	b094      	sub	sp, #80	; 0x50
 8009374:	af00      	add	r7, sp, #0
 8009376:	6078      	str	r0, [r7, #4]
 8009378:	6039      	str	r1, [r7, #0]
	uint16 crc318;
	uint8 tmpbuff318[64];
	unsigned short lenBuf = 0;
 800937a:	2300      	movs	r3, #0
 800937c:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
	*pxBuf318 = SYM_ST318;
 8009380:	687b      	ldr	r3, [r7, #4]
 8009382:	22c0      	movs	r2, #192	; 0xc0
 8009384:	701a      	strb	r2, [r3, #0]

	pxBuf318++;
 8009386:	687b      	ldr	r3, [r7, #4]
 8009388:	3301      	adds	r3, #1
 800938a:	607b      	str	r3, [r7, #4]
	*pxBuf318 = tmpbuff318[0] = GET_INFO;
 800938c:	2306      	movs	r3, #6
 800938e:	733b      	strb	r3, [r7, #12]
 8009390:	7b3a      	ldrb	r2, [r7, #12]
 8009392:	687b      	ldr	r3, [r7, #4]
 8009394:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009396:	687b      	ldr	r3, [r7, #4]
 8009398:	3301      	adds	r3, #1
 800939a:	607b      	str	r3, [r7, #4]
	lenBuf++;
 800939c:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 80093a0:	3301      	adds	r3, #1
 80093a2:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[1] = MeterNumber;
 80093a6:	683b      	ldr	r3, [r7, #0]
 80093a8:	b2db      	uxtb	r3, r3
 80093aa:	737b      	strb	r3, [r7, #13]
 80093ac:	7b7a      	ldrb	r2, [r7, #13]
 80093ae:	687b      	ldr	r3, [r7, #4]
 80093b0:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 80093b2:	687b      	ldr	r3, [r7, #4]
 80093b4:	3301      	adds	r3, #1
 80093b6:	607b      	str	r3, [r7, #4]
	lenBuf++;
 80093b8:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 80093bc:	3301      	adds	r3, #1
 80093be:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[2] = MeterNumber >> 8;
 80093c2:	683b      	ldr	r3, [r7, #0]
 80093c4:	0a1b      	lsrs	r3, r3, #8
 80093c6:	b2db      	uxtb	r3, r3
 80093c8:	73bb      	strb	r3, [r7, #14]
 80093ca:	7bba      	ldrb	r2, [r7, #14]
 80093cc:	687b      	ldr	r3, [r7, #4]
 80093ce:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 80093d0:	687b      	ldr	r3, [r7, #4]
 80093d2:	3301      	adds	r3, #1
 80093d4:	607b      	str	r3, [r7, #4]
	lenBuf++;
 80093d6:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 80093da:	3301      	adds	r3, #1
 80093dc:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[3] = MeterNumber >> 16;
 80093e0:	683b      	ldr	r3, [r7, #0]
 80093e2:	0c1b      	lsrs	r3, r3, #16
 80093e4:	b2db      	uxtb	r3, r3
 80093e6:	73fb      	strb	r3, [r7, #15]
 80093e8:	7bfa      	ldrb	r2, [r7, #15]
 80093ea:	687b      	ldr	r3, [r7, #4]
 80093ec:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 80093ee:	687b      	ldr	r3, [r7, #4]
 80093f0:	3301      	adds	r3, #1
 80093f2:	607b      	str	r3, [r7, #4]
	lenBuf++;
 80093f4:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 80093f8:	3301      	adds	r3, #1
 80093fa:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[4] = MeterNumber >> 24;
 80093fe:	683b      	ldr	r3, [r7, #0]
 8009400:	0e1b      	lsrs	r3, r3, #24
 8009402:	b2db      	uxtb	r3, r3
 8009404:	743b      	strb	r3, [r7, #16]
 8009406:	7c3a      	ldrb	r2, [r7, #16]
 8009408:	687b      	ldr	r3, [r7, #4]
 800940a:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 800940c:	687b      	ldr	r3, [r7, #4]
 800940e:	3301      	adds	r3, #1
 8009410:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009412:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009416:	3301      	adds	r3, #1
 8009418:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[5] = 0x00;
 800941c:	2300      	movs	r3, #0
 800941e:	747b      	strb	r3, [r7, #17]
 8009420:	7c7a      	ldrb	r2, [r7, #17]
 8009422:	687b      	ldr	r3, [r7, #4]
 8009424:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009426:	687b      	ldr	r3, [r7, #4]
 8009428:	3301      	adds	r3, #1
 800942a:	607b      	str	r3, [r7, #4]
	lenBuf++;
 800942c:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009430:	3301      	adds	r3, #1
 8009432:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[6] = GET_INFO;
 8009436:	2306      	movs	r3, #6
 8009438:	74bb      	strb	r3, [r7, #18]
 800943a:	7cba      	ldrb	r2, [r7, #18]
 800943c:	687b      	ldr	r3, [r7, #4]
 800943e:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009440:	687b      	ldr	r3, [r7, #4]
 8009442:	3301      	adds	r3, #1
 8009444:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009446:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800944a:	3301      	adds	r3, #1
 800944c:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[7] = GET_DATA_SINGLE;
 8009450:	230a      	movs	r3, #10
 8009452:	74fb      	strb	r3, [r7, #19]
 8009454:	7cfa      	ldrb	r2, [r7, #19]
 8009456:	687b      	ldr	r3, [r7, #4]
 8009458:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 800945a:	687b      	ldr	r3, [r7, #4]
 800945c:	3301      	adds	r3, #1
 800945e:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009460:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009464:	3301      	adds	r3, #1
 8009466:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[8] = 0x00;
 800946a:	2300      	movs	r3, #0
 800946c:	753b      	strb	r3, [r7, #20]
 800946e:	7d3a      	ldrb	r2, [r7, #20]
 8009470:	687b      	ldr	r3, [r7, #4]
 8009472:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009474:	687b      	ldr	r3, [r7, #4]
 8009476:	3301      	adds	r3, #1
 8009478:	607b      	str	r3, [r7, #4]
	lenBuf++;
 800947a:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800947e:	3301      	adds	r3, #1
 8009480:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[9] = GET_VOLT;
 8009484:	2318      	movs	r3, #24
 8009486:	757b      	strb	r3, [r7, #21]
 8009488:	7d7a      	ldrb	r2, [r7, #21]
 800948a:	687b      	ldr	r3, [r7, #4]
 800948c:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 800948e:	687b      	ldr	r3, [r7, #4]
 8009490:	3301      	adds	r3, #1
 8009492:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009494:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009498:	3301      	adds	r3, #1
 800949a:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[10] = GET_A;
 800949e:	2304      	movs	r3, #4
 80094a0:	75bb      	strb	r3, [r7, #22]
 80094a2:	7dba      	ldrb	r2, [r7, #22]
 80094a4:	687b      	ldr	r3, [r7, #4]
 80094a6:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 80094a8:	687b      	ldr	r3, [r7, #4]
 80094aa:	3301      	adds	r3, #1
 80094ac:	607b      	str	r3, [r7, #4]
	lenBuf++;
 80094ae:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 80094b2:	3301      	adds	r3, #1
 80094b4:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	crc318 = SetCRC16(tmpbuff318, lenBuf);
 80094b8:	f8b7 204e 	ldrh.w	r2, [r7, #78]	; 0x4e
 80094bc:	f107 030c 	add.w	r3, r7, #12
 80094c0:	4611      	mov	r1, r2
 80094c2:	4618      	mov	r0, r3
 80094c4:	4b15      	ldr	r3, [pc, #84]	; (800951c <AskVoltA+0x1ac>)
 80094c6:	4798      	blx	r3
 80094c8:	4603      	mov	r3, r0
 80094ca:	f8a7 304c 	strh.w	r3, [r7, #76]	; 0x4c

	*pxBuf318 = crc318 >> 8;
 80094ce:	f8b7 304c 	ldrh.w	r3, [r7, #76]	; 0x4c
 80094d2:	0a1b      	lsrs	r3, r3, #8
 80094d4:	b29b      	uxth	r3, r3
 80094d6:	b2da      	uxtb	r2, r3
 80094d8:	687b      	ldr	r3, [r7, #4]
 80094da:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 80094dc:	687b      	ldr	r3, [r7, #4]
 80094de:	3301      	adds	r3, #1
 80094e0:	607b      	str	r3, [r7, #4]
	lenBuf++;
 80094e2:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 80094e6:	3301      	adds	r3, #1
 80094e8:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
	*pxBuf318 = crc318;
 80094ec:	f8b7 304c 	ldrh.w	r3, [r7, #76]	; 0x4c
 80094f0:	b2da      	uxtb	r2, r3
 80094f2:	687b      	ldr	r3, [r7, #4]
 80094f4:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 80094f6:	687b      	ldr	r3, [r7, #4]
 80094f8:	3301      	adds	r3, #1
 80094fa:	607b      	str	r3, [r7, #4]
	lenBuf++;
 80094fc:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009500:	3301      	adds	r3, #1
 8009502:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
	*pxBuf318 = SYM_ST318;
 8009506:	687b      	ldr	r3, [r7, #4]
 8009508:	22c0      	movs	r2, #192	; 0xc0
 800950a:	701a      	strb	r2, [r3, #0]

	return (lenBuf + 2);
 800950c:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009510:	3302      	adds	r3, #2
 8009512:	b29b      	uxth	r3, r3
}
 8009514:	4618      	mov	r0, r3
 8009516:	3750      	adds	r7, #80	; 0x50
 8009518:	46bd      	mov	sp, r7
 800951a:	bd80      	pop	{r7, pc}
 800951c:	08009309 	.word	0x08009309

08009520 <AskVoltB>:

uint16 AskVoltB(uint8 *pxBuf318, uint32 MeterNumber)

{
 8009520:	b580      	push	{r7, lr}
 8009522:	b094      	sub	sp, #80	; 0x50
 8009524:	af00      	add	r7, sp, #0
 8009526:	6078      	str	r0, [r7, #4]
 8009528:	6039      	str	r1, [r7, #0]
	uint16 crc318;
	uint8 tmpbuff318[64];
	unsigned short lenBuf = 0;
 800952a:	2300      	movs	r3, #0
 800952c:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
	*pxBuf318 = SYM_ST318;
 8009530:	687b      	ldr	r3, [r7, #4]
 8009532:	22c0      	movs	r2, #192	; 0xc0
 8009534:	701a      	strb	r2, [r3, #0]

	pxBuf318++;
 8009536:	687b      	ldr	r3, [r7, #4]
 8009538:	3301      	adds	r3, #1
 800953a:	607b      	str	r3, [r7, #4]
	*pxBuf318 = tmpbuff318[0] = GET_INFO;
 800953c:	2306      	movs	r3, #6
 800953e:	733b      	strb	r3, [r7, #12]
 8009540:	7b3a      	ldrb	r2, [r7, #12]
 8009542:	687b      	ldr	r3, [r7, #4]
 8009544:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009546:	687b      	ldr	r3, [r7, #4]
 8009548:	3301      	adds	r3, #1
 800954a:	607b      	str	r3, [r7, #4]
	lenBuf++;
 800954c:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009550:	3301      	adds	r3, #1
 8009552:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[1] = MeterNumber;
 8009556:	683b      	ldr	r3, [r7, #0]
 8009558:	b2db      	uxtb	r3, r3
 800955a:	737b      	strb	r3, [r7, #13]
 800955c:	7b7a      	ldrb	r2, [r7, #13]
 800955e:	687b      	ldr	r3, [r7, #4]
 8009560:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009562:	687b      	ldr	r3, [r7, #4]
 8009564:	3301      	adds	r3, #1
 8009566:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009568:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800956c:	3301      	adds	r3, #1
 800956e:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[2] = MeterNumber >> 8;
 8009572:	683b      	ldr	r3, [r7, #0]
 8009574:	0a1b      	lsrs	r3, r3, #8
 8009576:	b2db      	uxtb	r3, r3
 8009578:	73bb      	strb	r3, [r7, #14]
 800957a:	7bba      	ldrb	r2, [r7, #14]
 800957c:	687b      	ldr	r3, [r7, #4]
 800957e:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009580:	687b      	ldr	r3, [r7, #4]
 8009582:	3301      	adds	r3, #1
 8009584:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009586:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800958a:	3301      	adds	r3, #1
 800958c:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[3] = MeterNumber >> 16;
 8009590:	683b      	ldr	r3, [r7, #0]
 8009592:	0c1b      	lsrs	r3, r3, #16
 8009594:	b2db      	uxtb	r3, r3
 8009596:	73fb      	strb	r3, [r7, #15]
 8009598:	7bfa      	ldrb	r2, [r7, #15]
 800959a:	687b      	ldr	r3, [r7, #4]
 800959c:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 800959e:	687b      	ldr	r3, [r7, #4]
 80095a0:	3301      	adds	r3, #1
 80095a2:	607b      	str	r3, [r7, #4]
	lenBuf++;
 80095a4:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 80095a8:	3301      	adds	r3, #1
 80095aa:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[4] = MeterNumber >> 24;
 80095ae:	683b      	ldr	r3, [r7, #0]
 80095b0:	0e1b      	lsrs	r3, r3, #24
 80095b2:	b2db      	uxtb	r3, r3
 80095b4:	743b      	strb	r3, [r7, #16]
 80095b6:	7c3a      	ldrb	r2, [r7, #16]
 80095b8:	687b      	ldr	r3, [r7, #4]
 80095ba:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 80095bc:	687b      	ldr	r3, [r7, #4]
 80095be:	3301      	adds	r3, #1
 80095c0:	607b      	str	r3, [r7, #4]
	lenBuf++;
 80095c2:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 80095c6:	3301      	adds	r3, #1
 80095c8:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[5] = 0x00;
 80095cc:	2300      	movs	r3, #0
 80095ce:	747b      	strb	r3, [r7, #17]
 80095d0:	7c7a      	ldrb	r2, [r7, #17]
 80095d2:	687b      	ldr	r3, [r7, #4]
 80095d4:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 80095d6:	687b      	ldr	r3, [r7, #4]
 80095d8:	3301      	adds	r3, #1
 80095da:	607b      	str	r3, [r7, #4]
	lenBuf++;
 80095dc:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 80095e0:	3301      	adds	r3, #1
 80095e2:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[6] = GET_INFO;
 80095e6:	2306      	movs	r3, #6
 80095e8:	74bb      	strb	r3, [r7, #18]
 80095ea:	7cba      	ldrb	r2, [r7, #18]
 80095ec:	687b      	ldr	r3, [r7, #4]
 80095ee:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 80095f0:	687b      	ldr	r3, [r7, #4]
 80095f2:	3301      	adds	r3, #1
 80095f4:	607b      	str	r3, [r7, #4]
	lenBuf++;
 80095f6:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 80095fa:	3301      	adds	r3, #1
 80095fc:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[7] = GET_DATA_SINGLE;
 8009600:	230a      	movs	r3, #10
 8009602:	74fb      	strb	r3, [r7, #19]
 8009604:	7cfa      	ldrb	r2, [r7, #19]
 8009606:	687b      	ldr	r3, [r7, #4]
 8009608:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 800960a:	687b      	ldr	r3, [r7, #4]
 800960c:	3301      	adds	r3, #1
 800960e:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009610:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009614:	3301      	adds	r3, #1
 8009616:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[8] = 0x00;
 800961a:	2300      	movs	r3, #0
 800961c:	753b      	strb	r3, [r7, #20]
 800961e:	7d3a      	ldrb	r2, [r7, #20]
 8009620:	687b      	ldr	r3, [r7, #4]
 8009622:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009624:	687b      	ldr	r3, [r7, #4]
 8009626:	3301      	adds	r3, #1
 8009628:	607b      	str	r3, [r7, #4]
	lenBuf++;
 800962a:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800962e:	3301      	adds	r3, #1
 8009630:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[9] = GET_VOLT;
 8009634:	2318      	movs	r3, #24
 8009636:	757b      	strb	r3, [r7, #21]
 8009638:	7d7a      	ldrb	r2, [r7, #21]
 800963a:	687b      	ldr	r3, [r7, #4]
 800963c:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 800963e:	687b      	ldr	r3, [r7, #4]
 8009640:	3301      	adds	r3, #1
 8009642:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009644:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009648:	3301      	adds	r3, #1
 800964a:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[10] = GET_B;
 800964e:	2308      	movs	r3, #8
 8009650:	75bb      	strb	r3, [r7, #22]
 8009652:	7dba      	ldrb	r2, [r7, #22]
 8009654:	687b      	ldr	r3, [r7, #4]
 8009656:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009658:	687b      	ldr	r3, [r7, #4]
 800965a:	3301      	adds	r3, #1
 800965c:	607b      	str	r3, [r7, #4]
	lenBuf++;
 800965e:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009662:	3301      	adds	r3, #1
 8009664:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	crc318 = SetCRC16(tmpbuff318, lenBuf);
 8009668:	f8b7 204e 	ldrh.w	r2, [r7, #78]	; 0x4e
 800966c:	f107 030c 	add.w	r3, r7, #12
 8009670:	4611      	mov	r1, r2
 8009672:	4618      	mov	r0, r3
 8009674:	4b15      	ldr	r3, [pc, #84]	; (80096cc <AskVoltB+0x1ac>)
 8009676:	4798      	blx	r3
 8009678:	4603      	mov	r3, r0
 800967a:	f8a7 304c 	strh.w	r3, [r7, #76]	; 0x4c

	*pxBuf318 = crc318 >> 8;
 800967e:	f8b7 304c 	ldrh.w	r3, [r7, #76]	; 0x4c
 8009682:	0a1b      	lsrs	r3, r3, #8
 8009684:	b29b      	uxth	r3, r3
 8009686:	b2da      	uxtb	r2, r3
 8009688:	687b      	ldr	r3, [r7, #4]
 800968a:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 800968c:	687b      	ldr	r3, [r7, #4]
 800968e:	3301      	adds	r3, #1
 8009690:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009692:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009696:	3301      	adds	r3, #1
 8009698:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
	*pxBuf318 = crc318;
 800969c:	f8b7 304c 	ldrh.w	r3, [r7, #76]	; 0x4c
 80096a0:	b2da      	uxtb	r2, r3
 80096a2:	687b      	ldr	r3, [r7, #4]
 80096a4:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 80096a6:	687b      	ldr	r3, [r7, #4]
 80096a8:	3301      	adds	r3, #1
 80096aa:	607b      	str	r3, [r7, #4]
	lenBuf++;
 80096ac:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 80096b0:	3301      	adds	r3, #1
 80096b2:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
	*pxBuf318 = SYM_ST318;
 80096b6:	687b      	ldr	r3, [r7, #4]
 80096b8:	22c0      	movs	r2, #192	; 0xc0
 80096ba:	701a      	strb	r2, [r3, #0]

	return (lenBuf + 2);
 80096bc:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 80096c0:	3302      	adds	r3, #2
 80096c2:	b29b      	uxth	r3, r3
}
 80096c4:	4618      	mov	r0, r3
 80096c6:	3750      	adds	r7, #80	; 0x50
 80096c8:	46bd      	mov	sp, r7
 80096ca:	bd80      	pop	{r7, pc}
 80096cc:	08009309 	.word	0x08009309

080096d0 <AskVoltC>:

uint16 AskVoltC(uint8 *pxBuf318, uint32 MeterNumber)

{
 80096d0:	b580      	push	{r7, lr}
 80096d2:	b094      	sub	sp, #80	; 0x50
 80096d4:	af00      	add	r7, sp, #0
 80096d6:	6078      	str	r0, [r7, #4]
 80096d8:	6039      	str	r1, [r7, #0]
	uint16 crc318;
	uint8 tmpbuff318[64];
	unsigned short lenBuf = 0;
 80096da:	2300      	movs	r3, #0
 80096dc:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
	*pxBuf318 = SYM_ST318;
 80096e0:	687b      	ldr	r3, [r7, #4]
 80096e2:	22c0      	movs	r2, #192	; 0xc0
 80096e4:	701a      	strb	r2, [r3, #0]

	pxBuf318++;
 80096e6:	687b      	ldr	r3, [r7, #4]
 80096e8:	3301      	adds	r3, #1
 80096ea:	607b      	str	r3, [r7, #4]
	*pxBuf318 = tmpbuff318[0] = GET_INFO;
 80096ec:	2306      	movs	r3, #6
 80096ee:	733b      	strb	r3, [r7, #12]
 80096f0:	7b3a      	ldrb	r2, [r7, #12]
 80096f2:	687b      	ldr	r3, [r7, #4]
 80096f4:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 80096f6:	687b      	ldr	r3, [r7, #4]
 80096f8:	3301      	adds	r3, #1
 80096fa:	607b      	str	r3, [r7, #4]
	lenBuf++;
 80096fc:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009700:	3301      	adds	r3, #1
 8009702:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[1] = MeterNumber;
 8009706:	683b      	ldr	r3, [r7, #0]
 8009708:	b2db      	uxtb	r3, r3
 800970a:	737b      	strb	r3, [r7, #13]
 800970c:	7b7a      	ldrb	r2, [r7, #13]
 800970e:	687b      	ldr	r3, [r7, #4]
 8009710:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009712:	687b      	ldr	r3, [r7, #4]
 8009714:	3301      	adds	r3, #1
 8009716:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009718:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800971c:	3301      	adds	r3, #1
 800971e:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[2] = MeterNumber >> 8;
 8009722:	683b      	ldr	r3, [r7, #0]
 8009724:	0a1b      	lsrs	r3, r3, #8
 8009726:	b2db      	uxtb	r3, r3
 8009728:	73bb      	strb	r3, [r7, #14]
 800972a:	7bba      	ldrb	r2, [r7, #14]
 800972c:	687b      	ldr	r3, [r7, #4]
 800972e:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009730:	687b      	ldr	r3, [r7, #4]
 8009732:	3301      	adds	r3, #1
 8009734:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009736:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800973a:	3301      	adds	r3, #1
 800973c:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[3] = MeterNumber >> 16;
 8009740:	683b      	ldr	r3, [r7, #0]
 8009742:	0c1b      	lsrs	r3, r3, #16
 8009744:	b2db      	uxtb	r3, r3
 8009746:	73fb      	strb	r3, [r7, #15]
 8009748:	7bfa      	ldrb	r2, [r7, #15]
 800974a:	687b      	ldr	r3, [r7, #4]
 800974c:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 800974e:	687b      	ldr	r3, [r7, #4]
 8009750:	3301      	adds	r3, #1
 8009752:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009754:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009758:	3301      	adds	r3, #1
 800975a:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[4] = MeterNumber >> 24;
 800975e:	683b      	ldr	r3, [r7, #0]
 8009760:	0e1b      	lsrs	r3, r3, #24
 8009762:	b2db      	uxtb	r3, r3
 8009764:	743b      	strb	r3, [r7, #16]
 8009766:	7c3a      	ldrb	r2, [r7, #16]
 8009768:	687b      	ldr	r3, [r7, #4]
 800976a:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 800976c:	687b      	ldr	r3, [r7, #4]
 800976e:	3301      	adds	r3, #1
 8009770:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009772:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009776:	3301      	adds	r3, #1
 8009778:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[5] = 0x00;
 800977c:	2300      	movs	r3, #0
 800977e:	747b      	strb	r3, [r7, #17]
 8009780:	7c7a      	ldrb	r2, [r7, #17]
 8009782:	687b      	ldr	r3, [r7, #4]
 8009784:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009786:	687b      	ldr	r3, [r7, #4]
 8009788:	3301      	adds	r3, #1
 800978a:	607b      	str	r3, [r7, #4]
	lenBuf++;
 800978c:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009790:	3301      	adds	r3, #1
 8009792:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[6] = GET_INFO;
 8009796:	2306      	movs	r3, #6
 8009798:	74bb      	strb	r3, [r7, #18]
 800979a:	7cba      	ldrb	r2, [r7, #18]
 800979c:	687b      	ldr	r3, [r7, #4]
 800979e:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 80097a0:	687b      	ldr	r3, [r7, #4]
 80097a2:	3301      	adds	r3, #1
 80097a4:	607b      	str	r3, [r7, #4]
	lenBuf++;
 80097a6:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 80097aa:	3301      	adds	r3, #1
 80097ac:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[7] = GET_DATA_SINGLE;
 80097b0:	230a      	movs	r3, #10
 80097b2:	74fb      	strb	r3, [r7, #19]
 80097b4:	7cfa      	ldrb	r2, [r7, #19]
 80097b6:	687b      	ldr	r3, [r7, #4]
 80097b8:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 80097ba:	687b      	ldr	r3, [r7, #4]
 80097bc:	3301      	adds	r3, #1
 80097be:	607b      	str	r3, [r7, #4]
	lenBuf++;
 80097c0:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 80097c4:	3301      	adds	r3, #1
 80097c6:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[8] = 0x00;
 80097ca:	2300      	movs	r3, #0
 80097cc:	753b      	strb	r3, [r7, #20]
 80097ce:	7d3a      	ldrb	r2, [r7, #20]
 80097d0:	687b      	ldr	r3, [r7, #4]
 80097d2:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 80097d4:	687b      	ldr	r3, [r7, #4]
 80097d6:	3301      	adds	r3, #1
 80097d8:	607b      	str	r3, [r7, #4]
	lenBuf++;
 80097da:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 80097de:	3301      	adds	r3, #1
 80097e0:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[9] = GET_VOLT;
 80097e4:	2318      	movs	r3, #24
 80097e6:	757b      	strb	r3, [r7, #21]
 80097e8:	7d7a      	ldrb	r2, [r7, #21]
 80097ea:	687b      	ldr	r3, [r7, #4]
 80097ec:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 80097ee:	687b      	ldr	r3, [r7, #4]
 80097f0:	3301      	adds	r3, #1
 80097f2:	607b      	str	r3, [r7, #4]
	lenBuf++;
 80097f4:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 80097f8:	3301      	adds	r3, #1
 80097fa:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[10] = GET_C;
 80097fe:	2310      	movs	r3, #16
 8009800:	75bb      	strb	r3, [r7, #22]
 8009802:	7dba      	ldrb	r2, [r7, #22]
 8009804:	687b      	ldr	r3, [r7, #4]
 8009806:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009808:	687b      	ldr	r3, [r7, #4]
 800980a:	3301      	adds	r3, #1
 800980c:	607b      	str	r3, [r7, #4]
	lenBuf++;
 800980e:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009812:	3301      	adds	r3, #1
 8009814:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	crc318 = SetCRC16(tmpbuff318, lenBuf);
 8009818:	f8b7 204e 	ldrh.w	r2, [r7, #78]	; 0x4e
 800981c:	f107 030c 	add.w	r3, r7, #12
 8009820:	4611      	mov	r1, r2
 8009822:	4618      	mov	r0, r3
 8009824:	4b15      	ldr	r3, [pc, #84]	; (800987c <AskVoltC+0x1ac>)
 8009826:	4798      	blx	r3
 8009828:	4603      	mov	r3, r0
 800982a:	f8a7 304c 	strh.w	r3, [r7, #76]	; 0x4c

	*pxBuf318 = crc318 >> 8;
 800982e:	f8b7 304c 	ldrh.w	r3, [r7, #76]	; 0x4c
 8009832:	0a1b      	lsrs	r3, r3, #8
 8009834:	b29b      	uxth	r3, r3
 8009836:	b2da      	uxtb	r2, r3
 8009838:	687b      	ldr	r3, [r7, #4]
 800983a:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 800983c:	687b      	ldr	r3, [r7, #4]
 800983e:	3301      	adds	r3, #1
 8009840:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009842:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009846:	3301      	adds	r3, #1
 8009848:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
	*pxBuf318 = crc318;
 800984c:	f8b7 304c 	ldrh.w	r3, [r7, #76]	; 0x4c
 8009850:	b2da      	uxtb	r2, r3
 8009852:	687b      	ldr	r3, [r7, #4]
 8009854:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009856:	687b      	ldr	r3, [r7, #4]
 8009858:	3301      	adds	r3, #1
 800985a:	607b      	str	r3, [r7, #4]
	lenBuf++;
 800985c:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009860:	3301      	adds	r3, #1
 8009862:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
	*pxBuf318 = SYM_ST318;
 8009866:	687b      	ldr	r3, [r7, #4]
 8009868:	22c0      	movs	r2, #192	; 0xc0
 800986a:	701a      	strb	r2, [r3, #0]

	return (lenBuf + 2);
 800986c:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009870:	3302      	adds	r3, #2
 8009872:	b29b      	uxth	r3, r3
}
 8009874:	4618      	mov	r0, r3
 8009876:	3750      	adds	r7, #80	; 0x50
 8009878:	46bd      	mov	sp, r7
 800987a:	bd80      	pop	{r7, pc}
 800987c:	08009309 	.word	0x08009309

08009880 <AskCurA>:
//  
uint16 AskCurA(uint8 *pxBuf318, uint32 MeterNumber)

{
 8009880:	b580      	push	{r7, lr}
 8009882:	b094      	sub	sp, #80	; 0x50
 8009884:	af00      	add	r7, sp, #0
 8009886:	6078      	str	r0, [r7, #4]
 8009888:	6039      	str	r1, [r7, #0]
	uint16 crc318;
	uint8 tmpbuff318[64];
	unsigned short lenBuf = 0;
 800988a:	2300      	movs	r3, #0
 800988c:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
	*pxBuf318 = SYM_ST318;
 8009890:	687b      	ldr	r3, [r7, #4]
 8009892:	22c0      	movs	r2, #192	; 0xc0
 8009894:	701a      	strb	r2, [r3, #0]

	pxBuf318++;
 8009896:	687b      	ldr	r3, [r7, #4]
 8009898:	3301      	adds	r3, #1
 800989a:	607b      	str	r3, [r7, #4]
	*pxBuf318 = tmpbuff318[0] = GET_INFO;
 800989c:	2306      	movs	r3, #6
 800989e:	733b      	strb	r3, [r7, #12]
 80098a0:	7b3a      	ldrb	r2, [r7, #12]
 80098a2:	687b      	ldr	r3, [r7, #4]
 80098a4:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 80098a6:	687b      	ldr	r3, [r7, #4]
 80098a8:	3301      	adds	r3, #1
 80098aa:	607b      	str	r3, [r7, #4]
	lenBuf++;
 80098ac:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 80098b0:	3301      	adds	r3, #1
 80098b2:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[1] = MeterNumber;
 80098b6:	683b      	ldr	r3, [r7, #0]
 80098b8:	b2db      	uxtb	r3, r3
 80098ba:	737b      	strb	r3, [r7, #13]
 80098bc:	7b7a      	ldrb	r2, [r7, #13]
 80098be:	687b      	ldr	r3, [r7, #4]
 80098c0:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 80098c2:	687b      	ldr	r3, [r7, #4]
 80098c4:	3301      	adds	r3, #1
 80098c6:	607b      	str	r3, [r7, #4]
	lenBuf++;
 80098c8:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 80098cc:	3301      	adds	r3, #1
 80098ce:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[2] = MeterNumber >> 8;
 80098d2:	683b      	ldr	r3, [r7, #0]
 80098d4:	0a1b      	lsrs	r3, r3, #8
 80098d6:	b2db      	uxtb	r3, r3
 80098d8:	73bb      	strb	r3, [r7, #14]
 80098da:	7bba      	ldrb	r2, [r7, #14]
 80098dc:	687b      	ldr	r3, [r7, #4]
 80098de:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 80098e0:	687b      	ldr	r3, [r7, #4]
 80098e2:	3301      	adds	r3, #1
 80098e4:	607b      	str	r3, [r7, #4]
	lenBuf++;
 80098e6:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 80098ea:	3301      	adds	r3, #1
 80098ec:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[3] = MeterNumber >> 16;
 80098f0:	683b      	ldr	r3, [r7, #0]
 80098f2:	0c1b      	lsrs	r3, r3, #16
 80098f4:	b2db      	uxtb	r3, r3
 80098f6:	73fb      	strb	r3, [r7, #15]
 80098f8:	7bfa      	ldrb	r2, [r7, #15]
 80098fa:	687b      	ldr	r3, [r7, #4]
 80098fc:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 80098fe:	687b      	ldr	r3, [r7, #4]
 8009900:	3301      	adds	r3, #1
 8009902:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009904:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009908:	3301      	adds	r3, #1
 800990a:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[4] = MeterNumber >> 24;
 800990e:	683b      	ldr	r3, [r7, #0]
 8009910:	0e1b      	lsrs	r3, r3, #24
 8009912:	b2db      	uxtb	r3, r3
 8009914:	743b      	strb	r3, [r7, #16]
 8009916:	7c3a      	ldrb	r2, [r7, #16]
 8009918:	687b      	ldr	r3, [r7, #4]
 800991a:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 800991c:	687b      	ldr	r3, [r7, #4]
 800991e:	3301      	adds	r3, #1
 8009920:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009922:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009926:	3301      	adds	r3, #1
 8009928:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[5] = 0x00;
 800992c:	2300      	movs	r3, #0
 800992e:	747b      	strb	r3, [r7, #17]
 8009930:	7c7a      	ldrb	r2, [r7, #17]
 8009932:	687b      	ldr	r3, [r7, #4]
 8009934:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009936:	687b      	ldr	r3, [r7, #4]
 8009938:	3301      	adds	r3, #1
 800993a:	607b      	str	r3, [r7, #4]
	lenBuf++;
 800993c:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009940:	3301      	adds	r3, #1
 8009942:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[6] = GET_INFO;
 8009946:	2306      	movs	r3, #6
 8009948:	74bb      	strb	r3, [r7, #18]
 800994a:	7cba      	ldrb	r2, [r7, #18]
 800994c:	687b      	ldr	r3, [r7, #4]
 800994e:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009950:	687b      	ldr	r3, [r7, #4]
 8009952:	3301      	adds	r3, #1
 8009954:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009956:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800995a:	3301      	adds	r3, #1
 800995c:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[7] = GET_DATA_SINGLE;
 8009960:	230a      	movs	r3, #10
 8009962:	74fb      	strb	r3, [r7, #19]
 8009964:	7cfa      	ldrb	r2, [r7, #19]
 8009966:	687b      	ldr	r3, [r7, #4]
 8009968:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 800996a:	687b      	ldr	r3, [r7, #4]
 800996c:	3301      	adds	r3, #1
 800996e:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009970:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009974:	3301      	adds	r3, #1
 8009976:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[8] = 0x00;
 800997a:	2300      	movs	r3, #0
 800997c:	753b      	strb	r3, [r7, #20]
 800997e:	7d3a      	ldrb	r2, [r7, #20]
 8009980:	687b      	ldr	r3, [r7, #4]
 8009982:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009984:	687b      	ldr	r3, [r7, #4]
 8009986:	3301      	adds	r3, #1
 8009988:	607b      	str	r3, [r7, #4]
	lenBuf++;
 800998a:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800998e:	3301      	adds	r3, #1
 8009990:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[9] = GET_CUR;
 8009994:	2316      	movs	r3, #22
 8009996:	757b      	strb	r3, [r7, #21]
 8009998:	7d7a      	ldrb	r2, [r7, #21]
 800999a:	687b      	ldr	r3, [r7, #4]
 800999c:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 800999e:	687b      	ldr	r3, [r7, #4]
 80099a0:	3301      	adds	r3, #1
 80099a2:	607b      	str	r3, [r7, #4]
	lenBuf++;
 80099a4:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 80099a8:	3301      	adds	r3, #1
 80099aa:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[10] = GET_A;
 80099ae:	2304      	movs	r3, #4
 80099b0:	75bb      	strb	r3, [r7, #22]
 80099b2:	7dba      	ldrb	r2, [r7, #22]
 80099b4:	687b      	ldr	r3, [r7, #4]
 80099b6:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 80099b8:	687b      	ldr	r3, [r7, #4]
 80099ba:	3301      	adds	r3, #1
 80099bc:	607b      	str	r3, [r7, #4]
	lenBuf++;
 80099be:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 80099c2:	3301      	adds	r3, #1
 80099c4:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	crc318 = SetCRC16(tmpbuff318, lenBuf);
 80099c8:	f8b7 204e 	ldrh.w	r2, [r7, #78]	; 0x4e
 80099cc:	f107 030c 	add.w	r3, r7, #12
 80099d0:	4611      	mov	r1, r2
 80099d2:	4618      	mov	r0, r3
 80099d4:	4b15      	ldr	r3, [pc, #84]	; (8009a2c <AskCurA+0x1ac>)
 80099d6:	4798      	blx	r3
 80099d8:	4603      	mov	r3, r0
 80099da:	f8a7 304c 	strh.w	r3, [r7, #76]	; 0x4c

	*pxBuf318 = crc318 >> 8;
 80099de:	f8b7 304c 	ldrh.w	r3, [r7, #76]	; 0x4c
 80099e2:	0a1b      	lsrs	r3, r3, #8
 80099e4:	b29b      	uxth	r3, r3
 80099e6:	b2da      	uxtb	r2, r3
 80099e8:	687b      	ldr	r3, [r7, #4]
 80099ea:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 80099ec:	687b      	ldr	r3, [r7, #4]
 80099ee:	3301      	adds	r3, #1
 80099f0:	607b      	str	r3, [r7, #4]
	lenBuf++;
 80099f2:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 80099f6:	3301      	adds	r3, #1
 80099f8:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
	*pxBuf318 = crc318;
 80099fc:	f8b7 304c 	ldrh.w	r3, [r7, #76]	; 0x4c
 8009a00:	b2da      	uxtb	r2, r3
 8009a02:	687b      	ldr	r3, [r7, #4]
 8009a04:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009a06:	687b      	ldr	r3, [r7, #4]
 8009a08:	3301      	adds	r3, #1
 8009a0a:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009a0c:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009a10:	3301      	adds	r3, #1
 8009a12:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
	*pxBuf318 = SYM_ST318;
 8009a16:	687b      	ldr	r3, [r7, #4]
 8009a18:	22c0      	movs	r2, #192	; 0xc0
 8009a1a:	701a      	strb	r2, [r3, #0]

	return (lenBuf + 2);
 8009a1c:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009a20:	3302      	adds	r3, #2
 8009a22:	b29b      	uxth	r3, r3
}
 8009a24:	4618      	mov	r0, r3
 8009a26:	3750      	adds	r7, #80	; 0x50
 8009a28:	46bd      	mov	sp, r7
 8009a2a:	bd80      	pop	{r7, pc}
 8009a2c:	08009309 	.word	0x08009309

08009a30 <AskCurB>:

uint16 AskCurB(uint8 *pxBuf318, uint32 MeterNumber)

{
 8009a30:	b580      	push	{r7, lr}
 8009a32:	b094      	sub	sp, #80	; 0x50
 8009a34:	af00      	add	r7, sp, #0
 8009a36:	6078      	str	r0, [r7, #4]
 8009a38:	6039      	str	r1, [r7, #0]
	uint16 crc318;
	uint8 tmpbuff318[64];
	unsigned short lenBuf = 0;
 8009a3a:	2300      	movs	r3, #0
 8009a3c:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
	*pxBuf318 = SYM_ST318;
 8009a40:	687b      	ldr	r3, [r7, #4]
 8009a42:	22c0      	movs	r2, #192	; 0xc0
 8009a44:	701a      	strb	r2, [r3, #0]

	pxBuf318++;
 8009a46:	687b      	ldr	r3, [r7, #4]
 8009a48:	3301      	adds	r3, #1
 8009a4a:	607b      	str	r3, [r7, #4]
	*pxBuf318 = tmpbuff318[0] = GET_INFO;
 8009a4c:	2306      	movs	r3, #6
 8009a4e:	733b      	strb	r3, [r7, #12]
 8009a50:	7b3a      	ldrb	r2, [r7, #12]
 8009a52:	687b      	ldr	r3, [r7, #4]
 8009a54:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009a56:	687b      	ldr	r3, [r7, #4]
 8009a58:	3301      	adds	r3, #1
 8009a5a:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009a5c:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009a60:	3301      	adds	r3, #1
 8009a62:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[1] = MeterNumber;
 8009a66:	683b      	ldr	r3, [r7, #0]
 8009a68:	b2db      	uxtb	r3, r3
 8009a6a:	737b      	strb	r3, [r7, #13]
 8009a6c:	7b7a      	ldrb	r2, [r7, #13]
 8009a6e:	687b      	ldr	r3, [r7, #4]
 8009a70:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009a72:	687b      	ldr	r3, [r7, #4]
 8009a74:	3301      	adds	r3, #1
 8009a76:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009a78:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009a7c:	3301      	adds	r3, #1
 8009a7e:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[2] = MeterNumber >> 8;
 8009a82:	683b      	ldr	r3, [r7, #0]
 8009a84:	0a1b      	lsrs	r3, r3, #8
 8009a86:	b2db      	uxtb	r3, r3
 8009a88:	73bb      	strb	r3, [r7, #14]
 8009a8a:	7bba      	ldrb	r2, [r7, #14]
 8009a8c:	687b      	ldr	r3, [r7, #4]
 8009a8e:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009a90:	687b      	ldr	r3, [r7, #4]
 8009a92:	3301      	adds	r3, #1
 8009a94:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009a96:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009a9a:	3301      	adds	r3, #1
 8009a9c:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[3] = MeterNumber >> 16;
 8009aa0:	683b      	ldr	r3, [r7, #0]
 8009aa2:	0c1b      	lsrs	r3, r3, #16
 8009aa4:	b2db      	uxtb	r3, r3
 8009aa6:	73fb      	strb	r3, [r7, #15]
 8009aa8:	7bfa      	ldrb	r2, [r7, #15]
 8009aaa:	687b      	ldr	r3, [r7, #4]
 8009aac:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009aae:	687b      	ldr	r3, [r7, #4]
 8009ab0:	3301      	adds	r3, #1
 8009ab2:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009ab4:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009ab8:	3301      	adds	r3, #1
 8009aba:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[4] = MeterNumber >> 24;
 8009abe:	683b      	ldr	r3, [r7, #0]
 8009ac0:	0e1b      	lsrs	r3, r3, #24
 8009ac2:	b2db      	uxtb	r3, r3
 8009ac4:	743b      	strb	r3, [r7, #16]
 8009ac6:	7c3a      	ldrb	r2, [r7, #16]
 8009ac8:	687b      	ldr	r3, [r7, #4]
 8009aca:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009acc:	687b      	ldr	r3, [r7, #4]
 8009ace:	3301      	adds	r3, #1
 8009ad0:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009ad2:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009ad6:	3301      	adds	r3, #1
 8009ad8:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[5] = 0x00;
 8009adc:	2300      	movs	r3, #0
 8009ade:	747b      	strb	r3, [r7, #17]
 8009ae0:	7c7a      	ldrb	r2, [r7, #17]
 8009ae2:	687b      	ldr	r3, [r7, #4]
 8009ae4:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009ae6:	687b      	ldr	r3, [r7, #4]
 8009ae8:	3301      	adds	r3, #1
 8009aea:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009aec:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009af0:	3301      	adds	r3, #1
 8009af2:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[6] = GET_INFO;
 8009af6:	2306      	movs	r3, #6
 8009af8:	74bb      	strb	r3, [r7, #18]
 8009afa:	7cba      	ldrb	r2, [r7, #18]
 8009afc:	687b      	ldr	r3, [r7, #4]
 8009afe:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009b00:	687b      	ldr	r3, [r7, #4]
 8009b02:	3301      	adds	r3, #1
 8009b04:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009b06:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009b0a:	3301      	adds	r3, #1
 8009b0c:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[7] = GET_DATA_SINGLE;
 8009b10:	230a      	movs	r3, #10
 8009b12:	74fb      	strb	r3, [r7, #19]
 8009b14:	7cfa      	ldrb	r2, [r7, #19]
 8009b16:	687b      	ldr	r3, [r7, #4]
 8009b18:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009b1a:	687b      	ldr	r3, [r7, #4]
 8009b1c:	3301      	adds	r3, #1
 8009b1e:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009b20:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009b24:	3301      	adds	r3, #1
 8009b26:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[8] = 0x00;
 8009b2a:	2300      	movs	r3, #0
 8009b2c:	753b      	strb	r3, [r7, #20]
 8009b2e:	7d3a      	ldrb	r2, [r7, #20]
 8009b30:	687b      	ldr	r3, [r7, #4]
 8009b32:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009b34:	687b      	ldr	r3, [r7, #4]
 8009b36:	3301      	adds	r3, #1
 8009b38:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009b3a:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009b3e:	3301      	adds	r3, #1
 8009b40:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[9] = GET_CUR;
 8009b44:	2316      	movs	r3, #22
 8009b46:	757b      	strb	r3, [r7, #21]
 8009b48:	7d7a      	ldrb	r2, [r7, #21]
 8009b4a:	687b      	ldr	r3, [r7, #4]
 8009b4c:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009b4e:	687b      	ldr	r3, [r7, #4]
 8009b50:	3301      	adds	r3, #1
 8009b52:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009b54:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009b58:	3301      	adds	r3, #1
 8009b5a:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[10] = GET_B;
 8009b5e:	2308      	movs	r3, #8
 8009b60:	75bb      	strb	r3, [r7, #22]
 8009b62:	7dba      	ldrb	r2, [r7, #22]
 8009b64:	687b      	ldr	r3, [r7, #4]
 8009b66:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009b68:	687b      	ldr	r3, [r7, #4]
 8009b6a:	3301      	adds	r3, #1
 8009b6c:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009b6e:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009b72:	3301      	adds	r3, #1
 8009b74:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	crc318 = SetCRC16(tmpbuff318, lenBuf);
 8009b78:	f8b7 204e 	ldrh.w	r2, [r7, #78]	; 0x4e
 8009b7c:	f107 030c 	add.w	r3, r7, #12
 8009b80:	4611      	mov	r1, r2
 8009b82:	4618      	mov	r0, r3
 8009b84:	4b15      	ldr	r3, [pc, #84]	; (8009bdc <AskCurB+0x1ac>)
 8009b86:	4798      	blx	r3
 8009b88:	4603      	mov	r3, r0
 8009b8a:	f8a7 304c 	strh.w	r3, [r7, #76]	; 0x4c

	*pxBuf318 = crc318 >> 8;
 8009b8e:	f8b7 304c 	ldrh.w	r3, [r7, #76]	; 0x4c
 8009b92:	0a1b      	lsrs	r3, r3, #8
 8009b94:	b29b      	uxth	r3, r3
 8009b96:	b2da      	uxtb	r2, r3
 8009b98:	687b      	ldr	r3, [r7, #4]
 8009b9a:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009b9c:	687b      	ldr	r3, [r7, #4]
 8009b9e:	3301      	adds	r3, #1
 8009ba0:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009ba2:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009ba6:	3301      	adds	r3, #1
 8009ba8:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
	*pxBuf318 = crc318;
 8009bac:	f8b7 304c 	ldrh.w	r3, [r7, #76]	; 0x4c
 8009bb0:	b2da      	uxtb	r2, r3
 8009bb2:	687b      	ldr	r3, [r7, #4]
 8009bb4:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009bb6:	687b      	ldr	r3, [r7, #4]
 8009bb8:	3301      	adds	r3, #1
 8009bba:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009bbc:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009bc0:	3301      	adds	r3, #1
 8009bc2:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
	*pxBuf318 = SYM_ST318;
 8009bc6:	687b      	ldr	r3, [r7, #4]
 8009bc8:	22c0      	movs	r2, #192	; 0xc0
 8009bca:	701a      	strb	r2, [r3, #0]

	return (lenBuf + 2);
 8009bcc:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009bd0:	3302      	adds	r3, #2
 8009bd2:	b29b      	uxth	r3, r3
}
 8009bd4:	4618      	mov	r0, r3
 8009bd6:	3750      	adds	r7, #80	; 0x50
 8009bd8:	46bd      	mov	sp, r7
 8009bda:	bd80      	pop	{r7, pc}
 8009bdc:	08009309 	.word	0x08009309

08009be0 <AskCurC>:

uint16 AskCurC(uint8 *pxBuf318, uint32 MeterNumber)

{
 8009be0:	b580      	push	{r7, lr}
 8009be2:	b094      	sub	sp, #80	; 0x50
 8009be4:	af00      	add	r7, sp, #0
 8009be6:	6078      	str	r0, [r7, #4]
 8009be8:	6039      	str	r1, [r7, #0]
	uint16 crc318;
	uint8 tmpbuff318[64];
	unsigned short lenBuf = 0;
 8009bea:	2300      	movs	r3, #0
 8009bec:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
	*pxBuf318 = SYM_ST318;
 8009bf0:	687b      	ldr	r3, [r7, #4]
 8009bf2:	22c0      	movs	r2, #192	; 0xc0
 8009bf4:	701a      	strb	r2, [r3, #0]

	pxBuf318++;
 8009bf6:	687b      	ldr	r3, [r7, #4]
 8009bf8:	3301      	adds	r3, #1
 8009bfa:	607b      	str	r3, [r7, #4]
	*pxBuf318 = tmpbuff318[0] = GET_INFO;
 8009bfc:	2306      	movs	r3, #6
 8009bfe:	733b      	strb	r3, [r7, #12]
 8009c00:	7b3a      	ldrb	r2, [r7, #12]
 8009c02:	687b      	ldr	r3, [r7, #4]
 8009c04:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009c06:	687b      	ldr	r3, [r7, #4]
 8009c08:	3301      	adds	r3, #1
 8009c0a:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009c0c:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009c10:	3301      	adds	r3, #1
 8009c12:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[1] = MeterNumber;
 8009c16:	683b      	ldr	r3, [r7, #0]
 8009c18:	b2db      	uxtb	r3, r3
 8009c1a:	737b      	strb	r3, [r7, #13]
 8009c1c:	7b7a      	ldrb	r2, [r7, #13]
 8009c1e:	687b      	ldr	r3, [r7, #4]
 8009c20:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009c22:	687b      	ldr	r3, [r7, #4]
 8009c24:	3301      	adds	r3, #1
 8009c26:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009c28:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009c2c:	3301      	adds	r3, #1
 8009c2e:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[2] = MeterNumber >> 8;
 8009c32:	683b      	ldr	r3, [r7, #0]
 8009c34:	0a1b      	lsrs	r3, r3, #8
 8009c36:	b2db      	uxtb	r3, r3
 8009c38:	73bb      	strb	r3, [r7, #14]
 8009c3a:	7bba      	ldrb	r2, [r7, #14]
 8009c3c:	687b      	ldr	r3, [r7, #4]
 8009c3e:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009c40:	687b      	ldr	r3, [r7, #4]
 8009c42:	3301      	adds	r3, #1
 8009c44:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009c46:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009c4a:	3301      	adds	r3, #1
 8009c4c:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[3] = MeterNumber >> 16;
 8009c50:	683b      	ldr	r3, [r7, #0]
 8009c52:	0c1b      	lsrs	r3, r3, #16
 8009c54:	b2db      	uxtb	r3, r3
 8009c56:	73fb      	strb	r3, [r7, #15]
 8009c58:	7bfa      	ldrb	r2, [r7, #15]
 8009c5a:	687b      	ldr	r3, [r7, #4]
 8009c5c:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009c5e:	687b      	ldr	r3, [r7, #4]
 8009c60:	3301      	adds	r3, #1
 8009c62:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009c64:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009c68:	3301      	adds	r3, #1
 8009c6a:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[4] = MeterNumber >> 24;
 8009c6e:	683b      	ldr	r3, [r7, #0]
 8009c70:	0e1b      	lsrs	r3, r3, #24
 8009c72:	b2db      	uxtb	r3, r3
 8009c74:	743b      	strb	r3, [r7, #16]
 8009c76:	7c3a      	ldrb	r2, [r7, #16]
 8009c78:	687b      	ldr	r3, [r7, #4]
 8009c7a:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009c7c:	687b      	ldr	r3, [r7, #4]
 8009c7e:	3301      	adds	r3, #1
 8009c80:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009c82:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009c86:	3301      	adds	r3, #1
 8009c88:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[5] = 0x00;
 8009c8c:	2300      	movs	r3, #0
 8009c8e:	747b      	strb	r3, [r7, #17]
 8009c90:	7c7a      	ldrb	r2, [r7, #17]
 8009c92:	687b      	ldr	r3, [r7, #4]
 8009c94:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009c96:	687b      	ldr	r3, [r7, #4]
 8009c98:	3301      	adds	r3, #1
 8009c9a:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009c9c:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009ca0:	3301      	adds	r3, #1
 8009ca2:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[6] = GET_INFO;
 8009ca6:	2306      	movs	r3, #6
 8009ca8:	74bb      	strb	r3, [r7, #18]
 8009caa:	7cba      	ldrb	r2, [r7, #18]
 8009cac:	687b      	ldr	r3, [r7, #4]
 8009cae:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009cb0:	687b      	ldr	r3, [r7, #4]
 8009cb2:	3301      	adds	r3, #1
 8009cb4:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009cb6:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009cba:	3301      	adds	r3, #1
 8009cbc:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[7] = GET_DATA_SINGLE;
 8009cc0:	230a      	movs	r3, #10
 8009cc2:	74fb      	strb	r3, [r7, #19]
 8009cc4:	7cfa      	ldrb	r2, [r7, #19]
 8009cc6:	687b      	ldr	r3, [r7, #4]
 8009cc8:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009cca:	687b      	ldr	r3, [r7, #4]
 8009ccc:	3301      	adds	r3, #1
 8009cce:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009cd0:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009cd4:	3301      	adds	r3, #1
 8009cd6:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[8] = 0x00;
 8009cda:	2300      	movs	r3, #0
 8009cdc:	753b      	strb	r3, [r7, #20]
 8009cde:	7d3a      	ldrb	r2, [r7, #20]
 8009ce0:	687b      	ldr	r3, [r7, #4]
 8009ce2:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009ce4:	687b      	ldr	r3, [r7, #4]
 8009ce6:	3301      	adds	r3, #1
 8009ce8:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009cea:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009cee:	3301      	adds	r3, #1
 8009cf0:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[9] = GET_CUR;
 8009cf4:	2316      	movs	r3, #22
 8009cf6:	757b      	strb	r3, [r7, #21]
 8009cf8:	7d7a      	ldrb	r2, [r7, #21]
 8009cfa:	687b      	ldr	r3, [r7, #4]
 8009cfc:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009cfe:	687b      	ldr	r3, [r7, #4]
 8009d00:	3301      	adds	r3, #1
 8009d02:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009d04:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009d08:	3301      	adds	r3, #1
 8009d0a:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[10] = GET_C;
 8009d0e:	2310      	movs	r3, #16
 8009d10:	75bb      	strb	r3, [r7, #22]
 8009d12:	7dba      	ldrb	r2, [r7, #22]
 8009d14:	687b      	ldr	r3, [r7, #4]
 8009d16:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009d18:	687b      	ldr	r3, [r7, #4]
 8009d1a:	3301      	adds	r3, #1
 8009d1c:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009d1e:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009d22:	3301      	adds	r3, #1
 8009d24:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	crc318 = SetCRC16(tmpbuff318, lenBuf);
 8009d28:	f8b7 204e 	ldrh.w	r2, [r7, #78]	; 0x4e
 8009d2c:	f107 030c 	add.w	r3, r7, #12
 8009d30:	4611      	mov	r1, r2
 8009d32:	4618      	mov	r0, r3
 8009d34:	4b15      	ldr	r3, [pc, #84]	; (8009d8c <AskCurC+0x1ac>)
 8009d36:	4798      	blx	r3
 8009d38:	4603      	mov	r3, r0
 8009d3a:	f8a7 304c 	strh.w	r3, [r7, #76]	; 0x4c

	*pxBuf318 = crc318 >> 8;
 8009d3e:	f8b7 304c 	ldrh.w	r3, [r7, #76]	; 0x4c
 8009d42:	0a1b      	lsrs	r3, r3, #8
 8009d44:	b29b      	uxth	r3, r3
 8009d46:	b2da      	uxtb	r2, r3
 8009d48:	687b      	ldr	r3, [r7, #4]
 8009d4a:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009d4c:	687b      	ldr	r3, [r7, #4]
 8009d4e:	3301      	adds	r3, #1
 8009d50:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009d52:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009d56:	3301      	adds	r3, #1
 8009d58:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
	*pxBuf318 = crc318;
 8009d5c:	f8b7 304c 	ldrh.w	r3, [r7, #76]	; 0x4c
 8009d60:	b2da      	uxtb	r2, r3
 8009d62:	687b      	ldr	r3, [r7, #4]
 8009d64:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009d66:	687b      	ldr	r3, [r7, #4]
 8009d68:	3301      	adds	r3, #1
 8009d6a:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009d6c:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009d70:	3301      	adds	r3, #1
 8009d72:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
	*pxBuf318 = SYM_ST318;
 8009d76:	687b      	ldr	r3, [r7, #4]
 8009d78:	22c0      	movs	r2, #192	; 0xc0
 8009d7a:	701a      	strb	r2, [r3, #0]

	return (lenBuf + 2);
 8009d7c:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009d80:	3302      	adds	r3, #2
 8009d82:	b29b      	uxth	r3, r3
}
 8009d84:	4618      	mov	r0, r3
 8009d86:	3750      	adds	r7, #80	; 0x50
 8009d88:	46bd      	mov	sp, r7
 8009d8a:	bd80      	pop	{r7, pc}
 8009d8c:	08009309 	.word	0x08009309

08009d90 <AskPowA>:
//  
uint16 AskPowA(uint8 *pxBuf318, uint32 MeterNumber) {
 8009d90:	b580      	push	{r7, lr}
 8009d92:	b094      	sub	sp, #80	; 0x50
 8009d94:	af00      	add	r7, sp, #0
 8009d96:	6078      	str	r0, [r7, #4]
 8009d98:	6039      	str	r1, [r7, #0]
	uint16 crc318;
	uint8 tmpbuff318[64];
	unsigned short lenBuf = 0;
 8009d9a:	2300      	movs	r3, #0
 8009d9c:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
	*pxBuf318 = SYM_ST318;
 8009da0:	687b      	ldr	r3, [r7, #4]
 8009da2:	22c0      	movs	r2, #192	; 0xc0
 8009da4:	701a      	strb	r2, [r3, #0]

	pxBuf318++;
 8009da6:	687b      	ldr	r3, [r7, #4]
 8009da8:	3301      	adds	r3, #1
 8009daa:	607b      	str	r3, [r7, #4]
	*pxBuf318 = tmpbuff318[0] = GET_INFO;
 8009dac:	2306      	movs	r3, #6
 8009dae:	733b      	strb	r3, [r7, #12]
 8009db0:	7b3a      	ldrb	r2, [r7, #12]
 8009db2:	687b      	ldr	r3, [r7, #4]
 8009db4:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009db6:	687b      	ldr	r3, [r7, #4]
 8009db8:	3301      	adds	r3, #1
 8009dba:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009dbc:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009dc0:	3301      	adds	r3, #1
 8009dc2:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[1] = MeterNumber;
 8009dc6:	683b      	ldr	r3, [r7, #0]
 8009dc8:	b2db      	uxtb	r3, r3
 8009dca:	737b      	strb	r3, [r7, #13]
 8009dcc:	7b7a      	ldrb	r2, [r7, #13]
 8009dce:	687b      	ldr	r3, [r7, #4]
 8009dd0:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009dd2:	687b      	ldr	r3, [r7, #4]
 8009dd4:	3301      	adds	r3, #1
 8009dd6:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009dd8:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009ddc:	3301      	adds	r3, #1
 8009dde:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[2] = MeterNumber >> 8;
 8009de2:	683b      	ldr	r3, [r7, #0]
 8009de4:	0a1b      	lsrs	r3, r3, #8
 8009de6:	b2db      	uxtb	r3, r3
 8009de8:	73bb      	strb	r3, [r7, #14]
 8009dea:	7bba      	ldrb	r2, [r7, #14]
 8009dec:	687b      	ldr	r3, [r7, #4]
 8009dee:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009df0:	687b      	ldr	r3, [r7, #4]
 8009df2:	3301      	adds	r3, #1
 8009df4:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009df6:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009dfa:	3301      	adds	r3, #1
 8009dfc:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[3] = MeterNumber >> 16;
 8009e00:	683b      	ldr	r3, [r7, #0]
 8009e02:	0c1b      	lsrs	r3, r3, #16
 8009e04:	b2db      	uxtb	r3, r3
 8009e06:	73fb      	strb	r3, [r7, #15]
 8009e08:	7bfa      	ldrb	r2, [r7, #15]
 8009e0a:	687b      	ldr	r3, [r7, #4]
 8009e0c:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009e0e:	687b      	ldr	r3, [r7, #4]
 8009e10:	3301      	adds	r3, #1
 8009e12:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009e14:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009e18:	3301      	adds	r3, #1
 8009e1a:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[4] = MeterNumber >> 24;
 8009e1e:	683b      	ldr	r3, [r7, #0]
 8009e20:	0e1b      	lsrs	r3, r3, #24
 8009e22:	b2db      	uxtb	r3, r3
 8009e24:	743b      	strb	r3, [r7, #16]
 8009e26:	7c3a      	ldrb	r2, [r7, #16]
 8009e28:	687b      	ldr	r3, [r7, #4]
 8009e2a:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009e2c:	687b      	ldr	r3, [r7, #4]
 8009e2e:	3301      	adds	r3, #1
 8009e30:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009e32:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009e36:	3301      	adds	r3, #1
 8009e38:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[5] = 0x00;
 8009e3c:	2300      	movs	r3, #0
 8009e3e:	747b      	strb	r3, [r7, #17]
 8009e40:	7c7a      	ldrb	r2, [r7, #17]
 8009e42:	687b      	ldr	r3, [r7, #4]
 8009e44:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009e46:	687b      	ldr	r3, [r7, #4]
 8009e48:	3301      	adds	r3, #1
 8009e4a:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009e4c:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009e50:	3301      	adds	r3, #1
 8009e52:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[6] = GET_INFO;
 8009e56:	2306      	movs	r3, #6
 8009e58:	74bb      	strb	r3, [r7, #18]
 8009e5a:	7cba      	ldrb	r2, [r7, #18]
 8009e5c:	687b      	ldr	r3, [r7, #4]
 8009e5e:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009e60:	687b      	ldr	r3, [r7, #4]
 8009e62:	3301      	adds	r3, #1
 8009e64:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009e66:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009e6a:	3301      	adds	r3, #1
 8009e6c:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[7] = GET_DATA_SINGLE;
 8009e70:	230a      	movs	r3, #10
 8009e72:	74fb      	strb	r3, [r7, #19]
 8009e74:	7cfa      	ldrb	r2, [r7, #19]
 8009e76:	687b      	ldr	r3, [r7, #4]
 8009e78:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009e7a:	687b      	ldr	r3, [r7, #4]
 8009e7c:	3301      	adds	r3, #1
 8009e7e:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009e80:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009e84:	3301      	adds	r3, #1
 8009e86:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[8] = 0x00;
 8009e8a:	2300      	movs	r3, #0
 8009e8c:	753b      	strb	r3, [r7, #20]
 8009e8e:	7d3a      	ldrb	r2, [r7, #20]
 8009e90:	687b      	ldr	r3, [r7, #4]
 8009e92:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009e94:	687b      	ldr	r3, [r7, #4]
 8009e96:	3301      	adds	r3, #1
 8009e98:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009e9a:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009e9e:	3301      	adds	r3, #1
 8009ea0:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[9] = GET_POW;
 8009ea4:	230d      	movs	r3, #13
 8009ea6:	757b      	strb	r3, [r7, #21]
 8009ea8:	7d7a      	ldrb	r2, [r7, #21]
 8009eaa:	687b      	ldr	r3, [r7, #4]
 8009eac:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009eae:	687b      	ldr	r3, [r7, #4]
 8009eb0:	3301      	adds	r3, #1
 8009eb2:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009eb4:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009eb8:	3301      	adds	r3, #1
 8009eba:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[10] = GET_A;
 8009ebe:	2304      	movs	r3, #4
 8009ec0:	75bb      	strb	r3, [r7, #22]
 8009ec2:	7dba      	ldrb	r2, [r7, #22]
 8009ec4:	687b      	ldr	r3, [r7, #4]
 8009ec6:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009ec8:	687b      	ldr	r3, [r7, #4]
 8009eca:	3301      	adds	r3, #1
 8009ecc:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009ece:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009ed2:	3301      	adds	r3, #1
 8009ed4:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	crc318 = SetCRC16(tmpbuff318, lenBuf);
 8009ed8:	f8b7 204e 	ldrh.w	r2, [r7, #78]	; 0x4e
 8009edc:	f107 030c 	add.w	r3, r7, #12
 8009ee0:	4611      	mov	r1, r2
 8009ee2:	4618      	mov	r0, r3
 8009ee4:	4b15      	ldr	r3, [pc, #84]	; (8009f3c <AskPowA+0x1ac>)
 8009ee6:	4798      	blx	r3
 8009ee8:	4603      	mov	r3, r0
 8009eea:	f8a7 304c 	strh.w	r3, [r7, #76]	; 0x4c

	*pxBuf318 = crc318 >> 8;
 8009eee:	f8b7 304c 	ldrh.w	r3, [r7, #76]	; 0x4c
 8009ef2:	0a1b      	lsrs	r3, r3, #8
 8009ef4:	b29b      	uxth	r3, r3
 8009ef6:	b2da      	uxtb	r2, r3
 8009ef8:	687b      	ldr	r3, [r7, #4]
 8009efa:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009efc:	687b      	ldr	r3, [r7, #4]
 8009efe:	3301      	adds	r3, #1
 8009f00:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009f02:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009f06:	3301      	adds	r3, #1
 8009f08:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
	*pxBuf318 = crc318;
 8009f0c:	f8b7 304c 	ldrh.w	r3, [r7, #76]	; 0x4c
 8009f10:	b2da      	uxtb	r2, r3
 8009f12:	687b      	ldr	r3, [r7, #4]
 8009f14:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009f16:	687b      	ldr	r3, [r7, #4]
 8009f18:	3301      	adds	r3, #1
 8009f1a:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009f1c:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009f20:	3301      	adds	r3, #1
 8009f22:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
	*pxBuf318 = SYM_ST318;
 8009f26:	687b      	ldr	r3, [r7, #4]
 8009f28:	22c0      	movs	r2, #192	; 0xc0
 8009f2a:	701a      	strb	r2, [r3, #0]

	return (lenBuf + 2);
 8009f2c:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009f30:	3302      	adds	r3, #2
 8009f32:	b29b      	uxth	r3, r3
}
 8009f34:	4618      	mov	r0, r3
 8009f36:	3750      	adds	r7, #80	; 0x50
 8009f38:	46bd      	mov	sp, r7
 8009f3a:	bd80      	pop	{r7, pc}
 8009f3c:	08009309 	.word	0x08009309

08009f40 <AskPowB>:

uint16 AskPowB(uint8 *pxBuf318, uint32 MeterNumber) {
 8009f40:	b580      	push	{r7, lr}
 8009f42:	b094      	sub	sp, #80	; 0x50
 8009f44:	af00      	add	r7, sp, #0
 8009f46:	6078      	str	r0, [r7, #4]
 8009f48:	6039      	str	r1, [r7, #0]
	uint16 crc318;
	uint8 tmpbuff318[64];
	unsigned short lenBuf = 0;
 8009f4a:	2300      	movs	r3, #0
 8009f4c:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
	*pxBuf318 = SYM_ST318;
 8009f50:	687b      	ldr	r3, [r7, #4]
 8009f52:	22c0      	movs	r2, #192	; 0xc0
 8009f54:	701a      	strb	r2, [r3, #0]

	pxBuf318++;
 8009f56:	687b      	ldr	r3, [r7, #4]
 8009f58:	3301      	adds	r3, #1
 8009f5a:	607b      	str	r3, [r7, #4]
	*pxBuf318 = tmpbuff318[0] = GET_INFO;
 8009f5c:	2306      	movs	r3, #6
 8009f5e:	733b      	strb	r3, [r7, #12]
 8009f60:	7b3a      	ldrb	r2, [r7, #12]
 8009f62:	687b      	ldr	r3, [r7, #4]
 8009f64:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009f66:	687b      	ldr	r3, [r7, #4]
 8009f68:	3301      	adds	r3, #1
 8009f6a:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009f6c:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009f70:	3301      	adds	r3, #1
 8009f72:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[1] = MeterNumber;
 8009f76:	683b      	ldr	r3, [r7, #0]
 8009f78:	b2db      	uxtb	r3, r3
 8009f7a:	737b      	strb	r3, [r7, #13]
 8009f7c:	7b7a      	ldrb	r2, [r7, #13]
 8009f7e:	687b      	ldr	r3, [r7, #4]
 8009f80:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009f82:	687b      	ldr	r3, [r7, #4]
 8009f84:	3301      	adds	r3, #1
 8009f86:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009f88:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009f8c:	3301      	adds	r3, #1
 8009f8e:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[2] = MeterNumber >> 8;
 8009f92:	683b      	ldr	r3, [r7, #0]
 8009f94:	0a1b      	lsrs	r3, r3, #8
 8009f96:	b2db      	uxtb	r3, r3
 8009f98:	73bb      	strb	r3, [r7, #14]
 8009f9a:	7bba      	ldrb	r2, [r7, #14]
 8009f9c:	687b      	ldr	r3, [r7, #4]
 8009f9e:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009fa0:	687b      	ldr	r3, [r7, #4]
 8009fa2:	3301      	adds	r3, #1
 8009fa4:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009fa6:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009faa:	3301      	adds	r3, #1
 8009fac:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[3] = MeterNumber >> 16;
 8009fb0:	683b      	ldr	r3, [r7, #0]
 8009fb2:	0c1b      	lsrs	r3, r3, #16
 8009fb4:	b2db      	uxtb	r3, r3
 8009fb6:	73fb      	strb	r3, [r7, #15]
 8009fb8:	7bfa      	ldrb	r2, [r7, #15]
 8009fba:	687b      	ldr	r3, [r7, #4]
 8009fbc:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009fbe:	687b      	ldr	r3, [r7, #4]
 8009fc0:	3301      	adds	r3, #1
 8009fc2:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009fc4:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009fc8:	3301      	adds	r3, #1
 8009fca:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[4] = MeterNumber >> 24;
 8009fce:	683b      	ldr	r3, [r7, #0]
 8009fd0:	0e1b      	lsrs	r3, r3, #24
 8009fd2:	b2db      	uxtb	r3, r3
 8009fd4:	743b      	strb	r3, [r7, #16]
 8009fd6:	7c3a      	ldrb	r2, [r7, #16]
 8009fd8:	687b      	ldr	r3, [r7, #4]
 8009fda:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009fdc:	687b      	ldr	r3, [r7, #4]
 8009fde:	3301      	adds	r3, #1
 8009fe0:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009fe2:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 8009fe6:	3301      	adds	r3, #1
 8009fe8:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[5] = 0x00;
 8009fec:	2300      	movs	r3, #0
 8009fee:	747b      	strb	r3, [r7, #17]
 8009ff0:	7c7a      	ldrb	r2, [r7, #17]
 8009ff2:	687b      	ldr	r3, [r7, #4]
 8009ff4:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 8009ff6:	687b      	ldr	r3, [r7, #4]
 8009ff8:	3301      	adds	r3, #1
 8009ffa:	607b      	str	r3, [r7, #4]
	lenBuf++;
 8009ffc:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800a000:	3301      	adds	r3, #1
 800a002:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[6] = GET_INFO;
 800a006:	2306      	movs	r3, #6
 800a008:	74bb      	strb	r3, [r7, #18]
 800a00a:	7cba      	ldrb	r2, [r7, #18]
 800a00c:	687b      	ldr	r3, [r7, #4]
 800a00e:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 800a010:	687b      	ldr	r3, [r7, #4]
 800a012:	3301      	adds	r3, #1
 800a014:	607b      	str	r3, [r7, #4]
	lenBuf++;
 800a016:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800a01a:	3301      	adds	r3, #1
 800a01c:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[7] = GET_DATA_SINGLE;
 800a020:	230a      	movs	r3, #10
 800a022:	74fb      	strb	r3, [r7, #19]
 800a024:	7cfa      	ldrb	r2, [r7, #19]
 800a026:	687b      	ldr	r3, [r7, #4]
 800a028:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 800a02a:	687b      	ldr	r3, [r7, #4]
 800a02c:	3301      	adds	r3, #1
 800a02e:	607b      	str	r3, [r7, #4]
	lenBuf++;
 800a030:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800a034:	3301      	adds	r3, #1
 800a036:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[8] = 0x00;
 800a03a:	2300      	movs	r3, #0
 800a03c:	753b      	strb	r3, [r7, #20]
 800a03e:	7d3a      	ldrb	r2, [r7, #20]
 800a040:	687b      	ldr	r3, [r7, #4]
 800a042:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 800a044:	687b      	ldr	r3, [r7, #4]
 800a046:	3301      	adds	r3, #1
 800a048:	607b      	str	r3, [r7, #4]
	lenBuf++;
 800a04a:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800a04e:	3301      	adds	r3, #1
 800a050:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[9] = GET_POW;
 800a054:	230d      	movs	r3, #13
 800a056:	757b      	strb	r3, [r7, #21]
 800a058:	7d7a      	ldrb	r2, [r7, #21]
 800a05a:	687b      	ldr	r3, [r7, #4]
 800a05c:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 800a05e:	687b      	ldr	r3, [r7, #4]
 800a060:	3301      	adds	r3, #1
 800a062:	607b      	str	r3, [r7, #4]
	lenBuf++;
 800a064:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800a068:	3301      	adds	r3, #1
 800a06a:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[10] = GET_B;
 800a06e:	2308      	movs	r3, #8
 800a070:	75bb      	strb	r3, [r7, #22]
 800a072:	7dba      	ldrb	r2, [r7, #22]
 800a074:	687b      	ldr	r3, [r7, #4]
 800a076:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 800a078:	687b      	ldr	r3, [r7, #4]
 800a07a:	3301      	adds	r3, #1
 800a07c:	607b      	str	r3, [r7, #4]
	lenBuf++;
 800a07e:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800a082:	3301      	adds	r3, #1
 800a084:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	crc318 = SetCRC16(tmpbuff318, lenBuf);
 800a088:	f8b7 204e 	ldrh.w	r2, [r7, #78]	; 0x4e
 800a08c:	f107 030c 	add.w	r3, r7, #12
 800a090:	4611      	mov	r1, r2
 800a092:	4618      	mov	r0, r3
 800a094:	4b15      	ldr	r3, [pc, #84]	; (800a0ec <AskPowB+0x1ac>)
 800a096:	4798      	blx	r3
 800a098:	4603      	mov	r3, r0
 800a09a:	f8a7 304c 	strh.w	r3, [r7, #76]	; 0x4c

	*pxBuf318 = crc318 >> 8;
 800a09e:	f8b7 304c 	ldrh.w	r3, [r7, #76]	; 0x4c
 800a0a2:	0a1b      	lsrs	r3, r3, #8
 800a0a4:	b29b      	uxth	r3, r3
 800a0a6:	b2da      	uxtb	r2, r3
 800a0a8:	687b      	ldr	r3, [r7, #4]
 800a0aa:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 800a0ac:	687b      	ldr	r3, [r7, #4]
 800a0ae:	3301      	adds	r3, #1
 800a0b0:	607b      	str	r3, [r7, #4]
	lenBuf++;
 800a0b2:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800a0b6:	3301      	adds	r3, #1
 800a0b8:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
	*pxBuf318 = crc318;
 800a0bc:	f8b7 304c 	ldrh.w	r3, [r7, #76]	; 0x4c
 800a0c0:	b2da      	uxtb	r2, r3
 800a0c2:	687b      	ldr	r3, [r7, #4]
 800a0c4:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 800a0c6:	687b      	ldr	r3, [r7, #4]
 800a0c8:	3301      	adds	r3, #1
 800a0ca:	607b      	str	r3, [r7, #4]
	lenBuf++;
 800a0cc:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800a0d0:	3301      	adds	r3, #1
 800a0d2:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
	*pxBuf318 = SYM_ST318;
 800a0d6:	687b      	ldr	r3, [r7, #4]
 800a0d8:	22c0      	movs	r2, #192	; 0xc0
 800a0da:	701a      	strb	r2, [r3, #0]

	return (lenBuf + 2);
 800a0dc:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800a0e0:	3302      	adds	r3, #2
 800a0e2:	b29b      	uxth	r3, r3
}
 800a0e4:	4618      	mov	r0, r3
 800a0e6:	3750      	adds	r7, #80	; 0x50
 800a0e8:	46bd      	mov	sp, r7
 800a0ea:	bd80      	pop	{r7, pc}
 800a0ec:	08009309 	.word	0x08009309

0800a0f0 <AskPowC>:

uint16 AskPowC(uint8 *pxBuf318, uint32 MeterNumber) {
 800a0f0:	b580      	push	{r7, lr}
 800a0f2:	b094      	sub	sp, #80	; 0x50
 800a0f4:	af00      	add	r7, sp, #0
 800a0f6:	6078      	str	r0, [r7, #4]
 800a0f8:	6039      	str	r1, [r7, #0]
	uint16 crc318;
	uint8 tmpbuff318[64];
	unsigned short lenBuf = 0;
 800a0fa:	2300      	movs	r3, #0
 800a0fc:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
	*pxBuf318 = SYM_ST318;
 800a100:	687b      	ldr	r3, [r7, #4]
 800a102:	22c0      	movs	r2, #192	; 0xc0
 800a104:	701a      	strb	r2, [r3, #0]

	pxBuf318++;
 800a106:	687b      	ldr	r3, [r7, #4]
 800a108:	3301      	adds	r3, #1
 800a10a:	607b      	str	r3, [r7, #4]
	*pxBuf318 = tmpbuff318[0] = GET_INFO;
 800a10c:	2306      	movs	r3, #6
 800a10e:	733b      	strb	r3, [r7, #12]
 800a110:	7b3a      	ldrb	r2, [r7, #12]
 800a112:	687b      	ldr	r3, [r7, #4]
 800a114:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 800a116:	687b      	ldr	r3, [r7, #4]
 800a118:	3301      	adds	r3, #1
 800a11a:	607b      	str	r3, [r7, #4]
	lenBuf++;
 800a11c:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800a120:	3301      	adds	r3, #1
 800a122:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[1] = MeterNumber;
 800a126:	683b      	ldr	r3, [r7, #0]
 800a128:	b2db      	uxtb	r3, r3
 800a12a:	737b      	strb	r3, [r7, #13]
 800a12c:	7b7a      	ldrb	r2, [r7, #13]
 800a12e:	687b      	ldr	r3, [r7, #4]
 800a130:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 800a132:	687b      	ldr	r3, [r7, #4]
 800a134:	3301      	adds	r3, #1
 800a136:	607b      	str	r3, [r7, #4]
	lenBuf++;
 800a138:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800a13c:	3301      	adds	r3, #1
 800a13e:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[2] = MeterNumber >> 8;
 800a142:	683b      	ldr	r3, [r7, #0]
 800a144:	0a1b      	lsrs	r3, r3, #8
 800a146:	b2db      	uxtb	r3, r3
 800a148:	73bb      	strb	r3, [r7, #14]
 800a14a:	7bba      	ldrb	r2, [r7, #14]
 800a14c:	687b      	ldr	r3, [r7, #4]
 800a14e:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 800a150:	687b      	ldr	r3, [r7, #4]
 800a152:	3301      	adds	r3, #1
 800a154:	607b      	str	r3, [r7, #4]
	lenBuf++;
 800a156:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800a15a:	3301      	adds	r3, #1
 800a15c:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[3] = MeterNumber >> 16;
 800a160:	683b      	ldr	r3, [r7, #0]
 800a162:	0c1b      	lsrs	r3, r3, #16
 800a164:	b2db      	uxtb	r3, r3
 800a166:	73fb      	strb	r3, [r7, #15]
 800a168:	7bfa      	ldrb	r2, [r7, #15]
 800a16a:	687b      	ldr	r3, [r7, #4]
 800a16c:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 800a16e:	687b      	ldr	r3, [r7, #4]
 800a170:	3301      	adds	r3, #1
 800a172:	607b      	str	r3, [r7, #4]
	lenBuf++;
 800a174:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800a178:	3301      	adds	r3, #1
 800a17a:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[4] = MeterNumber >> 24;
 800a17e:	683b      	ldr	r3, [r7, #0]
 800a180:	0e1b      	lsrs	r3, r3, #24
 800a182:	b2db      	uxtb	r3, r3
 800a184:	743b      	strb	r3, [r7, #16]
 800a186:	7c3a      	ldrb	r2, [r7, #16]
 800a188:	687b      	ldr	r3, [r7, #4]
 800a18a:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 800a18c:	687b      	ldr	r3, [r7, #4]
 800a18e:	3301      	adds	r3, #1
 800a190:	607b      	str	r3, [r7, #4]
	lenBuf++;
 800a192:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800a196:	3301      	adds	r3, #1
 800a198:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[5] = 0x00;
 800a19c:	2300      	movs	r3, #0
 800a19e:	747b      	strb	r3, [r7, #17]
 800a1a0:	7c7a      	ldrb	r2, [r7, #17]
 800a1a2:	687b      	ldr	r3, [r7, #4]
 800a1a4:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 800a1a6:	687b      	ldr	r3, [r7, #4]
 800a1a8:	3301      	adds	r3, #1
 800a1aa:	607b      	str	r3, [r7, #4]
	lenBuf++;
 800a1ac:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800a1b0:	3301      	adds	r3, #1
 800a1b2:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[6] = GET_INFO;
 800a1b6:	2306      	movs	r3, #6
 800a1b8:	74bb      	strb	r3, [r7, #18]
 800a1ba:	7cba      	ldrb	r2, [r7, #18]
 800a1bc:	687b      	ldr	r3, [r7, #4]
 800a1be:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 800a1c0:	687b      	ldr	r3, [r7, #4]
 800a1c2:	3301      	adds	r3, #1
 800a1c4:	607b      	str	r3, [r7, #4]
	lenBuf++;
 800a1c6:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800a1ca:	3301      	adds	r3, #1
 800a1cc:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[7] = GET_DATA_SINGLE;
 800a1d0:	230a      	movs	r3, #10
 800a1d2:	74fb      	strb	r3, [r7, #19]
 800a1d4:	7cfa      	ldrb	r2, [r7, #19]
 800a1d6:	687b      	ldr	r3, [r7, #4]
 800a1d8:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 800a1da:	687b      	ldr	r3, [r7, #4]
 800a1dc:	3301      	adds	r3, #1
 800a1de:	607b      	str	r3, [r7, #4]
	lenBuf++;
 800a1e0:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800a1e4:	3301      	adds	r3, #1
 800a1e6:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[8] = 0x00;
 800a1ea:	2300      	movs	r3, #0
 800a1ec:	753b      	strb	r3, [r7, #20]
 800a1ee:	7d3a      	ldrb	r2, [r7, #20]
 800a1f0:	687b      	ldr	r3, [r7, #4]
 800a1f2:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 800a1f4:	687b      	ldr	r3, [r7, #4]
 800a1f6:	3301      	adds	r3, #1
 800a1f8:	607b      	str	r3, [r7, #4]
	lenBuf++;
 800a1fa:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800a1fe:	3301      	adds	r3, #1
 800a200:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[9] = GET_POW;
 800a204:	230d      	movs	r3, #13
 800a206:	757b      	strb	r3, [r7, #21]
 800a208:	7d7a      	ldrb	r2, [r7, #21]
 800a20a:	687b      	ldr	r3, [r7, #4]
 800a20c:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 800a20e:	687b      	ldr	r3, [r7, #4]
 800a210:	3301      	adds	r3, #1
 800a212:	607b      	str	r3, [r7, #4]
	lenBuf++;
 800a214:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800a218:	3301      	adds	r3, #1
 800a21a:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[10] = GET_C;
 800a21e:	2310      	movs	r3, #16
 800a220:	75bb      	strb	r3, [r7, #22]
 800a222:	7dba      	ldrb	r2, [r7, #22]
 800a224:	687b      	ldr	r3, [r7, #4]
 800a226:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 800a228:	687b      	ldr	r3, [r7, #4]
 800a22a:	3301      	adds	r3, #1
 800a22c:	607b      	str	r3, [r7, #4]
	lenBuf++;
 800a22e:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800a232:	3301      	adds	r3, #1
 800a234:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	crc318 = SetCRC16(tmpbuff318, lenBuf);
 800a238:	f8b7 204e 	ldrh.w	r2, [r7, #78]	; 0x4e
 800a23c:	f107 030c 	add.w	r3, r7, #12
 800a240:	4611      	mov	r1, r2
 800a242:	4618      	mov	r0, r3
 800a244:	4b15      	ldr	r3, [pc, #84]	; (800a29c <AskPowC+0x1ac>)
 800a246:	4798      	blx	r3
 800a248:	4603      	mov	r3, r0
 800a24a:	f8a7 304c 	strh.w	r3, [r7, #76]	; 0x4c

	*pxBuf318 = crc318 >> 8;
 800a24e:	f8b7 304c 	ldrh.w	r3, [r7, #76]	; 0x4c
 800a252:	0a1b      	lsrs	r3, r3, #8
 800a254:	b29b      	uxth	r3, r3
 800a256:	b2da      	uxtb	r2, r3
 800a258:	687b      	ldr	r3, [r7, #4]
 800a25a:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 800a25c:	687b      	ldr	r3, [r7, #4]
 800a25e:	3301      	adds	r3, #1
 800a260:	607b      	str	r3, [r7, #4]
	lenBuf++;
 800a262:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800a266:	3301      	adds	r3, #1
 800a268:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
	*pxBuf318 = crc318;
 800a26c:	f8b7 304c 	ldrh.w	r3, [r7, #76]	; 0x4c
 800a270:	b2da      	uxtb	r2, r3
 800a272:	687b      	ldr	r3, [r7, #4]
 800a274:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 800a276:	687b      	ldr	r3, [r7, #4]
 800a278:	3301      	adds	r3, #1
 800a27a:	607b      	str	r3, [r7, #4]
	lenBuf++;
 800a27c:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800a280:	3301      	adds	r3, #1
 800a282:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
	*pxBuf318 = SYM_ST318;
 800a286:	687b      	ldr	r3, [r7, #4]
 800a288:	22c0      	movs	r2, #192	; 0xc0
 800a28a:	701a      	strb	r2, [r3, #0]

	return (lenBuf + 2);
 800a28c:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800a290:	3302      	adds	r3, #2
 800a292:	b29b      	uxth	r3, r3
}
 800a294:	4618      	mov	r0, r3
 800a296:	3750      	adds	r7, #80	; 0x50
 800a298:	46bd      	mov	sp, r7
 800a29a:	bd80      	pop	{r7, pc}
 800a29c:	08009309 	.word	0x08009309

0800a2a0 <AskEnerge>:
	*pxBuf318 = SYM_ST318;

	return (lenBuf + 2);
}

uint16 AskEnerge(uint8 *pxBuf318, uint32 MeterNumber) {
 800a2a0:	b580      	push	{r7, lr}
 800a2a2:	b094      	sub	sp, #80	; 0x50
 800a2a4:	af00      	add	r7, sp, #0
 800a2a6:	6078      	str	r0, [r7, #4]
 800a2a8:	6039      	str	r1, [r7, #0]
	uint16 crc318;
	uint8 tmpbuff318[64];
	unsigned short lenBuf = 0;
 800a2aa:	2300      	movs	r3, #0
 800a2ac:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
	*pxBuf318 = SYM_ST318;
 800a2b0:	687b      	ldr	r3, [r7, #4]
 800a2b2:	22c0      	movs	r2, #192	; 0xc0
 800a2b4:	701a      	strb	r2, [r3, #0]

	pxBuf318++;
 800a2b6:	687b      	ldr	r3, [r7, #4]
 800a2b8:	3301      	adds	r3, #1
 800a2ba:	607b      	str	r3, [r7, #4]
	*pxBuf318 = tmpbuff318[0] = GET_INFO;
 800a2bc:	2306      	movs	r3, #6
 800a2be:	733b      	strb	r3, [r7, #12]
 800a2c0:	7b3a      	ldrb	r2, [r7, #12]
 800a2c2:	687b      	ldr	r3, [r7, #4]
 800a2c4:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 800a2c6:	687b      	ldr	r3, [r7, #4]
 800a2c8:	3301      	adds	r3, #1
 800a2ca:	607b      	str	r3, [r7, #4]
	lenBuf++;
 800a2cc:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800a2d0:	3301      	adds	r3, #1
 800a2d2:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[1] = MeterNumber;
 800a2d6:	683b      	ldr	r3, [r7, #0]
 800a2d8:	b2db      	uxtb	r3, r3
 800a2da:	737b      	strb	r3, [r7, #13]
 800a2dc:	7b7a      	ldrb	r2, [r7, #13]
 800a2de:	687b      	ldr	r3, [r7, #4]
 800a2e0:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 800a2e2:	687b      	ldr	r3, [r7, #4]
 800a2e4:	3301      	adds	r3, #1
 800a2e6:	607b      	str	r3, [r7, #4]
	lenBuf++;
 800a2e8:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800a2ec:	3301      	adds	r3, #1
 800a2ee:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[2] = MeterNumber >> 8;
 800a2f2:	683b      	ldr	r3, [r7, #0]
 800a2f4:	0a1b      	lsrs	r3, r3, #8
 800a2f6:	b2db      	uxtb	r3, r3
 800a2f8:	73bb      	strb	r3, [r7, #14]
 800a2fa:	7bba      	ldrb	r2, [r7, #14]
 800a2fc:	687b      	ldr	r3, [r7, #4]
 800a2fe:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 800a300:	687b      	ldr	r3, [r7, #4]
 800a302:	3301      	adds	r3, #1
 800a304:	607b      	str	r3, [r7, #4]
	lenBuf++;
 800a306:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800a30a:	3301      	adds	r3, #1
 800a30c:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[3] = MeterNumber >> 16;
 800a310:	683b      	ldr	r3, [r7, #0]
 800a312:	0c1b      	lsrs	r3, r3, #16
 800a314:	b2db      	uxtb	r3, r3
 800a316:	73fb      	strb	r3, [r7, #15]
 800a318:	7bfa      	ldrb	r2, [r7, #15]
 800a31a:	687b      	ldr	r3, [r7, #4]
 800a31c:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 800a31e:	687b      	ldr	r3, [r7, #4]
 800a320:	3301      	adds	r3, #1
 800a322:	607b      	str	r3, [r7, #4]
	lenBuf++;
 800a324:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800a328:	3301      	adds	r3, #1
 800a32a:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[4] = MeterNumber >> 24;
 800a32e:	683b      	ldr	r3, [r7, #0]
 800a330:	0e1b      	lsrs	r3, r3, #24
 800a332:	b2db      	uxtb	r3, r3
 800a334:	743b      	strb	r3, [r7, #16]
 800a336:	7c3a      	ldrb	r2, [r7, #16]
 800a338:	687b      	ldr	r3, [r7, #4]
 800a33a:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 800a33c:	687b      	ldr	r3, [r7, #4]
 800a33e:	3301      	adds	r3, #1
 800a340:	607b      	str	r3, [r7, #4]
	lenBuf++;
 800a342:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800a346:	3301      	adds	r3, #1
 800a348:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[5] = 0x00;
 800a34c:	2300      	movs	r3, #0
 800a34e:	747b      	strb	r3, [r7, #17]
 800a350:	7c7a      	ldrb	r2, [r7, #17]
 800a352:	687b      	ldr	r3, [r7, #4]
 800a354:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 800a356:	687b      	ldr	r3, [r7, #4]
 800a358:	3301      	adds	r3, #1
 800a35a:	607b      	str	r3, [r7, #4]
	lenBuf++;
 800a35c:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800a360:	3301      	adds	r3, #1
 800a362:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[6] = GET_INFO;
 800a366:	2306      	movs	r3, #6
 800a368:	74bb      	strb	r3, [r7, #18]
 800a36a:	7cba      	ldrb	r2, [r7, #18]
 800a36c:	687b      	ldr	r3, [r7, #4]
 800a36e:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 800a370:	687b      	ldr	r3, [r7, #4]
 800a372:	3301      	adds	r3, #1
 800a374:	607b      	str	r3, [r7, #4]
	lenBuf++;
 800a376:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800a37a:	3301      	adds	r3, #1
 800a37c:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[7] = GET_DATA_SINGLE;
 800a380:	230a      	movs	r3, #10
 800a382:	74fb      	strb	r3, [r7, #19]
 800a384:	7cfa      	ldrb	r2, [r7, #19]
 800a386:	687b      	ldr	r3, [r7, #4]
 800a388:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 800a38a:	687b      	ldr	r3, [r7, #4]
 800a38c:	3301      	adds	r3, #1
 800a38e:	607b      	str	r3, [r7, #4]
	lenBuf++;
 800a390:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800a394:	3301      	adds	r3, #1
 800a396:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[8] = 0x00;
 800a39a:	2300      	movs	r3, #0
 800a39c:	753b      	strb	r3, [r7, #20]
 800a39e:	7d3a      	ldrb	r2, [r7, #20]
 800a3a0:	687b      	ldr	r3, [r7, #4]
 800a3a2:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 800a3a4:	687b      	ldr	r3, [r7, #4]
 800a3a6:	3301      	adds	r3, #1
 800a3a8:	607b      	str	r3, [r7, #4]
	lenBuf++;
 800a3aa:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800a3ae:	3301      	adds	r3, #1
 800a3b0:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[9] = GET_ENERGY;
 800a3b4:	2301      	movs	r3, #1
 800a3b6:	757b      	strb	r3, [r7, #21]
 800a3b8:	7d7a      	ldrb	r2, [r7, #21]
 800a3ba:	687b      	ldr	r3, [r7, #4]
 800a3bc:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 800a3be:	687b      	ldr	r3, [r7, #4]
 800a3c0:	3301      	adds	r3, #1
 800a3c2:	607b      	str	r3, [r7, #4]
	lenBuf++;
 800a3c4:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800a3c8:	3301      	adds	r3, #1
 800a3ca:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[10] = GET_ENFULL;
 800a3ce:	2302      	movs	r3, #2
 800a3d0:	75bb      	strb	r3, [r7, #22]
 800a3d2:	7dba      	ldrb	r2, [r7, #22]
 800a3d4:	687b      	ldr	r3, [r7, #4]
 800a3d6:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 800a3d8:	687b      	ldr	r3, [r7, #4]
 800a3da:	3301      	adds	r3, #1
 800a3dc:	607b      	str	r3, [r7, #4]
	lenBuf++;
 800a3de:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800a3e2:	3301      	adds	r3, #1
 800a3e4:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[11] = 0x00;
 800a3e8:	2300      	movs	r3, #0
 800a3ea:	75fb      	strb	r3, [r7, #23]
 800a3ec:	7dfa      	ldrb	r2, [r7, #23]
 800a3ee:	687b      	ldr	r3, [r7, #4]
 800a3f0:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 800a3f2:	687b      	ldr	r3, [r7, #4]
 800a3f4:	3301      	adds	r3, #1
 800a3f6:	607b      	str	r3, [r7, #4]
	lenBuf++;
 800a3f8:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800a3fc:	3301      	adds	r3, #1
 800a3fe:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	crc318 = SetCRC16(tmpbuff318, lenBuf);
 800a402:	f8b7 204e 	ldrh.w	r2, [r7, #78]	; 0x4e
 800a406:	f107 030c 	add.w	r3, r7, #12
 800a40a:	4611      	mov	r1, r2
 800a40c:	4618      	mov	r0, r3
 800a40e:	4b16      	ldr	r3, [pc, #88]	; (800a468 <AskEnerge+0x1c8>)
 800a410:	4798      	blx	r3
 800a412:	4603      	mov	r3, r0
 800a414:	f8a7 304c 	strh.w	r3, [r7, #76]	; 0x4c

	*pxBuf318 = crc318 >> 8;
 800a418:	f8b7 304c 	ldrh.w	r3, [r7, #76]	; 0x4c
 800a41c:	0a1b      	lsrs	r3, r3, #8
 800a41e:	b29b      	uxth	r3, r3
 800a420:	b2da      	uxtb	r2, r3
 800a422:	687b      	ldr	r3, [r7, #4]
 800a424:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 800a426:	687b      	ldr	r3, [r7, #4]
 800a428:	3301      	adds	r3, #1
 800a42a:	607b      	str	r3, [r7, #4]
	lenBuf++;
 800a42c:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800a430:	3301      	adds	r3, #1
 800a432:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
	*pxBuf318 = crc318;
 800a436:	f8b7 304c 	ldrh.w	r3, [r7, #76]	; 0x4c
 800a43a:	b2da      	uxtb	r2, r3
 800a43c:	687b      	ldr	r3, [r7, #4]
 800a43e:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 800a440:	687b      	ldr	r3, [r7, #4]
 800a442:	3301      	adds	r3, #1
 800a444:	607b      	str	r3, [r7, #4]
	lenBuf++;
 800a446:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800a44a:	3301      	adds	r3, #1
 800a44c:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
	*pxBuf318 = SYM_ST318;
 800a450:	687b      	ldr	r3, [r7, #4]
 800a452:	22c0      	movs	r2, #192	; 0xc0
 800a454:	701a      	strb	r2, [r3, #0]

	return (lenBuf + 2);
 800a456:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800a45a:	3302      	adds	r3, #2
 800a45c:	b29b      	uxth	r3, r3

}
 800a45e:	4618      	mov	r0, r3
 800a460:	3750      	adds	r7, #80	; 0x50
 800a462:	46bd      	mov	sp, r7
 800a464:	bd80      	pop	{r7, pc}
 800a466:	bf00      	nop
 800a468:	08009309 	.word	0x08009309

0800a46c <AskTime>:

//-
uint16 AskTime(uint8 *pxBuf318, uint32 MeterNumber) {
 800a46c:	b580      	push	{r7, lr}
 800a46e:	b094      	sub	sp, #80	; 0x50
 800a470:	af00      	add	r7, sp, #0
 800a472:	6078      	str	r0, [r7, #4]
 800a474:	6039      	str	r1, [r7, #0]
	uint16 crc318;
	uint8 tmpbuff318[64];
	unsigned short lenBuf = 0;
 800a476:	2300      	movs	r3, #0
 800a478:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
	*pxBuf318 = SYM_ST318;
 800a47c:	687b      	ldr	r3, [r7, #4]
 800a47e:	22c0      	movs	r2, #192	; 0xc0
 800a480:	701a      	strb	r2, [r3, #0]

	pxBuf318++;
 800a482:	687b      	ldr	r3, [r7, #4]
 800a484:	3301      	adds	r3, #1
 800a486:	607b      	str	r3, [r7, #4]
	*pxBuf318 = tmpbuff318[0] = GET_INFO;
 800a488:	2306      	movs	r3, #6
 800a48a:	733b      	strb	r3, [r7, #12]
 800a48c:	7b3a      	ldrb	r2, [r7, #12]
 800a48e:	687b      	ldr	r3, [r7, #4]
 800a490:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 800a492:	687b      	ldr	r3, [r7, #4]
 800a494:	3301      	adds	r3, #1
 800a496:	607b      	str	r3, [r7, #4]
	lenBuf++;
 800a498:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800a49c:	3301      	adds	r3, #1
 800a49e:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[1] = MeterNumber;
 800a4a2:	683b      	ldr	r3, [r7, #0]
 800a4a4:	b2db      	uxtb	r3, r3
 800a4a6:	737b      	strb	r3, [r7, #13]
 800a4a8:	7b7a      	ldrb	r2, [r7, #13]
 800a4aa:	687b      	ldr	r3, [r7, #4]
 800a4ac:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 800a4ae:	687b      	ldr	r3, [r7, #4]
 800a4b0:	3301      	adds	r3, #1
 800a4b2:	607b      	str	r3, [r7, #4]
	lenBuf++;
 800a4b4:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800a4b8:	3301      	adds	r3, #1
 800a4ba:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[2] = MeterNumber >> 8;
 800a4be:	683b      	ldr	r3, [r7, #0]
 800a4c0:	0a1b      	lsrs	r3, r3, #8
 800a4c2:	b2db      	uxtb	r3, r3
 800a4c4:	73bb      	strb	r3, [r7, #14]
 800a4c6:	7bba      	ldrb	r2, [r7, #14]
 800a4c8:	687b      	ldr	r3, [r7, #4]
 800a4ca:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 800a4cc:	687b      	ldr	r3, [r7, #4]
 800a4ce:	3301      	adds	r3, #1
 800a4d0:	607b      	str	r3, [r7, #4]
	lenBuf++;
 800a4d2:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800a4d6:	3301      	adds	r3, #1
 800a4d8:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[3] = MeterNumber >> 16;
 800a4dc:	683b      	ldr	r3, [r7, #0]
 800a4de:	0c1b      	lsrs	r3, r3, #16
 800a4e0:	b2db      	uxtb	r3, r3
 800a4e2:	73fb      	strb	r3, [r7, #15]
 800a4e4:	7bfa      	ldrb	r2, [r7, #15]
 800a4e6:	687b      	ldr	r3, [r7, #4]
 800a4e8:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 800a4ea:	687b      	ldr	r3, [r7, #4]
 800a4ec:	3301      	adds	r3, #1
 800a4ee:	607b      	str	r3, [r7, #4]
	lenBuf++;
 800a4f0:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800a4f4:	3301      	adds	r3, #1
 800a4f6:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[4] = MeterNumber >> 24;
 800a4fa:	683b      	ldr	r3, [r7, #0]
 800a4fc:	0e1b      	lsrs	r3, r3, #24
 800a4fe:	b2db      	uxtb	r3, r3
 800a500:	743b      	strb	r3, [r7, #16]
 800a502:	7c3a      	ldrb	r2, [r7, #16]
 800a504:	687b      	ldr	r3, [r7, #4]
 800a506:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 800a508:	687b      	ldr	r3, [r7, #4]
 800a50a:	3301      	adds	r3, #1
 800a50c:	607b      	str	r3, [r7, #4]
	lenBuf++;
 800a50e:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800a512:	3301      	adds	r3, #1
 800a514:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[5] = 0x00;
 800a518:	2300      	movs	r3, #0
 800a51a:	747b      	strb	r3, [r7, #17]
 800a51c:	7c7a      	ldrb	r2, [r7, #17]
 800a51e:	687b      	ldr	r3, [r7, #4]
 800a520:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 800a522:	687b      	ldr	r3, [r7, #4]
 800a524:	3301      	adds	r3, #1
 800a526:	607b      	str	r3, [r7, #4]
	lenBuf++;
 800a528:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800a52c:	3301      	adds	r3, #1
 800a52e:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[6] = GET_INFO;
 800a532:	2306      	movs	r3, #6
 800a534:	74bb      	strb	r3, [r7, #18]
 800a536:	7cba      	ldrb	r2, [r7, #18]
 800a538:	687b      	ldr	r3, [r7, #4]
 800a53a:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 800a53c:	687b      	ldr	r3, [r7, #4]
 800a53e:	3301      	adds	r3, #1
 800a540:	607b      	str	r3, [r7, #4]
	lenBuf++;
 800a542:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800a546:	3301      	adds	r3, #1
 800a548:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[7] = GET_OPTION;
 800a54c:	2304      	movs	r3, #4
 800a54e:	74fb      	strb	r3, [r7, #19]
 800a550:	7cfa      	ldrb	r2, [r7, #19]
 800a552:	687b      	ldr	r3, [r7, #4]
 800a554:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 800a556:	687b      	ldr	r3, [r7, #4]
 800a558:	3301      	adds	r3, #1
 800a55a:	607b      	str	r3, [r7, #4]
	lenBuf++;
 800a55c:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800a560:	3301      	adds	r3, #1
 800a562:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[8] = 0x00;
 800a566:	2300      	movs	r3, #0
 800a568:	753b      	strb	r3, [r7, #20]
 800a56a:	7d3a      	ldrb	r2, [r7, #20]
 800a56c:	687b      	ldr	r3, [r7, #4]
 800a56e:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 800a570:	687b      	ldr	r3, [r7, #4]
 800a572:	3301      	adds	r3, #1
 800a574:	607b      	str	r3, [r7, #4]
	lenBuf++;
 800a576:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800a57a:	3301      	adds	r3, #1
 800a57c:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	*pxBuf318 = tmpbuff318[9] = GET_TIME;
 800a580:	2301      	movs	r3, #1
 800a582:	757b      	strb	r3, [r7, #21]
 800a584:	7d7a      	ldrb	r2, [r7, #21]
 800a586:	687b      	ldr	r3, [r7, #4]
 800a588:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 800a58a:	687b      	ldr	r3, [r7, #4]
 800a58c:	3301      	adds	r3, #1
 800a58e:	607b      	str	r3, [r7, #4]
	lenBuf++;
 800a590:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800a594:	3301      	adds	r3, #1
 800a596:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

	crc318 = SetCRC16(tmpbuff318, lenBuf);
 800a59a:	f8b7 204e 	ldrh.w	r2, [r7, #78]	; 0x4e
 800a59e:	f107 030c 	add.w	r3, r7, #12
 800a5a2:	4611      	mov	r1, r2
 800a5a4:	4618      	mov	r0, r3
 800a5a6:	4b16      	ldr	r3, [pc, #88]	; (800a600 <AskTime+0x194>)
 800a5a8:	4798      	blx	r3
 800a5aa:	4603      	mov	r3, r0
 800a5ac:	f8a7 304c 	strh.w	r3, [r7, #76]	; 0x4c

	*pxBuf318 = crc318 >> 8;
 800a5b0:	f8b7 304c 	ldrh.w	r3, [r7, #76]	; 0x4c
 800a5b4:	0a1b      	lsrs	r3, r3, #8
 800a5b6:	b29b      	uxth	r3, r3
 800a5b8:	b2da      	uxtb	r2, r3
 800a5ba:	687b      	ldr	r3, [r7, #4]
 800a5bc:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 800a5be:	687b      	ldr	r3, [r7, #4]
 800a5c0:	3301      	adds	r3, #1
 800a5c2:	607b      	str	r3, [r7, #4]
	lenBuf++;
 800a5c4:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800a5c8:	3301      	adds	r3, #1
 800a5ca:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
	*pxBuf318 = crc318;
 800a5ce:	f8b7 304c 	ldrh.w	r3, [r7, #76]	; 0x4c
 800a5d2:	b2da      	uxtb	r2, r3
 800a5d4:	687b      	ldr	r3, [r7, #4]
 800a5d6:	701a      	strb	r2, [r3, #0]
	pxBuf318++;
 800a5d8:	687b      	ldr	r3, [r7, #4]
 800a5da:	3301      	adds	r3, #1
 800a5dc:	607b      	str	r3, [r7, #4]
	lenBuf++;
 800a5de:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800a5e2:	3301      	adds	r3, #1
 800a5e4:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
	*pxBuf318 = SYM_ST318;
 800a5e8:	687b      	ldr	r3, [r7, #4]
 800a5ea:	22c0      	movs	r2, #192	; 0xc0
 800a5ec:	701a      	strb	r2, [r3, #0]

	return (lenBuf + 2);
 800a5ee:	f8b7 304e 	ldrh.w	r3, [r7, #78]	; 0x4e
 800a5f2:	3302      	adds	r3, #2
 800a5f4:	b29b      	uxth	r3, r3
}
 800a5f6:	4618      	mov	r0, r3
 800a5f8:	3750      	adds	r7, #80	; 0x50
 800a5fa:	46bd      	mov	sp, r7
 800a5fc:	bd80      	pop	{r7, pc}
 800a5fe:	bf00      	nop
 800a600:	08009309 	.word	0x08009309

0800a604 <new_stof>:

void new_stof(char *str1, float f, char size)

{
 800a604:	b580      	push	{r7, lr}
 800a606:	b088      	sub	sp, #32
 800a608:	af00      	add	r7, sp, #0
 800a60a:	60f8      	str	r0, [r7, #12]
 800a60c:	60b9      	str	r1, [r7, #8]
 800a60e:	4613      	mov	r3, r2
 800a610:	71fb      	strb	r3, [r7, #7]

	char pos = 0;  // position in string
 800a612:	2300      	movs	r3, #0
 800a614:	77fb      	strb	r3, [r7, #31]

	char len = 0;  // length of decimal part of result
 800a616:	2300      	movs	r3, #0
 800a618:	74fb      	strb	r3, [r7, #19]

	char curr[3];  // temp holder for next digit

	int value = 0;  // decimal digit(s) to convert
 800a61a:	2300      	movs	r3, #0
 800a61c:	61bb      	str	r3, [r7, #24]
	int value2 = 0;  // decimal digit(s) to convert
 800a61e:	2300      	movs	r3, #0
 800a620:	617b      	str	r3, [r7, #20]

	value = (int) f;  // truncate the floating point number
 800a622:	4b2c      	ldr	r3, [pc, #176]	; (800a6d4 <new_stof+0xd0>)
 800a624:	68b8      	ldr	r0, [r7, #8]
 800a626:	4798      	blx	r3
 800a628:	4603      	mov	r3, r0
 800a62a:	61bb      	str	r3, [r7, #24]
	itoa1(value, str1); // this is kinda dangerous depending on the length of str
 800a62c:	68f9      	ldr	r1, [r7, #12]
 800a62e:	69b8      	ldr	r0, [r7, #24]
 800a630:	4b29      	ldr	r3, [pc, #164]	; (800a6d8 <new_stof+0xd4>)
 800a632:	4798      	blx	r3
	// now str array has the digits before the decimal

	if (f < 0)  // handle negative numbers
 800a634:	4b29      	ldr	r3, [pc, #164]	; (800a6dc <new_stof+0xd8>)
 800a636:	f04f 0100 	mov.w	r1, #0
 800a63a:	68b8      	ldr	r0, [r7, #8]
 800a63c:	4798      	blx	r3
 800a63e:	4603      	mov	r3, r0
 800a640:	2b00      	cmp	r3, #0
 800a642:	d006      	beq.n	800a652 <new_stof+0x4e>
			{
		f *= -1;
 800a644:	68bb      	ldr	r3, [r7, #8]
 800a646:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000
 800a64a:	60bb      	str	r3, [r7, #8]
		value *= -1;
 800a64c:	69bb      	ldr	r3, [r7, #24]
 800a64e:	425b      	negs	r3, r3
 800a650:	61bb      	str	r3, [r7, #24]
	}

	len = strlen(str1);  // find out how big the integer part was
 800a652:	68f8      	ldr	r0, [r7, #12]
 800a654:	4b22      	ldr	r3, [pc, #136]	; (800a6e0 <new_stof+0xdc>)
 800a656:	4798      	blx	r3
 800a658:	4603      	mov	r3, r0
 800a65a:	74fb      	strb	r3, [r7, #19]
	pos = len;  // position the pointer to the end of the integer part
 800a65c:	7cfb      	ldrb	r3, [r7, #19]
 800a65e:	77fb      	strb	r3, [r7, #31]
	str1[pos++] = '.';  // add decimal point to string
 800a660:	7ffb      	ldrb	r3, [r7, #31]
 800a662:	1c5a      	adds	r2, r3, #1
 800a664:	77fa      	strb	r2, [r7, #31]
 800a666:	461a      	mov	r2, r3
 800a668:	68fb      	ldr	r3, [r7, #12]
 800a66a:	4413      	add	r3, r2
 800a66c:	222e      	movs	r2, #46	; 0x2e
 800a66e:	701a      	strb	r2, [r3, #0]

	value2 = value;
 800a670:	69bb      	ldr	r3, [r7, #24]
 800a672:	617b      	str	r3, [r7, #20]

	while (pos < (size + len + 1))  // process remaining digits
 800a674:	e022      	b.n	800a6bc <new_stof+0xb8>
	{

		f = f - (float) value2;  // hack off the whole part of the number
 800a676:	4b1b      	ldr	r3, [pc, #108]	; (800a6e4 <new_stof+0xe0>)
 800a678:	6978      	ldr	r0, [r7, #20]
 800a67a:	4798      	blx	r3
 800a67c:	4603      	mov	r3, r0
 800a67e:	4a1a      	ldr	r2, [pc, #104]	; (800a6e8 <new_stof+0xe4>)
 800a680:	4619      	mov	r1, r3
 800a682:	68b8      	ldr	r0, [r7, #8]
 800a684:	4790      	blx	r2
 800a686:	4603      	mov	r3, r0
 800a688:	60bb      	str	r3, [r7, #8]
		f *= 10;  // move next digit over
 800a68a:	4b18      	ldr	r3, [pc, #96]	; (800a6ec <new_stof+0xe8>)
 800a68c:	4918      	ldr	r1, [pc, #96]	; (800a6f0 <new_stof+0xec>)
 800a68e:	68b8      	ldr	r0, [r7, #8]
 800a690:	4798      	blx	r3
 800a692:	4603      	mov	r3, r0
 800a694:	60bb      	str	r3, [r7, #8]
		value2 = (int) f;  // get next digit
 800a696:	4b0f      	ldr	r3, [pc, #60]	; (800a6d4 <new_stof+0xd0>)
 800a698:	68b8      	ldr	r0, [r7, #8]
 800a69a:	4798      	blx	r3
 800a69c:	4603      	mov	r3, r0
 800a69e:	617b      	str	r3, [r7, #20]
		itoa1(value2, curr); // convert digit to string
 800a6a0:	f107 0310 	add.w	r3, r7, #16
 800a6a4:	4619      	mov	r1, r3
 800a6a6:	6978      	ldr	r0, [r7, #20]
 800a6a8:	4b0b      	ldr	r3, [pc, #44]	; (800a6d8 <new_stof+0xd4>)
 800a6aa:	4798      	blx	r3
		str1[pos++] = *curr; // add digit to result string and increment pointer
 800a6ac:	7ffb      	ldrb	r3, [r7, #31]
 800a6ae:	1c5a      	adds	r2, r3, #1
 800a6b0:	77fa      	strb	r2, [r7, #31]
 800a6b2:	461a      	mov	r2, r3
 800a6b4:	68fb      	ldr	r3, [r7, #12]
 800a6b6:	4413      	add	r3, r2
 800a6b8:	7c3a      	ldrb	r2, [r7, #16]
 800a6ba:	701a      	strb	r2, [r3, #0]
	while (pos < (size + len + 1))  // process remaining digits
 800a6bc:	79fa      	ldrb	r2, [r7, #7]
 800a6be:	7cfb      	ldrb	r3, [r7, #19]
 800a6c0:	441a      	add	r2, r3
 800a6c2:	7ffb      	ldrb	r3, [r7, #31]
 800a6c4:	429a      	cmp	r2, r3
 800a6c6:	dad6      	bge.n	800a676 <new_stof+0x72>
		// str1[pos++] = *curr; // add digit to result string and increment pointer
		// str1[pos++] = *(curr+1); // add digit to result string and increment pointer
		// str1[pos++] = *(curr+2); // add digit to result string and increment pointer
	}

}
 800a6c8:	bf00      	nop
 800a6ca:	bf00      	nop
 800a6cc:	3720      	adds	r7, #32
 800a6ce:	46bd      	mov	sp, r7
 800a6d0:	bd80      	pop	{r7, pc}
 800a6d2:	bf00      	nop
 800a6d4:	080010ad 	.word	0x080010ad
 800a6d8:	0800e895 	.word	0x0800e895
 800a6dc:	0800105d 	.word	0x0800105d
 800a6e0:	08014731 	.word	0x08014731
 800a6e4:	08000f19 	.word	0x08000f19
 800a6e8:	08000dad 	.word	0x08000dad
 800a6ec:	080002b1 	.word	0x080002b1
 800a6f0:	41200000 	.word	0x41200000

0800a6f4 <TimeString>:
		predvYear++;
	//predvYear = predvYear+12;//2012
	return predvYear;
}

void TimeString(char *aBuf, DATATIME dtl) {
 800a6f4:	b084      	sub	sp, #16
 800a6f6:	b580      	push	{r7, lr}
 800a6f8:	b084      	sub	sp, #16
 800a6fa:	af00      	add	r7, sp, #0
 800a6fc:	6078      	str	r0, [r7, #4]
 800a6fe:	f107 001c 	add.w	r0, r7, #28
 800a702:	e880 000e 	stmia.w	r0, {r1, r2, r3}
	//DATATIME dtl;

	//rtcGetDataTime(&dtl);
	char conv_buf[8];
	if ((dtl.Hour < 24) && (dtl.Min < 60) && (dtl.Sec < 60)) {
 800a706:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800a708:	2b17      	cmp	r3, #23
 800a70a:	d847      	bhi.n	800a79c <TimeString+0xa8>
 800a70c:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 800a70e:	2b3b      	cmp	r3, #59	; 0x3b
 800a710:	d844      	bhi.n	800a79c <TimeString+0xa8>
 800a712:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 800a714:	2b3b      	cmp	r3, #59	; 0x3b
 800a716:	d841      	bhi.n	800a79c <TimeString+0xa8>
		itoa_n(dtl.Hour, conv_buf, 2);
 800a718:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800a71a:	4618      	mov	r0, r3
 800a71c:	f107 0308 	add.w	r3, r7, #8
 800a720:	2202      	movs	r2, #2
 800a722:	4619      	mov	r1, r3
 800a724:	4b21      	ldr	r3, [pc, #132]	; (800a7ac <TimeString+0xb8>)
 800a726:	4798      	blx	r3
		strcpy(aBuf, conv_buf);
 800a728:	f107 0308 	add.w	r3, r7, #8
 800a72c:	4619      	mov	r1, r3
 800a72e:	6878      	ldr	r0, [r7, #4]
 800a730:	4b1f      	ldr	r3, [pc, #124]	; (800a7b0 <TimeString+0xbc>)
 800a732:	4798      	blx	r3
		strcat(aBuf, ":");
 800a734:	6878      	ldr	r0, [r7, #4]
 800a736:	4b1f      	ldr	r3, [pc, #124]	; (800a7b4 <TimeString+0xc0>)
 800a738:	4798      	blx	r3
 800a73a:	4603      	mov	r3, r0
 800a73c:	461a      	mov	r2, r3
 800a73e:	687b      	ldr	r3, [r7, #4]
 800a740:	4413      	add	r3, r2
 800a742:	491d      	ldr	r1, [pc, #116]	; (800a7b8 <TimeString+0xc4>)
 800a744:	461a      	mov	r2, r3
 800a746:	460b      	mov	r3, r1
 800a748:	881b      	ldrh	r3, [r3, #0]
 800a74a:	8013      	strh	r3, [r2, #0]
		itoa_n(dtl.Min, conv_buf, 2);
 800a74c:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 800a74e:	4618      	mov	r0, r3
 800a750:	f107 0308 	add.w	r3, r7, #8
 800a754:	2202      	movs	r2, #2
 800a756:	4619      	mov	r1, r3
 800a758:	4b14      	ldr	r3, [pc, #80]	; (800a7ac <TimeString+0xb8>)
 800a75a:	4798      	blx	r3
		strcat(aBuf, conv_buf);
 800a75c:	f107 0308 	add.w	r3, r7, #8
 800a760:	4619      	mov	r1, r3
 800a762:	6878      	ldr	r0, [r7, #4]
 800a764:	4b15      	ldr	r3, [pc, #84]	; (800a7bc <TimeString+0xc8>)
 800a766:	4798      	blx	r3
		strcat(aBuf, ":");
 800a768:	6878      	ldr	r0, [r7, #4]
 800a76a:	4b12      	ldr	r3, [pc, #72]	; (800a7b4 <TimeString+0xc0>)
 800a76c:	4798      	blx	r3
 800a76e:	4603      	mov	r3, r0
 800a770:	461a      	mov	r2, r3
 800a772:	687b      	ldr	r3, [r7, #4]
 800a774:	4413      	add	r3, r2
 800a776:	4910      	ldr	r1, [pc, #64]	; (800a7b8 <TimeString+0xc4>)
 800a778:	461a      	mov	r2, r3
 800a77a:	460b      	mov	r3, r1
 800a77c:	881b      	ldrh	r3, [r3, #0]
 800a77e:	8013      	strh	r3, [r2, #0]
		itoa_n(dtl.Sec, conv_buf, 2);
 800a780:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 800a782:	4618      	mov	r0, r3
 800a784:	f107 0308 	add.w	r3, r7, #8
 800a788:	2202      	movs	r2, #2
 800a78a:	4619      	mov	r1, r3
 800a78c:	4b07      	ldr	r3, [pc, #28]	; (800a7ac <TimeString+0xb8>)
 800a78e:	4798      	blx	r3
		strcat(aBuf, conv_buf);
 800a790:	f107 0308 	add.w	r3, r7, #8
 800a794:	4619      	mov	r1, r3
 800a796:	6878      	ldr	r0, [r7, #4]
 800a798:	4b08      	ldr	r3, [pc, #32]	; (800a7bc <TimeString+0xc8>)
 800a79a:	4798      	blx	r3
	}
}
 800a79c:	bf00      	nop
 800a79e:	3710      	adds	r7, #16
 800a7a0:	46bd      	mov	sp, r7
 800a7a2:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 800a7a6:	b004      	add	sp, #16
 800a7a8:	4770      	bx	lr
 800a7aa:	bf00      	nop
 800a7ac:	0800e931 	.word	0x0800e931
 800a7b0:	08014675 	.word	0x08014675
 800a7b4:	08014731 	.word	0x08014731
 800a7b8:	08015044 	.word	0x08015044
 800a7bc:	08014635 	.word	0x08014635

0800a7c0 <DateString>:

void DateString(char *aBuf, DATATIME dtl) {
 800a7c0:	b084      	sub	sp, #16
 800a7c2:	b580      	push	{r7, lr}
 800a7c4:	b086      	sub	sp, #24
 800a7c6:	af00      	add	r7, sp, #0
 800a7c8:	6078      	str	r0, [r7, #4]
 800a7ca:	f107 0024 	add.w	r0, r7, #36	; 0x24
 800a7ce:	e880 000e 	stmia.w	r0, {r1, r2, r3}
	//DATATIME dtl;
	//rtcGetDataTime(&dtl);
	char conv_buf[16];
	if ((dtl.Day < 8) && (dtl.Data < 32) && (dtl.Month < 13)) {
 800a7d2:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 800a7d4:	2b07      	cmp	r3, #7
 800a7d6:	d861      	bhi.n	800a89c <DateString+0xdc>
 800a7d8:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 800a7da:	2b1f      	cmp	r3, #31
 800a7dc:	d85e      	bhi.n	800a89c <DateString+0xdc>
 800a7de:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 800a7e0:	2b0c      	cmp	r3, #12
 800a7e2:	d85b      	bhi.n	800a89c <DateString+0xdc>
		itoa_n(dtl.Day, conv_buf, 2);
 800a7e4:	8d7b      	ldrh	r3, [r7, #42]	; 0x2a
 800a7e6:	4618      	mov	r0, r3
 800a7e8:	f107 0308 	add.w	r3, r7, #8
 800a7ec:	2202      	movs	r2, #2
 800a7ee:	4619      	mov	r1, r3
 800a7f0:	4b2e      	ldr	r3, [pc, #184]	; (800a8ac <DateString+0xec>)
 800a7f2:	4798      	blx	r3
		strcpy(aBuf, conv_buf);
 800a7f4:	f107 0308 	add.w	r3, r7, #8
 800a7f8:	4619      	mov	r1, r3
 800a7fa:	6878      	ldr	r0, [r7, #4]
 800a7fc:	4b2c      	ldr	r3, [pc, #176]	; (800a8b0 <DateString+0xf0>)
 800a7fe:	4798      	blx	r3
		strcat(aBuf, ".");
 800a800:	6878      	ldr	r0, [r7, #4]
 800a802:	4b2c      	ldr	r3, [pc, #176]	; (800a8b4 <DateString+0xf4>)
 800a804:	4798      	blx	r3
 800a806:	4603      	mov	r3, r0
 800a808:	461a      	mov	r2, r3
 800a80a:	687b      	ldr	r3, [r7, #4]
 800a80c:	4413      	add	r3, r2
 800a80e:	492a      	ldr	r1, [pc, #168]	; (800a8b8 <DateString+0xf8>)
 800a810:	461a      	mov	r2, r3
 800a812:	460b      	mov	r3, r1
 800a814:	881b      	ldrh	r3, [r3, #0]
 800a816:	8013      	strh	r3, [r2, #0]
		itoa_n(dtl.Data, conv_buf, 2);
 800a818:	8d3b      	ldrh	r3, [r7, #40]	; 0x28
 800a81a:	4618      	mov	r0, r3
 800a81c:	f107 0308 	add.w	r3, r7, #8
 800a820:	2202      	movs	r2, #2
 800a822:	4619      	mov	r1, r3
 800a824:	4b21      	ldr	r3, [pc, #132]	; (800a8ac <DateString+0xec>)
 800a826:	4798      	blx	r3
		strcat(aBuf, conv_buf);
 800a828:	f107 0308 	add.w	r3, r7, #8
 800a82c:	4619      	mov	r1, r3
 800a82e:	6878      	ldr	r0, [r7, #4]
 800a830:	4b22      	ldr	r3, [pc, #136]	; (800a8bc <DateString+0xfc>)
 800a832:	4798      	blx	r3
		strcat(aBuf, ".");
 800a834:	6878      	ldr	r0, [r7, #4]
 800a836:	4b1f      	ldr	r3, [pc, #124]	; (800a8b4 <DateString+0xf4>)
 800a838:	4798      	blx	r3
 800a83a:	4603      	mov	r3, r0
 800a83c:	461a      	mov	r2, r3
 800a83e:	687b      	ldr	r3, [r7, #4]
 800a840:	4413      	add	r3, r2
 800a842:	491d      	ldr	r1, [pc, #116]	; (800a8b8 <DateString+0xf8>)
 800a844:	461a      	mov	r2, r3
 800a846:	460b      	mov	r3, r1
 800a848:	881b      	ldrh	r3, [r3, #0]
 800a84a:	8013      	strh	r3, [r2, #0]
		itoa_n(dtl.Month, conv_buf, 2);
 800a84c:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
 800a84e:	4618      	mov	r0, r3
 800a850:	f107 0308 	add.w	r3, r7, #8
 800a854:	2202      	movs	r2, #2
 800a856:	4619      	mov	r1, r3
 800a858:	4b14      	ldr	r3, [pc, #80]	; (800a8ac <DateString+0xec>)
 800a85a:	4798      	blx	r3
		strcat(aBuf, conv_buf);
 800a85c:	f107 0308 	add.w	r3, r7, #8
 800a860:	4619      	mov	r1, r3
 800a862:	6878      	ldr	r0, [r7, #4]
 800a864:	4b15      	ldr	r3, [pc, #84]	; (800a8bc <DateString+0xfc>)
 800a866:	4798      	blx	r3
		strcat(aBuf, ".");
 800a868:	6878      	ldr	r0, [r7, #4]
 800a86a:	4b12      	ldr	r3, [pc, #72]	; (800a8b4 <DateString+0xf4>)
 800a86c:	4798      	blx	r3
 800a86e:	4603      	mov	r3, r0
 800a870:	461a      	mov	r2, r3
 800a872:	687b      	ldr	r3, [r7, #4]
 800a874:	4413      	add	r3, r2
 800a876:	4910      	ldr	r1, [pc, #64]	; (800a8b8 <DateString+0xf8>)
 800a878:	461a      	mov	r2, r3
 800a87a:	460b      	mov	r3, r1
 800a87c:	881b      	ldrh	r3, [r3, #0]
 800a87e:	8013      	strh	r3, [r2, #0]
		itoa1(dtl.Years, conv_buf);
 800a880:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
 800a882:	461a      	mov	r2, r3
 800a884:	f107 0308 	add.w	r3, r7, #8
 800a888:	4619      	mov	r1, r3
 800a88a:	4610      	mov	r0, r2
 800a88c:	4b0c      	ldr	r3, [pc, #48]	; (800a8c0 <DateString+0x100>)
 800a88e:	4798      	blx	r3
		strcat(aBuf, conv_buf);
 800a890:	f107 0308 	add.w	r3, r7, #8
 800a894:	4619      	mov	r1, r3
 800a896:	6878      	ldr	r0, [r7, #4]
 800a898:	4b08      	ldr	r3, [pc, #32]	; (800a8bc <DateString+0xfc>)
 800a89a:	4798      	blx	r3
	}

}
 800a89c:	bf00      	nop
 800a89e:	3718      	adds	r7, #24
 800a8a0:	46bd      	mov	sp, r7
 800a8a2:	e8bd 4080 	ldmia.w	sp!, {r7, lr}
 800a8a6:	b004      	add	sp, #16
 800a8a8:	4770      	bx	lr
 800a8aa:	bf00      	nop
 800a8ac:	0800e931 	.word	0x0800e931
 800a8b0:	08014675 	.word	0x08014675
 800a8b4:	08014731 	.word	0x08014731
 800a8b8:	08015048 	.word	0x08015048
 800a8bc:	08014635 	.word	0x08014635
 800a8c0:	0800e895 	.word	0x0800e895

0800a8c4 <ParseAnswerData>:

bool ParseAnswerData(char *buf, char *dsn1, char *dsn2) {
 800a8c4:	b590      	push	{r4, r7, lr}
 800a8c6:	b095      	sub	sp, #84	; 0x54
 800a8c8:	af02      	add	r7, sp, #8
 800a8ca:	60f8      	str	r0, [r7, #12]
 800a8cc:	60b9      	str	r1, [r7, #8]
 800a8ce:	607a      	str	r2, [r7, #4]
	DATATIME dtsmp;
	uint32 tempNum[1];
	uint32 timeSec;
	int lYear;

	if (*buf == SYM_ST318) {
 800a8d0:	68fb      	ldr	r3, [r7, #12]
 800a8d2:	781b      	ldrb	r3, [r3, #0]
 800a8d4:	2bc0      	cmp	r3, #192	; 0xc0
 800a8d6:	f040 8102 	bne.w	800aade <ParseAnswerData+0x21a>
		buf = buf + 10;
 800a8da:	68fb      	ldr	r3, [r7, #12]
 800a8dc:	330a      	adds	r3, #10
 800a8de:	60fb      	str	r3, [r7, #12]

		if (*buf == GET_TIME) {
 800a8e0:	68fb      	ldr	r3, [r7, #12]
 800a8e2:	781b      	ldrb	r3, [r3, #0]
 800a8e4:	2b01      	cmp	r3, #1
 800a8e6:	f040 80f8 	bne.w	800aada <ParseAnswerData+0x216>
			buf++;
 800a8ea:	68fb      	ldr	r3, [r7, #12]
 800a8ec:	3301      	adds	r3, #1
 800a8ee:	60fb      	str	r3, [r7, #12]
			//	tempNum[0] = *(Decode(buf, 1));
			uint32 result[1];
			int num = 0;
 800a8f0:	2300      	movs	r3, #0
 800a8f2:	647b      	str	r3, [r7, #68]	; 0x44
			uint32 ch;
			for (int i = 0; i < 1; i++) {
 800a8f4:	2300      	movs	r3, #0
 800a8f6:	643b      	str	r3, [r7, #64]	; 0x40
 800a8f8:	e02c      	b.n	800a954 <ParseAnswerData+0x90>
				result[i] = 0;
 800a8fa:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800a8fc:	009b      	lsls	r3, r3, #2
 800a8fe:	3348      	adds	r3, #72	; 0x48
 800a900:	443b      	add	r3, r7
 800a902:	2200      	movs	r2, #0
 800a904:	f843 2c34 	str.w	r2, [r3, #-52]
				do {
					ch = (*buf & 0x7F); //   7 
 800a908:	68fb      	ldr	r3, [r7, #12]
 800a90a:	781b      	ldrb	r3, [r3, #0]
 800a90c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800a910:	62fb      	str	r3, [r7, #44]	; 0x2c
					result[i] += ch << (num * 7); //  
 800a912:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800a914:	009b      	lsls	r3, r3, #2
 800a916:	3348      	adds	r3, #72	; 0x48
 800a918:	443b      	add	r3, r7
 800a91a:	f853 1c34 	ldr.w	r1, [r3, #-52]
 800a91e:	6c7a      	ldr	r2, [r7, #68]	; 0x44
 800a920:	4613      	mov	r3, r2
 800a922:	00db      	lsls	r3, r3, #3
 800a924:	1a9b      	subs	r3, r3, r2
 800a926:	6afa      	ldr	r2, [r7, #44]	; 0x2c
 800a928:	fa02 f303 	lsl.w	r3, r2, r3
 800a92c:	18ca      	adds	r2, r1, r3
 800a92e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800a930:	009b      	lsls	r3, r3, #2
 800a932:	3348      	adds	r3, #72	; 0x48
 800a934:	443b      	add	r3, r7
 800a936:	f843 2c34 	str.w	r2, [r3, #-52]
					num++; //  num+=7;,   (num*7)   num
 800a93a:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 800a93c:	3301      	adds	r3, #1
 800a93e:	647b      	str	r3, [r7, #68]	; 0x44
				} while ((*(buf++) & 0x80)); //    lbf
 800a940:	68fb      	ldr	r3, [r7, #12]
 800a942:	1c5a      	adds	r2, r3, #1
 800a944:	60fa      	str	r2, [r7, #12]
 800a946:	781b      	ldrb	r3, [r3, #0]
 800a948:	b25b      	sxtb	r3, r3
 800a94a:	2b00      	cmp	r3, #0
 800a94c:	dbdc      	blt.n	800a908 <ParseAnswerData+0x44>
			for (int i = 0; i < 1; i++) {
 800a94e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800a950:	3301      	adds	r3, #1
 800a952:	643b      	str	r3, [r7, #64]	; 0x40
 800a954:	6c3b      	ldr	r3, [r7, #64]	; 0x40
 800a956:	2b00      	cmp	r3, #0
 800a958:	ddcf      	ble.n	800a8fa <ParseAnswerData+0x36>
			}
			timeSec = result[0];
 800a95a:	697b      	ldr	r3, [r7, #20]
 800a95c:	637b      	str	r3, [r7, #52]	; 0x34

			dtsmp.Sec = timeSec % 60;
 800a95e:	6b79      	ldr	r1, [r7, #52]	; 0x34
 800a960:	4b62      	ldr	r3, [pc, #392]	; (800aaec <ParseAnswerData+0x228>)
 800a962:	fba3 2301 	umull	r2, r3, r3, r1
 800a966:	095a      	lsrs	r2, r3, #5
 800a968:	4613      	mov	r3, r2
 800a96a:	011b      	lsls	r3, r3, #4
 800a96c:	1a9b      	subs	r3, r3, r2
 800a96e:	009b      	lsls	r3, r3, #2
 800a970:	1aca      	subs	r2, r1, r3
 800a972:	b293      	uxth	r3, r2
 800a974:	853b      	strh	r3, [r7, #40]	; 0x28
			dtsmp.Min = (timeSec / 60) % 60;
 800a976:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a978:	4a5c      	ldr	r2, [pc, #368]	; (800aaec <ParseAnswerData+0x228>)
 800a97a:	fba2 2303 	umull	r2, r3, r2, r3
 800a97e:	0959      	lsrs	r1, r3, #5
 800a980:	4b5a      	ldr	r3, [pc, #360]	; (800aaec <ParseAnswerData+0x228>)
 800a982:	fba3 2301 	umull	r2, r3, r3, r1
 800a986:	095a      	lsrs	r2, r3, #5
 800a988:	4613      	mov	r3, r2
 800a98a:	011b      	lsls	r3, r3, #4
 800a98c:	1a9b      	subs	r3, r3, r2
 800a98e:	009b      	lsls	r3, r3, #2
 800a990:	1aca      	subs	r2, r1, r3
 800a992:	b293      	uxth	r3, r2
 800a994:	84fb      	strh	r3, [r7, #38]	; 0x26
			dtsmp.Hour = (timeSec / (60 * 60)) % 24;
 800a996:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a998:	4a55      	ldr	r2, [pc, #340]	; (800aaf0 <ParseAnswerData+0x22c>)
 800a99a:	fba2 2303 	umull	r2, r3, r2, r3
 800a99e:	0ad9      	lsrs	r1, r3, #11
 800a9a0:	4b54      	ldr	r3, [pc, #336]	; (800aaf4 <ParseAnswerData+0x230>)
 800a9a2:	fba3 2301 	umull	r2, r3, r3, r1
 800a9a6:	091a      	lsrs	r2, r3, #4
 800a9a8:	4613      	mov	r3, r2
 800a9aa:	005b      	lsls	r3, r3, #1
 800a9ac:	4413      	add	r3, r2
 800a9ae:	00db      	lsls	r3, r3, #3
 800a9b0:	1aca      	subs	r2, r1, r3
 800a9b2:	b293      	uxth	r3, r2
 800a9b4:	84bb      	strh	r3, [r7, #36]	; 0x24
			dtsmp.Day = ((timeSec / (60 * 60 * 24))) % 7;	//1- 
 800a9b6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a9b8:	4a4f      	ldr	r2, [pc, #316]	; (800aaf8 <ParseAnswerData+0x234>)
 800a9ba:	fba2 2303 	umull	r2, r3, r2, r3
 800a9be:	0c1a      	lsrs	r2, r3, #16
 800a9c0:	4b4e      	ldr	r3, [pc, #312]	; (800aafc <ParseAnswerData+0x238>)
 800a9c2:	fba3 1302 	umull	r1, r3, r3, r2
 800a9c6:	1ad1      	subs	r1, r2, r3
 800a9c8:	0849      	lsrs	r1, r1, #1
 800a9ca:	440b      	add	r3, r1
 800a9cc:	0899      	lsrs	r1, r3, #2
 800a9ce:	460b      	mov	r3, r1
 800a9d0:	00db      	lsls	r3, r3, #3
 800a9d2:	1a5b      	subs	r3, r3, r1
 800a9d4:	1ad1      	subs	r1, r2, r3
 800a9d6:	b28b      	uxth	r3, r1
 800a9d8:	847b      	strh	r3, [r7, #34]	; 0x22
			//dtsmp.Years = GetYearsFromSecondsFrom2000(timeSec);
			int16 daysCurYear = timeSec / (60 * 60 * 24) + 1;		//01/01/2012
 800a9da:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800a9dc:	4a46      	ldr	r2, [pc, #280]	; (800aaf8 <ParseAnswerData+0x234>)
 800a9de:	fba2 2303 	umull	r2, r3, r2, r3
 800a9e2:	0c1b      	lsrs	r3, r3, #16
 800a9e4:	b29b      	uxth	r3, r3
 800a9e6:	3301      	adds	r3, #1
 800a9e8:	b29b      	uxth	r3, r3
 800a9ea:	87fb      	strh	r3, [r7, #62]	; 0x3e
			dtsmp.Years = 2012;						    //2012   
 800a9ec:	f240 73dc 	movw	r3, #2012	; 0x7dc
 800a9f0:	83bb      	strh	r3, [r7, #28]
			while (true) {
				lYear = leap_year(dtsmp.Years);
 800a9f2:	8bbb      	ldrh	r3, [r7, #28]
 800a9f4:	4618      	mov	r0, r3
 800a9f6:	4b42      	ldr	r3, [pc, #264]	; (800ab00 <ParseAnswerData+0x23c>)
 800a9f8:	4798      	blx	r3
 800a9fa:	6338      	str	r0, [r7, #48]	; 0x30
				if ((dtsmp.Years % 4 == 0) && (lYear == 1)) {
 800a9fc:	8bbb      	ldrh	r3, [r7, #28]
 800a9fe:	f003 0303 	and.w	r3, r3, #3
 800aa02:	b29b      	uxth	r3, r3
 800aa04:	2b00      	cmp	r3, #0
 800aa06:	d111      	bne.n	800aa2c <ParseAnswerData+0x168>
 800aa08:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800aa0a:	2b01      	cmp	r3, #1
 800aa0c:	d10e      	bne.n	800aa2c <ParseAnswerData+0x168>
					if (daysCurYear > 366) {
 800aa0e:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 800aa12:	f5b3 7fb7 	cmp.w	r3, #366	; 0x16e
 800aa16:	dd18      	ble.n	800aa4a <ParseAnswerData+0x186>
						daysCurYear = daysCurYear - 366;
 800aa18:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 800aa1a:	f5a3 73b7 	sub.w	r3, r3, #366	; 0x16e
 800aa1e:	b29b      	uxth	r3, r3
 800aa20:	87fb      	strh	r3, [r7, #62]	; 0x3e
						dtsmp.Years++;
 800aa22:	8bbb      	ldrh	r3, [r7, #28]
 800aa24:	3301      	adds	r3, #1
 800aa26:	b29b      	uxth	r3, r3
 800aa28:	83bb      	strh	r3, [r7, #28]
					if (daysCurYear > 366) {
 800aa2a:	e00d      	b.n	800aa48 <ParseAnswerData+0x184>
					} else {
						break;
					}

				} else if (daysCurYear > 365) {
 800aa2c:	f9b7 303e 	ldrsh.w	r3, [r7, #62]	; 0x3e
 800aa30:	f5b3 7fb7 	cmp.w	r3, #366	; 0x16e
 800aa34:	db0b      	blt.n	800aa4e <ParseAnswerData+0x18a>
					daysCurYear = daysCurYear - 365;
 800aa36:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 800aa38:	f2a3 136d 	subw	r3, r3, #365	; 0x16d
 800aa3c:	b29b      	uxth	r3, r3
 800aa3e:	87fb      	strh	r3, [r7, #62]	; 0x3e
					dtsmp.Years++;
 800aa40:	8bbb      	ldrh	r3, [r7, #28]
 800aa42:	3301      	adds	r3, #1
 800aa44:	b29b      	uxth	r3, r3
 800aa46:	83bb      	strh	r3, [r7, #28]
			while (true) {
 800aa48:	e7d3      	b.n	800a9f2 <ParseAnswerData+0x12e>
						break;
 800aa4a:	bf00      	nop
 800aa4c:	e000      	b.n	800aa50 <ParseAnswerData+0x18c>
				} else {
					break;
 800aa4e:	bf00      	nop
				}
			}

			for (int i = 0; i < 12; i++) {
 800aa50:	2300      	movs	r3, #0
 800aa52:	63bb      	str	r3, [r7, #56]	; 0x38
 800aa54:	e02d      	b.n	800aab2 <ParseAnswerData+0x1ee>
				if (daysCurYear
						> (month_day_table2[i] + ((i == 1) ? lYear : 0))) {
 800aa56:	f9b7 203e 	ldrsh.w	r2, [r7, #62]	; 0x3e
 800aa5a:	492a      	ldr	r1, [pc, #168]	; (800ab04 <ParseAnswerData+0x240>)
 800aa5c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800aa5e:	440b      	add	r3, r1
 800aa60:	781b      	ldrb	r3, [r3, #0]
 800aa62:	4619      	mov	r1, r3
 800aa64:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800aa66:	2b01      	cmp	r3, #1
 800aa68:	d101      	bne.n	800aa6e <ParseAnswerData+0x1aa>
 800aa6a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800aa6c:	e000      	b.n	800aa70 <ParseAnswerData+0x1ac>
 800aa6e:	2300      	movs	r3, #0
 800aa70:	440b      	add	r3, r1
				if (daysCurYear
 800aa72:	429a      	cmp	r2, r3
 800aa74:	dd12      	ble.n	800aa9c <ParseAnswerData+0x1d8>
					daysCurYear -= month_day_table2[i] + ((i == 1) ? lYear : 0);
 800aa76:	8ffa      	ldrh	r2, [r7, #62]	; 0x3e
 800aa78:	4922      	ldr	r1, [pc, #136]	; (800ab04 <ParseAnswerData+0x240>)
 800aa7a:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800aa7c:	440b      	add	r3, r1
 800aa7e:	781b      	ldrb	r3, [r3, #0]
 800aa80:	b299      	uxth	r1, r3
 800aa82:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800aa84:	2b01      	cmp	r3, #1
 800aa86:	d102      	bne.n	800aa8e <ParseAnswerData+0x1ca>
 800aa88:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800aa8a:	b29b      	uxth	r3, r3
 800aa8c:	e000      	b.n	800aa90 <ParseAnswerData+0x1cc>
 800aa8e:	2300      	movs	r3, #0
 800aa90:	440b      	add	r3, r1
 800aa92:	b29b      	uxth	r3, r3
 800aa94:	1ad3      	subs	r3, r2, r3
 800aa96:	b29b      	uxth	r3, r3
 800aa98:	87fb      	strh	r3, [r7, #62]	; 0x3e
 800aa9a:	e007      	b.n	800aaac <ParseAnswerData+0x1e8>
				} else {
					dtsmp.Month = i + 1;
 800aa9c:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800aa9e:	b29b      	uxth	r3, r3
 800aaa0:	3301      	adds	r3, #1
 800aaa2:	b29b      	uxth	r3, r3
 800aaa4:	83fb      	strh	r3, [r7, #30]
					dtsmp.Data = daysCurYear;
 800aaa6:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
 800aaa8:	843b      	strh	r3, [r7, #32]
					break;
 800aaaa:	e005      	b.n	800aab8 <ParseAnswerData+0x1f4>
			for (int i = 0; i < 12; i++) {
 800aaac:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800aaae:	3301      	adds	r3, #1
 800aab0:	63bb      	str	r3, [r7, #56]	; 0x38
 800aab2:	6bbb      	ldr	r3, [r7, #56]	; 0x38
 800aab4:	2b0b      	cmp	r3, #11
 800aab6:	ddce      	ble.n	800aa56 <ParseAnswerData+0x192>
				}
			}

			DateString(dsn1, dtsmp);
 800aab8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800aaba:	9300      	str	r3, [sp, #0]
 800aabc:	f107 031c 	add.w	r3, r7, #28
 800aac0:	cb0e      	ldmia	r3, {r1, r2, r3}
 800aac2:	68b8      	ldr	r0, [r7, #8]
 800aac4:	4c10      	ldr	r4, [pc, #64]	; (800ab08 <ParseAnswerData+0x244>)
 800aac6:	47a0      	blx	r4
			TimeString(dsn2, dtsmp);
 800aac8:	6abb      	ldr	r3, [r7, #40]	; 0x28
 800aaca:	9300      	str	r3, [sp, #0]
 800aacc:	f107 031c 	add.w	r3, r7, #28
 800aad0:	cb0e      	ldmia	r3, {r1, r2, r3}
 800aad2:	6878      	ldr	r0, [r7, #4]
 800aad4:	4c0d      	ldr	r4, [pc, #52]	; (800ab0c <ParseAnswerData+0x248>)
 800aad6:	47a0      	blx	r4
 800aad8:	e001      	b.n	800aade <ParseAnswerData+0x21a>

			//itoa(temp, dsn);
		} else
			return false;
 800aada:	2300      	movs	r3, #0
 800aadc:	e001      	b.n	800aae2 <ParseAnswerData+0x21e>
	}

	return true;
 800aade:	f04f 33ff 	mov.w	r3, #4294967295
}
 800aae2:	4618      	mov	r0, r3
 800aae4:	374c      	adds	r7, #76	; 0x4c
 800aae6:	46bd      	mov	sp, r7
 800aae8:	bd90      	pop	{r4, r7, pc}
 800aaea:	bf00      	nop
 800aaec:	88888889 	.word	0x88888889
 800aaf0:	91a2b3c5 	.word	0x91a2b3c5
 800aaf4:	aaaaaaab 	.word	0xaaaaaaab
 800aaf8:	c22e4507 	.word	0xc22e4507
 800aafc:	24924925 	.word	0x24924925
 800ab00:	08004eb9 	.word	0x08004eb9
 800ab04:	2000015c 	.word	0x2000015c
 800ab08:	0800a7c1 	.word	0x0800a7c1
 800ab0c:	0800a6f5 	.word	0x0800a6f5

0800ab10 <ParseAnswerVolt>:

bool ParseAnswerVolt(char *buf, char *dsn1/*,char *dsn2,char *dsn3*/) {
 800ab10:	b590      	push	{r4, r7, lr}
 800ab12:	b089      	sub	sp, #36	; 0x24
 800ab14:	af00      	add	r7, sp, #0
 800ab16:	6078      	str	r0, [r7, #4]
 800ab18:	6039      	str	r1, [r7, #0]
	uint32 *tempNum;
	float temp = 0.0;
 800ab1a:	f04f 0300 	mov.w	r3, #0
 800ab1e:	617b      	str	r3, [r7, #20]
	//uint8 *tmpbuff;

	if (*buf == SYM_ST318) {
 800ab20:	687b      	ldr	r3, [r7, #4]
 800ab22:	781b      	ldrb	r3, [r3, #0]
 800ab24:	2bc0      	cmp	r3, #192	; 0xc0
 800ab26:	d166      	bne.n	800abf6 <ParseAnswerVolt+0xe6>
		buf = buf + 10;
 800ab28:	687b      	ldr	r3, [r7, #4]
 800ab2a:	330a      	adds	r3, #10
 800ab2c:	607b      	str	r3, [r7, #4]

		if (*buf == GET_VOLT) {
 800ab2e:	687b      	ldr	r3, [r7, #4]
 800ab30:	781b      	ldrb	r3, [r3, #0]
 800ab32:	2b18      	cmp	r3, #24
 800ab34:	d15d      	bne.n	800abf2 <ParseAnswerVolt+0xe2>
			buf++;
 800ab36:	687b      	ldr	r3, [r7, #4]
 800ab38:	3301      	adds	r3, #1
 800ab3a:	607b      	str	r3, [r7, #4]
			//tempNum = Decode(buf, 1);
			uint32 result[1];
			int num = 0;
 800ab3c:	2300      	movs	r3, #0
 800ab3e:	61fb      	str	r3, [r7, #28]
			uint32 ch;
			for (int i = 0; i < 1; i++) {
 800ab40:	2300      	movs	r3, #0
 800ab42:	61bb      	str	r3, [r7, #24]
 800ab44:	e02c      	b.n	800aba0 <ParseAnswerVolt+0x90>
				result[i] = 0;
 800ab46:	69bb      	ldr	r3, [r7, #24]
 800ab48:	009b      	lsls	r3, r3, #2
 800ab4a:	3320      	adds	r3, #32
 800ab4c:	443b      	add	r3, r7
 800ab4e:	2200      	movs	r2, #0
 800ab50:	f843 2c14 	str.w	r2, [r3, #-20]
				do {
					ch = (*buf & 0x7F); //   7 
 800ab54:	687b      	ldr	r3, [r7, #4]
 800ab56:	781b      	ldrb	r3, [r3, #0]
 800ab58:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800ab5c:	613b      	str	r3, [r7, #16]
					result[i] += ch << (num * 7); //  
 800ab5e:	69bb      	ldr	r3, [r7, #24]
 800ab60:	009b      	lsls	r3, r3, #2
 800ab62:	3320      	adds	r3, #32
 800ab64:	443b      	add	r3, r7
 800ab66:	f853 1c14 	ldr.w	r1, [r3, #-20]
 800ab6a:	69fa      	ldr	r2, [r7, #28]
 800ab6c:	4613      	mov	r3, r2
 800ab6e:	00db      	lsls	r3, r3, #3
 800ab70:	1a9b      	subs	r3, r3, r2
 800ab72:	693a      	ldr	r2, [r7, #16]
 800ab74:	fa02 f303 	lsl.w	r3, r2, r3
 800ab78:	18ca      	adds	r2, r1, r3
 800ab7a:	69bb      	ldr	r3, [r7, #24]
 800ab7c:	009b      	lsls	r3, r3, #2
 800ab7e:	3320      	adds	r3, #32
 800ab80:	443b      	add	r3, r7
 800ab82:	f843 2c14 	str.w	r2, [r3, #-20]
					num++; //  num+=7;,   (num*7)   num
 800ab86:	69fb      	ldr	r3, [r7, #28]
 800ab88:	3301      	adds	r3, #1
 800ab8a:	61fb      	str	r3, [r7, #28]
				} while ((*(buf++) & 0x80)); //    lbf
 800ab8c:	687b      	ldr	r3, [r7, #4]
 800ab8e:	1c5a      	adds	r2, r3, #1
 800ab90:	607a      	str	r2, [r7, #4]
 800ab92:	781b      	ldrb	r3, [r3, #0]
 800ab94:	b25b      	sxtb	r3, r3
 800ab96:	2b00      	cmp	r3, #0
 800ab98:	dbdc      	blt.n	800ab54 <ParseAnswerVolt+0x44>
			for (int i = 0; i < 1; i++) {
 800ab9a:	69bb      	ldr	r3, [r7, #24]
 800ab9c:	3301      	adds	r3, #1
 800ab9e:	61bb      	str	r3, [r7, #24]
 800aba0:	69bb      	ldr	r3, [r7, #24]
 800aba2:	2b00      	cmp	r3, #0
 800aba4:	ddcf      	ble.n	800ab46 <ParseAnswerVolt+0x36>
			}
			temp = (result[0]) / 100.0;
 800aba6:	68fb      	ldr	r3, [r7, #12]
 800aba8:	4a17      	ldr	r2, [pc, #92]	; (800ac08 <ParseAnswerVolt+0xf8>)
 800abaa:	4618      	mov	r0, r3
 800abac:	4790      	blx	r2
 800abae:	4c17      	ldr	r4, [pc, #92]	; (800ac0c <ParseAnswerVolt+0xfc>)
 800abb0:	f04f 0200 	mov.w	r2, #0
 800abb4:	4b16      	ldr	r3, [pc, #88]	; (800ac10 <ParseAnswerVolt+0x100>)
 800abb6:	47a0      	blx	r4
 800abb8:	4602      	mov	r2, r0
 800abba:	460b      	mov	r3, r1
 800abbc:	4c15      	ldr	r4, [pc, #84]	; (800ac14 <ParseAnswerVolt+0x104>)
 800abbe:	4610      	mov	r0, r2
 800abc0:	4619      	mov	r1, r3
 800abc2:	47a0      	blx	r4
 800abc4:	4603      	mov	r3, r0
 800abc6:	617b      	str	r3, [r7, #20]

			if (temp > MAX_VOLT) {
 800abc8:	4b13      	ldr	r3, [pc, #76]	; (800ac18 <ParseAnswerVolt+0x108>)
 800abca:	6978      	ldr	r0, [r7, #20]
 800abcc:	4798      	blx	r3
 800abce:	4c13      	ldr	r4, [pc, #76]	; (800ac1c <ParseAnswerVolt+0x10c>)
 800abd0:	a30b      	add	r3, pc, #44	; (adr r3, 800ac00 <ParseAnswerVolt+0xf0>)
 800abd2:	e9d3 2300 	ldrd	r2, r3, [r3]
 800abd6:	47a0      	blx	r4
 800abd8:	4603      	mov	r3, r0
 800abda:	2b00      	cmp	r3, #0
 800abdc:	d001      	beq.n	800abe2 <ParseAnswerVolt+0xd2>
				return false;
 800abde:	2300      	movs	r3, #0
 800abe0:	e00a      	b.n	800abf8 <ParseAnswerVolt+0xe8>
			}
			/*temp[1] = *(tempNum+1)/100.0;
			 temp[2] = *(tempNum+2)/100.0;*/
			new_stof(dsn1, temp, 3);
 800abe2:	2203      	movs	r2, #3
 800abe4:	6979      	ldr	r1, [r7, #20]
 800abe6:	6838      	ldr	r0, [r7, #0]
 800abe8:	4b0d      	ldr	r3, [pc, #52]	; (800ac20 <ParseAnswerVolt+0x110>)
 800abea:	4798      	blx	r3
		} else
			return false;
	} else
		return false;

	return true;
 800abec:	f04f 33ff 	mov.w	r3, #4294967295
 800abf0:	e002      	b.n	800abf8 <ParseAnswerVolt+0xe8>
			return false;
 800abf2:	2300      	movs	r3, #0
 800abf4:	e000      	b.n	800abf8 <ParseAnswerVolt+0xe8>
		return false;
 800abf6:	2300      	movs	r3, #0
}
 800abf8:	4618      	mov	r0, r3
 800abfa:	3724      	adds	r7, #36	; 0x24
 800abfc:	46bd      	mov	sp, r7
 800abfe:	bd90      	pop	{r4, r7, pc}
 800ac00:	cccccccd 	.word	0xcccccccd
 800ac04:	40847acc 	.word	0x40847acc
 800ac08:	0800069d 	.word	0x0800069d
 800ac0c:	080009e5 	.word	0x080009e5
 800ac10:	40590000 	.word	0x40590000
 800ac14:	08000d05 	.word	0x08000d05
 800ac18:	080006e1 	.word	0x080006e1
 800ac1c:	08000cb1 	.word	0x08000cb1
 800ac20:	0800a605 	.word	0x0800a605
 800ac24:	00000000 	.word	0x00000000

0800ac28 <ParseAnswerCur>:

bool ParseAnswerCur(char *buf, char *dsn1/*,char *dsn2,char *dsn3*/) {
 800ac28:	b590      	push	{r4, r7, lr}
 800ac2a:	b089      	sub	sp, #36	; 0x24
 800ac2c:	af00      	add	r7, sp, #0
 800ac2e:	6078      	str	r0, [r7, #4]
 800ac30:	6039      	str	r1, [r7, #0]
	uint32 *tempNum;
	float temp = 0.0;
 800ac32:	f04f 0300 	mov.w	r3, #0
 800ac36:	617b      	str	r3, [r7, #20]

	if (*buf == SYM_ST318) {
 800ac38:	687b      	ldr	r3, [r7, #4]
 800ac3a:	781b      	ldrb	r3, [r3, #0]
 800ac3c:	2bc0      	cmp	r3, #192	; 0xc0
 800ac3e:	d166      	bne.n	800ad0e <ParseAnswerCur+0xe6>
		buf = buf + 10;
 800ac40:	687b      	ldr	r3, [r7, #4]
 800ac42:	330a      	adds	r3, #10
 800ac44:	607b      	str	r3, [r7, #4]

		if (*buf == GET_CUR) {
 800ac46:	687b      	ldr	r3, [r7, #4]
 800ac48:	781b      	ldrb	r3, [r3, #0]
 800ac4a:	2b16      	cmp	r3, #22
 800ac4c:	d15d      	bne.n	800ad0a <ParseAnswerCur+0xe2>
			buf++;
 800ac4e:	687b      	ldr	r3, [r7, #4]
 800ac50:	3301      	adds	r3, #1
 800ac52:	607b      	str	r3, [r7, #4]
			uint32 result[1];
			int num = 0;
 800ac54:	2300      	movs	r3, #0
 800ac56:	61fb      	str	r3, [r7, #28]
			uint32 ch;
			for (int i = 0; i < 1; i++) {
 800ac58:	2300      	movs	r3, #0
 800ac5a:	61bb      	str	r3, [r7, #24]
 800ac5c:	e02c      	b.n	800acb8 <ParseAnswerCur+0x90>
				result[i] = 0;
 800ac5e:	69bb      	ldr	r3, [r7, #24]
 800ac60:	009b      	lsls	r3, r3, #2
 800ac62:	3320      	adds	r3, #32
 800ac64:	443b      	add	r3, r7
 800ac66:	2200      	movs	r2, #0
 800ac68:	f843 2c14 	str.w	r2, [r3, #-20]
				do {
					ch = (*buf & 0x7F); //   7 
 800ac6c:	687b      	ldr	r3, [r7, #4]
 800ac6e:	781b      	ldrb	r3, [r3, #0]
 800ac70:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800ac74:	613b      	str	r3, [r7, #16]
					result[i] += ch << (num * 7); //  
 800ac76:	69bb      	ldr	r3, [r7, #24]
 800ac78:	009b      	lsls	r3, r3, #2
 800ac7a:	3320      	adds	r3, #32
 800ac7c:	443b      	add	r3, r7
 800ac7e:	f853 1c14 	ldr.w	r1, [r3, #-20]
 800ac82:	69fa      	ldr	r2, [r7, #28]
 800ac84:	4613      	mov	r3, r2
 800ac86:	00db      	lsls	r3, r3, #3
 800ac88:	1a9b      	subs	r3, r3, r2
 800ac8a:	693a      	ldr	r2, [r7, #16]
 800ac8c:	fa02 f303 	lsl.w	r3, r2, r3
 800ac90:	18ca      	adds	r2, r1, r3
 800ac92:	69bb      	ldr	r3, [r7, #24]
 800ac94:	009b      	lsls	r3, r3, #2
 800ac96:	3320      	adds	r3, #32
 800ac98:	443b      	add	r3, r7
 800ac9a:	f843 2c14 	str.w	r2, [r3, #-20]
					num++; //  num+=7;,   (num*7)   num
 800ac9e:	69fb      	ldr	r3, [r7, #28]
 800aca0:	3301      	adds	r3, #1
 800aca2:	61fb      	str	r3, [r7, #28]
				} while ((*(buf++) & 0x80)); //    lbf
 800aca4:	687b      	ldr	r3, [r7, #4]
 800aca6:	1c5a      	adds	r2, r3, #1
 800aca8:	607a      	str	r2, [r7, #4]
 800acaa:	781b      	ldrb	r3, [r3, #0]
 800acac:	b25b      	sxtb	r3, r3
 800acae:	2b00      	cmp	r3, #0
 800acb0:	dbdc      	blt.n	800ac6c <ParseAnswerCur+0x44>
			for (int i = 0; i < 1; i++) {
 800acb2:	69bb      	ldr	r3, [r7, #24]
 800acb4:	3301      	adds	r3, #1
 800acb6:	61bb      	str	r3, [r7, #24]
 800acb8:	69bb      	ldr	r3, [r7, #24]
 800acba:	2b00      	cmp	r3, #0
 800acbc:	ddcf      	ble.n	800ac5e <ParseAnswerCur+0x36>
			}

			temp = result[0] / 1000.0;
 800acbe:	68fb      	ldr	r3, [r7, #12]
 800acc0:	4a17      	ldr	r2, [pc, #92]	; (800ad20 <ParseAnswerCur+0xf8>)
 800acc2:	4618      	mov	r0, r3
 800acc4:	4790      	blx	r2
 800acc6:	4c17      	ldr	r4, [pc, #92]	; (800ad24 <ParseAnswerCur+0xfc>)
 800acc8:	f04f 0200 	mov.w	r2, #0
 800accc:	4b16      	ldr	r3, [pc, #88]	; (800ad28 <ParseAnswerCur+0x100>)
 800acce:	47a0      	blx	r4
 800acd0:	4602      	mov	r2, r0
 800acd2:	460b      	mov	r3, r1
 800acd4:	4c15      	ldr	r4, [pc, #84]	; (800ad2c <ParseAnswerCur+0x104>)
 800acd6:	4610      	mov	r0, r2
 800acd8:	4619      	mov	r1, r3
 800acda:	47a0      	blx	r4
 800acdc:	4603      	mov	r3, r0
 800acde:	617b      	str	r3, [r7, #20]

			if (temp > MAX_CUR) {
 800ace0:	4b13      	ldr	r3, [pc, #76]	; (800ad30 <ParseAnswerCur+0x108>)
 800ace2:	6978      	ldr	r0, [r7, #20]
 800ace4:	4798      	blx	r3
 800ace6:	4c13      	ldr	r4, [pc, #76]	; (800ad34 <ParseAnswerCur+0x10c>)
 800ace8:	a30b      	add	r3, pc, #44	; (adr r3, 800ad18 <ParseAnswerCur+0xf0>)
 800acea:	e9d3 2300 	ldrd	r2, r3, [r3]
 800acee:	47a0      	blx	r4
 800acf0:	4603      	mov	r3, r0
 800acf2:	2b00      	cmp	r3, #0
 800acf4:	d001      	beq.n	800acfa <ParseAnswerCur+0xd2>
				return false;
 800acf6:	2300      	movs	r3, #0
 800acf8:	e00a      	b.n	800ad10 <ParseAnswerCur+0xe8>
			}
			/*temp[1] = *(tempNum+1)/100.0;
			 temp[2] = *(tempNum+2)/100.0;*/
			new_stof(dsn1, temp, 3);
 800acfa:	2203      	movs	r2, #3
 800acfc:	6979      	ldr	r1, [r7, #20]
 800acfe:	6838      	ldr	r0, [r7, #0]
 800ad00:	4b0d      	ldr	r3, [pc, #52]	; (800ad38 <ParseAnswerCur+0x110>)
 800ad02:	4798      	blx	r3
		} else
			return false;
	} else
		return false;

	return true;
 800ad04:	f04f 33ff 	mov.w	r3, #4294967295
 800ad08:	e002      	b.n	800ad10 <ParseAnswerCur+0xe8>
			return false;
 800ad0a:	2300      	movs	r3, #0
 800ad0c:	e000      	b.n	800ad10 <ParseAnswerCur+0xe8>
		return false;
 800ad0e:	2300      	movs	r3, #0
}
 800ad10:	4618      	mov	r0, r3
 800ad12:	3724      	adds	r7, #36	; 0x24
 800ad14:	46bd      	mov	sp, r7
 800ad16:	bd90      	pop	{r4, r7, pc}
 800ad18:	d2f1a9fc 	.word	0xd2f1a9fc
 800ad1c:	4060624d 	.word	0x4060624d
 800ad20:	0800069d 	.word	0x0800069d
 800ad24:	080009e5 	.word	0x080009e5
 800ad28:	408f4000 	.word	0x408f4000
 800ad2c:	08000d05 	.word	0x08000d05
 800ad30:	080006e1 	.word	0x080006e1
 800ad34:	08000cb1 	.word	0x08000cb1
 800ad38:	0800a605 	.word	0x0800a605
 800ad3c:	00000000 	.word	0x00000000

0800ad40 <ParseAnswerPow>:

bool ParseAnswerPow(char *buf, char *dsn1/*,char *dsn2,char *dsn3*/) {
 800ad40:	b590      	push	{r4, r7, lr}
 800ad42:	b089      	sub	sp, #36	; 0x24
 800ad44:	af00      	add	r7, sp, #0
 800ad46:	6078      	str	r0, [r7, #4]
 800ad48:	6039      	str	r1, [r7, #0]
	uint32 *tempNum;
	float temp = 0.0;
 800ad4a:	f04f 0300 	mov.w	r3, #0
 800ad4e:	617b      	str	r3, [r7, #20]

	if (*buf == SYM_ST318) {
 800ad50:	687b      	ldr	r3, [r7, #4]
 800ad52:	781b      	ldrb	r3, [r3, #0]
 800ad54:	2bc0      	cmp	r3, #192	; 0xc0
 800ad56:	d166      	bne.n	800ae26 <ParseAnswerPow+0xe6>
		buf = buf + 10;
 800ad58:	687b      	ldr	r3, [r7, #4]
 800ad5a:	330a      	adds	r3, #10
 800ad5c:	607b      	str	r3, [r7, #4]

		if (*buf == GET_POW) {
 800ad5e:	687b      	ldr	r3, [r7, #4]
 800ad60:	781b      	ldrb	r3, [r3, #0]
 800ad62:	2b0d      	cmp	r3, #13
 800ad64:	d15d      	bne.n	800ae22 <ParseAnswerPow+0xe2>
			buf++;
 800ad66:	687b      	ldr	r3, [r7, #4]
 800ad68:	3301      	adds	r3, #1
 800ad6a:	607b      	str	r3, [r7, #4]
			uint32 result[1];
			int num = 0;
 800ad6c:	2300      	movs	r3, #0
 800ad6e:	61fb      	str	r3, [r7, #28]
			uint32 ch;
			for (int i = 0; i < 1; i++) {
 800ad70:	2300      	movs	r3, #0
 800ad72:	61bb      	str	r3, [r7, #24]
 800ad74:	e02c      	b.n	800add0 <ParseAnswerPow+0x90>
				result[i] = 0;
 800ad76:	69bb      	ldr	r3, [r7, #24]
 800ad78:	009b      	lsls	r3, r3, #2
 800ad7a:	3320      	adds	r3, #32
 800ad7c:	443b      	add	r3, r7
 800ad7e:	2200      	movs	r2, #0
 800ad80:	f843 2c14 	str.w	r2, [r3, #-20]
				do {
					ch = (*buf & 0x7F); //   7 
 800ad84:	687b      	ldr	r3, [r7, #4]
 800ad86:	781b      	ldrb	r3, [r3, #0]
 800ad88:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800ad8c:	613b      	str	r3, [r7, #16]
					result[i] += ch << (num * 7); //  
 800ad8e:	69bb      	ldr	r3, [r7, #24]
 800ad90:	009b      	lsls	r3, r3, #2
 800ad92:	3320      	adds	r3, #32
 800ad94:	443b      	add	r3, r7
 800ad96:	f853 1c14 	ldr.w	r1, [r3, #-20]
 800ad9a:	69fa      	ldr	r2, [r7, #28]
 800ad9c:	4613      	mov	r3, r2
 800ad9e:	00db      	lsls	r3, r3, #3
 800ada0:	1a9b      	subs	r3, r3, r2
 800ada2:	693a      	ldr	r2, [r7, #16]
 800ada4:	fa02 f303 	lsl.w	r3, r2, r3
 800ada8:	18ca      	adds	r2, r1, r3
 800adaa:	69bb      	ldr	r3, [r7, #24]
 800adac:	009b      	lsls	r3, r3, #2
 800adae:	3320      	adds	r3, #32
 800adb0:	443b      	add	r3, r7
 800adb2:	f843 2c14 	str.w	r2, [r3, #-20]
					num++; //  num+=7;,   (num*7)   num
 800adb6:	69fb      	ldr	r3, [r7, #28]
 800adb8:	3301      	adds	r3, #1
 800adba:	61fb      	str	r3, [r7, #28]
				} while ((*(buf++) & 0x80)); //    lbf
 800adbc:	687b      	ldr	r3, [r7, #4]
 800adbe:	1c5a      	adds	r2, r3, #1
 800adc0:	607a      	str	r2, [r7, #4]
 800adc2:	781b      	ldrb	r3, [r3, #0]
 800adc4:	b25b      	sxtb	r3, r3
 800adc6:	2b00      	cmp	r3, #0
 800adc8:	dbdc      	blt.n	800ad84 <ParseAnswerPow+0x44>
			for (int i = 0; i < 1; i++) {
 800adca:	69bb      	ldr	r3, [r7, #24]
 800adcc:	3301      	adds	r3, #1
 800adce:	61bb      	str	r3, [r7, #24]
 800add0:	69bb      	ldr	r3, [r7, #24]
 800add2:	2b00      	cmp	r3, #0
 800add4:	ddcf      	ble.n	800ad76 <ParseAnswerPow+0x36>
			}

			temp = result[0] / 1000.0;
 800add6:	68fb      	ldr	r3, [r7, #12]
 800add8:	4a17      	ldr	r2, [pc, #92]	; (800ae38 <ParseAnswerPow+0xf8>)
 800adda:	4618      	mov	r0, r3
 800addc:	4790      	blx	r2
 800adde:	4c17      	ldr	r4, [pc, #92]	; (800ae3c <ParseAnswerPow+0xfc>)
 800ade0:	f04f 0200 	mov.w	r2, #0
 800ade4:	4b16      	ldr	r3, [pc, #88]	; (800ae40 <ParseAnswerPow+0x100>)
 800ade6:	47a0      	blx	r4
 800ade8:	4602      	mov	r2, r0
 800adea:	460b      	mov	r3, r1
 800adec:	4c15      	ldr	r4, [pc, #84]	; (800ae44 <ParseAnswerPow+0x104>)
 800adee:	4610      	mov	r0, r2
 800adf0:	4619      	mov	r1, r3
 800adf2:	47a0      	blx	r4
 800adf4:	4603      	mov	r3, r0
 800adf6:	617b      	str	r3, [r7, #20]

			if (temp > MAX_POW) {
 800adf8:	4b13      	ldr	r3, [pc, #76]	; (800ae48 <ParseAnswerPow+0x108>)
 800adfa:	6978      	ldr	r0, [r7, #20]
 800adfc:	4798      	blx	r3
 800adfe:	4c13      	ldr	r4, [pc, #76]	; (800ae4c <ParseAnswerPow+0x10c>)
 800ae00:	a30b      	add	r3, pc, #44	; (adr r3, 800ae30 <ParseAnswerPow+0xf0>)
 800ae02:	e9d3 2300 	ldrd	r2, r3, [r3]
 800ae06:	47a0      	blx	r4
 800ae08:	4603      	mov	r3, r0
 800ae0a:	2b00      	cmp	r3, #0
 800ae0c:	d001      	beq.n	800ae12 <ParseAnswerPow+0xd2>
				return false;
 800ae0e:	2300      	movs	r3, #0
 800ae10:	e00a      	b.n	800ae28 <ParseAnswerPow+0xe8>
			}
			/*temp[1] = *(tempNum+1)/100.0;
			 temp[2] = *(tempNum+2)/100.0;*/
			new_stof(dsn1, temp, 3);
 800ae12:	2203      	movs	r2, #3
 800ae14:	6979      	ldr	r1, [r7, #20]
 800ae16:	6838      	ldr	r0, [r7, #0]
 800ae18:	4b0d      	ldr	r3, [pc, #52]	; (800ae50 <ParseAnswerPow+0x110>)
 800ae1a:	4798      	blx	r3
		} else
			return false;
	} else
		return false;

	return true;
 800ae1c:	f04f 33ff 	mov.w	r3, #4294967295
 800ae20:	e002      	b.n	800ae28 <ParseAnswerPow+0xe8>
			return false;
 800ae22:	2300      	movs	r3, #0
 800ae24:	e000      	b.n	800ae28 <ParseAnswerPow+0xe8>
		return false;
 800ae26:	2300      	movs	r3, #0
}
 800ae28:	4618      	mov	r0, r3
 800ae2a:	3724      	adds	r7, #36	; 0x24
 800ae2c:	46bd      	mov	sp, r7
 800ae2e:	bd90      	pop	{r4, r7, pc}
 800ae30:	70a3d70a 	.word	0x70a3d70a
 800ae34:	4050623d 	.word	0x4050623d
 800ae38:	0800069d 	.word	0x0800069d
 800ae3c:	080009e5 	.word	0x080009e5
 800ae40:	408f4000 	.word	0x408f4000
 800ae44:	08000d05 	.word	0x08000d05
 800ae48:	080006e1 	.word	0x080006e1
 800ae4c:	08000cb1 	.word	0x08000cb1
 800ae50:	0800a605 	.word	0x0800a605
 800ae54:	00000000 	.word	0x00000000

0800ae58 <ParseAnswerEnerge>:

bool ParseAnswerEnerge(char *buf, char *dsn1) {
 800ae58:	b590      	push	{r4, r7, lr}
 800ae5a:	b089      	sub	sp, #36	; 0x24
 800ae5c:	af00      	add	r7, sp, #0
 800ae5e:	6078      	str	r0, [r7, #4]
 800ae60:	6039      	str	r1, [r7, #0]
	uint32 *tempNum;
	float temp;

	if (*buf == SYM_ST318) {
 800ae62:	687b      	ldr	r3, [r7, #4]
 800ae64:	781b      	ldrb	r3, [r3, #0]
 800ae66:	2bc0      	cmp	r3, #192	; 0xc0
 800ae68:	d159      	bne.n	800af1e <ParseAnswerEnerge+0xc6>
		buf = buf + 10;
 800ae6a:	687b      	ldr	r3, [r7, #4]
 800ae6c:	330a      	adds	r3, #10
 800ae6e:	607b      	str	r3, [r7, #4]

		if (*buf == GET_ENERGY) {
 800ae70:	687b      	ldr	r3, [r7, #4]
 800ae72:	781b      	ldrb	r3, [r3, #0]
 800ae74:	2b01      	cmp	r3, #1
 800ae76:	d150      	bne.n	800af1a <ParseAnswerEnerge+0xc2>
			buf++;
 800ae78:	687b      	ldr	r3, [r7, #4]
 800ae7a:	3301      	adds	r3, #1
 800ae7c:	607b      	str	r3, [r7, #4]
			//	tempNum = Decode(buf, 1);
			uint32 result[1];
			int num = 0;
 800ae7e:	2300      	movs	r3, #0
 800ae80:	61fb      	str	r3, [r7, #28]
			uint32 ch;
			for (int i = 0; i < 1; i++) {
 800ae82:	2300      	movs	r3, #0
 800ae84:	61bb      	str	r3, [r7, #24]
 800ae86:	e02c      	b.n	800aee2 <ParseAnswerEnerge+0x8a>
				result[i] = 0;
 800ae88:	69bb      	ldr	r3, [r7, #24]
 800ae8a:	009b      	lsls	r3, r3, #2
 800ae8c:	3320      	adds	r3, #32
 800ae8e:	443b      	add	r3, r7
 800ae90:	2200      	movs	r2, #0
 800ae92:	f843 2c14 	str.w	r2, [r3, #-20]
				do {
					ch = (*buf & 0x7F); //   7 
 800ae96:	687b      	ldr	r3, [r7, #4]
 800ae98:	781b      	ldrb	r3, [r3, #0]
 800ae9a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 800ae9e:	613b      	str	r3, [r7, #16]
					result[i] += ch << (num * 7); //  
 800aea0:	69bb      	ldr	r3, [r7, #24]
 800aea2:	009b      	lsls	r3, r3, #2
 800aea4:	3320      	adds	r3, #32
 800aea6:	443b      	add	r3, r7
 800aea8:	f853 1c14 	ldr.w	r1, [r3, #-20]
 800aeac:	69fa      	ldr	r2, [r7, #28]
 800aeae:	4613      	mov	r3, r2
 800aeb0:	00db      	lsls	r3, r3, #3
 800aeb2:	1a9b      	subs	r3, r3, r2
 800aeb4:	693a      	ldr	r2, [r7, #16]
 800aeb6:	fa02 f303 	lsl.w	r3, r2, r3
 800aeba:	18ca      	adds	r2, r1, r3
 800aebc:	69bb      	ldr	r3, [r7, #24]
 800aebe:	009b      	lsls	r3, r3, #2
 800aec0:	3320      	adds	r3, #32
 800aec2:	443b      	add	r3, r7
 800aec4:	f843 2c14 	str.w	r2, [r3, #-20]
					num++; //  num+=7;,   (num*7)   num
 800aec8:	69fb      	ldr	r3, [r7, #28]
 800aeca:	3301      	adds	r3, #1
 800aecc:	61fb      	str	r3, [r7, #28]
				} while ((*(buf++) & 0x80)); //    lbf
 800aece:	687b      	ldr	r3, [r7, #4]
 800aed0:	1c5a      	adds	r2, r3, #1
 800aed2:	607a      	str	r2, [r7, #4]
 800aed4:	781b      	ldrb	r3, [r3, #0]
 800aed6:	b25b      	sxtb	r3, r3
 800aed8:	2b00      	cmp	r3, #0
 800aeda:	dbdc      	blt.n	800ae96 <ParseAnswerEnerge+0x3e>
			for (int i = 0; i < 1; i++) {
 800aedc:	69bb      	ldr	r3, [r7, #24]
 800aede:	3301      	adds	r3, #1
 800aee0:	61bb      	str	r3, [r7, #24]
 800aee2:	69bb      	ldr	r3, [r7, #24]
 800aee4:	2b00      	cmp	r3, #0
 800aee6:	ddcf      	ble.n	800ae88 <ParseAnswerEnerge+0x30>
			}

			temp = result[0] / 10000.0;
 800aee8:	68fb      	ldr	r3, [r7, #12]
 800aeea:	4a11      	ldr	r2, [pc, #68]	; (800af30 <ParseAnswerEnerge+0xd8>)
 800aeec:	4618      	mov	r0, r3
 800aeee:	4790      	blx	r2
 800aef0:	4c10      	ldr	r4, [pc, #64]	; (800af34 <ParseAnswerEnerge+0xdc>)
 800aef2:	a30d      	add	r3, pc, #52	; (adr r3, 800af28 <ParseAnswerEnerge+0xd0>)
 800aef4:	e9d3 2300 	ldrd	r2, r3, [r3]
 800aef8:	47a0      	blx	r4
 800aefa:	4602      	mov	r2, r0
 800aefc:	460b      	mov	r3, r1
 800aefe:	4c0e      	ldr	r4, [pc, #56]	; (800af38 <ParseAnswerEnerge+0xe0>)
 800af00:	4610      	mov	r0, r2
 800af02:	4619      	mov	r1, r3
 800af04:	47a0      	blx	r4
 800af06:	4603      	mov	r3, r0
 800af08:	617b      	str	r3, [r7, #20]
			new_stof(dsn1, temp, 3);
 800af0a:	2203      	movs	r2, #3
 800af0c:	6979      	ldr	r1, [r7, #20]
 800af0e:	6838      	ldr	r0, [r7, #0]
 800af10:	4b0a      	ldr	r3, [pc, #40]	; (800af3c <ParseAnswerEnerge+0xe4>)
 800af12:	4798      	blx	r3
		} else
			return false;

	} else
		return false;
	return true;
 800af14:	f04f 33ff 	mov.w	r3, #4294967295
 800af18:	e002      	b.n	800af20 <ParseAnswerEnerge+0xc8>
			return false;
 800af1a:	2300      	movs	r3, #0
 800af1c:	e000      	b.n	800af20 <ParseAnswerEnerge+0xc8>
		return false;
 800af1e:	2300      	movs	r3, #0
}
 800af20:	4618      	mov	r0, r3
 800af22:	3724      	adds	r7, #36	; 0x24
 800af24:	46bd      	mov	sp, r7
 800af26:	bd90      	pop	{r4, r7, pc}
 800af28:	00000000 	.word	0x00000000
 800af2c:	40c38800 	.word	0x40c38800
 800af30:	0800069d 	.word	0x0800069d
 800af34:	080009e5 	.word	0x080009e5
 800af38:	08000d05 	.word	0x08000d05
 800af3c:	0800a605 	.word	0x0800a605

0800af40 <MemInit>:
bool SetFlash(uint16, uint16*, uint16);
bool Buffercmp(uint8_t *pBuffer1, uint8_t *pBuffer2, uint16_t BufferLength);
bool GetSignature(uint16, uint16*, uint16);

//==============================================================================
void MemInit() {
 800af40:	b580      	push	{r7, lr}
 800af42:	b082      	sub	sp, #8
 800af44:	af00      	add	r7, sp, #0

	FLASHMEM *pxConfig = (FLASHMEM*) DEVICE_FLASHMEM_LOCATION;
 800af46:	4b30      	ldr	r3, [pc, #192]	; (800b008 <MemInit+0xc8>)
 800af48:	603b      	str	r3, [r7, #0]
	//EEPROM INIT
	//I2C_EE_Init();
	I2C_Configuration();
 800af4a:	4b30      	ldr	r3, [pc, #192]	; (800b00c <MemInit+0xcc>)
 800af4c:	4798      	blx	r3
	//MIOS32_IIC_Init(0);
	//Flash_Init();
	FLASH_Unlock();
 800af4e:	4b30      	ldr	r3, [pc, #192]	; (800b010 <MemInit+0xd0>)
 800af50:	4798      	blx	r3
	FLASH_SetLatency(FLASH_Latency_1);
 800af52:	2001      	movs	r0, #1
 800af54:	4b2f      	ldr	r3, [pc, #188]	; (800b014 <MemInit+0xd4>)
 800af56:	4798      	blx	r3

	int i;
	MemManInit();
 800af58:	4b2f      	ldr	r3, [pc, #188]	; (800b018 <MemInit+0xd8>)
 800af5a:	4798      	blx	r3
	for (i = 0; i < (DEVICE_RAMMEM_WORDS); i++) {
 800af5c:	2300      	movs	r3, #0
 800af5e:	607b      	str	r3, [r7, #4]
 800af60:	e007      	b.n	800af72 <MemInit+0x32>
		RAM.dwords[i] = 0;
 800af62:	4a2e      	ldr	r2, [pc, #184]	; (800b01c <MemInit+0xdc>)
 800af64:	687b      	ldr	r3, [r7, #4]
 800af66:	2100      	movs	r1, #0
 800af68:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
	for (i = 0; i < (DEVICE_RAMMEM_WORDS); i++) {
 800af6c:	687b      	ldr	r3, [r7, #4]
 800af6e:	3301      	adds	r3, #1
 800af70:	607b      	str	r3, [r7, #4]
 800af72:	687b      	ldr	r3, [r7, #4]
 800af74:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800af78:	dbf3      	blt.n	800af62 <MemInit+0x22>
	}

	memunit[0].startaddr = 0x0000;
 800af7a:	4b29      	ldr	r3, [pc, #164]	; (800b020 <MemInit+0xe0>)
 800af7c:	2200      	movs	r2, #0
 800af7e:	601a      	str	r2, [r3, #0]
	memunit[0].endaddr = DEVICE_RAMMEM_WORDS;
 800af80:	4b27      	ldr	r3, [pc, #156]	; (800b020 <MemInit+0xe0>)
 800af82:	f44f 6280 	mov.w	r2, #1024	; 0x400
 800af86:	605a      	str	r2, [r3, #4]
	memunit[0].GetMem = GetRam;
 800af88:	4b25      	ldr	r3, [pc, #148]	; (800b020 <MemInit+0xe0>)
 800af8a:	4a26      	ldr	r2, [pc, #152]	; (800b024 <MemInit+0xe4>)
 800af8c:	60da      	str	r2, [r3, #12]
	memunit[0].SetMem = SetRam;
 800af8e:	4b24      	ldr	r3, [pc, #144]	; (800b020 <MemInit+0xe0>)
 800af90:	4a25      	ldr	r2, [pc, #148]	; (800b028 <MemInit+0xe8>)
 800af92:	611a      	str	r2, [r3, #16]

#if(DEVICE_RAMMEM_WORDS!=0x400)
#error Check useer memory address table !!!
#endif

	memunit[4].startaddr = 0x0400;
 800af94:	4b22      	ldr	r3, [pc, #136]	; (800b020 <MemInit+0xe0>)
 800af96:	f44f 6280 	mov.w	r2, #1024	; 0x400
 800af9a:	651a      	str	r2, [r3, #80]	; 0x50
	memunit[4].endaddr = 0x480;
 800af9c:	4b20      	ldr	r3, [pc, #128]	; (800b020 <MemInit+0xe0>)
 800af9e:	f44f 6290 	mov.w	r2, #1152	; 0x480
 800afa2:	655a      	str	r2, [r3, #84]	; 0x54
	memunit[4].GetMem = GetSignature;
 800afa4:	4b1e      	ldr	r3, [pc, #120]	; (800b020 <MemInit+0xe0>)
 800afa6:	4a21      	ldr	r2, [pc, #132]	; (800b02c <MemInit+0xec>)
 800afa8:	65da      	str	r2, [r3, #92]	; 0x5c
	//	memunit[1].SetMem = SetRam;

	memunit[1].startaddr = 0x1000;
 800afaa:	4b1d      	ldr	r3, [pc, #116]	; (800b020 <MemInit+0xe0>)
 800afac:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 800afb0:	615a      	str	r2, [r3, #20]
	memunit[1].endaddr = 0x1031;
 800afb2:	4b1b      	ldr	r3, [pc, #108]	; (800b020 <MemInit+0xe0>)
 800afb4:	f241 0231 	movw	r2, #4145	; 0x1031
 800afb8:	619a      	str	r2, [r3, #24]
	memunit[1].GetMem = GetRtc;
 800afba:	4b19      	ldr	r3, [pc, #100]	; (800b020 <MemInit+0xe0>)
 800afbc:	4a1c      	ldr	r2, [pc, #112]	; (800b030 <MemInit+0xf0>)
 800afbe:	621a      	str	r2, [r3, #32]
	memunit[1].SetMem = SetRtc;
 800afc0:	4b17      	ldr	r3, [pc, #92]	; (800b020 <MemInit+0xe0>)
 800afc2:	4a1c      	ldr	r2, [pc, #112]	; (800b034 <MemInit+0xf4>)
 800afc4:	625a      	str	r2, [r3, #36]	; 0x24

	memunit[2].startaddr = 0x2000;
 800afc6:	4b16      	ldr	r3, [pc, #88]	; (800b020 <MemInit+0xe0>)
 800afc8:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 800afcc:	629a      	str	r2, [r3, #40]	; 0x28
	memunit[2].endaddr = 0x3677;
 800afce:	4b14      	ldr	r3, [pc, #80]	; (800b020 <MemInit+0xe0>)
 800afd0:	f243 6277 	movw	r2, #13943	; 0x3677
 800afd4:	62da      	str	r2, [r3, #44]	; 0x2c
	memunit[2].GetMem = GetEeprom;
 800afd6:	4b12      	ldr	r3, [pc, #72]	; (800b020 <MemInit+0xe0>)
 800afd8:	4a17      	ldr	r2, [pc, #92]	; (800b038 <MemInit+0xf8>)
 800afda:	635a      	str	r2, [r3, #52]	; 0x34
	memunit[2].SetMem = SetEeprom;
 800afdc:	4b10      	ldr	r3, [pc, #64]	; (800b020 <MemInit+0xe0>)
 800afde:	4a17      	ldr	r2, [pc, #92]	; (800b03c <MemInit+0xfc>)
 800afe0:	639a      	str	r2, [r3, #56]	; 0x38

	memunit[3].startaddr = 0x8000;
 800afe2:	4b0f      	ldr	r3, [pc, #60]	; (800b020 <MemInit+0xe0>)
 800afe4:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 800afe8:	63da      	str	r2, [r3, #60]	; 0x3c
	memunit[3].endaddr = 0x10000;
 800afea:	4b0d      	ldr	r3, [pc, #52]	; (800b020 <MemInit+0xe0>)
 800afec:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 800aff0:	641a      	str	r2, [r3, #64]	; 0x40
	memunit[3].GetMem = GetFlash;
 800aff2:	4b0b      	ldr	r3, [pc, #44]	; (800b020 <MemInit+0xe0>)
 800aff4:	4a12      	ldr	r2, [pc, #72]	; (800b040 <MemInit+0x100>)
 800aff6:	649a      	str	r2, [r3, #72]	; 0x48
	memunit[3].SetMem = SetFlash;
 800aff8:	4b09      	ldr	r3, [pc, #36]	; (800b020 <MemInit+0xe0>)
 800affa:	4a12      	ldr	r2, [pc, #72]	; (800b044 <MemInit+0x104>)
 800affc:	64da      	str	r2, [r3, #76]	; 0x4c

}
 800affe:	bf00      	nop
 800b000:	3708      	adds	r7, #8
 800b002:	46bd      	mov	sp, r7
 800b004:	bd80      	pop	{r7, pc}
 800b006:	bf00      	nop
 800b008:	0802b000 	.word	0x0802b000
 800b00c:	0801161d 	.word	0x0801161d
 800b010:	08002b85 	.word	0x08002b85
 800b014:	08002b1d 	.word	0x08002b1d
 800b018:	08006b05 	.word	0x08006b05
 800b01c:	2000745c 	.word	0x2000745c
 800b020:	2000711c 	.word	0x2000711c
 800b024:	0800b049 	.word	0x0800b049
 800b028:	0800b09d 	.word	0x0800b09d
 800b02c:	0800b0f1 	.word	0x0800b0f1
 800b030:	0800b455 	.word	0x0800b455
 800b034:	0800b649 	.word	0x0800b649
 800b038:	0800b1e5 	.word	0x0800b1e5
 800b03c:	0800b2e5 	.word	0x0800b2e5
 800b040:	0800b761 	.word	0x0800b761
 800b044:	0800b7b5 	.word	0x0800b7b5

0800b048 <GetRam>:

//==============================================================================
bool GetRam(uint16 addr, uint16 *pxDsn, uint16 len) {
 800b048:	b580      	push	{r7, lr}
 800b04a:	b084      	sub	sp, #16
 800b04c:	af00      	add	r7, sp, #0
 800b04e:	4603      	mov	r3, r0
 800b050:	6039      	str	r1, [r7, #0]
 800b052:	80fb      	strh	r3, [r7, #6]
 800b054:	4613      	mov	r3, r2
 800b056:	80bb      	strh	r3, [r7, #4]
	FLASHMEM *pxConfig = (FLASHMEM*) DEVICE_FLASHMEM_LOCATION;
 800b058:	4b0b      	ldr	r3, [pc, #44]	; (800b088 <GetRam+0x40>)
 800b05a:	60fb      	str	r3, [r7, #12]
	atcResetCounter();
 800b05c:	4b0b      	ldr	r3, [pc, #44]	; (800b08c <GetRam+0x44>)
 800b05e:	4798      	blx	r3
	CountReset = 0;
 800b060:	4b0b      	ldr	r3, [pc, #44]	; (800b090 <GetRam+0x48>)
 800b062:	2200      	movs	r2, #0
 800b064:	801a      	strh	r2, [r3, #0]
	CopyDataBytes((uint8*) &RAM.dwords[addr], (uint8*) pxDsn, len * 2);
 800b066:	88fb      	ldrh	r3, [r7, #6]
 800b068:	005b      	lsls	r3, r3, #1
 800b06a:	4a0a      	ldr	r2, [pc, #40]	; (800b094 <GetRam+0x4c>)
 800b06c:	1898      	adds	r0, r3, r2
 800b06e:	88bb      	ldrh	r3, [r7, #4]
 800b070:	005b      	lsls	r3, r3, #1
 800b072:	b29b      	uxth	r3, r3
 800b074:	461a      	mov	r2, r3
 800b076:	6839      	ldr	r1, [r7, #0]
 800b078:	4b07      	ldr	r3, [pc, #28]	; (800b098 <GetRam+0x50>)
 800b07a:	4798      	blx	r3
	return true;
 800b07c:	2301      	movs	r3, #1
}
 800b07e:	4618      	mov	r0, r3
 800b080:	3710      	adds	r7, #16
 800b082:	46bd      	mov	sp, r7
 800b084:	bd80      	pop	{r7, pc}
 800b086:	bf00      	nop
 800b088:	0802b000 	.word	0x0802b000
 800b08c:	080063c1 	.word	0x080063c1
 800b090:	2000942c 	.word	0x2000942c
 800b094:	2000745c 	.word	0x2000745c
 800b098:	08006b8d 	.word	0x08006b8d

0800b09c <SetRam>:
//==============================================================================
bool SetRam(uint16 addr, uint16 *pxSrc, uint16 len) {
 800b09c:	b580      	push	{r7, lr}
 800b09e:	b084      	sub	sp, #16
 800b0a0:	af00      	add	r7, sp, #0
 800b0a2:	4603      	mov	r3, r0
 800b0a4:	6039      	str	r1, [r7, #0]
 800b0a6:	80fb      	strh	r3, [r7, #6]
 800b0a8:	4613      	mov	r3, r2
 800b0aa:	80bb      	strh	r3, [r7, #4]
	FLASHMEM *pxConfig = (FLASHMEM*) DEVICE_FLASHMEM_LOCATION;
 800b0ac:	4b0b      	ldr	r3, [pc, #44]	; (800b0dc <SetRam+0x40>)
 800b0ae:	60fb      	str	r3, [r7, #12]
	atcResetCounter();
 800b0b0:	4b0b      	ldr	r3, [pc, #44]	; (800b0e0 <SetRam+0x44>)
 800b0b2:	4798      	blx	r3
	CountReset = 0;
 800b0b4:	4b0b      	ldr	r3, [pc, #44]	; (800b0e4 <SetRam+0x48>)
 800b0b6:	2200      	movs	r2, #0
 800b0b8:	801a      	strh	r2, [r3, #0]
	CopyDataBytes((uint8*) pxSrc, (uint8*) &RAM.dwords[addr], len * 2);
 800b0ba:	88fb      	ldrh	r3, [r7, #6]
 800b0bc:	005b      	lsls	r3, r3, #1
 800b0be:	4a0a      	ldr	r2, [pc, #40]	; (800b0e8 <SetRam+0x4c>)
 800b0c0:	1899      	adds	r1, r3, r2
 800b0c2:	88bb      	ldrh	r3, [r7, #4]
 800b0c4:	005b      	lsls	r3, r3, #1
 800b0c6:	b29b      	uxth	r3, r3
 800b0c8:	461a      	mov	r2, r3
 800b0ca:	6838      	ldr	r0, [r7, #0]
 800b0cc:	4b07      	ldr	r3, [pc, #28]	; (800b0ec <SetRam+0x50>)
 800b0ce:	4798      	blx	r3
	return true;
 800b0d0:	2301      	movs	r3, #1
}
 800b0d2:	4618      	mov	r0, r3
 800b0d4:	3710      	adds	r7, #16
 800b0d6:	46bd      	mov	sp, r7
 800b0d8:	bd80      	pop	{r7, pc}
 800b0da:	bf00      	nop
 800b0dc:	0802b000 	.word	0x0802b000
 800b0e0:	080063c1 	.word	0x080063c1
 800b0e4:	2000942c 	.word	0x2000942c
 800b0e8:	2000745c 	.word	0x2000745c
 800b0ec:	08006b8d 	.word	0x08006b8d

0800b0f0 <GetSignature>:
//==============================================================================
bool GetSignature(uint16 addr, uint16 *pxDsn, uint16 len) {
 800b0f0:	b590      	push	{r4, r7, lr}
 800b0f2:	b097      	sub	sp, #92	; 0x5c
 800b0f4:	af00      	add	r7, sp, #0
 800b0f6:	4603      	mov	r3, r0
 800b0f8:	6039      	str	r1, [r7, #0]
 800b0fa:	80fb      	strh	r3, [r7, #6]
 800b0fc:	4613      	mov	r3, r2
 800b0fe:	80bb      	strh	r3, [r7, #4]
	FLASHMEM *pxConfig = (FLASHMEM*) DEVICE_FLASHMEM_LOCATION;
 800b100:	4b2d      	ldr	r3, [pc, #180]	; (800b1b8 <GetSignature+0xc8>)
 800b102:	653b      	str	r3, [r7, #80]	; 0x50
	char bufferSign[64];
	char *DeviceName;
	//setDeviceName
	if (DeviceID == 1) {
 800b104:	4b2d      	ldr	r3, [pc, #180]	; (800b1bc <GetSignature+0xcc>)
 800b106:	681b      	ldr	r3, [r3, #0]
 800b108:	2b01      	cmp	r3, #1
 800b10a:	d102      	bne.n	800b112 <GetSignature+0x22>
		DeviceName = "RUNO UC20       ";
 800b10c:	4b2c      	ldr	r3, [pc, #176]	; (800b1c0 <GetSignature+0xd0>)
 800b10e:	657b      	str	r3, [r7, #84]	; 0x54
 800b110:	e016      	b.n	800b140 <GetSignature+0x50>
	} else if (DeviceID == 2) {
 800b112:	4b2a      	ldr	r3, [pc, #168]	; (800b1bc <GetSignature+0xcc>)
 800b114:	681b      	ldr	r3, [r3, #0]
 800b116:	2b02      	cmp	r3, #2
 800b118:	d102      	bne.n	800b120 <GetSignature+0x30>
		DeviceName = "RUNO M66        ";
 800b11a:	4b2a      	ldr	r3, [pc, #168]	; (800b1c4 <GetSignature+0xd4>)
 800b11c:	657b      	str	r3, [r7, #84]	; 0x54
 800b11e:	e00f      	b.n	800b140 <GetSignature+0x50>
	} else if (DeviceID == 3) {
 800b120:	4b26      	ldr	r3, [pc, #152]	; (800b1bc <GetSignature+0xcc>)
 800b122:	681b      	ldr	r3, [r3, #0]
 800b124:	2b03      	cmp	r3, #3
 800b126:	d102      	bne.n	800b12e <GetSignature+0x3e>
		DeviceName = "RUNO UC15       ";
 800b128:	4b27      	ldr	r3, [pc, #156]	; (800b1c8 <GetSignature+0xd8>)
 800b12a:	657b      	str	r3, [r7, #84]	; 0x54
 800b12c:	e008      	b.n	800b140 <GetSignature+0x50>
	} else if (DeviceID == 4) {
 800b12e:	4b23      	ldr	r3, [pc, #140]	; (800b1bc <GetSignature+0xcc>)
 800b130:	681b      	ldr	r3, [r3, #0]
 800b132:	2b04      	cmp	r3, #4
 800b134:	d102      	bne.n	800b13c <GetSignature+0x4c>
		DeviceName = "RUNO N715       ";
 800b136:	4b25      	ldr	r3, [pc, #148]	; (800b1cc <GetSignature+0xdc>)
 800b138:	657b      	str	r3, [r7, #84]	; 0x54
 800b13a:	e001      	b.n	800b140 <GetSignature+0x50>
	} else {
		DeviceName = "RUNO           ";
 800b13c:	4b24      	ldr	r3, [pc, #144]	; (800b1d0 <GetSignature+0xe0>)
 800b13e:	657b      	str	r3, [r7, #84]	; 0x54
	}
	uint8 version[4] = { 0, 17, 6, 8 };/*   GD32F103 12   */
 800b140:	4b24      	ldr	r3, [pc, #144]	; (800b1d4 <GetSignature+0xe4>)
 800b142:	60bb      	str	r3, [r7, #8]
	char *DateVersion = "18/09/2024"; //   
 800b144:	4b24      	ldr	r3, [pc, #144]	; (800b1d8 <GetSignature+0xe8>)
 800b146:	64fb      	str	r3, [r7, #76]	; 0x4c
	CopyDataBytes((uint8*) DeviceName, (uint8*) bufferSign,
			strlen(DeviceName) + 1);
 800b148:	6d78      	ldr	r0, [r7, #84]	; 0x54
 800b14a:	4b24      	ldr	r3, [pc, #144]	; (800b1dc <GetSignature+0xec>)
 800b14c:	4798      	blx	r3
 800b14e:	4603      	mov	r3, r0
	CopyDataBytes((uint8*) DeviceName, (uint8*) bufferSign,
 800b150:	b29b      	uxth	r3, r3
 800b152:	3301      	adds	r3, #1
 800b154:	b29a      	uxth	r2, r3
 800b156:	f107 030c 	add.w	r3, r7, #12
 800b15a:	4619      	mov	r1, r3
 800b15c:	6d78      	ldr	r0, [r7, #84]	; 0x54
 800b15e:	4b20      	ldr	r3, [pc, #128]	; (800b1e0 <GetSignature+0xf0>)
 800b160:	4798      	blx	r3
	CopyDataBytes((uint8*) version, (uint8*) bufferSign + 0x10, 4);
 800b162:	f107 030c 	add.w	r3, r7, #12
 800b166:	3310      	adds	r3, #16
 800b168:	f107 0008 	add.w	r0, r7, #8
 800b16c:	2204      	movs	r2, #4
 800b16e:	4619      	mov	r1, r3
 800b170:	4b1b      	ldr	r3, [pc, #108]	; (800b1e0 <GetSignature+0xf0>)
 800b172:	4798      	blx	r3
	CopyDataBytes((uint8*) DateVersion, (uint8*) bufferSign + 0x20,
 800b174:	f107 040c 	add.w	r4, r7, #12
 800b178:	3420      	adds	r4, #32
			strlen(DateVersion) + 1);
 800b17a:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 800b17c:	4b17      	ldr	r3, [pc, #92]	; (800b1dc <GetSignature+0xec>)
 800b17e:	4798      	blx	r3
 800b180:	4603      	mov	r3, r0
	CopyDataBytes((uint8*) DateVersion, (uint8*) bufferSign + 0x20,
 800b182:	b29b      	uxth	r3, r3
 800b184:	3301      	adds	r3, #1
 800b186:	b29b      	uxth	r3, r3
 800b188:	461a      	mov	r2, r3
 800b18a:	4621      	mov	r1, r4
 800b18c:	6cf8      	ldr	r0, [r7, #76]	; 0x4c
 800b18e:	4b14      	ldr	r3, [pc, #80]	; (800b1e0 <GetSignature+0xf0>)
 800b190:	4798      	blx	r3
	CopyDataBytes((uint8*) bufferSign + addr * 2, (uint8*) pxDsn, len * 2);
 800b192:	88fb      	ldrh	r3, [r7, #6]
 800b194:	005b      	lsls	r3, r3, #1
 800b196:	461a      	mov	r2, r3
 800b198:	f107 030c 	add.w	r3, r7, #12
 800b19c:	1898      	adds	r0, r3, r2
 800b19e:	88bb      	ldrh	r3, [r7, #4]
 800b1a0:	005b      	lsls	r3, r3, #1
 800b1a2:	b29b      	uxth	r3, r3
 800b1a4:	461a      	mov	r2, r3
 800b1a6:	6839      	ldr	r1, [r7, #0]
 800b1a8:	4b0d      	ldr	r3, [pc, #52]	; (800b1e0 <GetSignature+0xf0>)
 800b1aa:	4798      	blx	r3
	return true;
 800b1ac:	2301      	movs	r3, #1

}
 800b1ae:	4618      	mov	r0, r3
 800b1b0:	375c      	adds	r7, #92	; 0x5c
 800b1b2:	46bd      	mov	sp, r7
 800b1b4:	bd90      	pop	{r4, r7, pc}
 800b1b6:	bf00      	nop
 800b1b8:	0802b000 	.word	0x0802b000
 800b1bc:	20008468 	.word	0x20008468
 800b1c0:	0801504c 	.word	0x0801504c
 800b1c4:	08015060 	.word	0x08015060
 800b1c8:	08015074 	.word	0x08015074
 800b1cc:	08015088 	.word	0x08015088
 800b1d0:	0801509c 	.word	0x0801509c
 800b1d4:	08061100 	.word	0x08061100
 800b1d8:	080150ac 	.word	0x080150ac
 800b1dc:	08014731 	.word	0x08014731
 800b1e0:	08006b8d 	.word	0x08006b8d

0800b1e4 <GetEeprom>:
//==============================================================================
bool GetEeprom(uint16 addr, uint16 *pxDsn, uint16 len) {
 800b1e4:	b580      	push	{r7, lr}
 800b1e6:	b0c4      	sub	sp, #272	; 0x110
 800b1e8:	af00      	add	r7, sp, #0
 800b1ea:	f507 7388 	add.w	r3, r7, #272	; 0x110
 800b1ee:	f5a3 7388 	sub.w	r3, r3, #272	; 0x110
 800b1f2:	6019      	str	r1, [r3, #0]
 800b1f4:	4611      	mov	r1, r2
 800b1f6:	f507 7388 	add.w	r3, r7, #272	; 0x110
 800b1fa:	f5a3 7385 	sub.w	r3, r3, #266	; 0x10a
 800b1fe:	4602      	mov	r2, r0
 800b200:	801a      	strh	r2, [r3, #0]
 800b202:	f507 7388 	add.w	r3, r7, #272	; 0x110
 800b206:	f5a3 7386 	sub.w	r3, r3, #268	; 0x10c
 800b20a:	460a      	mov	r2, r1
 800b20c:	801a      	strh	r2, [r3, #0]
	FLASHMEM *pxConfig = (FLASHMEM*) DEVICE_FLASHMEM_LOCATION;
 800b20e:	4b32      	ldr	r3, [pc, #200]	; (800b2d8 <GetEeprom+0xf4>)
 800b210:	f8c7 3108 	str.w	r3, [r7, #264]	; 0x108
	uint8 charBuf[256];
	uint8 counter = 0;
 800b214:	2300      	movs	r3, #0
 800b216:	f887 310f 	strb.w	r3, [r7, #271]	; 0x10f

	uint8 curRead = 0;
 800b21a:	2300      	movs	r3, #0
 800b21c:	f887 310e 	strb.w	r3, [r7, #270]	; 0x10e
	while (curRead < len) {
 800b220:	e03a      	b.n	800b298 <GetEeprom+0xb4>
		counter = 0;
 800b222:	2300      	movs	r3, #0
 800b224:	f887 310f 	strb.w	r3, [r7, #271]	; 0x10f
		while (!I2C_EE_BufferRead(charBuf + curRead * 2, (addr + curRead) * 2,
 800b228:	e008      	b.n	800b23c <GetEeprom+0x58>
				((len - curRead > 0x10) ? 0x10 : (len - curRead)) * 2)) {
			if (counter++ >= 10)
 800b22a:	f897 310f 	ldrb.w	r3, [r7, #271]	; 0x10f
 800b22e:	1c5a      	adds	r2, r3, #1
 800b230:	f887 210f 	strb.w	r2, [r7, #271]	; 0x10f
 800b234:	2b09      	cmp	r3, #9
 800b236:	d901      	bls.n	800b23c <GetEeprom+0x58>
				return false;
 800b238:	2300      	movs	r3, #0
 800b23a:	e048      	b.n	800b2ce <GetEeprom+0xea>
		while (!I2C_EE_BufferRead(charBuf + curRead * 2, (addr + curRead) * 2,
 800b23c:	f897 310e 	ldrb.w	r3, [r7, #270]	; 0x10e
 800b240:	005b      	lsls	r3, r3, #1
 800b242:	461a      	mov	r2, r3
 800b244:	f107 0308 	add.w	r3, r7, #8
 800b248:	1898      	adds	r0, r3, r2
 800b24a:	f507 7388 	add.w	r3, r7, #272	; 0x110
 800b24e:	f5a3 7385 	sub.w	r3, r3, #266	; 0x10a
 800b252:	881a      	ldrh	r2, [r3, #0]
 800b254:	f897 310e 	ldrb.w	r3, [r7, #270]	; 0x10e
 800b258:	4413      	add	r3, r2
 800b25a:	b29b      	uxth	r3, r3
 800b25c:	005b      	lsls	r3, r3, #1
 800b25e:	b299      	uxth	r1, r3
				((len - curRead > 0x10) ? 0x10 : (len - curRead)) * 2)) {
 800b260:	f507 7388 	add.w	r3, r7, #272	; 0x110
 800b264:	f5a3 7386 	sub.w	r3, r3, #268	; 0x10c
 800b268:	881a      	ldrh	r2, [r3, #0]
 800b26a:	f897 310e 	ldrb.w	r3, [r7, #270]	; 0x10e
 800b26e:	1ad3      	subs	r3, r2, r3
 800b270:	2b10      	cmp	r3, #16
 800b272:	bfa8      	it	ge
 800b274:	2310      	movge	r3, #16
		while (!I2C_EE_BufferRead(charBuf + curRead * 2, (addr + curRead) * 2,
 800b276:	b29b      	uxth	r3, r3
 800b278:	005b      	lsls	r3, r3, #1
 800b27a:	b29b      	uxth	r3, r3
 800b27c:	461a      	mov	r2, r3
 800b27e:	4b17      	ldr	r3, [pc, #92]	; (800b2dc <GetEeprom+0xf8>)
 800b280:	4798      	blx	r3
 800b282:	4603      	mov	r3, r0
 800b284:	f083 0301 	eor.w	r3, r3, #1
 800b288:	b2db      	uxtb	r3, r3
 800b28a:	2b00      	cmp	r3, #0
 800b28c:	d1cd      	bne.n	800b22a <GetEeprom+0x46>
		}
		curRead += 0x10;
 800b28e:	f897 310e 	ldrb.w	r3, [r7, #270]	; 0x10e
 800b292:	3310      	adds	r3, #16
 800b294:	f887 310e 	strb.w	r3, [r7, #270]	; 0x10e
	while (curRead < len) {
 800b298:	f897 310e 	ldrb.w	r3, [r7, #270]	; 0x10e
 800b29c:	b29b      	uxth	r3, r3
 800b29e:	f507 7288 	add.w	r2, r7, #272	; 0x110
 800b2a2:	f5a2 7286 	sub.w	r2, r2, #268	; 0x10c
 800b2a6:	8812      	ldrh	r2, [r2, #0]
 800b2a8:	429a      	cmp	r2, r3
 800b2aa:	d8ba      	bhi.n	800b222 <GetEeprom+0x3e>
	}

	CopyDataBytes((uint8*) charBuf, (uint8*) pxDsn, len * 2);
 800b2ac:	f507 7388 	add.w	r3, r7, #272	; 0x110
 800b2b0:	f5a3 7386 	sub.w	r3, r3, #268	; 0x10c
 800b2b4:	881b      	ldrh	r3, [r3, #0]
 800b2b6:	005b      	lsls	r3, r3, #1
 800b2b8:	b29a      	uxth	r2, r3
 800b2ba:	f507 7388 	add.w	r3, r7, #272	; 0x110
 800b2be:	f5a3 7388 	sub.w	r3, r3, #272	; 0x110
 800b2c2:	f107 0008 	add.w	r0, r7, #8
 800b2c6:	6819      	ldr	r1, [r3, #0]
 800b2c8:	4b05      	ldr	r3, [pc, #20]	; (800b2e0 <GetEeprom+0xfc>)
 800b2ca:	4798      	blx	r3
	return true;
 800b2cc:	2301      	movs	r3, #1
}
 800b2ce:	4618      	mov	r0, r3
 800b2d0:	f507 7788 	add.w	r7, r7, #272	; 0x110
 800b2d4:	46bd      	mov	sp, r7
 800b2d6:	bd80      	pop	{r7, pc}
 800b2d8:	0802b000 	.word	0x0802b000
 800b2dc:	08011ad5 	.word	0x08011ad5
 800b2e0:	08006b8d 	.word	0x08006b8d

0800b2e4 <SetEeprom>:
//==============================================================================
bool SetEeprom(uint16 addr, uint16 *pxSrc, uint16 len) {
 800b2e4:	b580      	push	{r7, lr}
 800b2e6:	b0c4      	sub	sp, #272	; 0x110
 800b2e8:	af00      	add	r7, sp, #0
 800b2ea:	f507 7388 	add.w	r3, r7, #272	; 0x110
 800b2ee:	f5a3 7388 	sub.w	r3, r3, #272	; 0x110
 800b2f2:	6019      	str	r1, [r3, #0]
 800b2f4:	4611      	mov	r1, r2
 800b2f6:	f507 7388 	add.w	r3, r7, #272	; 0x110
 800b2fa:	f5a3 7385 	sub.w	r3, r3, #266	; 0x10a
 800b2fe:	4602      	mov	r2, r0
 800b300:	801a      	strh	r2, [r3, #0]
 800b302:	f507 7388 	add.w	r3, r7, #272	; 0x110
 800b306:	f5a3 7386 	sub.w	r3, r3, #268	; 0x10c
 800b30a:	460a      	mov	r2, r1
 800b30c:	801a      	strh	r2, [r3, #0]
	uint8 charBuf[256];
	uint8 counter = 0;
 800b30e:	2300      	movs	r3, #0
 800b310:	f887 310f 	strb.w	r3, [r7, #271]	; 0x10f

	uint8 curRead = 0;
 800b314:	2300      	movs	r3, #0
 800b316:	f887 310e 	strb.w	r3, [r7, #270]	; 0x10e

	if ((pxSrc[0] == 0) && (addr == 0)) {
 800b31a:	f507 7388 	add.w	r3, r7, #272	; 0x110
 800b31e:	f5a3 7388 	sub.w	r3, r3, #272	; 0x110
 800b322:	681b      	ldr	r3, [r3, #0]
 800b324:	881b      	ldrh	r3, [r3, #0]
 800b326:	2b00      	cmp	r3, #0
 800b328:	d111      	bne.n	800b34e <SetEeprom+0x6a>
 800b32a:	f507 7388 	add.w	r3, r7, #272	; 0x110
 800b32e:	f5a3 7385 	sub.w	r3, r3, #266	; 0x10a
 800b332:	881b      	ldrh	r3, [r3, #0]
 800b334:	2b00      	cmp	r3, #0
 800b336:	d10a      	bne.n	800b34e <SetEeprom+0x6a>
		return false;
 800b338:	2300      	movs	r3, #0
 800b33a:	e07d      	b.n	800b438 <SetEeprom+0x154>
	} else {

		while (!I2C_EE_BufferWrite((uint8*) pxSrc, addr * 2, len * 2)) {
			if (counter++ >= 10)
 800b33c:	f897 310f 	ldrb.w	r3, [r7, #271]	; 0x10f
 800b340:	1c5a      	adds	r2, r3, #1
 800b342:	f887 210f 	strb.w	r2, [r7, #271]	; 0x10f
 800b346:	2b09      	cmp	r3, #9
 800b348:	d901      	bls.n	800b34e <SetEeprom+0x6a>
				return false;
 800b34a:	2300      	movs	r3, #0
 800b34c:	e074      	b.n	800b438 <SetEeprom+0x154>
		while (!I2C_EE_BufferWrite((uint8*) pxSrc, addr * 2, len * 2)) {
 800b34e:	f507 7388 	add.w	r3, r7, #272	; 0x110
 800b352:	f5a3 7385 	sub.w	r3, r3, #266	; 0x10a
 800b356:	881b      	ldrh	r3, [r3, #0]
 800b358:	005b      	lsls	r3, r3, #1
 800b35a:	b299      	uxth	r1, r3
 800b35c:	f507 7388 	add.w	r3, r7, #272	; 0x110
 800b360:	f5a3 7386 	sub.w	r3, r3, #268	; 0x10c
 800b364:	881b      	ldrh	r3, [r3, #0]
 800b366:	005b      	lsls	r3, r3, #1
 800b368:	b29a      	uxth	r2, r3
 800b36a:	f507 7388 	add.w	r3, r7, #272	; 0x110
 800b36e:	f5a3 7388 	sub.w	r3, r3, #272	; 0x110
 800b372:	6818      	ldr	r0, [r3, #0]
 800b374:	4b33      	ldr	r3, [pc, #204]	; (800b444 <SetEeprom+0x160>)
 800b376:	4798      	blx	r3
 800b378:	4603      	mov	r3, r0
 800b37a:	f083 0301 	eor.w	r3, r3, #1
 800b37e:	b2db      	uxtb	r3, r3
 800b380:	2b00      	cmp	r3, #0
 800b382:	d1db      	bne.n	800b33c <SetEeprom+0x58>
		}
		vTaskDelay(10);
 800b384:	200a      	movs	r0, #10
 800b386:	4b30      	ldr	r3, [pc, #192]	; (800b448 <SetEeprom+0x164>)
 800b388:	4798      	blx	r3
		while (curRead < len) {
 800b38a:	e03a      	b.n	800b402 <SetEeprom+0x11e>
			counter = 0;
 800b38c:	2300      	movs	r3, #0
 800b38e:	f887 310f 	strb.w	r3, [r7, #271]	; 0x10f
			while (!I2C_EE_BufferRead(charBuf + curRead * 2,
 800b392:	e008      	b.n	800b3a6 <SetEeprom+0xc2>
					(addr + curRead) * 2,
					((len - curRead > 0x10) ? 0x10 : (len - curRead)) * 2)) {
				if (counter++ >= 10)
 800b394:	f897 310f 	ldrb.w	r3, [r7, #271]	; 0x10f
 800b398:	1c5a      	adds	r2, r3, #1
 800b39a:	f887 210f 	strb.w	r2, [r7, #271]	; 0x10f
 800b39e:	2b09      	cmp	r3, #9
 800b3a0:	d901      	bls.n	800b3a6 <SetEeprom+0xc2>
					return false;
 800b3a2:	2300      	movs	r3, #0
 800b3a4:	e048      	b.n	800b438 <SetEeprom+0x154>
			while (!I2C_EE_BufferRead(charBuf + curRead * 2,
 800b3a6:	f897 310e 	ldrb.w	r3, [r7, #270]	; 0x10e
 800b3aa:	005b      	lsls	r3, r3, #1
 800b3ac:	461a      	mov	r2, r3
 800b3ae:	f107 030c 	add.w	r3, r7, #12
 800b3b2:	1898      	adds	r0, r3, r2
					(addr + curRead) * 2,
 800b3b4:	f507 7388 	add.w	r3, r7, #272	; 0x110
 800b3b8:	f5a3 7385 	sub.w	r3, r3, #266	; 0x10a
 800b3bc:	881a      	ldrh	r2, [r3, #0]
 800b3be:	f897 310e 	ldrb.w	r3, [r7, #270]	; 0x10e
 800b3c2:	4413      	add	r3, r2
			while (!I2C_EE_BufferRead(charBuf + curRead * 2,
 800b3c4:	b29b      	uxth	r3, r3
 800b3c6:	005b      	lsls	r3, r3, #1
 800b3c8:	b299      	uxth	r1, r3
					((len - curRead > 0x10) ? 0x10 : (len - curRead)) * 2)) {
 800b3ca:	f507 7388 	add.w	r3, r7, #272	; 0x110
 800b3ce:	f5a3 7386 	sub.w	r3, r3, #268	; 0x10c
 800b3d2:	881a      	ldrh	r2, [r3, #0]
 800b3d4:	f897 310e 	ldrb.w	r3, [r7, #270]	; 0x10e
 800b3d8:	1ad3      	subs	r3, r2, r3
 800b3da:	2b10      	cmp	r3, #16
 800b3dc:	bfa8      	it	ge
 800b3de:	2310      	movge	r3, #16
			while (!I2C_EE_BufferRead(charBuf + curRead * 2,
 800b3e0:	b29b      	uxth	r3, r3
 800b3e2:	005b      	lsls	r3, r3, #1
 800b3e4:	b29b      	uxth	r3, r3
 800b3e6:	461a      	mov	r2, r3
 800b3e8:	4b18      	ldr	r3, [pc, #96]	; (800b44c <SetEeprom+0x168>)
 800b3ea:	4798      	blx	r3
 800b3ec:	4603      	mov	r3, r0
 800b3ee:	f083 0301 	eor.w	r3, r3, #1
 800b3f2:	b2db      	uxtb	r3, r3
 800b3f4:	2b00      	cmp	r3, #0
 800b3f6:	d1cd      	bne.n	800b394 <SetEeprom+0xb0>
			}

			curRead += 0x10;
 800b3f8:	f897 310e 	ldrb.w	r3, [r7, #270]	; 0x10e
 800b3fc:	3310      	adds	r3, #16
 800b3fe:	f887 310e 	strb.w	r3, [r7, #270]	; 0x10e
		while (curRead < len) {
 800b402:	f897 310e 	ldrb.w	r3, [r7, #270]	; 0x10e
 800b406:	b29b      	uxth	r3, r3
 800b408:	f507 7288 	add.w	r2, r7, #272	; 0x110
 800b40c:	f5a2 7286 	sub.w	r2, r2, #268	; 0x10c
 800b410:	8812      	ldrh	r2, [r2, #0]
 800b412:	429a      	cmp	r2, r3
 800b414:	d8ba      	bhi.n	800b38c <SetEeprom+0xa8>
		}
		//vTaskDelay(10);
		return Buffercmp(charBuf, (uint8*) pxSrc, len * 2);
 800b416:	f507 7388 	add.w	r3, r7, #272	; 0x110
 800b41a:	f5a3 7386 	sub.w	r3, r3, #268	; 0x10c
 800b41e:	881b      	ldrh	r3, [r3, #0]
 800b420:	005b      	lsls	r3, r3, #1
 800b422:	b29a      	uxth	r2, r3
 800b424:	f507 7388 	add.w	r3, r7, #272	; 0x110
 800b428:	f5a3 7388 	sub.w	r3, r3, #272	; 0x110
 800b42c:	f107 000c 	add.w	r0, r7, #12
 800b430:	6819      	ldr	r1, [r3, #0]
 800b432:	4b07      	ldr	r3, [pc, #28]	; (800b450 <SetEeprom+0x16c>)
 800b434:	4798      	blx	r3
 800b436:	4603      	mov	r3, r0
	}
}
 800b438:	4618      	mov	r0, r3
 800b43a:	f507 7788 	add.w	r7, r7, #272	; 0x110
 800b43e:	46bd      	mov	sp, r7
 800b440:	bd80      	pop	{r7, pc}
 800b442:	bf00      	nop
 800b444:	08011691 	.word	0x08011691
 800b448:	08001529 	.word	0x08001529
 800b44c:	08011ad5 	.word	0x08011ad5
 800b450:	0800ba59 	.word	0x0800ba59

0800b454 <GetRtc>:

//==============================================================================
bool GetRtc(uint16 addr, uint16 *pxDsn, uint16 len) {
 800b454:	b580      	push	{r7, lr}
 800b456:	b08e      	sub	sp, #56	; 0x38
 800b458:	af00      	add	r7, sp, #0
 800b45a:	4603      	mov	r3, r0
 800b45c:	6039      	str	r1, [r7, #0]
 800b45e:	80fb      	strh	r3, [r7, #6]
 800b460:	4613      	mov	r3, r2
 800b462:	80bb      	strh	r3, [r7, #4]
	FLASHMEM *pxConfig = (FLASHMEM*) DEVICE_FLASHMEM_LOCATION;
 800b464:	4b70      	ldr	r3, [pc, #448]	; (800b628 <GetRtc+0x1d4>)
 800b466:	633b      	str	r3, [r7, #48]	; 0x30
	DATATIME temprtc;

	char iFixstr[16];

	tmpPointer = addr;
 800b468:	88fb      	ldrh	r3, [r7, #6]
 800b46a:	4a70      	ldr	r2, [pc, #448]	; (800b62c <GetRtc+0x1d8>)
 800b46c:	6013      	str	r3, [r2, #0]
	tmpLen = len;
 800b46e:	88bb      	ldrh	r3, [r7, #4]
 800b470:	4a6f      	ldr	r2, [pc, #444]	; (800b630 <GetRtc+0x1dc>)
 800b472:	6013      	str	r3, [r2, #0]
	int tmp = 0;
 800b474:	2300      	movs	r3, #0
 800b476:	62fb      	str	r3, [r7, #44]	; 0x2c
	int wr = 0;
 800b478:	2300      	movs	r3, #0
 800b47a:	637b      	str	r3, [r7, #52]	; 0x34

	if (tmpPointer >= 0 && tmpPointer < 0x08 && tmpLen > 0) {
 800b47c:	4b6b      	ldr	r3, [pc, #428]	; (800b62c <GetRtc+0x1d8>)
 800b47e:	681b      	ldr	r3, [r3, #0]
 800b480:	2b00      	cmp	r3, #0
 800b482:	db3e      	blt.n	800b502 <GetRtc+0xae>
 800b484:	4b69      	ldr	r3, [pc, #420]	; (800b62c <GetRtc+0x1d8>)
 800b486:	681b      	ldr	r3, [r3, #0]
 800b488:	2b07      	cmp	r3, #7
 800b48a:	dc3a      	bgt.n	800b502 <GetRtc+0xae>
 800b48c:	4b68      	ldr	r3, [pc, #416]	; (800b630 <GetRtc+0x1dc>)
 800b48e:	681b      	ldr	r3, [r3, #0]
 800b490:	2b00      	cmp	r3, #0
 800b492:	dd36      	ble.n	800b502 <GetRtc+0xae>
		rtcGetDataTime(&temprtc);
 800b494:	f107 031c 	add.w	r3, r7, #28
 800b498:	4618      	mov	r0, r3
 800b49a:	4b66      	ldr	r3, [pc, #408]	; (800b634 <GetRtc+0x1e0>)
 800b49c:	4798      	blx	r3
		tmp = ((tmpPointer + tmpLen) > 8) ? ((8 - tmpPointer)) : (tmpLen);
 800b49e:	4b63      	ldr	r3, [pc, #396]	; (800b62c <GetRtc+0x1d8>)
 800b4a0:	681a      	ldr	r2, [r3, #0]
 800b4a2:	4b63      	ldr	r3, [pc, #396]	; (800b630 <GetRtc+0x1dc>)
 800b4a4:	681b      	ldr	r3, [r3, #0]
 800b4a6:	4413      	add	r3, r2
 800b4a8:	2b08      	cmp	r3, #8
 800b4aa:	dd04      	ble.n	800b4b6 <GetRtc+0x62>
 800b4ac:	4b5f      	ldr	r3, [pc, #380]	; (800b62c <GetRtc+0x1d8>)
 800b4ae:	681b      	ldr	r3, [r3, #0]
 800b4b0:	f1c3 0308 	rsb	r3, r3, #8
 800b4b4:	e001      	b.n	800b4ba <GetRtc+0x66>
 800b4b6:	4b5e      	ldr	r3, [pc, #376]	; (800b630 <GetRtc+0x1dc>)
 800b4b8:	681b      	ldr	r3, [r3, #0]
 800b4ba:	62fb      	str	r3, [r7, #44]	; 0x2c

		CopyDataBytes((uint8*) ((uint8*) (&temprtc) + tmpPointer * 2),
 800b4bc:	4b5b      	ldr	r3, [pc, #364]	; (800b62c <GetRtc+0x1d8>)
 800b4be:	681b      	ldr	r3, [r3, #0]
 800b4c0:	005b      	lsls	r3, r3, #1
 800b4c2:	461a      	mov	r2, r3
 800b4c4:	f107 031c 	add.w	r3, r7, #28
 800b4c8:	1898      	adds	r0, r3, r2
				(uint8*) (pxDsn) + wr * 2, tmp * 2);
 800b4ca:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b4cc:	005b      	lsls	r3, r3, #1
 800b4ce:	461a      	mov	r2, r3
		CopyDataBytes((uint8*) ((uint8*) (&temprtc) + tmpPointer * 2),
 800b4d0:	683b      	ldr	r3, [r7, #0]
 800b4d2:	1899      	adds	r1, r3, r2
 800b4d4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b4d6:	b29b      	uxth	r3, r3
 800b4d8:	005b      	lsls	r3, r3, #1
 800b4da:	b29b      	uxth	r3, r3
 800b4dc:	461a      	mov	r2, r3
 800b4de:	4b56      	ldr	r3, [pc, #344]	; (800b638 <GetRtc+0x1e4>)
 800b4e0:	4798      	blx	r3
		tmpPointer += tmp;
 800b4e2:	4b52      	ldr	r3, [pc, #328]	; (800b62c <GetRtc+0x1d8>)
 800b4e4:	681a      	ldr	r2, [r3, #0]
 800b4e6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b4e8:	4413      	add	r3, r2
 800b4ea:	4a50      	ldr	r2, [pc, #320]	; (800b62c <GetRtc+0x1d8>)
 800b4ec:	6013      	str	r3, [r2, #0]
		wr += tmp;
 800b4ee:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800b4f0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b4f2:	4413      	add	r3, r2
 800b4f4:	637b      	str	r3, [r7, #52]	; 0x34
		tmpLen -= tmp;
 800b4f6:	4b4e      	ldr	r3, [pc, #312]	; (800b630 <GetRtc+0x1dc>)
 800b4f8:	681a      	ldr	r2, [r3, #0]
 800b4fa:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b4fc:	1ad3      	subs	r3, r2, r3
 800b4fe:	4a4c      	ldr	r2, [pc, #304]	; (800b630 <GetRtc+0x1dc>)
 800b500:	6013      	str	r3, [r2, #0]
	}
	if (tmpPointer >= 0x08 && tmpPointer < 0x10 && tmpLen > 0) {
 800b502:	4b4a      	ldr	r3, [pc, #296]	; (800b62c <GetRtc+0x1d8>)
 800b504:	681b      	ldr	r3, [r3, #0]
 800b506:	2b07      	cmp	r3, #7
 800b508:	dd3f      	ble.n	800b58a <GetRtc+0x136>
 800b50a:	4b48      	ldr	r3, [pc, #288]	; (800b62c <GetRtc+0x1d8>)
 800b50c:	681b      	ldr	r3, [r3, #0]
 800b50e:	2b0f      	cmp	r3, #15
 800b510:	dc3b      	bgt.n	800b58a <GetRtc+0x136>
 800b512:	4b47      	ldr	r3, [pc, #284]	; (800b630 <GetRtc+0x1dc>)
 800b514:	681b      	ldr	r3, [r3, #0]
 800b516:	2b00      	cmp	r3, #0
 800b518:	dd37      	ble.n	800b58a <GetRtc+0x136>
		rtcGetDataTime(&temprtc);
 800b51a:	f107 031c 	add.w	r3, r7, #28
 800b51e:	4618      	mov	r0, r3
 800b520:	4b44      	ldr	r3, [pc, #272]	; (800b634 <GetRtc+0x1e0>)
 800b522:	4798      	blx	r3
		//rtcGetLocalDataTime(&temprtc);
		tmp = ((tmpPointer + tmpLen) > 0x10) ? ((0x10 - tmpPointer)) : (tmpLen);
 800b524:	4b41      	ldr	r3, [pc, #260]	; (800b62c <GetRtc+0x1d8>)
 800b526:	681a      	ldr	r2, [r3, #0]
 800b528:	4b41      	ldr	r3, [pc, #260]	; (800b630 <GetRtc+0x1dc>)
 800b52a:	681b      	ldr	r3, [r3, #0]
 800b52c:	4413      	add	r3, r2
 800b52e:	2b10      	cmp	r3, #16
 800b530:	dd04      	ble.n	800b53c <GetRtc+0xe8>
 800b532:	4b3e      	ldr	r3, [pc, #248]	; (800b62c <GetRtc+0x1d8>)
 800b534:	681b      	ldr	r3, [r3, #0]
 800b536:	f1c3 0310 	rsb	r3, r3, #16
 800b53a:	e001      	b.n	800b540 <GetRtc+0xec>
 800b53c:	4b3c      	ldr	r3, [pc, #240]	; (800b630 <GetRtc+0x1dc>)
 800b53e:	681b      	ldr	r3, [r3, #0]
 800b540:	62fb      	str	r3, [r7, #44]	; 0x2c
		CopyDataBytes((uint8*) ((uint8*) (&temprtc) + (tmpPointer - 0x08) * 2),
 800b542:	4b3a      	ldr	r3, [pc, #232]	; (800b62c <GetRtc+0x1d8>)
 800b544:	681b      	ldr	r3, [r3, #0]
 800b546:	3b08      	subs	r3, #8
 800b548:	005b      	lsls	r3, r3, #1
 800b54a:	461a      	mov	r2, r3
 800b54c:	f107 031c 	add.w	r3, r7, #28
 800b550:	1898      	adds	r0, r3, r2
				(uint8*) (pxDsn) + wr * 2, tmp * 2);
 800b552:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b554:	005b      	lsls	r3, r3, #1
 800b556:	461a      	mov	r2, r3
		CopyDataBytes((uint8*) ((uint8*) (&temprtc) + (tmpPointer - 0x08) * 2),
 800b558:	683b      	ldr	r3, [r7, #0]
 800b55a:	1899      	adds	r1, r3, r2
 800b55c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b55e:	b29b      	uxth	r3, r3
 800b560:	005b      	lsls	r3, r3, #1
 800b562:	b29b      	uxth	r3, r3
 800b564:	461a      	mov	r2, r3
 800b566:	4b34      	ldr	r3, [pc, #208]	; (800b638 <GetRtc+0x1e4>)
 800b568:	4798      	blx	r3
		tmpPointer += tmp;
 800b56a:	4b30      	ldr	r3, [pc, #192]	; (800b62c <GetRtc+0x1d8>)
 800b56c:	681a      	ldr	r2, [r3, #0]
 800b56e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b570:	4413      	add	r3, r2
 800b572:	4a2e      	ldr	r2, [pc, #184]	; (800b62c <GetRtc+0x1d8>)
 800b574:	6013      	str	r3, [r2, #0]
		wr += tmp;
 800b576:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800b578:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b57a:	4413      	add	r3, r2
 800b57c:	637b      	str	r3, [r7, #52]	; 0x34
		tmpLen -= tmp;
 800b57e:	4b2c      	ldr	r3, [pc, #176]	; (800b630 <GetRtc+0x1dc>)
 800b580:	681a      	ldr	r2, [r3, #0]
 800b582:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b584:	1ad3      	subs	r3, r2, r3
 800b586:	4a2a      	ldr	r2, [pc, #168]	; (800b630 <GetRtc+0x1dc>)
 800b588:	6013      	str	r3, [r2, #0]
	}
	if (tmpPointer >= 0x20 && tmpPointer < 0x30 && tmpLen > 0) {
 800b58a:	4b28      	ldr	r3, [pc, #160]	; (800b62c <GetRtc+0x1d8>)
 800b58c:	681b      	ldr	r3, [r3, #0]
 800b58e:	2b1f      	cmp	r3, #31
 800b590:	dd3f      	ble.n	800b612 <GetRtc+0x1be>
 800b592:	4b26      	ldr	r3, [pc, #152]	; (800b62c <GetRtc+0x1d8>)
 800b594:	681b      	ldr	r3, [r3, #0]
 800b596:	2b2f      	cmp	r3, #47	; 0x2f
 800b598:	dc3b      	bgt.n	800b612 <GetRtc+0x1be>
 800b59a:	4b25      	ldr	r3, [pc, #148]	; (800b630 <GetRtc+0x1dc>)
 800b59c:	681b      	ldr	r3, [r3, #0]
 800b59e:	2b00      	cmp	r3, #0
 800b5a0:	dd37      	ble.n	800b612 <GetRtc+0x1be>
		rtcGetiFixDateTime(iFixstr);
 800b5a2:	f107 030c 	add.w	r3, r7, #12
 800b5a6:	4618      	mov	r0, r3
 800b5a8:	4b24      	ldr	r3, [pc, #144]	; (800b63c <GetRtc+0x1e8>)
 800b5aa:	4798      	blx	r3
		tmp = ((tmpPointer + tmpLen) > 0x30) ? ((0x30 - tmpPointer)) : (tmpLen);
 800b5ac:	4b1f      	ldr	r3, [pc, #124]	; (800b62c <GetRtc+0x1d8>)
 800b5ae:	681a      	ldr	r2, [r3, #0]
 800b5b0:	4b1f      	ldr	r3, [pc, #124]	; (800b630 <GetRtc+0x1dc>)
 800b5b2:	681b      	ldr	r3, [r3, #0]
 800b5b4:	4413      	add	r3, r2
 800b5b6:	2b30      	cmp	r3, #48	; 0x30
 800b5b8:	dd04      	ble.n	800b5c4 <GetRtc+0x170>
 800b5ba:	4b1c      	ldr	r3, [pc, #112]	; (800b62c <GetRtc+0x1d8>)
 800b5bc:	681b      	ldr	r3, [r3, #0]
 800b5be:	f1c3 0330 	rsb	r3, r3, #48	; 0x30
 800b5c2:	e001      	b.n	800b5c8 <GetRtc+0x174>
 800b5c4:	4b1a      	ldr	r3, [pc, #104]	; (800b630 <GetRtc+0x1dc>)
 800b5c6:	681b      	ldr	r3, [r3, #0]
 800b5c8:	62fb      	str	r3, [r7, #44]	; 0x2c
		CopyDataBytes((uint8*) ((uint8*) (&iFixstr) + (tmpPointer - 0x20) * 2),
 800b5ca:	4b18      	ldr	r3, [pc, #96]	; (800b62c <GetRtc+0x1d8>)
 800b5cc:	681b      	ldr	r3, [r3, #0]
 800b5ce:	3b20      	subs	r3, #32
 800b5d0:	005b      	lsls	r3, r3, #1
 800b5d2:	461a      	mov	r2, r3
 800b5d4:	f107 030c 	add.w	r3, r7, #12
 800b5d8:	1898      	adds	r0, r3, r2
				(uint8*) (pxDsn) + wr * 2, tmp * 2);
 800b5da:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800b5dc:	005b      	lsls	r3, r3, #1
 800b5de:	461a      	mov	r2, r3
		CopyDataBytes((uint8*) ((uint8*) (&iFixstr) + (tmpPointer - 0x20) * 2),
 800b5e0:	683b      	ldr	r3, [r7, #0]
 800b5e2:	1899      	adds	r1, r3, r2
 800b5e4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b5e6:	b29b      	uxth	r3, r3
 800b5e8:	005b      	lsls	r3, r3, #1
 800b5ea:	b29b      	uxth	r3, r3
 800b5ec:	461a      	mov	r2, r3
 800b5ee:	4b12      	ldr	r3, [pc, #72]	; (800b638 <GetRtc+0x1e4>)
 800b5f0:	4798      	blx	r3
		tmpPointer += tmp;
 800b5f2:	4b0e      	ldr	r3, [pc, #56]	; (800b62c <GetRtc+0x1d8>)
 800b5f4:	681a      	ldr	r2, [r3, #0]
 800b5f6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b5f8:	4413      	add	r3, r2
 800b5fa:	4a0c      	ldr	r2, [pc, #48]	; (800b62c <GetRtc+0x1d8>)
 800b5fc:	6013      	str	r3, [r2, #0]
		wr += tmp;
 800b5fe:	6b7a      	ldr	r2, [r7, #52]	; 0x34
 800b600:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b602:	4413      	add	r3, r2
 800b604:	637b      	str	r3, [r7, #52]	; 0x34
		tmpLen -= tmp;
 800b606:	4b0a      	ldr	r3, [pc, #40]	; (800b630 <GetRtc+0x1dc>)
 800b608:	681a      	ldr	r2, [r3, #0]
 800b60a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800b60c:	1ad3      	subs	r3, r2, r3
 800b60e:	4a08      	ldr	r2, [pc, #32]	; (800b630 <GetRtc+0x1dc>)
 800b610:	6013      	str	r3, [r2, #0]
	}

	atcResetCounter();
 800b612:	4b0b      	ldr	r3, [pc, #44]	; (800b640 <GetRtc+0x1ec>)
 800b614:	4798      	blx	r3
	CountReset = 0;
 800b616:	4b0b      	ldr	r3, [pc, #44]	; (800b644 <GetRtc+0x1f0>)
 800b618:	2200      	movs	r2, #0
 800b61a:	801a      	strh	r2, [r3, #0]
	return true;
 800b61c:	2301      	movs	r3, #1
}
 800b61e:	4618      	mov	r0, r3
 800b620:	3738      	adds	r7, #56	; 0x38
 800b622:	46bd      	mov	sp, r7
 800b624:	bd80      	pop	{r7, pc}
 800b626:	bf00      	nop
 800b628:	0802b000 	.word	0x0802b000
 800b62c:	20007c60 	.word	0x20007c60
 800b630:	20007c64 	.word	0x20007c64
 800b634:	0800548d 	.word	0x0800548d
 800b638:	08006b8d 	.word	0x08006b8d
 800b63c:	0800594d 	.word	0x0800594d
 800b640:	080063c1 	.word	0x080063c1
 800b644:	2000942c 	.word	0x2000942c

0800b648 <SetRtc>:
//==============================================================================
bool SetRtc(uint16 addr, uint16 *pxSrc, uint16 len) {
 800b648:	b580      	push	{r7, lr}
 800b64a:	b08c      	sub	sp, #48	; 0x30
 800b64c:	af00      	add	r7, sp, #0
 800b64e:	4603      	mov	r3, r0
 800b650:	6039      	str	r1, [r7, #0]
 800b652:	80fb      	strh	r3, [r7, #6]
 800b654:	4613      	mov	r3, r2
 800b656:	80bb      	strh	r3, [r7, #4]
	FLASHMEM *pxConfig = (FLASHMEM*) DEVICE_FLASHMEM_LOCATION;
 800b658:	4b39      	ldr	r3, [pc, #228]	; (800b740 <SetRtc+0xf8>)
 800b65a:	62fb      	str	r3, [r7, #44]	; 0x2c
	DATATIME temprtc;

	char iFixstr[16];

	if (addr >= 0x20) {
 800b65c:	88fb      	ldrh	r3, [r7, #6]
 800b65e:	2b1f      	cmp	r3, #31
 800b660:	d913      	bls.n	800b68a <SetRtc+0x42>
		rtcGetiFixDateTime(iFixstr);
 800b662:	f107 030c 	add.w	r3, r7, #12
 800b666:	4618      	mov	r0, r3
 800b668:	4b36      	ldr	r3, [pc, #216]	; (800b744 <SetRtc+0xfc>)
 800b66a:	4798      	blx	r3
		CopyDataBytes((uint8*) pxSrc, (uint8*) iFixstr, len * 2);
 800b66c:	88bb      	ldrh	r3, [r7, #4]
 800b66e:	005b      	lsls	r3, r3, #1
 800b670:	b29a      	uxth	r2, r3
 800b672:	f107 030c 	add.w	r3, r7, #12
 800b676:	4619      	mov	r1, r3
 800b678:	6838      	ldr	r0, [r7, #0]
 800b67a:	4b33      	ldr	r3, [pc, #204]	; (800b748 <SetRtc+0x100>)
 800b67c:	4798      	blx	r3
		rtcSetiFixDateTime(iFixstr);
 800b67e:	f107 030c 	add.w	r3, r7, #12
 800b682:	4618      	mov	r0, r3
 800b684:	4b31      	ldr	r3, [pc, #196]	; (800b74c <SetRtc+0x104>)
 800b686:	4798      	blx	r3
 800b688:	e050      	b.n	800b72c <SetRtc+0xe4>
	} else if (addr < 0x08) {
 800b68a:	88fb      	ldrh	r3, [r7, #6]
 800b68c:	2b07      	cmp	r3, #7
 800b68e:	d823      	bhi.n	800b6d8 <SetRtc+0x90>
		rtcGetDataTime(&temprtc);
 800b690:	f107 031c 	add.w	r3, r7, #28
 800b694:	4618      	mov	r0, r3
 800b696:	4b2e      	ldr	r3, [pc, #184]	; (800b750 <SetRtc+0x108>)
 800b698:	4798      	blx	r3
		CopyDataBytes((uint8*) pxSrc, (uint8*) ((uint8*) (&temprtc) + addr * 2),
 800b69a:	88fb      	ldrh	r3, [r7, #6]
 800b69c:	005b      	lsls	r3, r3, #1
 800b69e:	461a      	mov	r2, r3
 800b6a0:	f107 031c 	add.w	r3, r7, #28
 800b6a4:	1899      	adds	r1, r3, r2
				((len + addr > 0x08) ? (8 - addr) : (len)) * 2);
 800b6a6:	88ba      	ldrh	r2, [r7, #4]
 800b6a8:	88fb      	ldrh	r3, [r7, #6]
 800b6aa:	4413      	add	r3, r2
		CopyDataBytes((uint8*) pxSrc, (uint8*) ((uint8*) (&temprtc) + addr * 2),
 800b6ac:	2b08      	cmp	r3, #8
 800b6ae:	dd06      	ble.n	800b6be <SetRtc+0x76>
				((len + addr > 0x08) ? (8 - addr) : (len)) * 2);
 800b6b0:	88fb      	ldrh	r3, [r7, #6]
 800b6b2:	f1c3 0308 	rsb	r3, r3, #8
		CopyDataBytes((uint8*) pxSrc, (uint8*) ((uint8*) (&temprtc) + addr * 2),
 800b6b6:	b29b      	uxth	r3, r3
 800b6b8:	005b      	lsls	r3, r3, #1
 800b6ba:	b29b      	uxth	r3, r3
 800b6bc:	e002      	b.n	800b6c4 <SetRtc+0x7c>
 800b6be:	88bb      	ldrh	r3, [r7, #4]
 800b6c0:	005b      	lsls	r3, r3, #1
 800b6c2:	b29b      	uxth	r3, r3
 800b6c4:	461a      	mov	r2, r3
 800b6c6:	6838      	ldr	r0, [r7, #0]
 800b6c8:	4b1f      	ldr	r3, [pc, #124]	; (800b748 <SetRtc+0x100>)
 800b6ca:	4798      	blx	r3
		rtcSetDataTime(&temprtc);
 800b6cc:	f107 031c 	add.w	r3, r7, #28
 800b6d0:	4618      	mov	r0, r3
 800b6d2:	4b20      	ldr	r3, [pc, #128]	; (800b754 <SetRtc+0x10c>)
 800b6d4:	4798      	blx	r3
 800b6d6:	e029      	b.n	800b72c <SetRtc+0xe4>
	} else if (addr >= 0x08 && addr < 0x10) {
 800b6d8:	88fb      	ldrh	r3, [r7, #6]
 800b6da:	2b07      	cmp	r3, #7
 800b6dc:	d926      	bls.n	800b72c <SetRtc+0xe4>
 800b6de:	88fb      	ldrh	r3, [r7, #6]
 800b6e0:	2b0f      	cmp	r3, #15
 800b6e2:	d823      	bhi.n	800b72c <SetRtc+0xe4>
		rtcGetDataTime(&temprtc);
 800b6e4:	f107 031c 	add.w	r3, r7, #28
 800b6e8:	4618      	mov	r0, r3
 800b6ea:	4b19      	ldr	r3, [pc, #100]	; (800b750 <SetRtc+0x108>)
 800b6ec:	4798      	blx	r3
		//rtcGetLocalDataTime(&temprtc);
		CopyDataBytes((uint8*) pxSrc,
				(uint8*) ((uint8*) (&temprtc) + (addr - 0x08) * 2),
 800b6ee:	88fb      	ldrh	r3, [r7, #6]
 800b6f0:	3b08      	subs	r3, #8
 800b6f2:	005b      	lsls	r3, r3, #1
 800b6f4:	461a      	mov	r2, r3
		CopyDataBytes((uint8*) pxSrc,
 800b6f6:	f107 031c 	add.w	r3, r7, #28
 800b6fa:	1899      	adds	r1, r3, r2
				((len + addr > 0x10) ? (0x10 - addr) : (len)) * 2);
 800b6fc:	88ba      	ldrh	r2, [r7, #4]
 800b6fe:	88fb      	ldrh	r3, [r7, #6]
 800b700:	4413      	add	r3, r2
		CopyDataBytes((uint8*) pxSrc,
 800b702:	2b10      	cmp	r3, #16
 800b704:	dd06      	ble.n	800b714 <SetRtc+0xcc>
				((len + addr > 0x10) ? (0x10 - addr) : (len)) * 2);
 800b706:	88fb      	ldrh	r3, [r7, #6]
 800b708:	f1c3 0310 	rsb	r3, r3, #16
		CopyDataBytes((uint8*) pxSrc,
 800b70c:	b29b      	uxth	r3, r3
 800b70e:	005b      	lsls	r3, r3, #1
 800b710:	b29b      	uxth	r3, r3
 800b712:	e002      	b.n	800b71a <SetRtc+0xd2>
 800b714:	88bb      	ldrh	r3, [r7, #4]
 800b716:	005b      	lsls	r3, r3, #1
 800b718:	b29b      	uxth	r3, r3
 800b71a:	461a      	mov	r2, r3
 800b71c:	6838      	ldr	r0, [r7, #0]
 800b71e:	4b0a      	ldr	r3, [pc, #40]	; (800b748 <SetRtc+0x100>)
 800b720:	4798      	blx	r3
		rtcSetDataTime(&temprtc);
 800b722:	f107 031c 	add.w	r3, r7, #28
 800b726:	4618      	mov	r0, r3
 800b728:	4b0a      	ldr	r3, [pc, #40]	; (800b754 <SetRtc+0x10c>)
 800b72a:	4798      	blx	r3
		//rtcSetLocalDataTime(&temprtc);
	}

	atcResetCounter();
 800b72c:	4b0a      	ldr	r3, [pc, #40]	; (800b758 <SetRtc+0x110>)
 800b72e:	4798      	blx	r3
	CountReset = 0;
 800b730:	4b0a      	ldr	r3, [pc, #40]	; (800b75c <SetRtc+0x114>)
 800b732:	2200      	movs	r2, #0
 800b734:	801a      	strh	r2, [r3, #0]
	return true;
 800b736:	2301      	movs	r3, #1
}
 800b738:	4618      	mov	r0, r3
 800b73a:	3730      	adds	r7, #48	; 0x30
 800b73c:	46bd      	mov	sp, r7
 800b73e:	bd80      	pop	{r7, pc}
 800b740:	0802b000 	.word	0x0802b000
 800b744:	0800594d 	.word	0x0800594d
 800b748:	08006b8d 	.word	0x08006b8d
 800b74c:	08005a79 	.word	0x08005a79
 800b750:	0800548d 	.word	0x0800548d
 800b754:	080054e5 	.word	0x080054e5
 800b758:	080063c1 	.word	0x080063c1
 800b75c:	2000942c 	.word	0x2000942c

0800b760 <GetFlash>:
//==============================================================================

//==============================================================================
bool GetFlash(uint16 addr, uint16 *pxDsn, uint16 len) {
 800b760:	b580      	push	{r7, lr}
 800b762:	b084      	sub	sp, #16
 800b764:	af00      	add	r7, sp, #0
 800b766:	4603      	mov	r3, r0
 800b768:	6039      	str	r1, [r7, #0]
 800b76a:	80fb      	strh	r3, [r7, #6]
 800b76c:	4613      	mov	r3, r2
 800b76e:	80bb      	strh	r3, [r7, #4]
	FLASHMEM *pxConfig = (FLASHMEM*) DEVICE_FLASHMEM_LOCATION;
 800b770:	4b0c      	ldr	r3, [pc, #48]	; (800b7a4 <GetFlash+0x44>)
 800b772:	60fb      	str	r3, [r7, #12]
	void *pxFlash = (void*) (DEVICE_FLASHMEM_LOCATION);
 800b774:	4b0b      	ldr	r3, [pc, #44]	; (800b7a4 <GetFlash+0x44>)
 800b776:	60bb      	str	r3, [r7, #8]
	//pxFlash = (void*) ((int) pxFlash + addr * 2);
	CopyDataBytes(((uint8*) pxFlash) + addr * 2, (uint8*) pxDsn, len * 2);
 800b778:	88fb      	ldrh	r3, [r7, #6]
 800b77a:	005b      	lsls	r3, r3, #1
 800b77c:	461a      	mov	r2, r3
 800b77e:	68bb      	ldr	r3, [r7, #8]
 800b780:	1898      	adds	r0, r3, r2
 800b782:	88bb      	ldrh	r3, [r7, #4]
 800b784:	005b      	lsls	r3, r3, #1
 800b786:	b29b      	uxth	r3, r3
 800b788:	461a      	mov	r2, r3
 800b78a:	6839      	ldr	r1, [r7, #0]
 800b78c:	4b06      	ldr	r3, [pc, #24]	; (800b7a8 <GetFlash+0x48>)
 800b78e:	4798      	blx	r3
	atcResetCounter();
 800b790:	4b06      	ldr	r3, [pc, #24]	; (800b7ac <GetFlash+0x4c>)
 800b792:	4798      	blx	r3
	CountReset = 0;
 800b794:	4b06      	ldr	r3, [pc, #24]	; (800b7b0 <GetFlash+0x50>)
 800b796:	2200      	movs	r2, #0
 800b798:	801a      	strh	r2, [r3, #0]
	return true;
 800b79a:	2301      	movs	r3, #1
}
 800b79c:	4618      	mov	r0, r3
 800b79e:	3710      	adds	r7, #16
 800b7a0:	46bd      	mov	sp, r7
 800b7a2:	bd80      	pop	{r7, pc}
 800b7a4:	0802b000 	.word	0x0802b000
 800b7a8:	08006b8d 	.word	0x08006b8d
 800b7ac:	080063c1 	.word	0x080063c1
 800b7b0:	2000942c 	.word	0x2000942c

0800b7b4 <SetFlash>:
//==============================================================================
bool SetFlash(uint16 addr, uint16 *pxSrc, uint16 len) {
 800b7b4:	b580      	push	{r7, lr}
 800b7b6:	b086      	sub	sp, #24
 800b7b8:	af00      	add	r7, sp, #0
 800b7ba:	4603      	mov	r3, r0
 800b7bc:	6039      	str	r1, [r7, #0]
 800b7be:	80fb      	strh	r3, [r7, #6]
 800b7c0:	4613      	mov	r3, r2
 800b7c2:	80bb      	strh	r3, [r7, #4]

	FLASHMEM *pxConfig = (FLASHMEM*) DEVICE_FLASHMEM_LOCATION;
 800b7c4:	4b98      	ldr	r3, [pc, #608]	; (800ba28 <SetFlash+0x274>)
 800b7c6:	617b      	str	r3, [r7, #20]

	uint16 tempadr = addr;
 800b7c8:	88fb      	ldrh	r3, [r7, #6]
 800b7ca:	827b      	strh	r3, [r7, #18]
	uint16 page = addr / 0x400;
 800b7cc:	88fb      	ldrh	r3, [r7, #6]
 800b7ce:	0a9b      	lsrs	r3, r3, #10
 800b7d0:	823b      	strh	r3, [r7, #16]
	uint16 pageEnd = (addr + len) / 0x400;
 800b7d2:	88fa      	ldrh	r2, [r7, #6]
 800b7d4:	88bb      	ldrh	r3, [r7, #4]
 800b7d6:	4413      	add	r3, r2
 800b7d8:	2b00      	cmp	r3, #0
 800b7da:	da01      	bge.n	800b7e0 <SetFlash+0x2c>
 800b7dc:	f203 33ff 	addw	r3, r3, #1023	; 0x3ff
 800b7e0:	129b      	asrs	r3, r3, #10
 800b7e2:	81fb      	strh	r3, [r7, #14]
	uint16 pageOffset = addr % 0x400;
 800b7e4:	88fb      	ldrh	r3, [r7, #6]
 800b7e6:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800b7ea:	81bb      	strh	r3, [r7, #12]
	uint16 pageEndOffset = (addr + len) % 0x400;
 800b7ec:	88fa      	ldrh	r2, [r7, #6]
 800b7ee:	88bb      	ldrh	r3, [r7, #4]
 800b7f0:	4413      	add	r3, r2
 800b7f2:	b29b      	uxth	r3, r3
 800b7f4:	f3c3 0309 	ubfx	r3, r3, #0, #10
 800b7f8:	817b      	strh	r3, [r7, #10]
	FLASH_Status status;
	//vTaskDelay(100);
	FLASH_Unlock();
 800b7fa:	4b8c      	ldr	r3, [pc, #560]	; (800ba2c <SetFlash+0x278>)
 800b7fc:	4798      	blx	r3
	if (page != pageEnd) {
 800b7fe:	8a3a      	ldrh	r2, [r7, #16]
 800b800:	89fb      	ldrh	r3, [r7, #14]
 800b802:	429a      	cmp	r2, r3
 800b804:	f000 80af 	beq.w	800b966 <SetFlash+0x1b2>

		//=================================first part
		CopyDataBytes(
				(uint8*) ((uint8*) (DEVICE_FLASHMEM_LOCATION) + 0x800 * page),
 800b808:	8a3b      	ldrh	r3, [r7, #16]
 800b80a:	02db      	lsls	r3, r3, #11
		CopyDataBytes(
 800b80c:	f103 6300 	add.w	r3, r3, #134217728	; 0x8000000
 800b810:	f503 332c 	add.w	r3, r3, #176128	; 0x2b000
 800b814:	f44f 6200 	mov.w	r2, #2048	; 0x800
 800b818:	4985      	ldr	r1, [pc, #532]	; (800ba30 <SetFlash+0x27c>)
 800b81a:	4618      	mov	r0, r3
 800b81c:	4b85      	ldr	r3, [pc, #532]	; (800ba34 <SetFlash+0x280>)
 800b81e:	4798      	blx	r3
				(uint8*) bigFlashBuff, 0x800);
		CopyDataBytes((uint8*) pxSrc, (uint8*) (&bigFlashBuff[pageOffset]),
 800b820:	89bb      	ldrh	r3, [r7, #12]
 800b822:	005b      	lsls	r3, r3, #1
 800b824:	4a82      	ldr	r2, [pc, #520]	; (800ba30 <SetFlash+0x27c>)
 800b826:	1899      	adds	r1, r3, r2
				(0x400 - pageOffset) * 2);
 800b828:	89bb      	ldrh	r3, [r7, #12]
 800b82a:	f5c3 6380 	rsb	r3, r3, #1024	; 0x400
		CopyDataBytes((uint8*) pxSrc, (uint8*) (&bigFlashBuff[pageOffset]),
 800b82e:	b29b      	uxth	r3, r3
 800b830:	005b      	lsls	r3, r3, #1
 800b832:	b29b      	uxth	r3, r3
 800b834:	461a      	mov	r2, r3
 800b836:	6838      	ldr	r0, [r7, #0]
 800b838:	4b7e      	ldr	r3, [pc, #504]	; (800ba34 <SetFlash+0x280>)
 800b83a:	4798      	blx	r3

		while (FLASH_ErasePage(DEVICE_FLASHMEM_LOCATION + 0x800 * page)
 800b83c:	e009      	b.n	800b852 <SetFlash+0x9e>
				!= FLASH_COMPLETE) {
			status = FLASH_GetStatus();
 800b83e:	4b7e      	ldr	r3, [pc, #504]	; (800ba38 <SetFlash+0x284>)
 800b840:	4798      	blx	r3
 800b842:	4603      	mov	r3, r0
 800b844:	727b      	strb	r3, [r7, #9]
			FLASH_ClearFlag(
 800b846:	2034      	movs	r0, #52	; 0x34
 800b848:	4b7c      	ldr	r3, [pc, #496]	; (800ba3c <SetFlash+0x288>)
 800b84a:	4798      	blx	r3
					FLASH_FLAG_EOP | FLASH_FLAG_PGERR | FLASH_FLAG_WRPRTERR);
			vTaskDelay(20);
 800b84c:	2014      	movs	r0, #20
 800b84e:	4b7c      	ldr	r3, [pc, #496]	; (800ba40 <SetFlash+0x28c>)
 800b850:	4798      	blx	r3
		while (FLASH_ErasePage(DEVICE_FLASHMEM_LOCATION + 0x800 * page)
 800b852:	8a3b      	ldrh	r3, [r7, #16]
 800b854:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
 800b858:	3356      	adds	r3, #86	; 0x56
 800b85a:	02db      	lsls	r3, r3, #11
 800b85c:	4618      	mov	r0, r3
 800b85e:	4b79      	ldr	r3, [pc, #484]	; (800ba44 <SetFlash+0x290>)
 800b860:	4798      	blx	r3
 800b862:	4603      	mov	r3, r0
 800b864:	2b04      	cmp	r3, #4
 800b866:	d1ea      	bne.n	800b83e <SetFlash+0x8a>
		}

		WriteFlash((void*) (bigFlashBuff),
				(void*) ((uint8*) (DEVICE_FLASHMEM_LOCATION) + 0x800 * page),
 800b868:	8a3b      	ldrh	r3, [r7, #16]
 800b86a:	02db      	lsls	r3, r3, #11
 800b86c:	f103 6300 	add.w	r3, r3, #134217728	; 0x8000000
 800b870:	f503 332c 	add.w	r3, r3, #176128	; 0x2b000
		WriteFlash((void*) (bigFlashBuff),
 800b874:	f44f 6200 	mov.w	r2, #2048	; 0x800
 800b878:	4619      	mov	r1, r3
 800b87a:	486d      	ldr	r0, [pc, #436]	; (800ba30 <SetFlash+0x27c>)
 800b87c:	4b72      	ldr	r3, [pc, #456]	; (800ba48 <SetFlash+0x294>)
 800b87e:	4798      	blx	r3
				0x800);
		vTaskDelay(100);
 800b880:	2064      	movs	r0, #100	; 0x64
 800b882:	4b6f      	ldr	r3, [pc, #444]	; (800ba40 <SetFlash+0x28c>)
 800b884:	4798      	blx	r3

		while (FLASH_GetStatus() != FLASH_COMPLETE) {
 800b886:	e011      	b.n	800b8ac <SetFlash+0xf8>
			FLASH_ClearFlag(
 800b888:	2034      	movs	r0, #52	; 0x34
 800b88a:	4b6c      	ldr	r3, [pc, #432]	; (800ba3c <SetFlash+0x288>)
 800b88c:	4798      	blx	r3
					FLASH_FLAG_EOP | FLASH_FLAG_PGERR | FLASH_FLAG_WRPRTERR);
			WriteFlash((void*) (bigFlashBuff),
					(void*) ((uint8*) (DEVICE_FLASHMEM_LOCATION) + 0x800 * page),
 800b88e:	8a3b      	ldrh	r3, [r7, #16]
 800b890:	02db      	lsls	r3, r3, #11
 800b892:	f103 6300 	add.w	r3, r3, #134217728	; 0x8000000
 800b896:	f503 332c 	add.w	r3, r3, #176128	; 0x2b000
			WriteFlash((void*) (bigFlashBuff),
 800b89a:	f44f 6200 	mov.w	r2, #2048	; 0x800
 800b89e:	4619      	mov	r1, r3
 800b8a0:	4863      	ldr	r0, [pc, #396]	; (800ba30 <SetFlash+0x27c>)
 800b8a2:	4b69      	ldr	r3, [pc, #420]	; (800ba48 <SetFlash+0x294>)
 800b8a4:	4798      	blx	r3
					0x800);
			vTaskDelay(100);
 800b8a6:	2064      	movs	r0, #100	; 0x64
 800b8a8:	4b65      	ldr	r3, [pc, #404]	; (800ba40 <SetFlash+0x28c>)
 800b8aa:	4798      	blx	r3
		while (FLASH_GetStatus() != FLASH_COMPLETE) {
 800b8ac:	4b62      	ldr	r3, [pc, #392]	; (800ba38 <SetFlash+0x284>)
 800b8ae:	4798      	blx	r3
 800b8b0:	4603      	mov	r3, r0
 800b8b2:	2b04      	cmp	r3, #4
 800b8b4:	d1e8      	bne.n	800b888 <SetFlash+0xd4>
		}
		//=================================Second part
		CopyDataBytes(
				(uint8*) ((uint8*) (DEVICE_FLASHMEM_LOCATION) + 0x800 * pageEnd),
 800b8b6:	89fb      	ldrh	r3, [r7, #14]
 800b8b8:	02db      	lsls	r3, r3, #11
		CopyDataBytes(
 800b8ba:	f103 6300 	add.w	r3, r3, #134217728	; 0x8000000
 800b8be:	f503 332c 	add.w	r3, r3, #176128	; 0x2b000
 800b8c2:	f44f 6200 	mov.w	r2, #2048	; 0x800
 800b8c6:	495a      	ldr	r1, [pc, #360]	; (800ba30 <SetFlash+0x27c>)
 800b8c8:	4618      	mov	r0, r3
 800b8ca:	4b5a      	ldr	r3, [pc, #360]	; (800ba34 <SetFlash+0x280>)
 800b8cc:	4798      	blx	r3
				(uint8*) bigFlashBuff, 0x800);
		CopyDataBytes(((uint8*) pxSrc) + (len - pageEndOffset) * 2,
 800b8ce:	88ba      	ldrh	r2, [r7, #4]
 800b8d0:	897b      	ldrh	r3, [r7, #10]
 800b8d2:	1ad3      	subs	r3, r2, r3
 800b8d4:	005b      	lsls	r3, r3, #1
 800b8d6:	461a      	mov	r2, r3
 800b8d8:	683b      	ldr	r3, [r7, #0]
 800b8da:	1898      	adds	r0, r3, r2
 800b8dc:	897b      	ldrh	r3, [r7, #10]
 800b8de:	005b      	lsls	r3, r3, #1
 800b8e0:	b29b      	uxth	r3, r3
 800b8e2:	461a      	mov	r2, r3
 800b8e4:	4952      	ldr	r1, [pc, #328]	; (800ba30 <SetFlash+0x27c>)
 800b8e6:	4b53      	ldr	r3, [pc, #332]	; (800ba34 <SetFlash+0x280>)
 800b8e8:	4798      	blx	r3
				(uint8*) (&bigFlashBuff[0]), pageEndOffset * 2);

		while (FLASH_ErasePage(DEVICE_FLASHMEM_LOCATION + 0x800 * pageEnd)
 800b8ea:	e009      	b.n	800b900 <SetFlash+0x14c>
				!= FLASH_COMPLETE) {
			status = FLASH_GetStatus();
 800b8ec:	4b52      	ldr	r3, [pc, #328]	; (800ba38 <SetFlash+0x284>)
 800b8ee:	4798      	blx	r3
 800b8f0:	4603      	mov	r3, r0
 800b8f2:	727b      	strb	r3, [r7, #9]
			FLASH_ClearFlag(
 800b8f4:	2034      	movs	r0, #52	; 0x34
 800b8f6:	4b51      	ldr	r3, [pc, #324]	; (800ba3c <SetFlash+0x288>)
 800b8f8:	4798      	blx	r3
					FLASH_FLAG_EOP | FLASH_FLAG_PGERR | FLASH_FLAG_WRPRTERR);
			vTaskDelay(20);
 800b8fa:	2014      	movs	r0, #20
 800b8fc:	4b50      	ldr	r3, [pc, #320]	; (800ba40 <SetFlash+0x28c>)
 800b8fe:	4798      	blx	r3
		while (FLASH_ErasePage(DEVICE_FLASHMEM_LOCATION + 0x800 * pageEnd)
 800b900:	89fb      	ldrh	r3, [r7, #14]
 800b902:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
 800b906:	3356      	adds	r3, #86	; 0x56
 800b908:	02db      	lsls	r3, r3, #11
 800b90a:	4618      	mov	r0, r3
 800b90c:	4b4d      	ldr	r3, [pc, #308]	; (800ba44 <SetFlash+0x290>)
 800b90e:	4798      	blx	r3
 800b910:	4603      	mov	r3, r0
 800b912:	2b04      	cmp	r3, #4
 800b914:	d1ea      	bne.n	800b8ec <SetFlash+0x138>
		}

		WriteFlash((void*) (bigFlashBuff),
				(void*) ((uint8*) (DEVICE_FLASHMEM_LOCATION) + 0x800 * pageEnd),
 800b916:	89fb      	ldrh	r3, [r7, #14]
 800b918:	02db      	lsls	r3, r3, #11
 800b91a:	f103 6300 	add.w	r3, r3, #134217728	; 0x8000000
 800b91e:	f503 332c 	add.w	r3, r3, #176128	; 0x2b000
		WriteFlash((void*) (bigFlashBuff),
 800b922:	f44f 6200 	mov.w	r2, #2048	; 0x800
 800b926:	4619      	mov	r1, r3
 800b928:	4841      	ldr	r0, [pc, #260]	; (800ba30 <SetFlash+0x27c>)
 800b92a:	4b47      	ldr	r3, [pc, #284]	; (800ba48 <SetFlash+0x294>)
 800b92c:	4798      	blx	r3
				0x800);
		vTaskDelay(100);
 800b92e:	2064      	movs	r0, #100	; 0x64
 800b930:	4b43      	ldr	r3, [pc, #268]	; (800ba40 <SetFlash+0x28c>)
 800b932:	4798      	blx	r3
		while (FLASH_GetStatus() != FLASH_COMPLETE) {
 800b934:	e011      	b.n	800b95a <SetFlash+0x1a6>
			FLASH_ClearFlag(
 800b936:	2034      	movs	r0, #52	; 0x34
 800b938:	4b40      	ldr	r3, [pc, #256]	; (800ba3c <SetFlash+0x288>)
 800b93a:	4798      	blx	r3
					FLASH_FLAG_EOP | FLASH_FLAG_PGERR | FLASH_FLAG_WRPRTERR);
			WriteFlash((void*) (bigFlashBuff),
					(void*) ((uint8*) (DEVICE_FLASHMEM_LOCATION)
							+ 0x800 * pageEnd), 0x800);
 800b93c:	89fb      	ldrh	r3, [r7, #14]
 800b93e:	02db      	lsls	r3, r3, #11
 800b940:	f103 6300 	add.w	r3, r3, #134217728	; 0x8000000
 800b944:	f503 332c 	add.w	r3, r3, #176128	; 0x2b000
			WriteFlash((void*) (bigFlashBuff),
 800b948:	f44f 6200 	mov.w	r2, #2048	; 0x800
 800b94c:	4619      	mov	r1, r3
 800b94e:	4838      	ldr	r0, [pc, #224]	; (800ba30 <SetFlash+0x27c>)
 800b950:	4b3d      	ldr	r3, [pc, #244]	; (800ba48 <SetFlash+0x294>)
 800b952:	4798      	blx	r3
			vTaskDelay(100);
 800b954:	2064      	movs	r0, #100	; 0x64
 800b956:	4b3a      	ldr	r3, [pc, #232]	; (800ba40 <SetFlash+0x28c>)
 800b958:	4798      	blx	r3
		while (FLASH_GetStatus() != FLASH_COMPLETE) {
 800b95a:	4b37      	ldr	r3, [pc, #220]	; (800ba38 <SetFlash+0x284>)
 800b95c:	4798      	blx	r3
 800b95e:	4603      	mov	r3, r0
 800b960:	2b04      	cmp	r3, #4
 800b962:	d1e8      	bne.n	800b936 <SetFlash+0x182>
 800b964:	e053      	b.n	800ba0e <SetFlash+0x25a>
		}
	} else {
		CopyDataBytes(
				(uint8*) ((uint8*) (DEVICE_FLASHMEM_LOCATION) + 0x800 * page),
 800b966:	8a3b      	ldrh	r3, [r7, #16]
 800b968:	02db      	lsls	r3, r3, #11
		CopyDataBytes(
 800b96a:	f103 6300 	add.w	r3, r3, #134217728	; 0x8000000
 800b96e:	f503 332c 	add.w	r3, r3, #176128	; 0x2b000
 800b972:	f44f 6200 	mov.w	r2, #2048	; 0x800
 800b976:	492e      	ldr	r1, [pc, #184]	; (800ba30 <SetFlash+0x27c>)
 800b978:	4618      	mov	r0, r3
 800b97a:	4b2e      	ldr	r3, [pc, #184]	; (800ba34 <SetFlash+0x280>)
 800b97c:	4798      	blx	r3
				(uint8*) bigFlashBuff, 0x800);
		CopyDataBytes((uint8*) pxSrc, (uint8*) (&bigFlashBuff[pageOffset]),
 800b97e:	89bb      	ldrh	r3, [r7, #12]
 800b980:	005b      	lsls	r3, r3, #1
 800b982:	4a2b      	ldr	r2, [pc, #172]	; (800ba30 <SetFlash+0x27c>)
 800b984:	1899      	adds	r1, r3, r2
 800b986:	88bb      	ldrh	r3, [r7, #4]
 800b988:	005b      	lsls	r3, r3, #1
 800b98a:	b29b      	uxth	r3, r3
 800b98c:	461a      	mov	r2, r3
 800b98e:	6838      	ldr	r0, [r7, #0]
 800b990:	4b28      	ldr	r3, [pc, #160]	; (800ba34 <SetFlash+0x280>)
 800b992:	4798      	blx	r3
				len * 2);

		while (FLASH_ErasePage(DEVICE_FLASHMEM_LOCATION + 0x800 * page)
 800b994:	e009      	b.n	800b9aa <SetFlash+0x1f6>
				!= FLASH_COMPLETE) {
			status = FLASH_GetStatus();
 800b996:	4b28      	ldr	r3, [pc, #160]	; (800ba38 <SetFlash+0x284>)
 800b998:	4798      	blx	r3
 800b99a:	4603      	mov	r3, r0
 800b99c:	727b      	strb	r3, [r7, #9]
			FLASH_ClearFlag(
 800b99e:	2034      	movs	r0, #52	; 0x34
 800b9a0:	4b26      	ldr	r3, [pc, #152]	; (800ba3c <SetFlash+0x288>)
 800b9a2:	4798      	blx	r3
					FLASH_FLAG_EOP | FLASH_FLAG_PGERR | FLASH_FLAG_WRPRTERR);
			vTaskDelay(20);
 800b9a4:	2014      	movs	r0, #20
 800b9a6:	4b26      	ldr	r3, [pc, #152]	; (800ba40 <SetFlash+0x28c>)
 800b9a8:	4798      	blx	r3
		while (FLASH_ErasePage(DEVICE_FLASHMEM_LOCATION + 0x800 * page)
 800b9aa:	8a3b      	ldrh	r3, [r7, #16]
 800b9ac:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
 800b9b0:	3356      	adds	r3, #86	; 0x56
 800b9b2:	02db      	lsls	r3, r3, #11
 800b9b4:	4618      	mov	r0, r3
 800b9b6:	4b23      	ldr	r3, [pc, #140]	; (800ba44 <SetFlash+0x290>)
 800b9b8:	4798      	blx	r3
 800b9ba:	4603      	mov	r3, r0
 800b9bc:	2b04      	cmp	r3, #4
 800b9be:	d1ea      	bne.n	800b996 <SetFlash+0x1e2>
		}

		WriteFlash((void*) (bigFlashBuff),
				(void*) ((uint8*) (DEVICE_FLASHMEM_LOCATION) + 0x800 * page),
 800b9c0:	8a3b      	ldrh	r3, [r7, #16]
 800b9c2:	02db      	lsls	r3, r3, #11
 800b9c4:	f103 6300 	add.w	r3, r3, #134217728	; 0x8000000
 800b9c8:	f503 332c 	add.w	r3, r3, #176128	; 0x2b000
		WriteFlash((void*) (bigFlashBuff),
 800b9cc:	f44f 6200 	mov.w	r2, #2048	; 0x800
 800b9d0:	4619      	mov	r1, r3
 800b9d2:	4817      	ldr	r0, [pc, #92]	; (800ba30 <SetFlash+0x27c>)
 800b9d4:	4b1c      	ldr	r3, [pc, #112]	; (800ba48 <SetFlash+0x294>)
 800b9d6:	4798      	blx	r3
				0x800);
		vTaskDelay(100);
 800b9d8:	2064      	movs	r0, #100	; 0x64
 800b9da:	4b19      	ldr	r3, [pc, #100]	; (800ba40 <SetFlash+0x28c>)
 800b9dc:	4798      	blx	r3
		while (FLASH_GetStatus() != FLASH_COMPLETE) {
 800b9de:	e011      	b.n	800ba04 <SetFlash+0x250>
			FLASH_ClearFlag(
 800b9e0:	2034      	movs	r0, #52	; 0x34
 800b9e2:	4b16      	ldr	r3, [pc, #88]	; (800ba3c <SetFlash+0x288>)
 800b9e4:	4798      	blx	r3
					FLASH_FLAG_EOP | FLASH_FLAG_PGERR | FLASH_FLAG_WRPRTERR);
			WriteFlash((void*) (bigFlashBuff),
					(void*) ((uint8*) (DEVICE_FLASHMEM_LOCATION) + 0x800 * page),
 800b9e6:	8a3b      	ldrh	r3, [r7, #16]
 800b9e8:	02db      	lsls	r3, r3, #11
 800b9ea:	f103 6300 	add.w	r3, r3, #134217728	; 0x8000000
 800b9ee:	f503 332c 	add.w	r3, r3, #176128	; 0x2b000
			WriteFlash((void*) (bigFlashBuff),
 800b9f2:	f44f 6200 	mov.w	r2, #2048	; 0x800
 800b9f6:	4619      	mov	r1, r3
 800b9f8:	480d      	ldr	r0, [pc, #52]	; (800ba30 <SetFlash+0x27c>)
 800b9fa:	4b13      	ldr	r3, [pc, #76]	; (800ba48 <SetFlash+0x294>)
 800b9fc:	4798      	blx	r3
					0x800);
			vTaskDelay(100);
 800b9fe:	2064      	movs	r0, #100	; 0x64
 800ba00:	4b0f      	ldr	r3, [pc, #60]	; (800ba40 <SetFlash+0x28c>)
 800ba02:	4798      	blx	r3
		while (FLASH_GetStatus() != FLASH_COMPLETE) {
 800ba04:	4b0c      	ldr	r3, [pc, #48]	; (800ba38 <SetFlash+0x284>)
 800ba06:	4798      	blx	r3
 800ba08:	4603      	mov	r3, r0
 800ba0a:	2b04      	cmp	r3, #4
 800ba0c:	d1e8      	bne.n	800b9e0 <SetFlash+0x22c>
		}
	}
	FLASH_Lock();
 800ba0e:	4b0f      	ldr	r3, [pc, #60]	; (800ba4c <SetFlash+0x298>)
 800ba10:	4798      	blx	r3
	atcResetCounter();
 800ba12:	4b0f      	ldr	r3, [pc, #60]	; (800ba50 <SetFlash+0x29c>)
 800ba14:	4798      	blx	r3
	JournalConf(tempadr);
 800ba16:	8a7b      	ldrh	r3, [r7, #18]
 800ba18:	4618      	mov	r0, r3
 800ba1a:	4b0e      	ldr	r3, [pc, #56]	; (800ba54 <SetFlash+0x2a0>)
 800ba1c:	4798      	blx	r3
	return true;
 800ba1e:	2301      	movs	r3, #1
}
 800ba20:	4618      	mov	r0, r3
 800ba22:	3718      	adds	r7, #24
 800ba24:	46bd      	mov	sp, r7
 800ba26:	bd80      	pop	{r7, pc}
 800ba28:	0802b000 	.word	0x0802b000
 800ba2c:	08002b85 	.word	0x08002b85
 800ba30:	20007c68 	.word	0x20007c68
 800ba34:	08006b8d 	.word	0x08006b8d
 800ba38:	08002c55 	.word	0x08002c55
 800ba3c:	08002c35 	.word	0x08002c35
 800ba40:	08001529 	.word	0x08001529
 800ba44:	08002bc5 	.word	0x08002bc5
 800ba48:	08002d21 	.word	0x08002d21
 800ba4c:	08002ba9 	.word	0x08002ba9
 800ba50:	080063c1 	.word	0x080063c1
 800ba54:	0800f1a1 	.word	0x0800f1a1

0800ba58 <Buffercmp>:

bool Buffercmp(uint8_t *pBuffer1, uint8_t *pBuffer2, uint16_t BufferLength) {
 800ba58:	b480      	push	{r7}
 800ba5a:	b087      	sub	sp, #28
 800ba5c:	af00      	add	r7, sp, #0
 800ba5e:	60f8      	str	r0, [r7, #12]
 800ba60:	60b9      	str	r1, [r7, #8]
 800ba62:	4613      	mov	r3, r2
 800ba64:	80fb      	strh	r3, [r7, #6]
	FLASHMEM *pxConfig = (FLASHMEM*) DEVICE_FLASHMEM_LOCATION;
 800ba66:	4b0e      	ldr	r3, [pc, #56]	; (800baa0 <Buffercmp+0x48>)
 800ba68:	617b      	str	r3, [r7, #20]
	while (BufferLength--) {
 800ba6a:	e00d      	b.n	800ba88 <Buffercmp+0x30>
		if (*pBuffer1 != *pBuffer2) {
 800ba6c:	68fb      	ldr	r3, [r7, #12]
 800ba6e:	781a      	ldrb	r2, [r3, #0]
 800ba70:	68bb      	ldr	r3, [r7, #8]
 800ba72:	781b      	ldrb	r3, [r3, #0]
 800ba74:	429a      	cmp	r2, r3
 800ba76:	d001      	beq.n	800ba7c <Buffercmp+0x24>
			return false;
 800ba78:	2300      	movs	r3, #0
 800ba7a:	e00b      	b.n	800ba94 <Buffercmp+0x3c>
		}

		pBuffer1++;
 800ba7c:	68fb      	ldr	r3, [r7, #12]
 800ba7e:	3301      	adds	r3, #1
 800ba80:	60fb      	str	r3, [r7, #12]
		pBuffer2++;
 800ba82:	68bb      	ldr	r3, [r7, #8]
 800ba84:	3301      	adds	r3, #1
 800ba86:	60bb      	str	r3, [r7, #8]
	while (BufferLength--) {
 800ba88:	88fb      	ldrh	r3, [r7, #6]
 800ba8a:	1e5a      	subs	r2, r3, #1
 800ba8c:	80fa      	strh	r2, [r7, #6]
 800ba8e:	2b00      	cmp	r3, #0
 800ba90:	d1ec      	bne.n	800ba6c <Buffercmp+0x14>
	}

	return true;
 800ba92:	2301      	movs	r3, #1
}
 800ba94:	4618      	mov	r0, r3
 800ba96:	371c      	adds	r7, #28
 800ba98:	46bd      	mov	sp, r7
 800ba9a:	bc80      	pop	{r7}
 800ba9c:	4770      	bx	lr
 800ba9e:	bf00      	nop
 800baa0:	0802b000 	.word	0x0802b000

0800baa4 <DiskretSet>:
   DiskretsWaveStateCount[i] = 0;
  }
}
//---------------------------------------
void DiskretSet(int num,DISKRETS vol)
{
 800baa4:	b480      	push	{r7}
 800baa6:	b083      	sub	sp, #12
 800baa8:	af00      	add	r7, sp, #0
 800baaa:	6078      	str	r0, [r7, #4]
 800baac:	460b      	mov	r3, r1
 800baae:	70fb      	strb	r3, [r7, #3]
 if( (num < DISKRETS_AMOUNT) &&
 800bab0:	687b      	ldr	r3, [r7, #4]
 800bab2:	2b0a      	cmp	r3, #10
 800bab4:	dc0d      	bgt.n	800bad2 <DiskretSet+0x2e>
 800bab6:	78fb      	ldrb	r3, [r7, #3]
 800bab8:	2b01      	cmp	r3, #1
 800baba:	d005      	beq.n	800bac8 <DiskretSet+0x24>
     ( (vol == DISKRET_STATE_ON) ||
 800babc:	78fb      	ldrb	r3, [r7, #3]
 800babe:	2b00      	cmp	r3, #0
 800bac0:	d002      	beq.n	800bac8 <DiskretSet+0x24>
       (vol == DISKRET_STATE_OFF)||
 800bac2:	78fb      	ldrb	r3, [r7, #3]
 800bac4:	2bff      	cmp	r3, #255	; 0xff
 800bac6:	d004      	beq.n	800bad2 <DiskretSet+0x2e>
       (vol != DISKRET_STATE_MAILFUNCTION) ) )
  {
   DiskretsWave[num] = vol;
 800bac8:	4a04      	ldr	r2, [pc, #16]	; (800badc <DiskretSet+0x38>)
 800baca:	687b      	ldr	r3, [r7, #4]
 800bacc:	4413      	add	r3, r2
 800bace:	78fa      	ldrb	r2, [r7, #3]
 800bad0:	701a      	strb	r2, [r3, #0]
  }
}
 800bad2:	bf00      	nop
 800bad4:	370c      	adds	r7, #12
 800bad6:	46bd      	mov	sp, r7
 800bad8:	bc80      	pop	{r7}
 800bada:	4770      	bx	lr
 800badc:	2000846c 	.word	0x2000846c

0800bae0 <DiskretsProcessWave>:
}
//-------------------------------------------------------------------------------
//        
//-------------------------------------------------------------------------------
void DiskretsProcessWave(int i)
{
 800bae0:	b480      	push	{r7}
 800bae2:	b083      	sub	sp, #12
 800bae4:	af00      	add	r7, sp, #0
 800bae6:	6078      	str	r0, [r7, #4]
    // Noise diskrets check
    if (DiskretsChangesTimer[i] < 40)
 800bae8:	4a44      	ldr	r2, [pc, #272]	; (800bbfc <DiskretsProcessWave+0x11c>)
 800baea:	687b      	ldr	r3, [r7, #4]
 800baec:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 800baf0:	2b27      	cmp	r3, #39	; 0x27
 800baf2:	d80a      	bhi.n	800bb0a <DiskretsProcessWave+0x2a>
      {
        DiskretsChangesTimer[i]++;
 800baf4:	4a41      	ldr	r2, [pc, #260]	; (800bbfc <DiskretsProcessWave+0x11c>)
 800baf6:	687b      	ldr	r3, [r7, #4]
 800baf8:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 800bafc:	3301      	adds	r3, #1
 800bafe:	b299      	uxth	r1, r3
 800bb00:	4a3e      	ldr	r2, [pc, #248]	; (800bbfc <DiskretsProcessWave+0x11c>)
 800bb02:	687b      	ldr	r3, [r7, #4]
 800bb04:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
 800bb08:	e016      	b.n	800bb38 <DiskretsProcessWave+0x58>
      }
    else
      {
        if (DiskretsChangesCounter[i] > DISKRET_NOISE)
 800bb0a:	4a3d      	ldr	r2, [pc, #244]	; (800bc00 <DiskretsProcessWave+0x120>)
 800bb0c:	687b      	ldr	r3, [r7, #4]
 800bb0e:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 800bb12:	2b5a      	cmp	r3, #90	; 0x5a
 800bb14:	d906      	bls.n	800bb24 <DiskretsProcessWave+0x44>
          {
            DiskretsChangesCounter[i] = 0xFFFF;
 800bb16:	4a3a      	ldr	r2, [pc, #232]	; (800bc00 <DiskretsProcessWave+0x120>)
 800bb18:	687b      	ldr	r3, [r7, #4]
 800bb1a:	f64f 71ff 	movw	r1, #65535	; 0xffff
 800bb1e:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
 800bb22:	e009      	b.n	800bb38 <DiskretsProcessWave+0x58>
          }
        else
          {
            DiskretsChangesCounter[i] = 0;
 800bb24:	4a36      	ldr	r2, [pc, #216]	; (800bc00 <DiskretsProcessWave+0x120>)
 800bb26:	687b      	ldr	r3, [r7, #4]
 800bb28:	2100      	movs	r1, #0
 800bb2a:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
            DiskretsChangesTimer[i] = 0;
 800bb2e:	4a33      	ldr	r2, [pc, #204]	; (800bbfc <DiskretsProcessWave+0x11c>)
 800bb30:	687b      	ldr	r3, [r7, #4]
 800bb32:	2100      	movs	r1, #0
 800bb34:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
          };
      }
    // Set Mailf Diskrets
    if ((DiskretsWave[i] == DISKRET_STATE_MAILFUNCTION))
 800bb38:	4a32      	ldr	r2, [pc, #200]	; (800bc04 <DiskretsProcessWave+0x124>)
 800bb3a:	687b      	ldr	r3, [r7, #4]
 800bb3c:	4413      	add	r3, r2
 800bb3e:	781b      	ldrb	r3, [r3, #0]
 800bb40:	2bff      	cmp	r3, #255	; 0xff
 800bb42:	d10e      	bne.n	800bb62 <DiskretsProcessWave+0x82>
      {
        DiskretsWaveFiltered[i] = DISKRET_STATE_MAILFUNCTION;
 800bb44:	4a30      	ldr	r2, [pc, #192]	; (800bc08 <DiskretsProcessWave+0x128>)
 800bb46:	687b      	ldr	r3, [r7, #4]
 800bb48:	4413      	add	r3, r2
 800bb4a:	22ff      	movs	r2, #255	; 0xff
 800bb4c:	701a      	strb	r2, [r3, #0]
        DiskretsWaveOld[i] = DiskretsWave[i];
 800bb4e:	4a2d      	ldr	r2, [pc, #180]	; (800bc04 <DiskretsProcessWave+0x124>)
 800bb50:	687b      	ldr	r3, [r7, #4]
 800bb52:	4413      	add	r3, r2
 800bb54:	7819      	ldrb	r1, [r3, #0]
 800bb56:	4a2d      	ldr	r2, [pc, #180]	; (800bc0c <DiskretsProcessWave+0x12c>)
 800bb58:	687b      	ldr	r3, [r7, #4]
 800bb5a:	4413      	add	r3, r2
 800bb5c:	460a      	mov	r2, r1
 800bb5e:	701a      	strb	r2, [r3, #0]
        return;
 800bb60:	e048      	b.n	800bbf4 <DiskretsProcessWave+0x114>
      }

    // Diskrets wave processing
    if (DiskretsWave[i] != DiskretsWaveOld[i])
 800bb62:	4a28      	ldr	r2, [pc, #160]	; (800bc04 <DiskretsProcessWave+0x124>)
 800bb64:	687b      	ldr	r3, [r7, #4]
 800bb66:	4413      	add	r3, r2
 800bb68:	781a      	ldrb	r2, [r3, #0]
 800bb6a:	4928      	ldr	r1, [pc, #160]	; (800bc0c <DiskretsProcessWave+0x12c>)
 800bb6c:	687b      	ldr	r3, [r7, #4]
 800bb6e:	440b      	add	r3, r1
 800bb70:	781b      	ldrb	r3, [r3, #0]
 800bb72:	429a      	cmp	r2, r3
 800bb74:	d01b      	beq.n	800bbae <DiskretsProcessWave+0xce>
      {//     
        DiskretsChangesCounter[i]++;
 800bb76:	4a22      	ldr	r2, [pc, #136]	; (800bc00 <DiskretsProcessWave+0x120>)
 800bb78:	687b      	ldr	r3, [r7, #4]
 800bb7a:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 800bb7e:	3301      	adds	r3, #1
 800bb80:	b299      	uxth	r1, r3
 800bb82:	4a1f      	ldr	r2, [pc, #124]	; (800bc00 <DiskretsProcessWave+0x120>)
 800bb84:	687b      	ldr	r3, [r7, #4]
 800bb86:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
        if (DiskretsWave[i] == DISKRET_STATE_ON)
 800bb8a:	4a1e      	ldr	r2, [pc, #120]	; (800bc04 <DiskretsProcessWave+0x124>)
 800bb8c:	687b      	ldr	r3, [r7, #4]
 800bb8e:	4413      	add	r3, r2
 800bb90:	781b      	ldrb	r3, [r3, #0]
 800bb92:	2b01      	cmp	r3, #1
 800bb94:	d105      	bne.n	800bba2 <DiskretsProcessWave+0xc2>
          {
            DiskretsWaveStateCount[i] = DISKRET_POSWAVE_TIME;
 800bb96:	4a1e      	ldr	r2, [pc, #120]	; (800bc10 <DiskretsProcessWave+0x130>)
 800bb98:	687b      	ldr	r3, [r7, #4]
 800bb9a:	2101      	movs	r1, #1
 800bb9c:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
 800bba0:	e01f      	b.n	800bbe2 <DiskretsProcessWave+0x102>
          }
        else
          {//     
            DiskretsWaveStateCount[i] = DISKRET_NEGWAVE_TIME;
 800bba2:	4a1b      	ldr	r2, [pc, #108]	; (800bc10 <DiskretsProcessWave+0x130>)
 800bba4:	687b      	ldr	r3, [r7, #4]
 800bba6:	210a      	movs	r1, #10
 800bba8:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
 800bbac:	e019      	b.n	800bbe2 <DiskretsProcessWave+0x102>
          }
      }
    else
      {//     0
        if (DiskretsWaveStateCount[i] == 0)
 800bbae:	4a18      	ldr	r2, [pc, #96]	; (800bc10 <DiskretsProcessWave+0x130>)
 800bbb0:	687b      	ldr	r3, [r7, #4]
 800bbb2:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 800bbb6:	2b00      	cmp	r3, #0
 800bbb8:	d109      	bne.n	800bbce <DiskretsProcessWave+0xee>
          {
            DiskretsWaveFiltered[i] = DiskretsWave[i];
 800bbba:	4a12      	ldr	r2, [pc, #72]	; (800bc04 <DiskretsProcessWave+0x124>)
 800bbbc:	687b      	ldr	r3, [r7, #4]
 800bbbe:	4413      	add	r3, r2
 800bbc0:	7819      	ldrb	r1, [r3, #0]
 800bbc2:	4a11      	ldr	r2, [pc, #68]	; (800bc08 <DiskretsProcessWave+0x128>)
 800bbc4:	687b      	ldr	r3, [r7, #4]
 800bbc6:	4413      	add	r3, r2
 800bbc8:	460a      	mov	r2, r1
 800bbca:	701a      	strb	r2, [r3, #0]
 800bbcc:	e009      	b.n	800bbe2 <DiskretsProcessWave+0x102>
          }
        else
          {
            DiskretsWaveStateCount[i]--;
 800bbce:	4a10      	ldr	r2, [pc, #64]	; (800bc10 <DiskretsProcessWave+0x130>)
 800bbd0:	687b      	ldr	r3, [r7, #4]
 800bbd2:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 800bbd6:	3b01      	subs	r3, #1
 800bbd8:	b299      	uxth	r1, r3
 800bbda:	4a0d      	ldr	r2, [pc, #52]	; (800bc10 <DiskretsProcessWave+0x130>)
 800bbdc:	687b      	ldr	r3, [r7, #4]
 800bbde:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
          }
      }
     DiskretsWaveOld[i] = DiskretsWave[i];
 800bbe2:	4a08      	ldr	r2, [pc, #32]	; (800bc04 <DiskretsProcessWave+0x124>)
 800bbe4:	687b      	ldr	r3, [r7, #4]
 800bbe6:	4413      	add	r3, r2
 800bbe8:	7819      	ldrb	r1, [r3, #0]
 800bbea:	4a08      	ldr	r2, [pc, #32]	; (800bc0c <DiskretsProcessWave+0x12c>)
 800bbec:	687b      	ldr	r3, [r7, #4]
 800bbee:	4413      	add	r3, r2
 800bbf0:	460a      	mov	r2, r1
 800bbf2:	701a      	strb	r2, [r3, #0]
}
 800bbf4:	370c      	adds	r7, #12
 800bbf6:	46bd      	mov	sp, r7
 800bbf8:	bc80      	pop	{r7}
 800bbfa:	4770      	bx	lr
 800bbfc:	200084a8 	.word	0x200084a8
 800bc00:	20008490 	.word	0x20008490
 800bc04:	2000846c 	.word	0x2000846c
 800bc08:	20008484 	.word	0x20008484
 800bc0c:	20008478 	.word	0x20008478
 800bc10:	200084c0 	.word	0x200084c0

0800bc14 <DiskretsProcess>:
//-------------------------------------------------------------------------------
//    
//-------------------------------------------------------------------------------
void DiskretsProcess()
{
 800bc14:	b580      	push	{r7, lr}
 800bc16:	b082      	sub	sp, #8
 800bc18:	af00      	add	r7, sp, #0
      {
      RAM.diskrets[i] = tmpRam[i];
      }
  //MemSetWords(0x0000,tmpRam,4);
#else
  uint16 tmpRam=0;
 800bc1a:	2300      	movs	r3, #0
 800bc1c:	80fb      	strh	r3, [r7, #6]

  int i = DISKRETS_AMOUNT;
 800bc1e:	230b      	movs	r3, #11
 800bc20:	603b      	str	r3, [r7, #0]

   while(i--)
 800bc22:	e023      	b.n	800bc6c <DiskretsProcess+0x58>
    {
      DiskretsProcessWave(i);
 800bc24:	6838      	ldr	r0, [r7, #0]
 800bc26:	4b18      	ldr	r3, [pc, #96]	; (800bc88 <DiskretsProcess+0x74>)
 800bc28:	4798      	blx	r3
      if(DiskretsWaveFiltered[i] == DISKRET_STATE_ON)
 800bc2a:	4a18      	ldr	r2, [pc, #96]	; (800bc8c <DiskretsProcess+0x78>)
 800bc2c:	683b      	ldr	r3, [r7, #0]
 800bc2e:	4413      	add	r3, r2
 800bc30:	781b      	ldrb	r3, [r3, #0]
 800bc32:	2b01      	cmp	r3, #1
 800bc34:	d10c      	bne.n	800bc50 <DiskretsProcess+0x3c>
         {
           tmpRam |= (1<<(i&0x0f));
 800bc36:	683b      	ldr	r3, [r7, #0]
 800bc38:	f003 030f 	and.w	r3, r3, #15
 800bc3c:	2201      	movs	r2, #1
 800bc3e:	fa02 f303 	lsl.w	r3, r2, r3
 800bc42:	b21a      	sxth	r2, r3
 800bc44:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 800bc48:	4313      	orrs	r3, r2
 800bc4a:	b21b      	sxth	r3, r3
 800bc4c:	80fb      	strh	r3, [r7, #6]
 800bc4e:	e00d      	b.n	800bc6c <DiskretsProcess+0x58>
         } else
          {
            tmpRam &= ~(1<<(i&0x0f));
 800bc50:	683b      	ldr	r3, [r7, #0]
 800bc52:	f003 030f 	and.w	r3, r3, #15
 800bc56:	2201      	movs	r2, #1
 800bc58:	fa02 f303 	lsl.w	r3, r2, r3
 800bc5c:	b21b      	sxth	r3, r3
 800bc5e:	43db      	mvns	r3, r3
 800bc60:	b21a      	sxth	r2, r3
 800bc62:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 800bc66:	4013      	ands	r3, r2
 800bc68:	b21b      	sxth	r3, r3
 800bc6a:	80fb      	strh	r3, [r7, #6]
   while(i--)
 800bc6c:	683b      	ldr	r3, [r7, #0]
 800bc6e:	1e5a      	subs	r2, r3, #1
 800bc70:	603a      	str	r2, [r7, #0]
 800bc72:	2b00      	cmp	r3, #0
 800bc74:	d1d6      	bne.n	800bc24 <DiskretsProcess+0x10>
          }

    }

  RAM.diskrets[0]=tmpRam;
 800bc76:	4b06      	ldr	r3, [pc, #24]	; (800bc90 <DiskretsProcess+0x7c>)
 800bc78:	88fa      	ldrh	r2, [r7, #6]
 800bc7a:	f8a3 2400 	strh.w	r2, [r3, #1024]	; 0x400

#endif
}
 800bc7e:	bf00      	nop
 800bc80:	3708      	adds	r7, #8
 800bc82:	46bd      	mov	sp, r7
 800bc84:	bd80      	pop	{r7, pc}
 800bc86:	bf00      	nop
 800bc88:	0800bae1 	.word	0x0800bae1
 800bc8c:	20008484 	.word	0x20008484
 800bc90:	2000745c 	.word	0x2000745c

0800bc94 <USART2TIMConfigure>:
#include "usart2.h"

//UART_FIFO_STR u2Fifo;
struct ReceivedMsgStr ReceivedMsg;
void USART2TIMConfigure(uint16_t aTIMtime)
{
 800bc94:	b580      	push	{r7, lr}
 800bc96:	b088      	sub	sp, #32
 800bc98:	af00      	add	r7, sp, #0
 800bc9a:	4603      	mov	r3, r0
 800bc9c:	80fb      	strh	r3, [r7, #6]
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM5, ENABLE);
 800bc9e:	2101      	movs	r1, #1
 800bca0:	2008      	movs	r0, #8
 800bca2:	4b18      	ldr	r3, [pc, #96]	; (800bd04 <USART2TIMConfigure+0x70>)
 800bca4:	4798      	blx	r3

	TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
	TIM_TimeBaseStructure.TIM_Period = 100000;
 800bca6:	f248 63a0 	movw	r3, #34464	; 0x86a0
 800bcaa:	833b      	strh	r3, [r7, #24]
	TIM_TimeBaseStructure.TIM_Prescaler = 1000;
 800bcac:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 800bcb0:	82bb      	strh	r3, [r7, #20]
	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
 800bcb2:	2300      	movs	r3, #0
 800bcb4:	837b      	strh	r3, [r7, #26]
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
 800bcb6:	2300      	movs	r3, #0
 800bcb8:	82fb      	strh	r3, [r7, #22]
	TIM_TimeBaseInit(TIM5, &TIM_TimeBaseStructure);
 800bcba:	f107 0314 	add.w	r3, r7, #20
 800bcbe:	4619      	mov	r1, r3
 800bcc0:	4811      	ldr	r0, [pc, #68]	; (800bd08 <USART2TIMConfigure+0x74>)
 800bcc2:	4b12      	ldr	r3, [pc, #72]	; (800bd0c <USART2TIMConfigure+0x78>)
 800bcc4:	4798      	blx	r3

	TIM_ARRPreloadConfig(TIM5, ENABLE);
 800bcc6:	2101      	movs	r1, #1
 800bcc8:	480f      	ldr	r0, [pc, #60]	; (800bd08 <USART2TIMConfigure+0x74>)
 800bcca:	4b11      	ldr	r3, [pc, #68]	; (800bd10 <USART2TIMConfigure+0x7c>)
 800bccc:	4798      	blx	r3

	TIM_ICInitTypeDef TIM_ICInitStructure;
	TIM_ICInitStructure.TIM_Channel = TIM_Channel_2;
 800bcce:	2304      	movs	r3, #4
 800bcd0:	813b      	strh	r3, [r7, #8]
	TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;
 800bcd2:	2300      	movs	r3, #0
 800bcd4:	817b      	strh	r3, [r7, #10]
	TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;
 800bcd6:	2301      	movs	r3, #1
 800bcd8:	81bb      	strh	r3, [r7, #12]
	TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;
 800bcda:	2300      	movs	r3, #0
 800bcdc:	81fb      	strh	r3, [r7, #14]
	TIM_ICInitStructure.TIM_ICFilter = 0x0;
 800bcde:	2300      	movs	r3, #0
 800bce0:	823b      	strh	r3, [r7, #16]
//	TIM_ICInit(TIM5, &TIM_ICInitStructure);

	//TIM_SelectInputTrigger(TIM5, TIM_TS_TI2FP2);
//	TIM_SelectSlaveMode(TIM5, TIM_SlaveMode_Reset);
//	TIM_SelectMasterSlaveMode(TIM5, TIM_MasterSlaveMode_Enable);
    TIM_ClearFlag(TIM5,TIM_FLAG_Update);//
 800bce2:	2101      	movs	r1, #1
 800bce4:	4808      	ldr	r0, [pc, #32]	; (800bd08 <USART2TIMConfigure+0x74>)
 800bce6:	4b0b      	ldr	r3, [pc, #44]	; (800bd14 <USART2TIMConfigure+0x80>)
 800bce8:	4798      	blx	r3
//	TIM_Cmd(TIM5, ENABLE);

	TIM_ITConfig(TIM5, TIM_IT_Update, ENABLE);
 800bcea:	2201      	movs	r2, #1
 800bcec:	2101      	movs	r1, #1
 800bcee:	4806      	ldr	r0, [pc, #24]	; (800bd08 <USART2TIMConfigure+0x74>)
 800bcf0:	4b09      	ldr	r3, [pc, #36]	; (800bd18 <USART2TIMConfigure+0x84>)
 800bcf2:	4798      	blx	r3

//	TIM_ClearITPendingBit(TIM5, TIM_IT_Update);
    TIM_Cmd(TIM5, ENABLE);//
 800bcf4:	2101      	movs	r1, #1
 800bcf6:	4804      	ldr	r0, [pc, #16]	; (800bd08 <USART2TIMConfigure+0x74>)
 800bcf8:	4b08      	ldr	r3, [pc, #32]	; (800bd1c <USART2TIMConfigure+0x88>)
 800bcfa:	4798      	blx	r3
	TIM_Cmd(TIM5, ENABLE);
	TIM_ITConfig(TIM5,TIM_IT_Update,ENABLE);

	TIM_ClearITPendingBit(TIM5, TIM_IT_Update);
*/
}
 800bcfc:	bf00      	nop
 800bcfe:	3720      	adds	r7, #32
 800bd00:	46bd      	mov	sp, r7
 800bd02:	bd80      	pop	{r7, pc}
 800bd04:	080034f9 	.word	0x080034f9
 800bd08:	40000c00 	.word	0x40000c00
 800bd0c:	08003a19 	.word	0x08003a19
 800bd10:	08003b17 	.word	0x08003b17
 800bd14:	08003b89 	.word	0x08003b89
 800bd18:	08003ad1 	.word	0x08003ad1
 800bd1c:	08003a91 	.word	0x08003a91

0800bd20 <TIM5_IRQHandler>:

void TIM5_IRQHandler(void)
{
 800bd20:	b580      	push	{r7, lr}
 800bd22:	b082      	sub	sp, #8
 800bd24:	af00      	add	r7, sp, #0
	//ReceivedMsgStr ReceivedMsg;
	TIM_ClearITPendingBit(TIM5, TIM_IT_Update);
 800bd26:	2101      	movs	r1, #1
 800bd28:	4810      	ldr	r0, [pc, #64]	; (800bd6c <TIM5_IRQHandler+0x4c>)
 800bd2a:	4b11      	ldr	r3, [pc, #68]	; (800bd70 <TIM5_IRQHandler+0x50>)
 800bd2c:	4798      	blx	r3

    int asize = uart2Read(ReceivedMsg.buffer,260);
 800bd2e:	f44f 7182 	mov.w	r1, #260	; 0x104
 800bd32:	4810      	ldr	r0, [pc, #64]	; (800bd74 <TIM5_IRQHandler+0x54>)
 800bd34:	4b10      	ldr	r3, [pc, #64]	; (800bd78 <TIM5_IRQHandler+0x58>)
 800bd36:	4798      	blx	r3
 800bd38:	4603      	mov	r3, r0
 800bd3a:	607b      	str	r3, [r7, #4]
	if(asize>0)
 800bd3c:	687b      	ldr	r3, [r7, #4]
 800bd3e:	2b00      	cmp	r3, #0
 800bd40:	dd0f      	ble.n	800bd62 <TIM5_IRQHandler+0x42>
    {
	if(ReceivedMsg.size == 0)
 800bd42:	4b0e      	ldr	r3, [pc, #56]	; (800bd7c <TIM5_IRQHandler+0x5c>)
 800bd44:	f8b3 3202 	ldrh.w	r3, [r3, #514]	; 0x202
 800bd48:	2b00      	cmp	r3, #0
 800bd4a:	d10a      	bne.n	800bd62 <TIM5_IRQHandler+0x42>
        {
		ReceivedMsg.flag = true;
 800bd4c:	4b0b      	ldr	r3, [pc, #44]	; (800bd7c <TIM5_IRQHandler+0x5c>)
 800bd4e:	2201      	movs	r2, #1
 800bd50:	701a      	strb	r2, [r3, #0]
		ReceivedMsg.Readflag = false;
 800bd52:	4b0a      	ldr	r3, [pc, #40]	; (800bd7c <TIM5_IRQHandler+0x5c>)
 800bd54:	2200      	movs	r2, #0
 800bd56:	705a      	strb	r2, [r3, #1]
		ReceivedMsg.size = asize;
 800bd58:	687b      	ldr	r3, [r7, #4]
 800bd5a:	b29a      	uxth	r2, r3
 800bd5c:	4b07      	ldr	r3, [pc, #28]	; (800bd7c <TIM5_IRQHandler+0x5c>)
 800bd5e:	f8a3 2202 	strh.w	r2, [r3, #514]	; 0x202
		}
		//TIM_Cmd(TIM5, DISABLE);//
	}
}
 800bd62:	bf00      	nop
 800bd64:	3708      	adds	r7, #8
 800bd66:	46bd      	mov	sp, r7
 800bd68:	bd80      	pop	{r7, pc}
 800bd6a:	bf00      	nop
 800bd6c:	40000c00 	.word	0x40000c00
 800bd70:	08003bfb 	.word	0x08003bfb
 800bd74:	200084da 	.word	0x200084da
 800bd78:	080048e5 	.word	0x080048e5
 800bd7c:	200084d8 	.word	0x200084d8

0800bd80 <IsLiteral>:
		MA_STATEIPCLOSE, "STATE: IP INITIAL", MA_STATEIPINITIAL,
		"STATE: IP GPRSACT", MA_STATEIPGPRSACT, "STATE: PDP DEACT",
		MA_STATEPDPDEACT, "> ", MA_CIPSENDREADY, "CONNECT", MA_CONNECT,
		"NO CARRIER", MA_NOCARRIER, "ERROR", MA_ERROR, "READY", MA_READY };

bool IsLiteral(char ch) {
 800bd80:	b480      	push	{r7}
 800bd82:	b083      	sub	sp, #12
 800bd84:	af00      	add	r7, sp, #0
 800bd86:	4603      	mov	r3, r0
 800bd88:	71fb      	strb	r3, [r7, #7]
	if ((ch >= ' ') && (ch <= '~')) {
 800bd8a:	79fb      	ldrb	r3, [r7, #7]
 800bd8c:	2b1f      	cmp	r3, #31
 800bd8e:	d904      	bls.n	800bd9a <IsLiteral+0x1a>
 800bd90:	79fb      	ldrb	r3, [r7, #7]
 800bd92:	2b7e      	cmp	r3, #126	; 0x7e
 800bd94:	d801      	bhi.n	800bd9a <IsLiteral+0x1a>
		return true;
 800bd96:	2301      	movs	r3, #1
 800bd98:	e000      	b.n	800bd9c <IsLiteral+0x1c>
	}
	return false;
 800bd9a:	2300      	movs	r3, #0
}
 800bd9c:	4618      	mov	r0, r3
 800bd9e:	370c      	adds	r7, #12
 800bda0:	46bd      	mov	sp, r7
 800bda2:	bc80      	pop	{r7}
 800bda4:	4770      	bx	lr
	...

0800bda8 <InitSioBuf>:

void InitSioBuf() {
 800bda8:	b480      	push	{r7}
 800bdaa:	af00      	add	r7, sp, #0
	bufpoint = 0;
 800bdac:	4b04      	ldr	r3, [pc, #16]	; (800bdc0 <InitSioBuf+0x18>)
 800bdae:	2200      	movs	r2, #0
 800bdb0:	601a      	str	r2, [r3, #0]
	bufsize = 0;
 800bdb2:	4b04      	ldr	r3, [pc, #16]	; (800bdc4 <InitSioBuf+0x1c>)
 800bdb4:	2200      	movs	r2, #0
 800bdb6:	801a      	strh	r2, [r3, #0]
}
 800bdb8:	bf00      	nop
 800bdba:	46bd      	mov	sp, r7
 800bdbc:	bc80      	pop	{r7}
 800bdbe:	4770      	bx	lr
 800bdc0:	200092e0 	.word	0x200092e0
 800bdc4:	200092e4 	.word	0x200092e4

0800bdc8 <PopFromBuf>:

bool PopFromBuf(char *ch) {
 800bdc8:	b480      	push	{r7}
 800bdca:	b083      	sub	sp, #12
 800bdcc:	af00      	add	r7, sp, #0
 800bdce:	6078      	str	r0, [r7, #4]
	if (bufpoint >= bufsize) {
 800bdd0:	4b0d      	ldr	r3, [pc, #52]	; (800be08 <PopFromBuf+0x40>)
 800bdd2:	881b      	ldrh	r3, [r3, #0]
 800bdd4:	b29b      	uxth	r3, r3
 800bdd6:	461a      	mov	r2, r3
 800bdd8:	4b0c      	ldr	r3, [pc, #48]	; (800be0c <PopFromBuf+0x44>)
 800bdda:	681b      	ldr	r3, [r3, #0]
 800bddc:	429a      	cmp	r2, r3
 800bdde:	dc01      	bgt.n	800bde4 <PopFromBuf+0x1c>
		return false;
 800bde0:	2300      	movs	r3, #0
 800bde2:	e00b      	b.n	800bdfc <PopFromBuf+0x34>
	}
	*ch = sio_buf[bufpoint];
 800bde4:	4b09      	ldr	r3, [pc, #36]	; (800be0c <PopFromBuf+0x44>)
 800bde6:	681b      	ldr	r3, [r3, #0]
 800bde8:	4a09      	ldr	r2, [pc, #36]	; (800be10 <PopFromBuf+0x48>)
 800bdea:	5cd2      	ldrb	r2, [r2, r3]
 800bdec:	687b      	ldr	r3, [r7, #4]
 800bdee:	701a      	strb	r2, [r3, #0]
	bufpoint++;
 800bdf0:	4b06      	ldr	r3, [pc, #24]	; (800be0c <PopFromBuf+0x44>)
 800bdf2:	681b      	ldr	r3, [r3, #0]
 800bdf4:	3301      	adds	r3, #1
 800bdf6:	4a05      	ldr	r2, [pc, #20]	; (800be0c <PopFromBuf+0x44>)
 800bdf8:	6013      	str	r3, [r2, #0]
	return true;
 800bdfa:	2301      	movs	r3, #1
}
 800bdfc:	4618      	mov	r0, r3
 800bdfe:	370c      	adds	r7, #12
 800be00:	46bd      	mov	sp, r7
 800be02:	bc80      	pop	{r7}
 800be04:	4770      	bx	lr
 800be06:	bf00      	nop
 800be08:	200092e4 	.word	0x200092e4
 800be0c:	200092e0 	.word	0x200092e0
 800be10:	200086e0 	.word	0x200086e0

0800be14 <FillBuf>:
	//vTaskDelay(1000);
	//bufsize = uart2Read(sio_buf,256);

}

void FillBuf() {
 800be14:	b580      	push	{r7, lr}
 800be16:	b084      	sub	sp, #16
 800be18:	af00      	add	r7, sp, #0
	InitSioBuf();
 800be1a:	4b22      	ldr	r3, [pc, #136]	; (800bea4 <FillBuf+0x90>)
 800be1c:	4798      	blx	r3
	uint16_t time = 1500;
 800be1e:	f240 53dc 	movw	r3, #1500	; 0x5dc
 800be22:	80fb      	strh	r3, [r7, #6]
	uint16_t counter = 0;
 800be24:	2300      	movs	r3, #0
 800be26:	81fb      	strh	r3, [r7, #14]

	while (ReceivedMsg.flag == false && counter < time) {
 800be28:	e005      	b.n	800be36 <FillBuf+0x22>
		counter++;
 800be2a:	89fb      	ldrh	r3, [r7, #14]
 800be2c:	3301      	adds	r3, #1
 800be2e:	81fb      	strh	r3, [r7, #14]
		vTaskDelay(1);
 800be30:	2001      	movs	r0, #1
 800be32:	4b1d      	ldr	r3, [pc, #116]	; (800bea8 <FillBuf+0x94>)
 800be34:	4798      	blx	r3
	while (ReceivedMsg.flag == false && counter < time) {
 800be36:	4b1d      	ldr	r3, [pc, #116]	; (800beac <FillBuf+0x98>)
 800be38:	781b      	ldrb	r3, [r3, #0]
 800be3a:	f083 0301 	eor.w	r3, r3, #1
 800be3e:	b2db      	uxtb	r3, r3
 800be40:	2b00      	cmp	r3, #0
 800be42:	d003      	beq.n	800be4c <FillBuf+0x38>
 800be44:	89fa      	ldrh	r2, [r7, #14]
 800be46:	88fb      	ldrh	r3, [r7, #6]
 800be48:	429a      	cmp	r2, r3
 800be4a:	d3ee      	bcc.n	800be2a <FillBuf+0x16>
	}

	if (ReceivedMsg.flag == true) {
 800be4c:	4b17      	ldr	r3, [pc, #92]	; (800beac <FillBuf+0x98>)
 800be4e:	781b      	ldrb	r3, [r3, #0]
 800be50:	2b00      	cmp	r3, #0
 800be52:	d022      	beq.n	800be9a <FillBuf+0x86>
		for (int i = 0; i < ReceivedMsg.size; i++) {
 800be54:	2300      	movs	r3, #0
 800be56:	60bb      	str	r3, [r7, #8]
 800be58:	e00c      	b.n	800be74 <FillBuf+0x60>
			sio_buf[i] = ReceivedMsg.buffer[i];
 800be5a:	4a14      	ldr	r2, [pc, #80]	; (800beac <FillBuf+0x98>)
 800be5c:	68bb      	ldr	r3, [r7, #8]
 800be5e:	4413      	add	r3, r2
 800be60:	3302      	adds	r3, #2
 800be62:	7819      	ldrb	r1, [r3, #0]
 800be64:	4a12      	ldr	r2, [pc, #72]	; (800beb0 <FillBuf+0x9c>)
 800be66:	68bb      	ldr	r3, [r7, #8]
 800be68:	4413      	add	r3, r2
 800be6a:	460a      	mov	r2, r1
 800be6c:	701a      	strb	r2, [r3, #0]
		for (int i = 0; i < ReceivedMsg.size; i++) {
 800be6e:	68bb      	ldr	r3, [r7, #8]
 800be70:	3301      	adds	r3, #1
 800be72:	60bb      	str	r3, [r7, #8]
 800be74:	4b0d      	ldr	r3, [pc, #52]	; (800beac <FillBuf+0x98>)
 800be76:	f8b3 3202 	ldrh.w	r3, [r3, #514]	; 0x202
 800be7a:	461a      	mov	r2, r3
 800be7c:	68bb      	ldr	r3, [r7, #8]
 800be7e:	4293      	cmp	r3, r2
 800be80:	dbeb      	blt.n	800be5a <FillBuf+0x46>
		}
		bufsize = ReceivedMsg.size;
 800be82:	4b0a      	ldr	r3, [pc, #40]	; (800beac <FillBuf+0x98>)
 800be84:	f8b3 2202 	ldrh.w	r2, [r3, #514]	; 0x202
 800be88:	4b0a      	ldr	r3, [pc, #40]	; (800beb4 <FillBuf+0xa0>)
 800be8a:	801a      	strh	r2, [r3, #0]
		ReceivedMsg.size = 0;
 800be8c:	4b07      	ldr	r3, [pc, #28]	; (800beac <FillBuf+0x98>)
 800be8e:	2200      	movs	r2, #0
 800be90:	f8a3 2202 	strh.w	r2, [r3, #514]	; 0x202
		ReceivedMsg.flag = false;
 800be94:	4b05      	ldr	r3, [pc, #20]	; (800beac <FillBuf+0x98>)
 800be96:	2200      	movs	r2, #0
 800be98:	701a      	strb	r2, [r3, #0]
		//TIM_Cmd(TIM5, ENABLE);
	}
	//vTaskDelay(1000);
	//bufsize = uart2Read(sio_buf,256);

}
 800be9a:	bf00      	nop
 800be9c:	3710      	adds	r7, #16
 800be9e:	46bd      	mov	sp, r7
 800bea0:	bd80      	pop	{r7, pc}
 800bea2:	bf00      	nop
 800bea4:	0800bda9 	.word	0x0800bda9
 800bea8:	08001529 	.word	0x08001529
 800beac:	200084d8 	.word	0x200084d8
 800beb0:	200086e0 	.word	0x200086e0
 800beb4:	200092e4 	.word	0x200092e4

0800beb8 <ReadString>:

bool ReadString(char *str, int size) {
 800beb8:	b580      	push	{r7, lr}
 800beba:	b084      	sub	sp, #16
 800bebc:	af00      	add	r7, sp, #0
 800bebe:	6078      	str	r0, [r7, #4]
 800bec0:	6039      	str	r1, [r7, #0]
	char ch;
	if (bufpoint >= bufsize) {
 800bec2:	4b20      	ldr	r3, [pc, #128]	; (800bf44 <ReadString+0x8c>)
 800bec4:	881b      	ldrh	r3, [r3, #0]
 800bec6:	b29b      	uxth	r3, r3
 800bec8:	461a      	mov	r2, r3
 800beca:	4b1f      	ldr	r3, [pc, #124]	; (800bf48 <ReadString+0x90>)
 800becc:	681b      	ldr	r3, [r3, #0]
 800bece:	429a      	cmp	r2, r3
 800bed0:	dc01      	bgt.n	800bed6 <ReadString+0x1e>
		FillBuf();
 800bed2:	4b1e      	ldr	r3, [pc, #120]	; (800bf4c <ReadString+0x94>)
 800bed4:	4798      	blx	r3
	}
	do // remove non symbolic data
	{
		if (PopFromBuf(&ch) == false) {
 800bed6:	f107 030f 	add.w	r3, r7, #15
 800beda:	4618      	mov	r0, r3
 800bedc:	4b1c      	ldr	r3, [pc, #112]	; (800bf50 <ReadString+0x98>)
 800bede:	4798      	blx	r3
 800bee0:	4603      	mov	r3, r0
 800bee2:	f083 0301 	eor.w	r3, r3, #1
 800bee6:	b2db      	uxtb	r3, r3
 800bee8:	2b00      	cmp	r3, #0
 800beea:	d001      	beq.n	800bef0 <ReadString+0x38>
			return false;
 800beec:	2300      	movs	r3, #0
 800beee:	e025      	b.n	800bf3c <ReadString+0x84>
		}
	} while (!IsLiteral(ch));
 800bef0:	7bfb      	ldrb	r3, [r7, #15]
 800bef2:	4618      	mov	r0, r3
 800bef4:	4b17      	ldr	r3, [pc, #92]	; (800bf54 <ReadString+0x9c>)
 800bef6:	4798      	blx	r3
 800bef8:	4603      	mov	r3, r0
 800befa:	f083 0301 	eor.w	r3, r3, #1
 800befe:	b2db      	uxtb	r3, r3
 800bf00:	2b00      	cmp	r3, #0
 800bf02:	d1e8      	bne.n	800bed6 <ReadString+0x1e>
	do {
		if (IsLiteral(ch)) {
 800bf04:	7bfb      	ldrb	r3, [r7, #15]
 800bf06:	4618      	mov	r0, r3
 800bf08:	4b12      	ldr	r3, [pc, #72]	; (800bf54 <ReadString+0x9c>)
 800bf0a:	4798      	blx	r3
 800bf0c:	4603      	mov	r3, r0
 800bf0e:	2b00      	cmp	r3, #0
 800bf10:	d006      	beq.n	800bf20 <ReadString+0x68>
			*str = ch;
 800bf12:	7bfa      	ldrb	r2, [r7, #15]
 800bf14:	687b      	ldr	r3, [r7, #4]
 800bf16:	701a      	strb	r2, [r3, #0]
			str++;
 800bf18:	687b      	ldr	r3, [r7, #4]
 800bf1a:	3301      	adds	r3, #1
 800bf1c:	607b      	str	r3, [r7, #4]
 800bf1e:	e004      	b.n	800bf2a <ReadString+0x72>
		} else // packet end
		{
			*str = 0; //  add end of string
 800bf20:	687b      	ldr	r3, [r7, #4]
 800bf22:	2200      	movs	r2, #0
 800bf24:	701a      	strb	r2, [r3, #0]
			return true;
 800bf26:	2301      	movs	r3, #1
 800bf28:	e008      	b.n	800bf3c <ReadString+0x84>
		}
	} while (PopFromBuf(&ch) == true);
 800bf2a:	f107 030f 	add.w	r3, r7, #15
 800bf2e:	4618      	mov	r0, r3
 800bf30:	4b07      	ldr	r3, [pc, #28]	; (800bf50 <ReadString+0x98>)
 800bf32:	4798      	blx	r3
 800bf34:	4603      	mov	r3, r0
 800bf36:	2b00      	cmp	r3, #0
 800bf38:	d1e4      	bne.n	800bf04 <ReadString+0x4c>
	return false;
 800bf3a:	2300      	movs	r3, #0
}
 800bf3c:	4618      	mov	r0, r3
 800bf3e:	3710      	adds	r7, #16
 800bf40:	46bd      	mov	sp, r7
 800bf42:	bd80      	pop	{r7, pc}
 800bf44:	200092e4 	.word	0x200092e4
 800bf48:	200092e0 	.word	0x200092e0
 800bf4c:	0800be15 	.word	0x0800be15
 800bf50:	0800bdc9 	.word	0x0800bdc9
 800bf54:	0800bd81 	.word	0x0800bd81

0800bf58 <GetModemAnswer>:

MDEM_ANSWER GetModemAnswer(char *s) {
 800bf58:	b580      	push	{r7, lr}
 800bf5a:	b084      	sub	sp, #16
 800bf5c:	af00      	add	r7, sp, #0
 800bf5e:	6078      	str	r0, [r7, #4]
	int i;
	if (*s == 0) {
 800bf60:	687b      	ldr	r3, [r7, #4]
 800bf62:	781b      	ldrb	r3, [r3, #0]
 800bf64:	2b00      	cmp	r3, #0
 800bf66:	d101      	bne.n	800bf6c <GetModemAnswer+0x14>
		return MA_UNKNOWN;
 800bf68:	2300      	movs	r3, #0
 800bf6a:	e01a      	b.n	800bfa2 <GetModemAnswer+0x4a>
	}
	for (i = 0; i < AT_AMOUNT; i++) {
 800bf6c:	2300      	movs	r3, #0
 800bf6e:	60fb      	str	r3, [r7, #12]
 800bf70:	e013      	b.n	800bf9a <GetModemAnswer+0x42>
		if (strcmp(atset[i].str, s) == 0) {
 800bf72:	4a0e      	ldr	r2, [pc, #56]	; (800bfac <GetModemAnswer+0x54>)
 800bf74:	68fb      	ldr	r3, [r7, #12]
 800bf76:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
 800bf7a:	6879      	ldr	r1, [r7, #4]
 800bf7c:	4618      	mov	r0, r3
 800bf7e:	4b0c      	ldr	r3, [pc, #48]	; (800bfb0 <GetModemAnswer+0x58>)
 800bf80:	4798      	blx	r3
 800bf82:	4603      	mov	r3, r0
 800bf84:	2b00      	cmp	r3, #0
 800bf86:	d105      	bne.n	800bf94 <GetModemAnswer+0x3c>
			return (atset[i].ma);
 800bf88:	4a08      	ldr	r2, [pc, #32]	; (800bfac <GetModemAnswer+0x54>)
 800bf8a:	68fb      	ldr	r3, [r7, #12]
 800bf8c:	00db      	lsls	r3, r3, #3
 800bf8e:	4413      	add	r3, r2
 800bf90:	791b      	ldrb	r3, [r3, #4]
 800bf92:	e006      	b.n	800bfa2 <GetModemAnswer+0x4a>
	for (i = 0; i < AT_AMOUNT; i++) {
 800bf94:	68fb      	ldr	r3, [r7, #12]
 800bf96:	3301      	adds	r3, #1
 800bf98:	60fb      	str	r3, [r7, #12]
 800bf9a:	68fb      	ldr	r3, [r7, #12]
 800bf9c:	2b0b      	cmp	r3, #11
 800bf9e:	dde8      	ble.n	800bf72 <GetModemAnswer+0x1a>
		}
	}
	return MA_UNKNOWN;
 800bfa0:	2300      	movs	r3, #0
}
 800bfa2:	4618      	mov	r0, r3
 800bfa4:	3710      	adds	r7, #16
 800bfa6:	46bd      	mov	sp, r7
 800bfa8:	bd80      	pop	{r7, pc}
 800bfaa:	bf00      	nop
 800bfac:	08015494 	.word	0x08015494
 800bfb0:	080000f5 	.word	0x080000f5

0800bfb4 <ReadModem>:

MDEM_ANSWER ReadModem() {
 800bfb4:	b580      	push	{r7, lr}
 800bfb6:	af00      	add	r7, sp, #0
	if (ReadString(strbuf, STRBUFLEN) == false) {
 800bfb8:	f44f 7180 	mov.w	r1, #256	; 0x100
 800bfbc:	4808      	ldr	r0, [pc, #32]	; (800bfe0 <ReadModem+0x2c>)
 800bfbe:	4b09      	ldr	r3, [pc, #36]	; (800bfe4 <ReadModem+0x30>)
 800bfc0:	4798      	blx	r3
 800bfc2:	4603      	mov	r3, r0
 800bfc4:	f083 0301 	eor.w	r3, r3, #1
 800bfc8:	b2db      	uxtb	r3, r3
 800bfca:	2b00      	cmp	r3, #0
 800bfcc:	d001      	beq.n	800bfd2 <ReadModem+0x1e>
		return MA_UNKNOWN;
 800bfce:	2300      	movs	r3, #0
 800bfd0:	e003      	b.n	800bfda <ReadModem+0x26>
	}
	return GetModemAnswer((char*) strbuf);
 800bfd2:	4803      	ldr	r0, [pc, #12]	; (800bfe0 <ReadModem+0x2c>)
 800bfd4:	4b04      	ldr	r3, [pc, #16]	; (800bfe8 <ReadModem+0x34>)
 800bfd6:	4798      	blx	r3
 800bfd8:	4603      	mov	r3, r0
}
 800bfda:	4618      	mov	r0, r3
 800bfdc:	bd80      	pop	{r7, pc}
 800bfde:	bf00      	nop
 800bfe0:	200092fc 	.word	0x200092fc
 800bfe4:	0800beb9 	.word	0x0800beb9
 800bfe8:	0800bf59 	.word	0x0800bf59

0800bfec <ModemWrite>:
/* ----------------------- Start implementation -----------------------------*/
void ModemWrite(char *str) {
 800bfec:	b580      	push	{r7, lr}
 800bfee:	b084      	sub	sp, #16
 800bff0:	af00      	add	r7, sp, #0
 800bff2:	6078      	str	r0, [r7, #4]

	uint32 i = 0;
 800bff4:	2300      	movs	r3, #0
 800bff6:	60fb      	str	r3, [r7, #12]
	char *tmpstr = str;
 800bff8:	687b      	ldr	r3, [r7, #4]
 800bffa:	60bb      	str	r3, [r7, #8]
	while (*str) {
 800bffc:	e008      	b.n	800c010 <ModemWrite+0x24>
		str++;
 800bffe:	687b      	ldr	r3, [r7, #4]
 800c000:	3301      	adds	r3, #1
 800c002:	607b      	str	r3, [r7, #4]
		i++;
 800c004:	68fb      	ldr	r3, [r7, #12]
 800c006:	3301      	adds	r3, #1
 800c008:	60fb      	str	r3, [r7, #12]
		if (i == 62)
 800c00a:	68fb      	ldr	r3, [r7, #12]
 800c00c:	2b3e      	cmp	r3, #62	; 0x3e
 800c00e:	d004      	beq.n	800c01a <ModemWrite+0x2e>
	while (*str) {
 800c010:	687b      	ldr	r3, [r7, #4]
 800c012:	781b      	ldrb	r3, [r3, #0]
 800c014:	2b00      	cmp	r3, #0
 800c016:	d1f2      	bne.n	800bffe <ModemWrite+0x12>
 800c018:	e000      	b.n	800c01c <ModemWrite+0x30>
			break;
 800c01a:	bf00      	nop
	}
	//AT91F_USART_SEND(MODEM_PORT, (uint8*) tmpstr, i);
	uart2Write((uint8*) tmpstr, i);
 800c01c:	68f9      	ldr	r1, [r7, #12]
 800c01e:	68b8      	ldr	r0, [r7, #8]
 800c020:	4b02      	ldr	r3, [pc, #8]	; (800c02c <ModemWrite+0x40>)
 800c022:	4798      	blx	r3
}
 800c024:	bf00      	nop
 800c026:	3710      	adds	r7, #16
 800c028:	46bd      	mov	sp, r7
 800c02a:	bd80      	pop	{r7, pc}
 800c02c:	08004941 	.word	0x08004941

0800c030 <WaitAnsver>:
bool WaitAnsver(MDEM_ANSWER ma, int i) {
 800c030:	b580      	push	{r7, lr}
 800c032:	b082      	sub	sp, #8
 800c034:	af00      	add	r7, sp, #0
 800c036:	4603      	mov	r3, r0
 800c038:	6039      	str	r1, [r7, #0]
 800c03a:	71fb      	strb	r3, [r7, #7]
	//int i = 10;

	while (ReadModem() != ma) {
 800c03c:	e007      	b.n	800c04e <WaitAnsver+0x1e>
		if (i == 0) {
 800c03e:	683b      	ldr	r3, [r7, #0]
 800c040:	2b00      	cmp	r3, #0
 800c042:	d101      	bne.n	800c048 <WaitAnsver+0x18>
			return false;
 800c044:	2300      	movs	r3, #0
 800c046:	e00a      	b.n	800c05e <WaitAnsver+0x2e>
		}
		i--;
 800c048:	683b      	ldr	r3, [r7, #0]
 800c04a:	3b01      	subs	r3, #1
 800c04c:	603b      	str	r3, [r7, #0]
	while (ReadModem() != ma) {
 800c04e:	4b06      	ldr	r3, [pc, #24]	; (800c068 <WaitAnsver+0x38>)
 800c050:	4798      	blx	r3
 800c052:	4603      	mov	r3, r0
 800c054:	461a      	mov	r2, r3
 800c056:	79fb      	ldrb	r3, [r7, #7]
 800c058:	4293      	cmp	r3, r2
 800c05a:	d1f0      	bne.n	800c03e <WaitAnsver+0xe>
	}
	//	dbgmessage("Ok\n");
	return true;
 800c05c:	2301      	movs	r3, #1
}
 800c05e:	4618      	mov	r0, r3
 800c060:	3708      	adds	r7, #8
 800c062:	46bd      	mov	sp, r7
 800c064:	bd80      	pop	{r7, pc}
 800c066:	bf00      	nop
 800c068:	0800bfb5 	.word	0x0800bfb5

0800c06c <WaitOk>:
		}
		i++;
	};
	return true;
}
bool WaitOk() {
 800c06c:	b580      	push	{r7, lr}
 800c06e:	af00      	add	r7, sp, #0
	vTaskDelay(100);
 800c070:	2064      	movs	r0, #100	; 0x64
 800c072:	4b06      	ldr	r3, [pc, #24]	; (800c08c <WaitOk+0x20>)
 800c074:	4798      	blx	r3
	ModemWrite("AT\r\n");
 800c076:	4806      	ldr	r0, [pc, #24]	; (800c090 <WaitOk+0x24>)
 800c078:	4b06      	ldr	r3, [pc, #24]	; (800c094 <WaitOk+0x28>)
 800c07a:	4798      	blx	r3
	return WaitAnsver(MA_OK, 30);
 800c07c:	211e      	movs	r1, #30
 800c07e:	2002      	movs	r0, #2
 800c080:	4b05      	ldr	r3, [pc, #20]	; (800c098 <WaitOk+0x2c>)
 800c082:	4798      	blx	r3
 800c084:	4603      	mov	r3, r0
}
 800c086:	4618      	mov	r0, r3
 800c088:	bd80      	pop	{r7, pc}
 800c08a:	bf00      	nop
 800c08c:	08001529 	.word	0x08001529
 800c090:	08015174 	.word	0x08015174
 800c094:	0800bfed 	.word	0x0800bfed
 800c098:	0800c031 	.word	0x0800c031

0800c09c <WaitAtd>:

bool WaitAtd() {
 800c09c:	b580      	push	{r7, lr}
 800c09e:	af00      	add	r7, sp, #0
	vTaskDelay(100);
 800c0a0:	2064      	movs	r0, #100	; 0x64
 800c0a2:	4b06      	ldr	r3, [pc, #24]	; (800c0bc <WaitAtd+0x20>)
 800c0a4:	4798      	blx	r3
	//ModemWrite("ATZ\r\n");
	ModemWrite("AT&D0\r\n");  //    115200?
 800c0a6:	4806      	ldr	r0, [pc, #24]	; (800c0c0 <WaitAtd+0x24>)
 800c0a8:	4b06      	ldr	r3, [pc, #24]	; (800c0c4 <WaitAtd+0x28>)
 800c0aa:	4798      	blx	r3
	return WaitAnsver(MA_CALLREADY, 10);
 800c0ac:	210a      	movs	r1, #10
 800c0ae:	2001      	movs	r0, #1
 800c0b0:	4b05      	ldr	r3, [pc, #20]	; (800c0c8 <WaitAtd+0x2c>)
 800c0b2:	4798      	blx	r3
 800c0b4:	4603      	mov	r3, r0
	//return WaitAnsver(MA_OK, 30);
}
 800c0b6:	4618      	mov	r0, r3
 800c0b8:	bd80      	pop	{r7, pc}
 800c0ba:	bf00      	nop
 800c0bc:	08001529 	.word	0x08001529
 800c0c0:	0801517c 	.word	0x0801517c
 800c0c4:	0800bfed 	.word	0x0800bfed
 800c0c8:	0800c031 	.word	0x0800c031

0800c0cc <WaitAtd1>:
bool WaitAtd1() {
 800c0cc:	b580      	push	{r7, lr}
 800c0ce:	af00      	add	r7, sp, #0
	vTaskDelay(100);
 800c0d0:	2064      	movs	r0, #100	; 0x64
 800c0d2:	4b06      	ldr	r3, [pc, #24]	; (800c0ec <WaitAtd1+0x20>)
 800c0d4:	4798      	blx	r3
	//ModemWrite("ATZ\r\n");
	ModemWrite("AT&D0\r\n");  //    115200?
 800c0d6:	4806      	ldr	r0, [pc, #24]	; (800c0f0 <WaitAtd1+0x24>)
 800c0d8:	4b06      	ldr	r3, [pc, #24]	; (800c0f4 <WaitAtd1+0x28>)
 800c0da:	4798      	blx	r3
	return WaitAnsver(MA_OK, 10);
 800c0dc:	210a      	movs	r1, #10
 800c0de:	2002      	movs	r0, #2
 800c0e0:	4b05      	ldr	r3, [pc, #20]	; (800c0f8 <WaitAtd1+0x2c>)
 800c0e2:	4798      	blx	r3
 800c0e4:	4603      	mov	r3, r0
	//return WaitAnsver(MA_OK, 30);
}
 800c0e6:	4618      	mov	r0, r3
 800c0e8:	bd80      	pop	{r7, pc}
 800c0ea:	bf00      	nop
 800c0ec:	08001529 	.word	0x08001529
 800c0f0:	0801517c 	.word	0x0801517c
 800c0f4:	0800bfed 	.word	0x0800bfed
 800c0f8:	0800c031 	.word	0x0800c031

0800c0fc <CSQ>:
	ModemWrite("AT+SIGNAL?\r\n"); //0v1
	return WaitAnsver(MA_OK, 30);

}
//  
bool CSQ() {
 800c0fc:	b580      	push	{r7, lr}
 800c0fe:	b084      	sub	sp, #16
 800c100:	af00      	add	r7, sp, #0
	ModemWrite("AT+CSQ\r\n");
 800c102:	4832      	ldr	r0, [pc, #200]	; (800c1cc <CSQ+0xd0>)
 800c104:	4b32      	ldr	r3, [pc, #200]	; (800c1d0 <CSQ+0xd4>)
 800c106:	4798      	blx	r3
	//ModemWrite("AT+IPR?\r\n");//  
	vTaskDelay(100);
 800c108:	2064      	movs	r0, #100	; 0x64
 800c10a:	4b32      	ldr	r3, [pc, #200]	; (800c1d4 <CSQ+0xd8>)
 800c10c:	4798      	blx	r3
	bufsize2 = uart2Read(sio_buf2, 256);
 800c10e:	f44f 7180 	mov.w	r1, #256	; 0x100
 800c112:	4831      	ldr	r0, [pc, #196]	; (800c1d8 <CSQ+0xdc>)
 800c114:	4b31      	ldr	r3, [pc, #196]	; (800c1dc <CSQ+0xe0>)
 800c116:	4798      	blx	r3
 800c118:	4603      	mov	r3, r0
 800c11a:	b29a      	uxth	r2, r3
 800c11c:	4b30      	ldr	r3, [pc, #192]	; (800c1e0 <CSQ+0xe4>)
 800c11e:	801a      	strh	r2, [r3, #0]
	uint16 CSQ = 0, i1 = 0, i2 = 0;
 800c120:	2300      	movs	r3, #0
 800c122:	817b      	strh	r3, [r7, #10]
 800c124:	2300      	movs	r3, #0
 800c126:	813b      	strh	r3, [r7, #8]
 800c128:	2300      	movs	r3, #0
 800c12a:	80fb      	strh	r3, [r7, #6]
	if (bufsize2 != 0) {
 800c12c:	4b2c      	ldr	r3, [pc, #176]	; (800c1e0 <CSQ+0xe4>)
 800c12e:	881b      	ldrh	r3, [r3, #0]
 800c130:	b29b      	uxth	r3, r3
 800c132:	2b00      	cmp	r3, #0
 800c134:	d046      	beq.n	800c1c4 <CSQ+0xc8>
		for (int i = 0; i < bufsize2; i++) {
 800c136:	2300      	movs	r3, #0
 800c138:	60fb      	str	r3, [r7, #12]
 800c13a:	e03c      	b.n	800c1b6 <CSQ+0xba>
			if ((sio_buf2[i] == '+') && (sio_buf2[i + 1] == 'C')
 800c13c:	4a26      	ldr	r2, [pc, #152]	; (800c1d8 <CSQ+0xdc>)
 800c13e:	68fb      	ldr	r3, [r7, #12]
 800c140:	4413      	add	r3, r2
 800c142:	781b      	ldrb	r3, [r3, #0]
 800c144:	2b2b      	cmp	r3, #43	; 0x2b
 800c146:	d133      	bne.n	800c1b0 <CSQ+0xb4>
 800c148:	68fb      	ldr	r3, [r7, #12]
 800c14a:	3301      	adds	r3, #1
 800c14c:	4a22      	ldr	r2, [pc, #136]	; (800c1d8 <CSQ+0xdc>)
 800c14e:	5cd3      	ldrb	r3, [r2, r3]
 800c150:	2b43      	cmp	r3, #67	; 0x43
 800c152:	d12d      	bne.n	800c1b0 <CSQ+0xb4>
					&& (sio_buf2[i + 2] == 'S') && (sio_buf2[i + 3] == 'Q')
 800c154:	68fb      	ldr	r3, [r7, #12]
 800c156:	3302      	adds	r3, #2
 800c158:	4a1f      	ldr	r2, [pc, #124]	; (800c1d8 <CSQ+0xdc>)
 800c15a:	5cd3      	ldrb	r3, [r2, r3]
 800c15c:	2b53      	cmp	r3, #83	; 0x53
 800c15e:	d127      	bne.n	800c1b0 <CSQ+0xb4>
 800c160:	68fb      	ldr	r3, [r7, #12]
 800c162:	3303      	adds	r3, #3
 800c164:	4a1c      	ldr	r2, [pc, #112]	; (800c1d8 <CSQ+0xdc>)
 800c166:	5cd3      	ldrb	r3, [r2, r3]
 800c168:	2b51      	cmp	r3, #81	; 0x51
 800c16a:	d121      	bne.n	800c1b0 <CSQ+0xb4>
					&& (sio_buf2[i + 4] == ':')) {
 800c16c:	68fb      	ldr	r3, [r7, #12]
 800c16e:	3304      	adds	r3, #4
 800c170:	4a19      	ldr	r2, [pc, #100]	; (800c1d8 <CSQ+0xdc>)
 800c172:	5cd3      	ldrb	r3, [r2, r3]
 800c174:	2b3a      	cmp	r3, #58	; 0x3a
 800c176:	d11b      	bne.n	800c1b0 <CSQ+0xb4>
				char c1, c2;
				c1 = sio_buf2[i + 7];
 800c178:	68fb      	ldr	r3, [r7, #12]
 800c17a:	3307      	adds	r3, #7
 800c17c:	4a16      	ldr	r2, [pc, #88]	; (800c1d8 <CSQ+0xdc>)
 800c17e:	5cd3      	ldrb	r3, [r2, r3]
 800c180:	717b      	strb	r3, [r7, #5]
				c2 = sio_buf2[i + 6];
 800c182:	68fb      	ldr	r3, [r7, #12]
 800c184:	3306      	adds	r3, #6
 800c186:	4a14      	ldr	r2, [pc, #80]	; (800c1d8 <CSQ+0xdc>)
 800c188:	5cd3      	ldrb	r3, [r2, r3]
 800c18a:	713b      	strb	r3, [r7, #4]
				CSQ = atoi1(&c2);
 800c18c:	1d3b      	adds	r3, r7, #4
 800c18e:	4618      	mov	r0, r3
 800c190:	4b14      	ldr	r3, [pc, #80]	; (800c1e4 <CSQ+0xe8>)
 800c192:	4798      	blx	r3
 800c194:	4603      	mov	r3, r0
 800c196:	817b      	strh	r3, [r7, #10]
				RAM.CSQ = CSQ;
 800c198:	4b13      	ldr	r3, [pc, #76]	; (800c1e8 <CSQ+0xec>)
 800c19a:	897a      	ldrh	r2, [r7, #10]
 800c19c:	87da      	strh	r2, [r3, #62]	; 0x3e
				if (RAM.CSQ == 99) {
 800c19e:	4b12      	ldr	r3, [pc, #72]	; (800c1e8 <CSQ+0xec>)
 800c1a0:	8fdb      	ldrh	r3, [r3, #62]	; 0x3e
 800c1a2:	b29b      	uxth	r3, r3
 800c1a4:	2b63      	cmp	r3, #99	; 0x63
 800c1a6:	d101      	bne.n	800c1ac <CSQ+0xb0>
					 char minbuf[32];
					 itoa(RAM.CSQ, minbuf);
					 strcpy(buffer, "GSM   = ");
					 strcat(buffer, minbuf);
					 JrnlWrite(buffer);*/
					return false;
 800c1a8:	2300      	movs	r3, #0
 800c1aa:	e00b      	b.n	800c1c4 <CSQ+0xc8>
				}
				return true;
 800c1ac:	2301      	movs	r3, #1
 800c1ae:	e009      	b.n	800c1c4 <CSQ+0xc8>
		for (int i = 0; i < bufsize2; i++) {
 800c1b0:	68fb      	ldr	r3, [r7, #12]
 800c1b2:	3301      	adds	r3, #1
 800c1b4:	60fb      	str	r3, [r7, #12]
 800c1b6:	4b0a      	ldr	r3, [pc, #40]	; (800c1e0 <CSQ+0xe4>)
 800c1b8:	881b      	ldrh	r3, [r3, #0]
 800c1ba:	b29b      	uxth	r3, r3
 800c1bc:	461a      	mov	r2, r3
 800c1be:	68fb      	ldr	r3, [r7, #12]
 800c1c0:	4293      	cmp	r3, r2
 800c1c2:	dbbb      	blt.n	800c13c <CSQ+0x40>
			}
		}

	}
}
 800c1c4:	4618      	mov	r0, r3
 800c1c6:	3710      	adds	r7, #16
 800c1c8:	46bd      	mov	sp, r7
 800c1ca:	bd80      	pop	{r7, pc}
 800c1cc:	08015194 	.word	0x08015194
 800c1d0:	0800bfed 	.word	0x0800bfed
 800c1d4:	08001529 	.word	0x08001529
 800c1d8:	20008ae0 	.word	0x20008ae0
 800c1dc:	080048e5 	.word	0x080048e5
 800c1e0:	200092e6 	.word	0x200092e6
 800c1e4:	0800e9e5 	.word	0x0800e9e5
 800c1e8:	2000745c 	.word	0x2000745c

0800c1ec <GSM_clock>:

bool GSM_clock() {
 800c1ec:	b580      	push	{r7, lr}
 800c1ee:	b088      	sub	sp, #32
 800c1f0:	af00      	add	r7, sp, #0
	char buffer[3];
	buffer[2] = 0;
 800c1f2:	2300      	movs	r3, #0
 800c1f4:	74bb      	strb	r3, [r7, #18]
	DATATIME dtC;
	int temp_zone;
	int count = 0;
 800c1f6:	2300      	movs	r3, #0
 800c1f8:	61fb      	str	r3, [r7, #28]

	vTaskDelay(300);
 800c1fa:	f44f 7096 	mov.w	r0, #300	; 0x12c
 800c1fe:	4b7e      	ldr	r3, [pc, #504]	; (800c3f8 <GSM_clock+0x20c>)
 800c200:	4798      	blx	r3
	while (count < 50) {
 800c202:	e019      	b.n	800c238 <GSM_clock+0x4c>
		ModemWrite("AT+CCLK?\r\n");
 800c204:	487d      	ldr	r0, [pc, #500]	; (800c3fc <GSM_clock+0x210>)
 800c206:	4b7e      	ldr	r3, [pc, #504]	; (800c400 <GSM_clock+0x214>)
 800c208:	4798      	blx	r3
		vTaskDelay(100);
 800c20a:	2064      	movs	r0, #100	; 0x64
 800c20c:	4b7a      	ldr	r3, [pc, #488]	; (800c3f8 <GSM_clock+0x20c>)
 800c20e:	4798      	blx	r3
		bufsize2 = uart2Read(sio_buf2, 256);
 800c210:	f44f 7180 	mov.w	r1, #256	; 0x100
 800c214:	487b      	ldr	r0, [pc, #492]	; (800c404 <GSM_clock+0x218>)
 800c216:	4b7c      	ldr	r3, [pc, #496]	; (800c408 <GSM_clock+0x21c>)
 800c218:	4798      	blx	r3
 800c21a:	4603      	mov	r3, r0
 800c21c:	b29a      	uxth	r2, r3
 800c21e:	4b7b      	ldr	r3, [pc, #492]	; (800c40c <GSM_clock+0x220>)
 800c220:	801a      	strh	r2, [r3, #0]
		if (bufsize2 > 24)
 800c222:	4b7a      	ldr	r3, [pc, #488]	; (800c40c <GSM_clock+0x220>)
 800c224:	881b      	ldrh	r3, [r3, #0]
 800c226:	b29b      	uxth	r3, r3
 800c228:	2b18      	cmp	r3, #24
 800c22a:	d809      	bhi.n	800c240 <GSM_clock+0x54>
			break;
		count++;
 800c22c:	69fb      	ldr	r3, [r7, #28]
 800c22e:	3301      	adds	r3, #1
 800c230:	61fb      	str	r3, [r7, #28]
		vTaskDelay(100);
 800c232:	2064      	movs	r0, #100	; 0x64
 800c234:	4b70      	ldr	r3, [pc, #448]	; (800c3f8 <GSM_clock+0x20c>)
 800c236:	4798      	blx	r3
	while (count < 50) {
 800c238:	69fb      	ldr	r3, [r7, #28]
 800c23a:	2b31      	cmp	r3, #49	; 0x31
 800c23c:	dde2      	ble.n	800c204 <GSM_clock+0x18>
 800c23e:	e000      	b.n	800c242 <GSM_clock+0x56>
			break;
 800c240:	bf00      	nop
	}
	if (bufsize2 != 0) {
 800c242:	4b72      	ldr	r3, [pc, #456]	; (800c40c <GSM_clock+0x220>)
 800c244:	881b      	ldrh	r3, [r3, #0]
 800c246:	b29b      	uxth	r3, r3
 800c248:	2b00      	cmp	r3, #0
 800c24a:	f000 80d1 	beq.w	800c3f0 <GSM_clock+0x204>
		for (int i = 0; i < bufsize2; i++) {
 800c24e:	2300      	movs	r3, #0
 800c250:	61bb      	str	r3, [r7, #24]
 800c252:	e0b7      	b.n	800c3c4 <GSM_clock+0x1d8>
			if ((sio_buf2[i] == '+') && (sio_buf2[i + 1] == 'C')
 800c254:	4a6b      	ldr	r2, [pc, #428]	; (800c404 <GSM_clock+0x218>)
 800c256:	69bb      	ldr	r3, [r7, #24]
 800c258:	4413      	add	r3, r2
 800c25a:	781b      	ldrb	r3, [r3, #0]
 800c25c:	2b2b      	cmp	r3, #43	; 0x2b
 800c25e:	f040 80ae 	bne.w	800c3be <GSM_clock+0x1d2>
 800c262:	69bb      	ldr	r3, [r7, #24]
 800c264:	3301      	adds	r3, #1
 800c266:	4a67      	ldr	r2, [pc, #412]	; (800c404 <GSM_clock+0x218>)
 800c268:	5cd3      	ldrb	r3, [r2, r3]
 800c26a:	2b43      	cmp	r3, #67	; 0x43
 800c26c:	f040 80a7 	bne.w	800c3be <GSM_clock+0x1d2>
					&& (sio_buf2[i + 2] == 'C') && (sio_buf2[i + 3] == 'L')
 800c270:	69bb      	ldr	r3, [r7, #24]
 800c272:	3302      	adds	r3, #2
 800c274:	4a63      	ldr	r2, [pc, #396]	; (800c404 <GSM_clock+0x218>)
 800c276:	5cd3      	ldrb	r3, [r2, r3]
 800c278:	2b43      	cmp	r3, #67	; 0x43
 800c27a:	f040 80a0 	bne.w	800c3be <GSM_clock+0x1d2>
 800c27e:	69bb      	ldr	r3, [r7, #24]
 800c280:	3303      	adds	r3, #3
 800c282:	4a60      	ldr	r2, [pc, #384]	; (800c404 <GSM_clock+0x218>)
 800c284:	5cd3      	ldrb	r3, [r2, r3]
 800c286:	2b4c      	cmp	r3, #76	; 0x4c
 800c288:	f040 8099 	bne.w	800c3be <GSM_clock+0x1d2>
					&& (sio_buf2[i + 4] == 'K') && (sio_buf2[i + 5] == ':')) {
 800c28c:	69bb      	ldr	r3, [r7, #24]
 800c28e:	3304      	adds	r3, #4
 800c290:	4a5c      	ldr	r2, [pc, #368]	; (800c404 <GSM_clock+0x218>)
 800c292:	5cd3      	ldrb	r3, [r2, r3]
 800c294:	2b4b      	cmp	r3, #75	; 0x4b
 800c296:	f040 8092 	bne.w	800c3be <GSM_clock+0x1d2>
 800c29a:	69bb      	ldr	r3, [r7, #24]
 800c29c:	3305      	adds	r3, #5
 800c29e:	4a59      	ldr	r2, [pc, #356]	; (800c404 <GSM_clock+0x218>)
 800c2a0:	5cd3      	ldrb	r3, [r2, r3]
 800c2a2:	2b3a      	cmp	r3, #58	; 0x3a
 800c2a4:	f040 808b 	bne.w	800c3be <GSM_clock+0x1d2>
				buffer[0] = sio_buf2[i + 8];
 800c2a8:	69bb      	ldr	r3, [r7, #24]
 800c2aa:	3308      	adds	r3, #8
 800c2ac:	4a55      	ldr	r2, [pc, #340]	; (800c404 <GSM_clock+0x218>)
 800c2ae:	5cd3      	ldrb	r3, [r2, r3]
 800c2b0:	743b      	strb	r3, [r7, #16]
				buffer[1] = sio_buf2[i + 9];
 800c2b2:	69bb      	ldr	r3, [r7, #24]
 800c2b4:	3309      	adds	r3, #9
 800c2b6:	4a53      	ldr	r2, [pc, #332]	; (800c404 <GSM_clock+0x218>)
 800c2b8:	5cd3      	ldrb	r3, [r2, r3]
 800c2ba:	747b      	strb	r3, [r7, #17]
				dtC.Years = atoi1(buffer);
 800c2bc:	f107 0310 	add.w	r3, r7, #16
 800c2c0:	4618      	mov	r0, r3
 800c2c2:	4b53      	ldr	r3, [pc, #332]	; (800c410 <GSM_clock+0x224>)
 800c2c4:	4798      	blx	r3
 800c2c6:	4603      	mov	r3, r0
 800c2c8:	b29b      	uxth	r3, r3
 800c2ca:	803b      	strh	r3, [r7, #0]

				buffer[0] = sio_buf2[i + 11];
 800c2cc:	69bb      	ldr	r3, [r7, #24]
 800c2ce:	330b      	adds	r3, #11
 800c2d0:	4a4c      	ldr	r2, [pc, #304]	; (800c404 <GSM_clock+0x218>)
 800c2d2:	5cd3      	ldrb	r3, [r2, r3]
 800c2d4:	743b      	strb	r3, [r7, #16]
				buffer[1] = sio_buf2[i + 12];
 800c2d6:	69bb      	ldr	r3, [r7, #24]
 800c2d8:	330c      	adds	r3, #12
 800c2da:	4a4a      	ldr	r2, [pc, #296]	; (800c404 <GSM_clock+0x218>)
 800c2dc:	5cd3      	ldrb	r3, [r2, r3]
 800c2de:	747b      	strb	r3, [r7, #17]
				dtC.Month = atoi1(buffer);
 800c2e0:	f107 0310 	add.w	r3, r7, #16
 800c2e4:	4618      	mov	r0, r3
 800c2e6:	4b4a      	ldr	r3, [pc, #296]	; (800c410 <GSM_clock+0x224>)
 800c2e8:	4798      	blx	r3
 800c2ea:	4603      	mov	r3, r0
 800c2ec:	b29b      	uxth	r3, r3
 800c2ee:	807b      	strh	r3, [r7, #2]

				buffer[0] = sio_buf2[i + 14];
 800c2f0:	69bb      	ldr	r3, [r7, #24]
 800c2f2:	330e      	adds	r3, #14
 800c2f4:	4a43      	ldr	r2, [pc, #268]	; (800c404 <GSM_clock+0x218>)
 800c2f6:	5cd3      	ldrb	r3, [r2, r3]
 800c2f8:	743b      	strb	r3, [r7, #16]
				buffer[1] = sio_buf2[i + 15];
 800c2fa:	69bb      	ldr	r3, [r7, #24]
 800c2fc:	330f      	adds	r3, #15
 800c2fe:	4a41      	ldr	r2, [pc, #260]	; (800c404 <GSM_clock+0x218>)
 800c300:	5cd3      	ldrb	r3, [r2, r3]
 800c302:	747b      	strb	r3, [r7, #17]
				dtC.Data = atoi1(buffer);
 800c304:	f107 0310 	add.w	r3, r7, #16
 800c308:	4618      	mov	r0, r3
 800c30a:	4b41      	ldr	r3, [pc, #260]	; (800c410 <GSM_clock+0x224>)
 800c30c:	4798      	blx	r3
 800c30e:	4603      	mov	r3, r0
 800c310:	b29b      	uxth	r3, r3
 800c312:	80bb      	strh	r3, [r7, #4]

				buffer[0] = sio_buf2[i + 17];
 800c314:	69bb      	ldr	r3, [r7, #24]
 800c316:	3311      	adds	r3, #17
 800c318:	4a3a      	ldr	r2, [pc, #232]	; (800c404 <GSM_clock+0x218>)
 800c31a:	5cd3      	ldrb	r3, [r2, r3]
 800c31c:	743b      	strb	r3, [r7, #16]
				buffer[1] = sio_buf2[i + 18];
 800c31e:	69bb      	ldr	r3, [r7, #24]
 800c320:	3312      	adds	r3, #18
 800c322:	4a38      	ldr	r2, [pc, #224]	; (800c404 <GSM_clock+0x218>)
 800c324:	5cd3      	ldrb	r3, [r2, r3]
 800c326:	747b      	strb	r3, [r7, #17]
				dtC.Hour = atoi1(buffer);
 800c328:	f107 0310 	add.w	r3, r7, #16
 800c32c:	4618      	mov	r0, r3
 800c32e:	4b38      	ldr	r3, [pc, #224]	; (800c410 <GSM_clock+0x224>)
 800c330:	4798      	blx	r3
 800c332:	4603      	mov	r3, r0
 800c334:	b29b      	uxth	r3, r3
 800c336:	813b      	strh	r3, [r7, #8]

				buffer[0] = sio_buf2[i + 20];
 800c338:	69bb      	ldr	r3, [r7, #24]
 800c33a:	3314      	adds	r3, #20
 800c33c:	4a31      	ldr	r2, [pc, #196]	; (800c404 <GSM_clock+0x218>)
 800c33e:	5cd3      	ldrb	r3, [r2, r3]
 800c340:	743b      	strb	r3, [r7, #16]
				buffer[1] = sio_buf2[i + 21];
 800c342:	69bb      	ldr	r3, [r7, #24]
 800c344:	3315      	adds	r3, #21
 800c346:	4a2f      	ldr	r2, [pc, #188]	; (800c404 <GSM_clock+0x218>)
 800c348:	5cd3      	ldrb	r3, [r2, r3]
 800c34a:	747b      	strb	r3, [r7, #17]
				dtC.Min = atoi1(buffer);
 800c34c:	f107 0310 	add.w	r3, r7, #16
 800c350:	4618      	mov	r0, r3
 800c352:	4b2f      	ldr	r3, [pc, #188]	; (800c410 <GSM_clock+0x224>)
 800c354:	4798      	blx	r3
 800c356:	4603      	mov	r3, r0
 800c358:	b29b      	uxth	r3, r3
 800c35a:	817b      	strh	r3, [r7, #10]

				buffer[0] = sio_buf2[i + 23];
 800c35c:	69bb      	ldr	r3, [r7, #24]
 800c35e:	3317      	adds	r3, #23
 800c360:	4a28      	ldr	r2, [pc, #160]	; (800c404 <GSM_clock+0x218>)
 800c362:	5cd3      	ldrb	r3, [r2, r3]
 800c364:	743b      	strb	r3, [r7, #16]
				buffer[1] = sio_buf2[i + 24];
 800c366:	69bb      	ldr	r3, [r7, #24]
 800c368:	3318      	adds	r3, #24
 800c36a:	4a26      	ldr	r2, [pc, #152]	; (800c404 <GSM_clock+0x218>)
 800c36c:	5cd3      	ldrb	r3, [r2, r3]
 800c36e:	747b      	strb	r3, [r7, #17]
				dtC.Sec = atoi1(buffer);
 800c370:	f107 0310 	add.w	r3, r7, #16
 800c374:	4618      	mov	r0, r3
 800c376:	4b26      	ldr	r3, [pc, #152]	; (800c410 <GSM_clock+0x224>)
 800c378:	4798      	blx	r3
 800c37a:	4603      	mov	r3, r0
 800c37c:	b29b      	uxth	r3, r3
 800c37e:	81bb      	strh	r3, [r7, #12]

				if ((DeviceID == 3) || (DeviceID == 1)) {
 800c380:	4b24      	ldr	r3, [pc, #144]	; (800c414 <GSM_clock+0x228>)
 800c382:	681b      	ldr	r3, [r3, #0]
 800c384:	2b03      	cmp	r3, #3
 800c386:	d003      	beq.n	800c390 <GSM_clock+0x1a4>
 800c388:	4b22      	ldr	r3, [pc, #136]	; (800c414 <GSM_clock+0x228>)
 800c38a:	681b      	ldr	r3, [r3, #0]
 800c38c:	2b01      	cmp	r3, #1
 800c38e:	d116      	bne.n	800c3be <GSM_clock+0x1d2>
					buffer[0] = sio_buf2[i + 26];
 800c390:	69bb      	ldr	r3, [r7, #24]
 800c392:	331a      	adds	r3, #26
 800c394:	4a1b      	ldr	r2, [pc, #108]	; (800c404 <GSM_clock+0x218>)
 800c396:	5cd3      	ldrb	r3, [r2, r3]
 800c398:	743b      	strb	r3, [r7, #16]
					buffer[1] = sio_buf2[i + 27];
 800c39a:	69bb      	ldr	r3, [r7, #24]
 800c39c:	331b      	adds	r3, #27
 800c39e:	4a19      	ldr	r2, [pc, #100]	; (800c404 <GSM_clock+0x218>)
 800c3a0:	5cd3      	ldrb	r3, [r2, r3]
 800c3a2:	747b      	strb	r3, [r7, #17]
					temp_zone = atoi1(buffer);
 800c3a4:	f107 0310 	add.w	r3, r7, #16
 800c3a8:	4618      	mov	r0, r3
 800c3aa:	4b19      	ldr	r3, [pc, #100]	; (800c410 <GSM_clock+0x224>)
 800c3ac:	4798      	blx	r3
 800c3ae:	6178      	str	r0, [r7, #20]

					if (temp_zone == 12) {
 800c3b0:	697b      	ldr	r3, [r7, #20]
 800c3b2:	2b0c      	cmp	r3, #12
 800c3b4:	d103      	bne.n	800c3be <GSM_clock+0x1d2>
						dtC.Hour = dtC.Hour + 3;
 800c3b6:	893b      	ldrh	r3, [r7, #8]
 800c3b8:	3303      	adds	r3, #3
 800c3ba:	b29b      	uxth	r3, r3
 800c3bc:	813b      	strh	r3, [r7, #8]
		for (int i = 0; i < bufsize2; i++) {
 800c3be:	69bb      	ldr	r3, [r7, #24]
 800c3c0:	3301      	adds	r3, #1
 800c3c2:	61bb      	str	r3, [r7, #24]
 800c3c4:	4b11      	ldr	r3, [pc, #68]	; (800c40c <GSM_clock+0x220>)
 800c3c6:	881b      	ldrh	r3, [r3, #0]
 800c3c8:	b29b      	uxth	r3, r3
 800c3ca:	461a      	mov	r2, r3
 800c3cc:	69bb      	ldr	r3, [r7, #24]
 800c3ce:	4293      	cmp	r3, r2
 800c3d0:	f6ff af40 	blt.w	800c254 <GSM_clock+0x68>
					}
				}
			}
		}
		dtC.Years += 2000;
 800c3d4:	883b      	ldrh	r3, [r7, #0]
 800c3d6:	f503 63fa 	add.w	r3, r3, #2000	; 0x7d0
 800c3da:	b29b      	uxth	r3, r3
 800c3dc:	803b      	strh	r3, [r7, #0]

		rtcSetDataTime(&dtC);
 800c3de:	463b      	mov	r3, r7
 800c3e0:	4618      	mov	r0, r3
 800c3e2:	4b0d      	ldr	r3, [pc, #52]	; (800c418 <GSM_clock+0x22c>)
 800c3e4:	4798      	blx	r3

		FlagGSMtime = 1;
 800c3e6:	4b0d      	ldr	r3, [pc, #52]	; (800c41c <GSM_clock+0x230>)
 800c3e8:	2201      	movs	r2, #1
 800c3ea:	701a      	strb	r2, [r3, #0]
		return true;
 800c3ec:	2301      	movs	r3, #1
 800c3ee:	e7ff      	b.n	800c3f0 <GSM_clock+0x204>

	}

}
 800c3f0:	4618      	mov	r0, r3
 800c3f2:	3720      	adds	r7, #32
 800c3f4:	46bd      	mov	sp, r7
 800c3f6:	bd80      	pop	{r7, pc}
 800c3f8:	08001529 	.word	0x08001529
 800c3fc:	080151a0 	.word	0x080151a0
 800c400:	0800bfed 	.word	0x0800bfed
 800c404:	20008ae0 	.word	0x20008ae0
 800c408:	080048e5 	.word	0x080048e5
 800c40c:	200092e6 	.word	0x200092e6
 800c410:	0800e9e5 	.word	0x0800e9e5
 800c414:	20008468 	.word	0x20008468
 800c418:	080054e5 	.word	0x080054e5
 800c41c:	200070fc 	.word	0x200070fc

0800c420 <ATCPIN>:
		}
	}

}

bool ATCPIN() {
 800c420:	b580      	push	{r7, lr}
 800c422:	b082      	sub	sp, #8
 800c424:	af00      	add	r7, sp, #0
	vTaskDelay(200);
 800c426:	20c8      	movs	r0, #200	; 0xc8
 800c428:	4b3f      	ldr	r3, [pc, #252]	; (800c528 <ATCPIN+0x108>)
 800c42a:	4798      	blx	r3
	ModemWrite("AT+CPIN?\r\n");
 800c42c:	483f      	ldr	r0, [pc, #252]	; (800c52c <ATCPIN+0x10c>)
 800c42e:	4b40      	ldr	r3, [pc, #256]	; (800c530 <ATCPIN+0x110>)
 800c430:	4798      	blx	r3
	vTaskDelay(200);
 800c432:	20c8      	movs	r0, #200	; 0xc8
 800c434:	4b3c      	ldr	r3, [pc, #240]	; (800c528 <ATCPIN+0x108>)
 800c436:	4798      	blx	r3
	bufsize2 = uart2Read(sio_buf2, 256);
 800c438:	f44f 7180 	mov.w	r1, #256	; 0x100
 800c43c:	483d      	ldr	r0, [pc, #244]	; (800c534 <ATCPIN+0x114>)
 800c43e:	4b3e      	ldr	r3, [pc, #248]	; (800c538 <ATCPIN+0x118>)
 800c440:	4798      	blx	r3
 800c442:	4603      	mov	r3, r0
 800c444:	b29a      	uxth	r2, r3
 800c446:	4b3d      	ldr	r3, [pc, #244]	; (800c53c <ATCPIN+0x11c>)
 800c448:	801a      	strh	r2, [r3, #0]
	if (bufsize2 != 0) {
 800c44a:	4b3c      	ldr	r3, [pc, #240]	; (800c53c <ATCPIN+0x11c>)
 800c44c:	881b      	ldrh	r3, [r3, #0]
 800c44e:	b29b      	uxth	r3, r3
 800c450:	2b00      	cmp	r3, #0
 800c452:	d063      	beq.n	800c51c <ATCPIN+0xfc>
		for (int i = 2; i < bufsize2; i++) {
 800c454:	2302      	movs	r3, #2
 800c456:	607b      	str	r3, [r7, #4]
 800c458:	e059      	b.n	800c50e <ATCPIN+0xee>
			if ((sio_buf2[i] == '+') && (sio_buf2[i + 1] == 'C')
 800c45a:	4a36      	ldr	r2, [pc, #216]	; (800c534 <ATCPIN+0x114>)
 800c45c:	687b      	ldr	r3, [r7, #4]
 800c45e:	4413      	add	r3, r2
 800c460:	781b      	ldrb	r3, [r3, #0]
 800c462:	2b2b      	cmp	r3, #43	; 0x2b
 800c464:	d150      	bne.n	800c508 <ATCPIN+0xe8>
 800c466:	687b      	ldr	r3, [r7, #4]
 800c468:	3301      	adds	r3, #1
 800c46a:	4a32      	ldr	r2, [pc, #200]	; (800c534 <ATCPIN+0x114>)
 800c46c:	5cd3      	ldrb	r3, [r2, r3]
 800c46e:	2b43      	cmp	r3, #67	; 0x43
 800c470:	d14a      	bne.n	800c508 <ATCPIN+0xe8>
					&& (sio_buf2[i + 2] == 'P') && (sio_buf2[i + 3] == 'I')
 800c472:	687b      	ldr	r3, [r7, #4]
 800c474:	3302      	adds	r3, #2
 800c476:	4a2f      	ldr	r2, [pc, #188]	; (800c534 <ATCPIN+0x114>)
 800c478:	5cd3      	ldrb	r3, [r2, r3]
 800c47a:	2b50      	cmp	r3, #80	; 0x50
 800c47c:	d144      	bne.n	800c508 <ATCPIN+0xe8>
 800c47e:	687b      	ldr	r3, [r7, #4]
 800c480:	3303      	adds	r3, #3
 800c482:	4a2c      	ldr	r2, [pc, #176]	; (800c534 <ATCPIN+0x114>)
 800c484:	5cd3      	ldrb	r3, [r2, r3]
 800c486:	2b49      	cmp	r3, #73	; 0x49
 800c488:	d13e      	bne.n	800c508 <ATCPIN+0xe8>
					&& (sio_buf2[i + 4] == 'N') && (sio_buf2[i + 5] == ':')
 800c48a:	687b      	ldr	r3, [r7, #4]
 800c48c:	3304      	adds	r3, #4
 800c48e:	4a29      	ldr	r2, [pc, #164]	; (800c534 <ATCPIN+0x114>)
 800c490:	5cd3      	ldrb	r3, [r2, r3]
 800c492:	2b4e      	cmp	r3, #78	; 0x4e
 800c494:	d138      	bne.n	800c508 <ATCPIN+0xe8>
 800c496:	687b      	ldr	r3, [r7, #4]
 800c498:	3305      	adds	r3, #5
 800c49a:	4a26      	ldr	r2, [pc, #152]	; (800c534 <ATCPIN+0x114>)
 800c49c:	5cd3      	ldrb	r3, [r2, r3]
 800c49e:	2b3a      	cmp	r3, #58	; 0x3a
 800c4a0:	d132      	bne.n	800c508 <ATCPIN+0xe8>
					&& (sio_buf2[i + 6] == ' ') && (sio_buf2[i + 7] == 'R')
 800c4a2:	687b      	ldr	r3, [r7, #4]
 800c4a4:	3306      	adds	r3, #6
 800c4a6:	4a23      	ldr	r2, [pc, #140]	; (800c534 <ATCPIN+0x114>)
 800c4a8:	5cd3      	ldrb	r3, [r2, r3]
 800c4aa:	2b20      	cmp	r3, #32
 800c4ac:	d12c      	bne.n	800c508 <ATCPIN+0xe8>
 800c4ae:	687b      	ldr	r3, [r7, #4]
 800c4b0:	3307      	adds	r3, #7
 800c4b2:	4a20      	ldr	r2, [pc, #128]	; (800c534 <ATCPIN+0x114>)
 800c4b4:	5cd3      	ldrb	r3, [r2, r3]
 800c4b6:	2b52      	cmp	r3, #82	; 0x52
 800c4b8:	d126      	bne.n	800c508 <ATCPIN+0xe8>
					&& (sio_buf2[i + 8] == 'E') && (sio_buf2[i + 9] == 'A')
 800c4ba:	687b      	ldr	r3, [r7, #4]
 800c4bc:	3308      	adds	r3, #8
 800c4be:	4a1d      	ldr	r2, [pc, #116]	; (800c534 <ATCPIN+0x114>)
 800c4c0:	5cd3      	ldrb	r3, [r2, r3]
 800c4c2:	2b45      	cmp	r3, #69	; 0x45
 800c4c4:	d120      	bne.n	800c508 <ATCPIN+0xe8>
 800c4c6:	687b      	ldr	r3, [r7, #4]
 800c4c8:	3309      	adds	r3, #9
 800c4ca:	4a1a      	ldr	r2, [pc, #104]	; (800c534 <ATCPIN+0x114>)
 800c4cc:	5cd3      	ldrb	r3, [r2, r3]
 800c4ce:	2b41      	cmp	r3, #65	; 0x41
 800c4d0:	d11a      	bne.n	800c508 <ATCPIN+0xe8>
					&& (sio_buf2[i + 10] == 'D') && (sio_buf2[i + 11] == 'Y')) {
 800c4d2:	687b      	ldr	r3, [r7, #4]
 800c4d4:	330a      	adds	r3, #10
 800c4d6:	4a17      	ldr	r2, [pc, #92]	; (800c534 <ATCPIN+0x114>)
 800c4d8:	5cd3      	ldrb	r3, [r2, r3]
 800c4da:	2b44      	cmp	r3, #68	; 0x44
 800c4dc:	d114      	bne.n	800c508 <ATCPIN+0xe8>
 800c4de:	687b      	ldr	r3, [r7, #4]
 800c4e0:	330b      	adds	r3, #11
 800c4e2:	4a14      	ldr	r2, [pc, #80]	; (800c534 <ATCPIN+0x114>)
 800c4e4:	5cd3      	ldrb	r3, [r2, r3]
 800c4e6:	2b59      	cmp	r3, #89	; 0x59
 800c4e8:	d10e      	bne.n	800c508 <ATCPIN+0xe8>
				if (LedSIM_Journal) {
 800c4ea:	4b15      	ldr	r3, [pc, #84]	; (800c540 <ATCPIN+0x120>)
 800c4ec:	781b      	ldrb	r3, [r3, #0]
 800c4ee:	2b00      	cmp	r3, #0
 800c4f0:	d005      	beq.n	800c4fe <ATCPIN+0xde>
					LedSIM_Journal = 0;
 800c4f2:	4b13      	ldr	r3, [pc, #76]	; (800c540 <ATCPIN+0x120>)
 800c4f4:	2200      	movs	r2, #0
 800c4f6:	701a      	strb	r2, [r3, #0]
					JrnlWrite("GSM:- ");
 800c4f8:	4812      	ldr	r0, [pc, #72]	; (800c544 <ATCPIN+0x124>)
 800c4fa:	4b13      	ldr	r3, [pc, #76]	; (800c548 <ATCPIN+0x128>)
 800c4fc:	4798      	blx	r3
				}

				LedSIM = 0;
 800c4fe:	4b13      	ldr	r3, [pc, #76]	; (800c54c <ATCPIN+0x12c>)
 800c500:	2200      	movs	r2, #0
 800c502:	701a      	strb	r2, [r3, #0]
				return true;
 800c504:	2301      	movs	r3, #1
 800c506:	e00a      	b.n	800c51e <ATCPIN+0xfe>
		for (int i = 2; i < bufsize2; i++) {
 800c508:	687b      	ldr	r3, [r7, #4]
 800c50a:	3301      	adds	r3, #1
 800c50c:	607b      	str	r3, [r7, #4]
 800c50e:	4b0b      	ldr	r3, [pc, #44]	; (800c53c <ATCPIN+0x11c>)
 800c510:	881b      	ldrh	r3, [r3, #0]
 800c512:	b29b      	uxth	r3, r3
 800c514:	461a      	mov	r2, r3
 800c516:	687b      	ldr	r3, [r7, #4]
 800c518:	4293      	cmp	r3, r2
 800c51a:	db9e      	blt.n	800c45a <ATCPIN+0x3a>

			}
		}
	}

	return false;
 800c51c:	2300      	movs	r3, #0

}
 800c51e:	4618      	mov	r0, r3
 800c520:	3708      	adds	r7, #8
 800c522:	46bd      	mov	sp, r7
 800c524:	bd80      	pop	{r7, pc}
 800c526:	bf00      	nop
 800c528:	08001529 	.word	0x08001529
 800c52c:	080151b8 	.word	0x080151b8
 800c530:	0800bfed 	.word	0x0800bfed
 800c534:	20008ae0 	.word	0x20008ae0
 800c538:	080048e5 	.word	0x080048e5
 800c53c:	200092e6 	.word	0x200092e6
 800c540:	200092f9 	.word	0x200092f9
 800c544:	080151c4 	.word	0x080151c4
 800c548:	0800edb5 	.word	0x0800edb5
 800c54c:	200072b9 	.word	0x200072b9

0800c550 <ATCREG>:

bool ATCREG() {
 800c550:	b580      	push	{r7, lr}
 800c552:	b082      	sub	sp, #8
 800c554:	af00      	add	r7, sp, #0
	vTaskDelay(100);
 800c556:	2064      	movs	r0, #100	; 0x64
 800c558:	4b32      	ldr	r3, [pc, #200]	; (800c624 <ATCREG+0xd4>)
 800c55a:	4798      	blx	r3
	ModemWrite("AT+CREG?\r\n");
 800c55c:	4832      	ldr	r0, [pc, #200]	; (800c628 <ATCREG+0xd8>)
 800c55e:	4b33      	ldr	r3, [pc, #204]	; (800c62c <ATCREG+0xdc>)
 800c560:	4798      	blx	r3
	vTaskDelay(100);
 800c562:	2064      	movs	r0, #100	; 0x64
 800c564:	4b2f      	ldr	r3, [pc, #188]	; (800c624 <ATCREG+0xd4>)
 800c566:	4798      	blx	r3
	bufsize2 = uart2Read(sio_buf2, 256);
 800c568:	f44f 7180 	mov.w	r1, #256	; 0x100
 800c56c:	4830      	ldr	r0, [pc, #192]	; (800c630 <ATCREG+0xe0>)
 800c56e:	4b31      	ldr	r3, [pc, #196]	; (800c634 <ATCREG+0xe4>)
 800c570:	4798      	blx	r3
 800c572:	4603      	mov	r3, r0
 800c574:	b29a      	uxth	r2, r3
 800c576:	4b30      	ldr	r3, [pc, #192]	; (800c638 <ATCREG+0xe8>)
 800c578:	801a      	strh	r2, [r3, #0]
	if (bufsize2 != 0) {
 800c57a:	4b2f      	ldr	r3, [pc, #188]	; (800c638 <ATCREG+0xe8>)
 800c57c:	881b      	ldrh	r3, [r3, #0]
 800c57e:	b29b      	uxth	r3, r3
 800c580:	2b00      	cmp	r3, #0
 800c582:	d04a      	beq.n	800c61a <ATCREG+0xca>
		for (int i = 2; i < bufsize2; i++) {
 800c584:	2302      	movs	r3, #2
 800c586:	607b      	str	r3, [r7, #4]
 800c588:	e040      	b.n	800c60c <ATCREG+0xbc>
			if ((sio_buf2[i] == '+') && (sio_buf2[i + 1] == 'C')
 800c58a:	4a29      	ldr	r2, [pc, #164]	; (800c630 <ATCREG+0xe0>)
 800c58c:	687b      	ldr	r3, [r7, #4]
 800c58e:	4413      	add	r3, r2
 800c590:	781b      	ldrb	r3, [r3, #0]
 800c592:	2b2b      	cmp	r3, #43	; 0x2b
 800c594:	d137      	bne.n	800c606 <ATCREG+0xb6>
 800c596:	687b      	ldr	r3, [r7, #4]
 800c598:	3301      	adds	r3, #1
 800c59a:	4a25      	ldr	r2, [pc, #148]	; (800c630 <ATCREG+0xe0>)
 800c59c:	5cd3      	ldrb	r3, [r2, r3]
 800c59e:	2b43      	cmp	r3, #67	; 0x43
 800c5a0:	d131      	bne.n	800c606 <ATCREG+0xb6>
					&& (sio_buf2[i + 2] == 'R') && (sio_buf2[i + 3] == 'E')
 800c5a2:	687b      	ldr	r3, [r7, #4]
 800c5a4:	3302      	adds	r3, #2
 800c5a6:	4a22      	ldr	r2, [pc, #136]	; (800c630 <ATCREG+0xe0>)
 800c5a8:	5cd3      	ldrb	r3, [r2, r3]
 800c5aa:	2b52      	cmp	r3, #82	; 0x52
 800c5ac:	d12b      	bne.n	800c606 <ATCREG+0xb6>
 800c5ae:	687b      	ldr	r3, [r7, #4]
 800c5b0:	3303      	adds	r3, #3
 800c5b2:	4a1f      	ldr	r2, [pc, #124]	; (800c630 <ATCREG+0xe0>)
 800c5b4:	5cd3      	ldrb	r3, [r2, r3]
 800c5b6:	2b45      	cmp	r3, #69	; 0x45
 800c5b8:	d125      	bne.n	800c606 <ATCREG+0xb6>
					&& (sio_buf2[i + 4] == 'G') && (sio_buf2[i + 5] == ':')
 800c5ba:	687b      	ldr	r3, [r7, #4]
 800c5bc:	3304      	adds	r3, #4
 800c5be:	4a1c      	ldr	r2, [pc, #112]	; (800c630 <ATCREG+0xe0>)
 800c5c0:	5cd3      	ldrb	r3, [r2, r3]
 800c5c2:	2b47      	cmp	r3, #71	; 0x47
 800c5c4:	d11f      	bne.n	800c606 <ATCREG+0xb6>
 800c5c6:	687b      	ldr	r3, [r7, #4]
 800c5c8:	3305      	adds	r3, #5
 800c5ca:	4a19      	ldr	r2, [pc, #100]	; (800c630 <ATCREG+0xe0>)
 800c5cc:	5cd3      	ldrb	r3, [r2, r3]
 800c5ce:	2b3a      	cmp	r3, #58	; 0x3a
 800c5d0:	d119      	bne.n	800c606 <ATCREG+0xb6>
					&& (sio_buf2[i + 6] == ' ') && (sio_buf2[i + 7] == '0')
 800c5d2:	687b      	ldr	r3, [r7, #4]
 800c5d4:	3306      	adds	r3, #6
 800c5d6:	4a16      	ldr	r2, [pc, #88]	; (800c630 <ATCREG+0xe0>)
 800c5d8:	5cd3      	ldrb	r3, [r2, r3]
 800c5da:	2b20      	cmp	r3, #32
 800c5dc:	d113      	bne.n	800c606 <ATCREG+0xb6>
 800c5de:	687b      	ldr	r3, [r7, #4]
 800c5e0:	3307      	adds	r3, #7
 800c5e2:	4a13      	ldr	r2, [pc, #76]	; (800c630 <ATCREG+0xe0>)
 800c5e4:	5cd3      	ldrb	r3, [r2, r3]
 800c5e6:	2b30      	cmp	r3, #48	; 0x30
 800c5e8:	d10d      	bne.n	800c606 <ATCREG+0xb6>
					&& (sio_buf2[i + 8] == ',') && (sio_buf2[i + 9] == '1')) {
 800c5ea:	687b      	ldr	r3, [r7, #4]
 800c5ec:	3308      	adds	r3, #8
 800c5ee:	4a10      	ldr	r2, [pc, #64]	; (800c630 <ATCREG+0xe0>)
 800c5f0:	5cd3      	ldrb	r3, [r2, r3]
 800c5f2:	2b2c      	cmp	r3, #44	; 0x2c
 800c5f4:	d107      	bne.n	800c606 <ATCREG+0xb6>
 800c5f6:	687b      	ldr	r3, [r7, #4]
 800c5f8:	3309      	adds	r3, #9
 800c5fa:	4a0d      	ldr	r2, [pc, #52]	; (800c630 <ATCREG+0xe0>)
 800c5fc:	5cd3      	ldrb	r3, [r2, r3]
 800c5fe:	2b31      	cmp	r3, #49	; 0x31
 800c600:	d101      	bne.n	800c606 <ATCREG+0xb6>
				return true;
 800c602:	2301      	movs	r3, #1
 800c604:	e00a      	b.n	800c61c <ATCREG+0xcc>
		for (int i = 2; i < bufsize2; i++) {
 800c606:	687b      	ldr	r3, [r7, #4]
 800c608:	3301      	adds	r3, #1
 800c60a:	607b      	str	r3, [r7, #4]
 800c60c:	4b0a      	ldr	r3, [pc, #40]	; (800c638 <ATCREG+0xe8>)
 800c60e:	881b      	ldrh	r3, [r3, #0]
 800c610:	b29b      	uxth	r3, r3
 800c612:	461a      	mov	r2, r3
 800c614:	687b      	ldr	r3, [r7, #4]
 800c616:	4293      	cmp	r3, r2
 800c618:	dbb7      	blt.n	800c58a <ATCREG+0x3a>
			}
		}
	}

	return false;
 800c61a:	2300      	movs	r3, #0

}
 800c61c:	4618      	mov	r0, r3
 800c61e:	3708      	adds	r7, #8
 800c620:	46bd      	mov	sp, r7
 800c622:	bd80      	pop	{r7, pc}
 800c624:	08001529 	.word	0x08001529
 800c628:	080151d8 	.word	0x080151d8
 800c62c:	0800bfed 	.word	0x0800bfed
 800c630:	20008ae0 	.word	0x20008ae0
 800c634:	080048e5 	.word	0x080048e5
 800c638:	200092e6 	.word	0x200092e6

0800c63c <ATOPEN>:

bool ATOPEN() {
 800c63c:	b580      	push	{r7, lr}
 800c63e:	b082      	sub	sp, #8
 800c640:	af00      	add	r7, sp, #0
	vTaskDelay(100);
 800c642:	2064      	movs	r0, #100	; 0x64
 800c644:	4b7a      	ldr	r3, [pc, #488]	; (800c830 <ATOPEN+0x1f4>)
 800c646:	4798      	blx	r3
	ModemWrite("AT+QIOPEN=1,1,\"TCP LISTENER\",\"127.0.0.1\",0,4444,0\r\n");
 800c648:	487a      	ldr	r0, [pc, #488]	; (800c834 <ATOPEN+0x1f8>)
 800c64a:	4b7b      	ldr	r3, [pc, #492]	; (800c838 <ATOPEN+0x1fc>)
 800c64c:	4798      	blx	r3
	vTaskDelay(100);
 800c64e:	2064      	movs	r0, #100	; 0x64
 800c650:	4b77      	ldr	r3, [pc, #476]	; (800c830 <ATOPEN+0x1f4>)
 800c652:	4798      	blx	r3
	bufsize2 = uart2Read(sio_buf2, 256);
 800c654:	f44f 7180 	mov.w	r1, #256	; 0x100
 800c658:	4878      	ldr	r0, [pc, #480]	; (800c83c <ATOPEN+0x200>)
 800c65a:	4b79      	ldr	r3, [pc, #484]	; (800c840 <ATOPEN+0x204>)
 800c65c:	4798      	blx	r3
 800c65e:	4603      	mov	r3, r0
 800c660:	b29a      	uxth	r2, r3
 800c662:	4b78      	ldr	r3, [pc, #480]	; (800c844 <ATOPEN+0x208>)
 800c664:	801a      	strh	r2, [r3, #0]
	if (bufsize2 != 0) {
 800c666:	4b77      	ldr	r3, [pc, #476]	; (800c844 <ATOPEN+0x208>)
 800c668:	881b      	ldrh	r3, [r3, #0]
 800c66a:	b29b      	uxth	r3, r3
 800c66c:	2b00      	cmp	r3, #0
 800c66e:	f000 80d5 	beq.w	800c81c <ATOPEN+0x1e0>
		for (int i = 2; i < bufsize2; i++) {
 800c672:	2302      	movs	r3, #2
 800c674:	607b      	str	r3, [r7, #4]
 800c676:	e0c9      	b.n	800c80c <ATOPEN+0x1d0>
			if ((sio_buf2[i] == 'O') && (sio_buf2[i + 1] == 'K')
 800c678:	4a70      	ldr	r2, [pc, #448]	; (800c83c <ATOPEN+0x200>)
 800c67a:	687b      	ldr	r3, [r7, #4]
 800c67c:	4413      	add	r3, r2
 800c67e:	781b      	ldrb	r3, [r3, #0]
 800c680:	2b4f      	cmp	r3, #79	; 0x4f
 800c682:	d152      	bne.n	800c72a <ATOPEN+0xee>
 800c684:	687b      	ldr	r3, [r7, #4]
 800c686:	3301      	adds	r3, #1
 800c688:	4a6c      	ldr	r2, [pc, #432]	; (800c83c <ATOPEN+0x200>)
 800c68a:	5cd3      	ldrb	r3, [r2, r3]
 800c68c:	2b4b      	cmp	r3, #75	; 0x4b
 800c68e:	d14c      	bne.n	800c72a <ATOPEN+0xee>
					&& (sio_buf2[i + 6] == '+') && (sio_buf2[i + 7] == 'Q')
 800c690:	687b      	ldr	r3, [r7, #4]
 800c692:	3306      	adds	r3, #6
 800c694:	4a69      	ldr	r2, [pc, #420]	; (800c83c <ATOPEN+0x200>)
 800c696:	5cd3      	ldrb	r3, [r2, r3]
 800c698:	2b2b      	cmp	r3, #43	; 0x2b
 800c69a:	d146      	bne.n	800c72a <ATOPEN+0xee>
 800c69c:	687b      	ldr	r3, [r7, #4]
 800c69e:	3307      	adds	r3, #7
 800c6a0:	4a66      	ldr	r2, [pc, #408]	; (800c83c <ATOPEN+0x200>)
 800c6a2:	5cd3      	ldrb	r3, [r2, r3]
 800c6a4:	2b51      	cmp	r3, #81	; 0x51
 800c6a6:	d140      	bne.n	800c72a <ATOPEN+0xee>
					&& (sio_buf2[i + 8] == 'I') && (sio_buf2[i + 9] == 'O')
 800c6a8:	687b      	ldr	r3, [r7, #4]
 800c6aa:	3308      	adds	r3, #8
 800c6ac:	4a63      	ldr	r2, [pc, #396]	; (800c83c <ATOPEN+0x200>)
 800c6ae:	5cd3      	ldrb	r3, [r2, r3]
 800c6b0:	2b49      	cmp	r3, #73	; 0x49
 800c6b2:	d13a      	bne.n	800c72a <ATOPEN+0xee>
 800c6b4:	687b      	ldr	r3, [r7, #4]
 800c6b6:	3309      	adds	r3, #9
 800c6b8:	4a60      	ldr	r2, [pc, #384]	; (800c83c <ATOPEN+0x200>)
 800c6ba:	5cd3      	ldrb	r3, [r2, r3]
 800c6bc:	2b4f      	cmp	r3, #79	; 0x4f
 800c6be:	d134      	bne.n	800c72a <ATOPEN+0xee>
					&& (sio_buf2[i + 10] == 'P') && (sio_buf2[i + 11] == 'E')
 800c6c0:	687b      	ldr	r3, [r7, #4]
 800c6c2:	330a      	adds	r3, #10
 800c6c4:	4a5d      	ldr	r2, [pc, #372]	; (800c83c <ATOPEN+0x200>)
 800c6c6:	5cd3      	ldrb	r3, [r2, r3]
 800c6c8:	2b50      	cmp	r3, #80	; 0x50
 800c6ca:	d12e      	bne.n	800c72a <ATOPEN+0xee>
 800c6cc:	687b      	ldr	r3, [r7, #4]
 800c6ce:	330b      	adds	r3, #11
 800c6d0:	4a5a      	ldr	r2, [pc, #360]	; (800c83c <ATOPEN+0x200>)
 800c6d2:	5cd3      	ldrb	r3, [r2, r3]
 800c6d4:	2b45      	cmp	r3, #69	; 0x45
 800c6d6:	d128      	bne.n	800c72a <ATOPEN+0xee>
					&& (sio_buf2[i + 12] == 'N') && (sio_buf2[i + 13] == ':')
 800c6d8:	687b      	ldr	r3, [r7, #4]
 800c6da:	330c      	adds	r3, #12
 800c6dc:	4a57      	ldr	r2, [pc, #348]	; (800c83c <ATOPEN+0x200>)
 800c6de:	5cd3      	ldrb	r3, [r2, r3]
 800c6e0:	2b4e      	cmp	r3, #78	; 0x4e
 800c6e2:	d122      	bne.n	800c72a <ATOPEN+0xee>
 800c6e4:	687b      	ldr	r3, [r7, #4]
 800c6e6:	330d      	adds	r3, #13
 800c6e8:	4a54      	ldr	r2, [pc, #336]	; (800c83c <ATOPEN+0x200>)
 800c6ea:	5cd3      	ldrb	r3, [r2, r3]
 800c6ec:	2b3a      	cmp	r3, #58	; 0x3a
 800c6ee:	d11c      	bne.n	800c72a <ATOPEN+0xee>
					&& (sio_buf2[i + 14] == ' ') && (sio_buf2[i + 15] == '1')
 800c6f0:	687b      	ldr	r3, [r7, #4]
 800c6f2:	330e      	adds	r3, #14
 800c6f4:	4a51      	ldr	r2, [pc, #324]	; (800c83c <ATOPEN+0x200>)
 800c6f6:	5cd3      	ldrb	r3, [r2, r3]
 800c6f8:	2b20      	cmp	r3, #32
 800c6fa:	d116      	bne.n	800c72a <ATOPEN+0xee>
 800c6fc:	687b      	ldr	r3, [r7, #4]
 800c6fe:	330f      	adds	r3, #15
 800c700:	4a4e      	ldr	r2, [pc, #312]	; (800c83c <ATOPEN+0x200>)
 800c702:	5cd3      	ldrb	r3, [r2, r3]
 800c704:	2b31      	cmp	r3, #49	; 0x31
 800c706:	d110      	bne.n	800c72a <ATOPEN+0xee>
					&& (sio_buf2[i + 16] == ',') && (sio_buf2[i + 17] == '0'))
 800c708:	687b      	ldr	r3, [r7, #4]
 800c70a:	3310      	adds	r3, #16
 800c70c:	4a4b      	ldr	r2, [pc, #300]	; (800c83c <ATOPEN+0x200>)
 800c70e:	5cd3      	ldrb	r3, [r2, r3]
 800c710:	2b2c      	cmp	r3, #44	; 0x2c
 800c712:	d10a      	bne.n	800c72a <ATOPEN+0xee>
 800c714:	687b      	ldr	r3, [r7, #4]
 800c716:	3311      	adds	r3, #17
 800c718:	4a48      	ldr	r2, [pc, #288]	; (800c83c <ATOPEN+0x200>)
 800c71a:	5cd3      	ldrb	r3, [r2, r3]
 800c71c:	2b30      	cmp	r3, #48	; 0x30
 800c71e:	d104      	bne.n	800c72a <ATOPEN+0xee>

					{
				i_OPEN = 0;
 800c720:	4b49      	ldr	r3, [pc, #292]	; (800c848 <ATOPEN+0x20c>)
 800c722:	2200      	movs	r2, #0
 800c724:	601a      	str	r2, [r3, #0]
				return true;
 800c726:	2301      	movs	r3, #1
 800c728:	e07d      	b.n	800c826 <ATOPEN+0x1ea>
			}
			if ((sio_buf2[i] == 'O') && (sio_buf2[i + 1] == 'K')
 800c72a:	4a44      	ldr	r2, [pc, #272]	; (800c83c <ATOPEN+0x200>)
 800c72c:	687b      	ldr	r3, [r7, #4]
 800c72e:	4413      	add	r3, r2
 800c730:	781b      	ldrb	r3, [r3, #0]
 800c732:	2b4f      	cmp	r3, #79	; 0x4f
 800c734:	d167      	bne.n	800c806 <ATOPEN+0x1ca>
 800c736:	687b      	ldr	r3, [r7, #4]
 800c738:	3301      	adds	r3, #1
 800c73a:	4a40      	ldr	r2, [pc, #256]	; (800c83c <ATOPEN+0x200>)
 800c73c:	5cd3      	ldrb	r3, [r2, r3]
 800c73e:	2b4b      	cmp	r3, #75	; 0x4b
 800c740:	d161      	bne.n	800c806 <ATOPEN+0x1ca>
					&& (sio_buf2[i + 6] == '+') && (sio_buf2[i + 7] == 'Q')
 800c742:	687b      	ldr	r3, [r7, #4]
 800c744:	3306      	adds	r3, #6
 800c746:	4a3d      	ldr	r2, [pc, #244]	; (800c83c <ATOPEN+0x200>)
 800c748:	5cd3      	ldrb	r3, [r2, r3]
 800c74a:	2b2b      	cmp	r3, #43	; 0x2b
 800c74c:	d15b      	bne.n	800c806 <ATOPEN+0x1ca>
 800c74e:	687b      	ldr	r3, [r7, #4]
 800c750:	3307      	adds	r3, #7
 800c752:	4a3a      	ldr	r2, [pc, #232]	; (800c83c <ATOPEN+0x200>)
 800c754:	5cd3      	ldrb	r3, [r2, r3]
 800c756:	2b51      	cmp	r3, #81	; 0x51
 800c758:	d155      	bne.n	800c806 <ATOPEN+0x1ca>
					&& (sio_buf2[i + 8] == 'I') && (sio_buf2[i + 9] == 'O')
 800c75a:	687b      	ldr	r3, [r7, #4]
 800c75c:	3308      	adds	r3, #8
 800c75e:	4a37      	ldr	r2, [pc, #220]	; (800c83c <ATOPEN+0x200>)
 800c760:	5cd3      	ldrb	r3, [r2, r3]
 800c762:	2b49      	cmp	r3, #73	; 0x49
 800c764:	d14f      	bne.n	800c806 <ATOPEN+0x1ca>
 800c766:	687b      	ldr	r3, [r7, #4]
 800c768:	3309      	adds	r3, #9
 800c76a:	4a34      	ldr	r2, [pc, #208]	; (800c83c <ATOPEN+0x200>)
 800c76c:	5cd3      	ldrb	r3, [r2, r3]
 800c76e:	2b4f      	cmp	r3, #79	; 0x4f
 800c770:	d149      	bne.n	800c806 <ATOPEN+0x1ca>
					&& (sio_buf2[i + 10] == 'P') && (sio_buf2[i + 11] == 'E')
 800c772:	687b      	ldr	r3, [r7, #4]
 800c774:	330a      	adds	r3, #10
 800c776:	4a31      	ldr	r2, [pc, #196]	; (800c83c <ATOPEN+0x200>)
 800c778:	5cd3      	ldrb	r3, [r2, r3]
 800c77a:	2b50      	cmp	r3, #80	; 0x50
 800c77c:	d143      	bne.n	800c806 <ATOPEN+0x1ca>
 800c77e:	687b      	ldr	r3, [r7, #4]
 800c780:	330b      	adds	r3, #11
 800c782:	4a2e      	ldr	r2, [pc, #184]	; (800c83c <ATOPEN+0x200>)
 800c784:	5cd3      	ldrb	r3, [r2, r3]
 800c786:	2b45      	cmp	r3, #69	; 0x45
 800c788:	d13d      	bne.n	800c806 <ATOPEN+0x1ca>
					&& (sio_buf2[i + 12] == 'N') && (sio_buf2[i + 13] == ':')
 800c78a:	687b      	ldr	r3, [r7, #4]
 800c78c:	330c      	adds	r3, #12
 800c78e:	4a2b      	ldr	r2, [pc, #172]	; (800c83c <ATOPEN+0x200>)
 800c790:	5cd3      	ldrb	r3, [r2, r3]
 800c792:	2b4e      	cmp	r3, #78	; 0x4e
 800c794:	d137      	bne.n	800c806 <ATOPEN+0x1ca>
 800c796:	687b      	ldr	r3, [r7, #4]
 800c798:	330d      	adds	r3, #13
 800c79a:	4a28      	ldr	r2, [pc, #160]	; (800c83c <ATOPEN+0x200>)
 800c79c:	5cd3      	ldrb	r3, [r2, r3]
 800c79e:	2b3a      	cmp	r3, #58	; 0x3a
 800c7a0:	d131      	bne.n	800c806 <ATOPEN+0x1ca>
					&& (sio_buf2[i + 14] == ' ') && (sio_buf2[i + 15] == '1')
 800c7a2:	687b      	ldr	r3, [r7, #4]
 800c7a4:	330e      	adds	r3, #14
 800c7a6:	4a25      	ldr	r2, [pc, #148]	; (800c83c <ATOPEN+0x200>)
 800c7a8:	5cd3      	ldrb	r3, [r2, r3]
 800c7aa:	2b20      	cmp	r3, #32
 800c7ac:	d12b      	bne.n	800c806 <ATOPEN+0x1ca>
 800c7ae:	687b      	ldr	r3, [r7, #4]
 800c7b0:	330f      	adds	r3, #15
 800c7b2:	4a22      	ldr	r2, [pc, #136]	; (800c83c <ATOPEN+0x200>)
 800c7b4:	5cd3      	ldrb	r3, [r2, r3]
 800c7b6:	2b31      	cmp	r3, #49	; 0x31
 800c7b8:	d125      	bne.n	800c806 <ATOPEN+0x1ca>
					&& (sio_buf2[i + 16] == ',') && (sio_buf2[i + 17] == '5')
 800c7ba:	687b      	ldr	r3, [r7, #4]
 800c7bc:	3310      	adds	r3, #16
 800c7be:	4a1f      	ldr	r2, [pc, #124]	; (800c83c <ATOPEN+0x200>)
 800c7c0:	5cd3      	ldrb	r3, [r2, r3]
 800c7c2:	2b2c      	cmp	r3, #44	; 0x2c
 800c7c4:	d11f      	bne.n	800c806 <ATOPEN+0x1ca>
 800c7c6:	687b      	ldr	r3, [r7, #4]
 800c7c8:	3311      	adds	r3, #17
 800c7ca:	4a1c      	ldr	r2, [pc, #112]	; (800c83c <ATOPEN+0x200>)
 800c7cc:	5cd3      	ldrb	r3, [r2, r3]
 800c7ce:	2b35      	cmp	r3, #53	; 0x35
 800c7d0:	d119      	bne.n	800c806 <ATOPEN+0x1ca>
					&& (sio_buf2[i + 18] == '6') && (sio_buf2[i + 19] == '3'))
 800c7d2:	687b      	ldr	r3, [r7, #4]
 800c7d4:	3312      	adds	r3, #18
 800c7d6:	4a19      	ldr	r2, [pc, #100]	; (800c83c <ATOPEN+0x200>)
 800c7d8:	5cd3      	ldrb	r3, [r2, r3]
 800c7da:	2b36      	cmp	r3, #54	; 0x36
 800c7dc:	d113      	bne.n	800c806 <ATOPEN+0x1ca>
 800c7de:	687b      	ldr	r3, [r7, #4]
 800c7e0:	3313      	adds	r3, #19
 800c7e2:	4a16      	ldr	r2, [pc, #88]	; (800c83c <ATOPEN+0x200>)
 800c7e4:	5cd3      	ldrb	r3, [r2, r3]
 800c7e6:	2b33      	cmp	r3, #51	; 0x33
 800c7e8:	d10d      	bne.n	800c806 <ATOPEN+0x1ca>

					{
				if (!WaitCloseServer()) //  1,563   tcp
 800c7ea:	4b18      	ldr	r3, [pc, #96]	; (800c84c <ATOPEN+0x210>)
 800c7ec:	4798      	blx	r3
 800c7ee:	4603      	mov	r3, r0
 800c7f0:	f083 0301 	eor.w	r3, r3, #1
 800c7f4:	b2db      	uxtb	r3, r3
 800c7f6:	2b00      	cmp	r3, #0
 800c7f8:	d104      	bne.n	800c804 <ATOPEN+0x1c8>
					continue;
				i_OPEN = 5;
 800c7fa:	4b13      	ldr	r3, [pc, #76]	; (800c848 <ATOPEN+0x20c>)
 800c7fc:	2205      	movs	r2, #5
 800c7fe:	601a      	str	r2, [r3, #0]
				return false;
 800c800:	2300      	movs	r3, #0
 800c802:	e010      	b.n	800c826 <ATOPEN+0x1ea>
					continue;
 800c804:	bf00      	nop
		for (int i = 2; i < bufsize2; i++) {
 800c806:	687b      	ldr	r3, [r7, #4]
 800c808:	3301      	adds	r3, #1
 800c80a:	607b      	str	r3, [r7, #4]
 800c80c:	4b0d      	ldr	r3, [pc, #52]	; (800c844 <ATOPEN+0x208>)
 800c80e:	881b      	ldrh	r3, [r3, #0]
 800c810:	b29b      	uxth	r3, r3
 800c812:	461a      	mov	r2, r3
 800c814:	687b      	ldr	r3, [r7, #4]
 800c816:	4293      	cmp	r3, r2
 800c818:	f6ff af2e 	blt.w	800c678 <ATOPEN+0x3c>
			}

		}

	}
	vTaskDelay(5000);
 800c81c:	f241 3088 	movw	r0, #5000	; 0x1388
 800c820:	4b03      	ldr	r3, [pc, #12]	; (800c830 <ATOPEN+0x1f4>)
 800c822:	4798      	blx	r3
	return false;
 800c824:	2300      	movs	r3, #0
}
 800c826:	4618      	mov	r0, r3
 800c828:	3708      	adds	r7, #8
 800c82a:	46bd      	mov	sp, r7
 800c82c:	bd80      	pop	{r7, pc}
 800c82e:	bf00      	nop
 800c830:	08001529 	.word	0x08001529
 800c834:	080151e4 	.word	0x080151e4
 800c838:	0800bfed 	.word	0x0800bfed
 800c83c:	20008ae0 	.word	0x20008ae0
 800c840:	080048e5 	.word	0x080048e5
 800c844:	200092e6 	.word	0x200092e6
 800c848:	200092f0 	.word	0x200092f0
 800c84c:	0800c8f5 	.word	0x0800c8f5

0800c850 <WaitClose>:

bool WaitClose(int IDs) {
 800c850:	b580      	push	{r7, lr}
 800c852:	b0ca      	sub	sp, #296	; 0x128
 800c854:	af00      	add	r7, sp, #0
 800c856:	f507 7394 	add.w	r3, r7, #296	; 0x128
 800c85a:	f5a3 7392 	sub.w	r3, r3, #292	; 0x124
 800c85e:	6018      	str	r0, [r3, #0]

	char buffer[256];
	char minbuf[32];

	itoa1(IDs, minbuf);
 800c860:	f107 0208 	add.w	r2, r7, #8
 800c864:	f507 7394 	add.w	r3, r7, #296	; 0x128
 800c868:	f5a3 7392 	sub.w	r3, r3, #292	; 0x124
 800c86c:	4611      	mov	r1, r2
 800c86e:	6818      	ldr	r0, [r3, #0]
 800c870:	4b18      	ldr	r3, [pc, #96]	; (800c8d4 <WaitClose+0x84>)
 800c872:	4798      	blx	r3
	strcpy(buffer, "AT+QICLOSE="); //  TCP
 800c874:	f107 0328 	add.w	r3, r7, #40	; 0x28
 800c878:	4a17      	ldr	r2, [pc, #92]	; (800c8d8 <WaitClose+0x88>)
 800c87a:	ca07      	ldmia	r2, {r0, r1, r2}
 800c87c:	e883 0007 	stmia.w	r3, {r0, r1, r2}
	strcat(buffer, minbuf);
 800c880:	f107 0208 	add.w	r2, r7, #8
 800c884:	f107 0328 	add.w	r3, r7, #40	; 0x28
 800c888:	4611      	mov	r1, r2
 800c88a:	4618      	mov	r0, r3
 800c88c:	4b13      	ldr	r3, [pc, #76]	; (800c8dc <WaitClose+0x8c>)
 800c88e:	4798      	blx	r3
	strcat(buffer, "\r\n");
 800c890:	f107 0328 	add.w	r3, r7, #40	; 0x28
 800c894:	4618      	mov	r0, r3
 800c896:	4b12      	ldr	r3, [pc, #72]	; (800c8e0 <WaitClose+0x90>)
 800c898:	4798      	blx	r3
 800c89a:	4603      	mov	r3, r0
 800c89c:	461a      	mov	r2, r3
 800c89e:	f107 0328 	add.w	r3, r7, #40	; 0x28
 800c8a2:	4413      	add	r3, r2
 800c8a4:	4a0f      	ldr	r2, [pc, #60]	; (800c8e4 <WaitClose+0x94>)
 800c8a6:	8811      	ldrh	r1, [r2, #0]
 800c8a8:	7892      	ldrb	r2, [r2, #2]
 800c8aa:	8019      	strh	r1, [r3, #0]
 800c8ac:	709a      	strb	r2, [r3, #2]
	ModemWrite(buffer);
 800c8ae:	f107 0328 	add.w	r3, r7, #40	; 0x28
 800c8b2:	4618      	mov	r0, r3
 800c8b4:	4b0c      	ldr	r3, [pc, #48]	; (800c8e8 <WaitClose+0x98>)
 800c8b6:	4798      	blx	r3
	vTaskDelay(100);
 800c8b8:	2064      	movs	r0, #100	; 0x64
 800c8ba:	4b0c      	ldr	r3, [pc, #48]	; (800c8ec <WaitClose+0x9c>)
 800c8bc:	4798      	blx	r3
	return WaitAnsver(MA_OK, 1000);
 800c8be:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 800c8c2:	2002      	movs	r0, #2
 800c8c4:	4b0a      	ldr	r3, [pc, #40]	; (800c8f0 <WaitClose+0xa0>)
 800c8c6:	4798      	blx	r3
 800c8c8:	4603      	mov	r3, r0

}
 800c8ca:	4618      	mov	r0, r3
 800c8cc:	f507 7794 	add.w	r7, r7, #296	; 0x128
 800c8d0:	46bd      	mov	sp, r7
 800c8d2:	bd80      	pop	{r7, pc}
 800c8d4:	0800e895 	.word	0x0800e895
 800c8d8:	08015218 	.word	0x08015218
 800c8dc:	08014635 	.word	0x08014635
 800c8e0:	08014731 	.word	0x08014731
 800c8e4:	08015224 	.word	0x08015224
 800c8e8:	0800bfed 	.word	0x0800bfed
 800c8ec:	08001529 	.word	0x08001529
 800c8f0:	0800c031 	.word	0x0800c031

0800c8f4 <WaitCloseServer>:

bool WaitCloseServer() {
 800c8f4:	b580      	push	{r7, lr}
 800c8f6:	af00      	add	r7, sp, #0
	ModemWrite("AT+QICLOSE=1\r\n"); //  TCP
 800c8f8:	4806      	ldr	r0, [pc, #24]	; (800c914 <WaitCloseServer+0x20>)
 800c8fa:	4b07      	ldr	r3, [pc, #28]	; (800c918 <WaitCloseServer+0x24>)
 800c8fc:	4798      	blx	r3
	vTaskDelay(100);
 800c8fe:	2064      	movs	r0, #100	; 0x64
 800c900:	4b06      	ldr	r3, [pc, #24]	; (800c91c <WaitCloseServer+0x28>)
 800c902:	4798      	blx	r3
	return WaitAnsver(MA_OK, 1000);
 800c904:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 800c908:	2002      	movs	r0, #2
 800c90a:	4b05      	ldr	r3, [pc, #20]	; (800c920 <WaitCloseServer+0x2c>)
 800c90c:	4798      	blx	r3
 800c90e:	4603      	mov	r3, r0
}
 800c910:	4618      	mov	r0, r3
 800c912:	bd80      	pop	{r7, pc}
 800c914:	08015228 	.word	0x08015228
 800c918:	0800bfed 	.word	0x0800bfed
 800c91c:	08001529 	.word	0x08001529
 800c920:	0800c031 	.word	0x0800c031

0800c924 <WaitGprsConnectUC20>:
	}

}

//======================================================
bool WaitGprsConnectUC20() {
 800c924:	b590      	push	{r4, r7, lr}
 800c926:	b0d7      	sub	sp, #348	; 0x15c
 800c928:	af00      	add	r7, sp, #0
	FLASHMEM *pxConfig = (FLASHMEM*) DEVICE_FLASHMEM_LOCATION;
 800c92a:	4b75      	ldr	r3, [pc, #468]	; (800cb00 <WaitGprsConnectUC20+0x1dc>)
 800c92c:	f8c7 3154 	str.w	r3, [r7, #340]	; 0x154
	int packSize;
	int headerSize;
	//FLASHMEM *pxConfig = (FLASHMEM*) DEVICE_FLASHMEM_LOCATION;
	int i;

	vTaskDelay(100);
 800c930:	2064      	movs	r0, #100	; 0x64
 800c932:	4b74      	ldr	r3, [pc, #464]	; (800cb04 <WaitGprsConnectUC20+0x1e0>)
 800c934:	4798      	blx	r3
	ModemWrite("AT+QIDEACT=1\r\n");    // 
 800c936:	4874      	ldr	r0, [pc, #464]	; (800cb08 <WaitGprsConnectUC20+0x1e4>)
 800c938:	4b74      	ldr	r3, [pc, #464]	; (800cb0c <WaitGprsConnectUC20+0x1e8>)
 800c93a:	4798      	blx	r3
	/*if (WaitAnsver(MA_OK,10) == false)
	 return false;*/
	vTaskDelay(4000); //40c
 800c93c:	f44f 607a 	mov.w	r0, #4000	; 0xfa0
 800c940:	4b70      	ldr	r3, [pc, #448]	; (800cb04 <WaitGprsConnectUC20+0x1e0>)
 800c942:	4798      	blx	r3
	//vTaskDelay(1000);
//	ModemWrite("AT+QIMODE=0\r\n");  //
//	if (WaitAnsver(MA_OK,10) == false)
//				return false;

	vTaskDelay(100);
 800c944:	2064      	movs	r0, #100	; 0x64
 800c946:	4b6f      	ldr	r3, [pc, #444]	; (800cb04 <WaitGprsConnectUC20+0x1e0>)
 800c948:	4798      	blx	r3
	BKP_WriteBackupRegister(BKP_DR7, 27);
 800c94a:	211b      	movs	r1, #27
 800c94c:	201c      	movs	r0, #28
 800c94e:	4b70      	ldr	r3, [pc, #448]	; (800cb10 <WaitGprsConnectUC20+0x1ec>)
 800c950:	4798      	blx	r3
//		strcat(buf, PPP_USER);
//		strcat(buf, "\",\"");
//		strcat(buf, PPP_PASS);
//		strcat(buf, "\"\,1\r\n");
//	} else {
	strcpy(buf, "AT+QICSGP=1,1,\"");
 800c952:	463b      	mov	r3, r7
 800c954:	4a6f      	ldr	r2, [pc, #444]	; (800cb14 <WaitGprsConnectUC20+0x1f0>)
 800c956:	461c      	mov	r4, r3
 800c958:	4613      	mov	r3, r2
 800c95a:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 800c95c:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
	strcat(buf, pxConfig->devcfg.gprs.adparam);
 800c960:	f8d7 2154 	ldr.w	r2, [r7, #340]	; 0x154
 800c964:	463b      	mov	r3, r7
 800c966:	4611      	mov	r1, r2
 800c968:	4618      	mov	r0, r3
 800c96a:	4b6b      	ldr	r3, [pc, #428]	; (800cb18 <WaitGprsConnectUC20+0x1f4>)
 800c96c:	4798      	blx	r3
	strcat(buf, "\",\"");
 800c96e:	463b      	mov	r3, r7
 800c970:	4618      	mov	r0, r3
 800c972:	4b6a      	ldr	r3, [pc, #424]	; (800cb1c <WaitGprsConnectUC20+0x1f8>)
 800c974:	4798      	blx	r3
 800c976:	4603      	mov	r3, r0
 800c978:	461a      	mov	r2, r3
 800c97a:	463b      	mov	r3, r7
 800c97c:	4413      	add	r3, r2
 800c97e:	4a68      	ldr	r2, [pc, #416]	; (800cb20 <WaitGprsConnectUC20+0x1fc>)
 800c980:	6810      	ldr	r0, [r2, #0]
 800c982:	6018      	str	r0, [r3, #0]
	strcat(buf, pxConfig->devcfg.gprs.login);
 800c984:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 800c988:	f103 0280 	add.w	r2, r3, #128	; 0x80
 800c98c:	463b      	mov	r3, r7
 800c98e:	4611      	mov	r1, r2
 800c990:	4618      	mov	r0, r3
 800c992:	4b61      	ldr	r3, [pc, #388]	; (800cb18 <WaitGprsConnectUC20+0x1f4>)
 800c994:	4798      	blx	r3
	strcat(buf, "\",\"");
 800c996:	463b      	mov	r3, r7
 800c998:	4618      	mov	r0, r3
 800c99a:	4b60      	ldr	r3, [pc, #384]	; (800cb1c <WaitGprsConnectUC20+0x1f8>)
 800c99c:	4798      	blx	r3
 800c99e:	4603      	mov	r3, r0
 800c9a0:	461a      	mov	r2, r3
 800c9a2:	463b      	mov	r3, r7
 800c9a4:	4413      	add	r3, r2
 800c9a6:	4a5e      	ldr	r2, [pc, #376]	; (800cb20 <WaitGprsConnectUC20+0x1fc>)
 800c9a8:	6810      	ldr	r0, [r2, #0]
 800c9aa:	6018      	str	r0, [r3, #0]
	strcat(buf, pxConfig->devcfg.gprs.password);
 800c9ac:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 800c9b0:	f103 02c0 	add.w	r2, r3, #192	; 0xc0
 800c9b4:	463b      	mov	r3, r7
 800c9b6:	4611      	mov	r1, r2
 800c9b8:	4618      	mov	r0, r3
 800c9ba:	4b57      	ldr	r3, [pc, #348]	; (800cb18 <WaitGprsConnectUC20+0x1f4>)
 800c9bc:	4798      	blx	r3
	strcat(buf, "\"\,1\r\n");
 800c9be:	463b      	mov	r3, r7
 800c9c0:	4618      	mov	r0, r3
 800c9c2:	4b56      	ldr	r3, [pc, #344]	; (800cb1c <WaitGprsConnectUC20+0x1f8>)
 800c9c4:	4798      	blx	r3
 800c9c6:	4603      	mov	r3, r0
 800c9c8:	461a      	mov	r2, r3
 800c9ca:	463b      	mov	r3, r7
 800c9cc:	4413      	add	r3, r2
 800c9ce:	4a55      	ldr	r2, [pc, #340]	; (800cb24 <WaitGprsConnectUC20+0x200>)
 800c9d0:	6810      	ldr	r0, [r2, #0]
 800c9d2:	6018      	str	r0, [r3, #0]
 800c9d4:	8892      	ldrh	r2, [r2, #4]
 800c9d6:	809a      	strh	r2, [r3, #4]
	//}
	vTaskDelay(100);
 800c9d8:	2064      	movs	r0, #100	; 0x64
 800c9da:	4b4a      	ldr	r3, [pc, #296]	; (800cb04 <WaitGprsConnectUC20+0x1e0>)
 800c9dc:	4798      	blx	r3
	ModemWrite(buf);
 800c9de:	463b      	mov	r3, r7
 800c9e0:	4618      	mov	r0, r3
 800c9e2:	4b4a      	ldr	r3, [pc, #296]	; (800cb0c <WaitGprsConnectUC20+0x1e8>)
 800c9e4:	4798      	blx	r3
	if (WaitAnsver(MA_OK, 10) == false) {
 800c9e6:	210a      	movs	r1, #10
 800c9e8:	2002      	movs	r0, #2
 800c9ea:	4b4f      	ldr	r3, [pc, #316]	; (800cb28 <WaitGprsConnectUC20+0x204>)
 800c9ec:	4798      	blx	r3
 800c9ee:	4603      	mov	r3, r0
 800c9f0:	f083 0301 	eor.w	r3, r3, #1
 800c9f4:	b2db      	uxtb	r3, r3
 800c9f6:	2b00      	cmp	r3, #0
 800c9f8:	d00e      	beq.n	800ca18 <WaitGprsConnectUC20+0xf4>
		if (!LedAPN_Journal) {
 800c9fa:	4b4c      	ldr	r3, [pc, #304]	; (800cb2c <WaitGprsConnectUC20+0x208>)
 800c9fc:	781b      	ldrb	r3, [r3, #0]
 800c9fe:	f083 0301 	eor.w	r3, r3, #1
 800ca02:	b2db      	uxtb	r3, r3
 800ca04:	2b00      	cmp	r3, #0
 800ca06:	d005      	beq.n	800ca14 <WaitGprsConnectUC20+0xf0>
			JrnlWrite("GSM: .");
 800ca08:	4849      	ldr	r0, [pc, #292]	; (800cb30 <WaitGprsConnectUC20+0x20c>)
 800ca0a:	4b4a      	ldr	r3, [pc, #296]	; (800cb34 <WaitGprsConnectUC20+0x210>)
 800ca0c:	4798      	blx	r3
			LedAPN_Journal = 1;
 800ca0e:	4b47      	ldr	r3, [pc, #284]	; (800cb2c <WaitGprsConnectUC20+0x208>)
 800ca10:	2201      	movs	r2, #1
 800ca12:	701a      	strb	r2, [r3, #0]
		}
		return false;
 800ca14:	2300      	movs	r3, #0
 800ca16:	e06d      	b.n	800caf4 <WaitGprsConnectUC20+0x1d0>
	}
	LedAPN = 0;
 800ca18:	4b47      	ldr	r3, [pc, #284]	; (800cb38 <WaitGprsConnectUC20+0x214>)
 800ca1a:	2200      	movs	r2, #0
 800ca1c:	701a      	strb	r2, [r3, #0]
	vTaskDelay(100);
 800ca1e:	2064      	movs	r0, #100	; 0x64
 800ca20:	4b38      	ldr	r3, [pc, #224]	; (800cb04 <WaitGprsConnectUC20+0x1e0>)
 800ca22:	4798      	blx	r3
	ModemWrite("AT+CMGF=1\r\n");
 800ca24:	4845      	ldr	r0, [pc, #276]	; (800cb3c <WaitGprsConnectUC20+0x218>)
 800ca26:	4b39      	ldr	r3, [pc, #228]	; (800cb0c <WaitGprsConnectUC20+0x1e8>)
 800ca28:	4798      	blx	r3
	if (WaitAnsver(MA_OK, 10) == false)
 800ca2a:	210a      	movs	r1, #10
 800ca2c:	2002      	movs	r0, #2
 800ca2e:	4b3e      	ldr	r3, [pc, #248]	; (800cb28 <WaitGprsConnectUC20+0x204>)
 800ca30:	4798      	blx	r3
 800ca32:	4603      	mov	r3, r0
 800ca34:	f083 0301 	eor.w	r3, r3, #1
 800ca38:	b2db      	uxtb	r3, r3
 800ca3a:	2b00      	cmp	r3, #0
 800ca3c:	d001      	beq.n	800ca42 <WaitGprsConnectUC20+0x11e>
		return false;
 800ca3e:	2300      	movs	r3, #0
 800ca40:	e058      	b.n	800caf4 <WaitGprsConnectUC20+0x1d0>
	vTaskDelay(100);
 800ca42:	2064      	movs	r0, #100	; 0x64
 800ca44:	4b2f      	ldr	r3, [pc, #188]	; (800cb04 <WaitGprsConnectUC20+0x1e0>)
 800ca46:	4798      	blx	r3
	ModemWrite("AT+CNMI=2,2,0,0,0\r\n");
 800ca48:	483d      	ldr	r0, [pc, #244]	; (800cb40 <WaitGprsConnectUC20+0x21c>)
 800ca4a:	4b30      	ldr	r3, [pc, #192]	; (800cb0c <WaitGprsConnectUC20+0x1e8>)
 800ca4c:	4798      	blx	r3
	if (WaitAnsver(MA_OK, 10) == false)
 800ca4e:	210a      	movs	r1, #10
 800ca50:	2002      	movs	r0, #2
 800ca52:	4b35      	ldr	r3, [pc, #212]	; (800cb28 <WaitGprsConnectUC20+0x204>)
 800ca54:	4798      	blx	r3
 800ca56:	4603      	mov	r3, r0
 800ca58:	f083 0301 	eor.w	r3, r3, #1
 800ca5c:	b2db      	uxtb	r3, r3
 800ca5e:	2b00      	cmp	r3, #0
 800ca60:	d001      	beq.n	800ca66 <WaitGprsConnectUC20+0x142>
		return false;
 800ca62:	2300      	movs	r3, #0
 800ca64:	e046      	b.n	800caf4 <WaitGprsConnectUC20+0x1d0>
	vTaskDelay(100);
 800ca66:	2064      	movs	r0, #100	; 0x64
 800ca68:	4b26      	ldr	r3, [pc, #152]	; (800cb04 <WaitGprsConnectUC20+0x1e0>)
 800ca6a:	4798      	blx	r3

	ModemWrite("AT+QIACT=1\r\n"); // 
 800ca6c:	4835      	ldr	r0, [pc, #212]	; (800cb44 <WaitGprsConnectUC20+0x220>)
 800ca6e:	4b27      	ldr	r3, [pc, #156]	; (800cb0c <WaitGprsConnectUC20+0x1e8>)
 800ca70:	4798      	blx	r3
	//vTaskDelay(100);
	if (WaitAnsver(MA_OK, 4000) == false)
 800ca72:	f44f 617a 	mov.w	r1, #4000	; 0xfa0
 800ca76:	2002      	movs	r0, #2
 800ca78:	4b2b      	ldr	r3, [pc, #172]	; (800cb28 <WaitGprsConnectUC20+0x204>)
 800ca7a:	4798      	blx	r3
 800ca7c:	4603      	mov	r3, r0
 800ca7e:	f083 0301 	eor.w	r3, r3, #1
 800ca82:	b2db      	uxtb	r3, r3
 800ca84:	2b00      	cmp	r3, #0
 800ca86:	d001      	beq.n	800ca8c <WaitGprsConnectUC20+0x168>
		return false;
 800ca88:	2300      	movs	r3, #0
 800ca8a:	e033      	b.n	800caf4 <WaitGprsConnectUC20+0x1d0>
	vTaskDelay(100);
 800ca8c:	2064      	movs	r0, #100	; 0x64
 800ca8e:	4b1d      	ldr	r3, [pc, #116]	; (800cb04 <WaitGprsConnectUC20+0x1e0>)
 800ca90:	4798      	blx	r3

	i_OPEN = 5;
 800ca92:	4b2d      	ldr	r3, [pc, #180]	; (800cb48 <WaitGprsConnectUC20+0x224>)
 800ca94:	2205      	movs	r2, #5
 800ca96:	601a      	str	r2, [r3, #0]

	while (!ATOPEN()) //    TCP
 800ca98:	e008      	b.n	800caac <WaitGprsConnectUC20+0x188>
	{
		if (i_OPEN == 0) {
 800ca9a:	4b2b      	ldr	r3, [pc, #172]	; (800cb48 <WaitGprsConnectUC20+0x224>)
 800ca9c:	681b      	ldr	r3, [r3, #0]
 800ca9e:	2b00      	cmp	r3, #0
 800caa0:	d00d      	beq.n	800cabe <WaitGprsConnectUC20+0x19a>
			break;
		}
		i_OPEN--;
 800caa2:	4b29      	ldr	r3, [pc, #164]	; (800cb48 <WaitGprsConnectUC20+0x224>)
 800caa4:	681b      	ldr	r3, [r3, #0]
 800caa6:	3b01      	subs	r3, #1
 800caa8:	4a27      	ldr	r2, [pc, #156]	; (800cb48 <WaitGprsConnectUC20+0x224>)
 800caaa:	6013      	str	r3, [r2, #0]
	while (!ATOPEN()) //    TCP
 800caac:	4b27      	ldr	r3, [pc, #156]	; (800cb4c <WaitGprsConnectUC20+0x228>)
 800caae:	4798      	blx	r3
 800cab0:	4603      	mov	r3, r0
 800cab2:	f083 0301 	eor.w	r3, r3, #1
 800cab6:	b2db      	uxtb	r3, r3
 800cab8:	2b00      	cmp	r3, #0
 800caba:	d1ee      	bne.n	800ca9a <WaitGprsConnectUC20+0x176>
 800cabc:	e000      	b.n	800cac0 <WaitGprsConnectUC20+0x19c>
			break;
 800cabe:	bf00      	nop
	}

	i_OPEN = 0;
 800cac0:	4b21      	ldr	r3, [pc, #132]	; (800cb48 <WaitGprsConnectUC20+0x224>)
 800cac2:	2200      	movs	r2, #0
 800cac4:	601a      	str	r2, [r3, #0]

	ModemWrite("AT+QILOCIP\r\n"); // IP
 800cac6:	4822      	ldr	r0, [pc, #136]	; (800cb50 <WaitGprsConnectUC20+0x22c>)
 800cac8:	4b10      	ldr	r3, [pc, #64]	; (800cb0c <WaitGprsConnectUC20+0x1e8>)
 800caca:	4798      	blx	r3
	WaitAnsver(MA_UNKNOWN, 10);
 800cacc:	210a      	movs	r1, #10
 800cace:	2000      	movs	r0, #0
 800cad0:	4b15      	ldr	r3, [pc, #84]	; (800cb28 <WaitGprsConnectUC20+0x204>)
 800cad2:	4798      	blx	r3
	vTaskDelay(100);
 800cad4:	2064      	movs	r0, #100	; 0x64
 800cad6:	4b0b      	ldr	r3, [pc, #44]	; (800cb04 <WaitGprsConnectUC20+0x1e0>)
 800cad8:	4798      	blx	r3
	 ModemWrite("AT+QISRVC=2\r\n"); // 
	 if (WaitAnsver(MA_OK,10) == false)
	 return false;*/

	//vTaskDelay(200);
	if (pxConfig->devcfg.GSMtime == 1)  //   
 800cada:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 800cade:	f8b3 3100 	ldrh.w	r3, [r3, #256]	; 0x100
 800cae2:	b29b      	uxth	r3, r3
 800cae4:	2b01      	cmp	r3, #1
 800cae6:	d104      	bne.n	800caf2 <WaitGprsConnectUC20+0x1ce>
			{

		GSM_clock();
 800cae8:	4b1a      	ldr	r3, [pc, #104]	; (800cb54 <WaitGprsConnectUC20+0x230>)
 800caea:	4798      	blx	r3
		FlagGSMtime = 0;
 800caec:	4b1a      	ldr	r3, [pc, #104]	; (800cb58 <WaitGprsConnectUC20+0x234>)
 800caee:	2200      	movs	r2, #0
 800caf0:	701a      	strb	r2, [r3, #0]

	}

	return true;
 800caf2:	2301      	movs	r3, #1
}
 800caf4:	4618      	mov	r0, r3
 800caf6:	f507 77ae 	add.w	r7, r7, #348	; 0x15c
 800cafa:	46bd      	mov	sp, r7
 800cafc:	bd90      	pop	{r4, r7, pc}
 800cafe:	bf00      	nop
 800cb00:	0802b000 	.word	0x0802b000
 800cb04:	08001529 	.word	0x08001529
 800cb08:	0801526c 	.word	0x0801526c
 800cb0c:	0800bfed 	.word	0x0800bfed
 800cb10:	08003621 	.word	0x08003621
 800cb14:	0801527c 	.word	0x0801527c
 800cb18:	08014635 	.word	0x08014635
 800cb1c:	08014731 	.word	0x08014731
 800cb20:	0801528c 	.word	0x0801528c
 800cb24:	08015290 	.word	0x08015290
 800cb28:	0800c031 	.word	0x0800c031
 800cb2c:	200092fa 	.word	0x200092fa
 800cb30:	08015298 	.word	0x08015298
 800cb34:	0800edb5 	.word	0x0800edb5
 800cb38:	200072ba 	.word	0x200072ba
 800cb3c:	080152ac 	.word	0x080152ac
 800cb40:	080152b8 	.word	0x080152b8
 800cb44:	080152cc 	.word	0x080152cc
 800cb48:	200092f0 	.word	0x200092f0
 800cb4c:	0800c63d 	.word	0x0800c63d
 800cb50:	080152dc 	.word	0x080152dc
 800cb54:	0800c1ed 	.word	0x0800c1ed
 800cb58:	200070fc 	.word	0x200070fc

0800cb5c <WaitGprsConnectUC15>:
//======================================================
bool WaitGprsConnectUC15() {
 800cb5c:	b5b0      	push	{r4, r5, r7, lr}
 800cb5e:	b0d6      	sub	sp, #344	; 0x158
 800cb60:	af00      	add	r7, sp, #0
	FLASHMEM *pxConfig = (FLASHMEM*) DEVICE_FLASHMEM_LOCATION;
 800cb62:	4ba0      	ldr	r3, [pc, #640]	; (800cde4 <WaitGprsConnectUC15+0x288>)
 800cb64:	f8c7 3154 	str.w	r3, [r7, #340]	; 0x154
	int packSize;
	int headerSize;
	//FLASHMEM *pxConfig = (FLASHMEM*) DEVICE_FLASHMEM_LOCATION;
	int i;

	vTaskDelay(100);
 800cb68:	2064      	movs	r0, #100	; 0x64
 800cb6a:	4b9f      	ldr	r3, [pc, #636]	; (800cde8 <WaitGprsConnectUC15+0x28c>)
 800cb6c:	4798      	blx	r3
	ModemWrite("AT+QIDEACT=1\r\n");    // 
 800cb6e:	489f      	ldr	r0, [pc, #636]	; (800cdec <WaitGprsConnectUC15+0x290>)
 800cb70:	4b9f      	ldr	r3, [pc, #636]	; (800cdf0 <WaitGprsConnectUC15+0x294>)
 800cb72:	4798      	blx	r3
	/*if (WaitAnsver(MA_OK,10) == false)
	 return false;*/
	vTaskDelay(4000); //40c
 800cb74:	f44f 607a 	mov.w	r0, #4000	; 0xfa0
 800cb78:	4b9b      	ldr	r3, [pc, #620]	; (800cde8 <WaitGprsConnectUC15+0x28c>)
 800cb7a:	4798      	blx	r3
	//vTaskDelay(1000);
//		ModemWrite("AT+QIMODE=0\r\n");  //
//		if (WaitAnsver(MA_OK,10) == false)
//					return false;

	vTaskDelay(100);
 800cb7c:	2064      	movs	r0, #100	; 0x64
 800cb7e:	4b9a      	ldr	r3, [pc, #616]	; (800cde8 <WaitGprsConnectUC15+0x28c>)
 800cb80:	4798      	blx	r3
	BKP_WriteBackupRegister(BKP_DR7, 27);
 800cb82:	211b      	movs	r1, #27
 800cb84:	201c      	movs	r0, #28
 800cb86:	4b9b      	ldr	r3, [pc, #620]	; (800cdf4 <WaitGprsConnectUC15+0x298>)
 800cb88:	4798      	blx	r3

	//LedAPN = 1;
	if (strlen(pxConfig->devcfg.gprs.login) > 16
 800cb8a:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 800cb8e:	3380      	adds	r3, #128	; 0x80
 800cb90:	4618      	mov	r0, r3
 800cb92:	4b99      	ldr	r3, [pc, #612]	; (800cdf8 <WaitGprsConnectUC15+0x29c>)
 800cb94:	4798      	blx	r3
 800cb96:	4603      	mov	r3, r0
 800cb98:	2b10      	cmp	r3, #16
 800cb9a:	d810      	bhi.n	800cbbe <WaitGprsConnectUC15+0x62>
			|| strlen(pxConfig->devcfg.gprs.password) > 16
 800cb9c:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 800cba0:	33c0      	adds	r3, #192	; 0xc0
 800cba2:	4618      	mov	r0, r3
 800cba4:	4b94      	ldr	r3, [pc, #592]	; (800cdf8 <WaitGprsConnectUC15+0x29c>)
 800cba6:	4798      	blx	r3
 800cba8:	4603      	mov	r3, r0
 800cbaa:	2b10      	cmp	r3, #16
 800cbac:	d807      	bhi.n	800cbbe <WaitGprsConnectUC15+0x62>
			|| strlen(pxConfig->devcfg.gprs.adparam) > 32) {
 800cbae:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 800cbb2:	4618      	mov	r0, r3
 800cbb4:	4b90      	ldr	r3, [pc, #576]	; (800cdf8 <WaitGprsConnectUC15+0x29c>)
 800cbb6:	4798      	blx	r3
 800cbb8:	4603      	mov	r3, r0
 800cbba:	2b20      	cmp	r3, #32
 800cbbc:	d958      	bls.n	800cc70 <WaitGprsConnectUC15+0x114>
		strcpy(buf, "AT+QICSGP=1,1,\""); //AT+QICSGP=1,1,"vmi.velcom.by"," "," ",1
 800cbbe:	463b      	mov	r3, r7
 800cbc0:	4a8e      	ldr	r2, [pc, #568]	; (800cdfc <WaitGprsConnectUC15+0x2a0>)
 800cbc2:	461c      	mov	r4, r3
 800cbc4:	4613      	mov	r3, r2
 800cbc6:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 800cbc8:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
		strcat(buf, PPP_ADPARAM);
 800cbcc:	463b      	mov	r3, r7
 800cbce:	4618      	mov	r0, r3
 800cbd0:	4b89      	ldr	r3, [pc, #548]	; (800cdf8 <WaitGprsConnectUC15+0x29c>)
 800cbd2:	4798      	blx	r3
 800cbd4:	4603      	mov	r3, r0
 800cbd6:	461a      	mov	r2, r3
 800cbd8:	463b      	mov	r3, r7
 800cbda:	4413      	add	r3, r2
 800cbdc:	4a88      	ldr	r2, [pc, #544]	; (800ce00 <WaitGprsConnectUC15+0x2a4>)
 800cbde:	461d      	mov	r5, r3
 800cbe0:	4614      	mov	r4, r2
 800cbe2:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800cbe4:	6028      	str	r0, [r5, #0]
 800cbe6:	6069      	str	r1, [r5, #4]
 800cbe8:	60aa      	str	r2, [r5, #8]
 800cbea:	60eb      	str	r3, [r5, #12]
 800cbec:	6820      	ldr	r0, [r4, #0]
 800cbee:	6128      	str	r0, [r5, #16]
 800cbf0:	7923      	ldrb	r3, [r4, #4]
 800cbf2:	752b      	strb	r3, [r5, #20]
		strcat(buf, "\",\"");
 800cbf4:	463b      	mov	r3, r7
 800cbf6:	4618      	mov	r0, r3
 800cbf8:	4b7f      	ldr	r3, [pc, #508]	; (800cdf8 <WaitGprsConnectUC15+0x29c>)
 800cbfa:	4798      	blx	r3
 800cbfc:	4603      	mov	r3, r0
 800cbfe:	461a      	mov	r2, r3
 800cc00:	463b      	mov	r3, r7
 800cc02:	4413      	add	r3, r2
 800cc04:	4a7f      	ldr	r2, [pc, #508]	; (800ce04 <WaitGprsConnectUC15+0x2a8>)
 800cc06:	6810      	ldr	r0, [r2, #0]
 800cc08:	6018      	str	r0, [r3, #0]
		strcat(buf, PPP_USER);
 800cc0a:	463b      	mov	r3, r7
 800cc0c:	4618      	mov	r0, r3
 800cc0e:	4b7a      	ldr	r3, [pc, #488]	; (800cdf8 <WaitGprsConnectUC15+0x29c>)
 800cc10:	4798      	blx	r3
 800cc12:	4603      	mov	r3, r0
 800cc14:	461a      	mov	r2, r3
 800cc16:	463b      	mov	r3, r7
 800cc18:	4413      	add	r3, r2
 800cc1a:	497b      	ldr	r1, [pc, #492]	; (800ce08 <WaitGprsConnectUC15+0x2ac>)
 800cc1c:	461a      	mov	r2, r3
 800cc1e:	460b      	mov	r3, r1
 800cc20:	881b      	ldrh	r3, [r3, #0]
 800cc22:	8013      	strh	r3, [r2, #0]
		strcat(buf, "\",\"");
 800cc24:	463b      	mov	r3, r7
 800cc26:	4618      	mov	r0, r3
 800cc28:	4b73      	ldr	r3, [pc, #460]	; (800cdf8 <WaitGprsConnectUC15+0x29c>)
 800cc2a:	4798      	blx	r3
 800cc2c:	4603      	mov	r3, r0
 800cc2e:	461a      	mov	r2, r3
 800cc30:	463b      	mov	r3, r7
 800cc32:	4413      	add	r3, r2
 800cc34:	4a73      	ldr	r2, [pc, #460]	; (800ce04 <WaitGprsConnectUC15+0x2a8>)
 800cc36:	6810      	ldr	r0, [r2, #0]
 800cc38:	6018      	str	r0, [r3, #0]
		strcat(buf, PPP_PASS);
 800cc3a:	463b      	mov	r3, r7
 800cc3c:	4618      	mov	r0, r3
 800cc3e:	4b6e      	ldr	r3, [pc, #440]	; (800cdf8 <WaitGprsConnectUC15+0x29c>)
 800cc40:	4798      	blx	r3
 800cc42:	4603      	mov	r3, r0
 800cc44:	461a      	mov	r2, r3
 800cc46:	463b      	mov	r3, r7
 800cc48:	4413      	add	r3, r2
 800cc4a:	496f      	ldr	r1, [pc, #444]	; (800ce08 <WaitGprsConnectUC15+0x2ac>)
 800cc4c:	461a      	mov	r2, r3
 800cc4e:	460b      	mov	r3, r1
 800cc50:	881b      	ldrh	r3, [r3, #0]
 800cc52:	8013      	strh	r3, [r2, #0]
		strcat(buf, "\"\,1\r\n");
 800cc54:	463b      	mov	r3, r7
 800cc56:	4618      	mov	r0, r3
 800cc58:	4b67      	ldr	r3, [pc, #412]	; (800cdf8 <WaitGprsConnectUC15+0x29c>)
 800cc5a:	4798      	blx	r3
 800cc5c:	4603      	mov	r3, r0
 800cc5e:	461a      	mov	r2, r3
 800cc60:	463b      	mov	r3, r7
 800cc62:	4413      	add	r3, r2
 800cc64:	4a69      	ldr	r2, [pc, #420]	; (800ce0c <WaitGprsConnectUC15+0x2b0>)
 800cc66:	6810      	ldr	r0, [r2, #0]
 800cc68:	6018      	str	r0, [r3, #0]
 800cc6a:	8892      	ldrh	r2, [r2, #4]
 800cc6c:	809a      	strh	r2, [r3, #4]
 800cc6e:	e042      	b.n	800ccf6 <WaitGprsConnectUC15+0x19a>
	} else {
		strcpy(buf, "AT+QICSGP=1,1,\"");
 800cc70:	463b      	mov	r3, r7
 800cc72:	4a62      	ldr	r2, [pc, #392]	; (800cdfc <WaitGprsConnectUC15+0x2a0>)
 800cc74:	461c      	mov	r4, r3
 800cc76:	4613      	mov	r3, r2
 800cc78:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 800cc7a:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
		strcat(buf, pxConfig->devcfg.gprs.adparam);
 800cc7e:	f8d7 2154 	ldr.w	r2, [r7, #340]	; 0x154
 800cc82:	463b      	mov	r3, r7
 800cc84:	4611      	mov	r1, r2
 800cc86:	4618      	mov	r0, r3
 800cc88:	4b61      	ldr	r3, [pc, #388]	; (800ce10 <WaitGprsConnectUC15+0x2b4>)
 800cc8a:	4798      	blx	r3
		strcat(buf, "\",\"");
 800cc8c:	463b      	mov	r3, r7
 800cc8e:	4618      	mov	r0, r3
 800cc90:	4b59      	ldr	r3, [pc, #356]	; (800cdf8 <WaitGprsConnectUC15+0x29c>)
 800cc92:	4798      	blx	r3
 800cc94:	4603      	mov	r3, r0
 800cc96:	461a      	mov	r2, r3
 800cc98:	463b      	mov	r3, r7
 800cc9a:	4413      	add	r3, r2
 800cc9c:	4a59      	ldr	r2, [pc, #356]	; (800ce04 <WaitGprsConnectUC15+0x2a8>)
 800cc9e:	6810      	ldr	r0, [r2, #0]
 800cca0:	6018      	str	r0, [r3, #0]
		strcat(buf, pxConfig->devcfg.gprs.login);
 800cca2:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 800cca6:	f103 0280 	add.w	r2, r3, #128	; 0x80
 800ccaa:	463b      	mov	r3, r7
 800ccac:	4611      	mov	r1, r2
 800ccae:	4618      	mov	r0, r3
 800ccb0:	4b57      	ldr	r3, [pc, #348]	; (800ce10 <WaitGprsConnectUC15+0x2b4>)
 800ccb2:	4798      	blx	r3
		strcat(buf, "\",\"");
 800ccb4:	463b      	mov	r3, r7
 800ccb6:	4618      	mov	r0, r3
 800ccb8:	4b4f      	ldr	r3, [pc, #316]	; (800cdf8 <WaitGprsConnectUC15+0x29c>)
 800ccba:	4798      	blx	r3
 800ccbc:	4603      	mov	r3, r0
 800ccbe:	461a      	mov	r2, r3
 800ccc0:	463b      	mov	r3, r7
 800ccc2:	4413      	add	r3, r2
 800ccc4:	4a4f      	ldr	r2, [pc, #316]	; (800ce04 <WaitGprsConnectUC15+0x2a8>)
 800ccc6:	6810      	ldr	r0, [r2, #0]
 800ccc8:	6018      	str	r0, [r3, #0]
		strcat(buf, pxConfig->devcfg.gprs.password);
 800ccca:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 800ccce:	f103 02c0 	add.w	r2, r3, #192	; 0xc0
 800ccd2:	463b      	mov	r3, r7
 800ccd4:	4611      	mov	r1, r2
 800ccd6:	4618      	mov	r0, r3
 800ccd8:	4b4d      	ldr	r3, [pc, #308]	; (800ce10 <WaitGprsConnectUC15+0x2b4>)
 800ccda:	4798      	blx	r3
		strcat(buf, "\"\,1\r\n");
 800ccdc:	463b      	mov	r3, r7
 800ccde:	4618      	mov	r0, r3
 800cce0:	4b45      	ldr	r3, [pc, #276]	; (800cdf8 <WaitGprsConnectUC15+0x29c>)
 800cce2:	4798      	blx	r3
 800cce4:	4603      	mov	r3, r0
 800cce6:	461a      	mov	r2, r3
 800cce8:	463b      	mov	r3, r7
 800ccea:	4413      	add	r3, r2
 800ccec:	4a47      	ldr	r2, [pc, #284]	; (800ce0c <WaitGprsConnectUC15+0x2b0>)
 800ccee:	6810      	ldr	r0, [r2, #0]
 800ccf0:	6018      	str	r0, [r3, #0]
 800ccf2:	8892      	ldrh	r2, [r2, #4]
 800ccf4:	809a      	strh	r2, [r3, #4]
	}
	vTaskDelay(100);
 800ccf6:	2064      	movs	r0, #100	; 0x64
 800ccf8:	4b3b      	ldr	r3, [pc, #236]	; (800cde8 <WaitGprsConnectUC15+0x28c>)
 800ccfa:	4798      	blx	r3
	ModemWrite(buf);
 800ccfc:	463b      	mov	r3, r7
 800ccfe:	4618      	mov	r0, r3
 800cd00:	4b3b      	ldr	r3, [pc, #236]	; (800cdf0 <WaitGprsConnectUC15+0x294>)
 800cd02:	4798      	blx	r3
	if (WaitAnsver(MA_OK, 10) == false) {
 800cd04:	210a      	movs	r1, #10
 800cd06:	2002      	movs	r0, #2
 800cd08:	4b42      	ldr	r3, [pc, #264]	; (800ce14 <WaitGprsConnectUC15+0x2b8>)
 800cd0a:	4798      	blx	r3
 800cd0c:	4603      	mov	r3, r0
 800cd0e:	f083 0301 	eor.w	r3, r3, #1
 800cd12:	b2db      	uxtb	r3, r3
 800cd14:	2b00      	cmp	r3, #0
 800cd16:	d00e      	beq.n	800cd36 <WaitGprsConnectUC15+0x1da>
		if (!LedAPN_Journal) {
 800cd18:	4b3f      	ldr	r3, [pc, #252]	; (800ce18 <WaitGprsConnectUC15+0x2bc>)
 800cd1a:	781b      	ldrb	r3, [r3, #0]
 800cd1c:	f083 0301 	eor.w	r3, r3, #1
 800cd20:	b2db      	uxtb	r3, r3
 800cd22:	2b00      	cmp	r3, #0
 800cd24:	d005      	beq.n	800cd32 <WaitGprsConnectUC15+0x1d6>
			JrnlWrite("GSM: .");
 800cd26:	483d      	ldr	r0, [pc, #244]	; (800ce1c <WaitGprsConnectUC15+0x2c0>)
 800cd28:	4b3d      	ldr	r3, [pc, #244]	; (800ce20 <WaitGprsConnectUC15+0x2c4>)
 800cd2a:	4798      	blx	r3
			LedAPN_Journal = 1;
 800cd2c:	4b3a      	ldr	r3, [pc, #232]	; (800ce18 <WaitGprsConnectUC15+0x2bc>)
 800cd2e:	2201      	movs	r2, #1
 800cd30:	701a      	strb	r2, [r3, #0]
		}
		return false;
 800cd32:	2300      	movs	r3, #0
 800cd34:	e09d      	b.n	800ce72 <WaitGprsConnectUC15+0x316>
	}
	LedAPN = 0;
 800cd36:	4b3b      	ldr	r3, [pc, #236]	; (800ce24 <WaitGprsConnectUC15+0x2c8>)
 800cd38:	2200      	movs	r2, #0
 800cd3a:	701a      	strb	r2, [r3, #0]
	vTaskDelay(100);
 800cd3c:	2064      	movs	r0, #100	; 0x64
 800cd3e:	4b2a      	ldr	r3, [pc, #168]	; (800cde8 <WaitGprsConnectUC15+0x28c>)
 800cd40:	4798      	blx	r3
	ModemWrite("AT+CMGF=1\r\n");
 800cd42:	4839      	ldr	r0, [pc, #228]	; (800ce28 <WaitGprsConnectUC15+0x2cc>)
 800cd44:	4b2a      	ldr	r3, [pc, #168]	; (800cdf0 <WaitGprsConnectUC15+0x294>)
 800cd46:	4798      	blx	r3
	if (WaitAnsver(MA_OK, 10) == false)
 800cd48:	210a      	movs	r1, #10
 800cd4a:	2002      	movs	r0, #2
 800cd4c:	4b31      	ldr	r3, [pc, #196]	; (800ce14 <WaitGprsConnectUC15+0x2b8>)
 800cd4e:	4798      	blx	r3
 800cd50:	4603      	mov	r3, r0
 800cd52:	f083 0301 	eor.w	r3, r3, #1
 800cd56:	b2db      	uxtb	r3, r3
 800cd58:	2b00      	cmp	r3, #0
 800cd5a:	d001      	beq.n	800cd60 <WaitGprsConnectUC15+0x204>
		return false;
 800cd5c:	2300      	movs	r3, #0
 800cd5e:	e088      	b.n	800ce72 <WaitGprsConnectUC15+0x316>
	vTaskDelay(100);
 800cd60:	2064      	movs	r0, #100	; 0x64
 800cd62:	4b21      	ldr	r3, [pc, #132]	; (800cde8 <WaitGprsConnectUC15+0x28c>)
 800cd64:	4798      	blx	r3
	ModemWrite("AT+CNMI=2,2,0,0,0\r\n");
 800cd66:	4831      	ldr	r0, [pc, #196]	; (800ce2c <WaitGprsConnectUC15+0x2d0>)
 800cd68:	4b21      	ldr	r3, [pc, #132]	; (800cdf0 <WaitGprsConnectUC15+0x294>)
 800cd6a:	4798      	blx	r3
	if (WaitAnsver(MA_OK, 10) == false)
 800cd6c:	210a      	movs	r1, #10
 800cd6e:	2002      	movs	r0, #2
 800cd70:	4b28      	ldr	r3, [pc, #160]	; (800ce14 <WaitGprsConnectUC15+0x2b8>)
 800cd72:	4798      	blx	r3
 800cd74:	4603      	mov	r3, r0
 800cd76:	f083 0301 	eor.w	r3, r3, #1
 800cd7a:	b2db      	uxtb	r3, r3
 800cd7c:	2b00      	cmp	r3, #0
 800cd7e:	d001      	beq.n	800cd84 <WaitGprsConnectUC15+0x228>
		return false;
 800cd80:	2300      	movs	r3, #0
 800cd82:	e076      	b.n	800ce72 <WaitGprsConnectUC15+0x316>
	vTaskDelay(100);
 800cd84:	2064      	movs	r0, #100	; 0x64
 800cd86:	4b18      	ldr	r3, [pc, #96]	; (800cde8 <WaitGprsConnectUC15+0x28c>)
 800cd88:	4798      	blx	r3

	ModemWrite("AT+QIACT=1\r\n"); // 
 800cd8a:	4829      	ldr	r0, [pc, #164]	; (800ce30 <WaitGprsConnectUC15+0x2d4>)
 800cd8c:	4b18      	ldr	r3, [pc, #96]	; (800cdf0 <WaitGprsConnectUC15+0x294>)
 800cd8e:	4798      	blx	r3
	vTaskDelay(100);
 800cd90:	2064      	movs	r0, #100	; 0x64
 800cd92:	4b15      	ldr	r3, [pc, #84]	; (800cde8 <WaitGprsConnectUC15+0x28c>)
 800cd94:	4798      	blx	r3
	if (WaitAnsver(MA_OK, 4000) == false)
 800cd96:	f44f 617a 	mov.w	r1, #4000	; 0xfa0
 800cd9a:	2002      	movs	r0, #2
 800cd9c:	4b1d      	ldr	r3, [pc, #116]	; (800ce14 <WaitGprsConnectUC15+0x2b8>)
 800cd9e:	4798      	blx	r3
 800cda0:	4603      	mov	r3, r0
 800cda2:	f083 0301 	eor.w	r3, r3, #1
 800cda6:	b2db      	uxtb	r3, r3
 800cda8:	2b00      	cmp	r3, #0
 800cdaa:	d001      	beq.n	800cdb0 <WaitGprsConnectUC15+0x254>
		return false;
 800cdac:	2300      	movs	r3, #0
 800cdae:	e060      	b.n	800ce72 <WaitGprsConnectUC15+0x316>
	vTaskDelay(100);
 800cdb0:	2064      	movs	r0, #100	; 0x64
 800cdb2:	4b0d      	ldr	r3, [pc, #52]	; (800cde8 <WaitGprsConnectUC15+0x28c>)
 800cdb4:	4798      	blx	r3

	i_OPEN = 5;
 800cdb6:	4b1f      	ldr	r3, [pc, #124]	; (800ce34 <WaitGprsConnectUC15+0x2d8>)
 800cdb8:	2205      	movs	r2, #5
 800cdba:	601a      	str	r2, [r3, #0]

	while (!ATOPEN()) //    TCP
 800cdbc:	e008      	b.n	800cdd0 <WaitGprsConnectUC15+0x274>
	{
		if (i_OPEN == 0) {
 800cdbe:	4b1d      	ldr	r3, [pc, #116]	; (800ce34 <WaitGprsConnectUC15+0x2d8>)
 800cdc0:	681b      	ldr	r3, [r3, #0]
 800cdc2:	2b00      	cmp	r3, #0
 800cdc4:	d03a      	beq.n	800ce3c <WaitGprsConnectUC15+0x2e0>
			break;
		}
		i_OPEN--;
 800cdc6:	4b1b      	ldr	r3, [pc, #108]	; (800ce34 <WaitGprsConnectUC15+0x2d8>)
 800cdc8:	681b      	ldr	r3, [r3, #0]
 800cdca:	3b01      	subs	r3, #1
 800cdcc:	4a19      	ldr	r2, [pc, #100]	; (800ce34 <WaitGprsConnectUC15+0x2d8>)
 800cdce:	6013      	str	r3, [r2, #0]
	while (!ATOPEN()) //    TCP
 800cdd0:	4b19      	ldr	r3, [pc, #100]	; (800ce38 <WaitGprsConnectUC15+0x2dc>)
 800cdd2:	4798      	blx	r3
 800cdd4:	4603      	mov	r3, r0
 800cdd6:	f083 0301 	eor.w	r3, r3, #1
 800cdda:	b2db      	uxtb	r3, r3
 800cddc:	2b00      	cmp	r3, #0
 800cdde:	d1ee      	bne.n	800cdbe <WaitGprsConnectUC15+0x262>
 800cde0:	e02d      	b.n	800ce3e <WaitGprsConnectUC15+0x2e2>
 800cde2:	bf00      	nop
 800cde4:	0802b000 	.word	0x0802b000
 800cde8:	08001529 	.word	0x08001529
 800cdec:	0801526c 	.word	0x0801526c
 800cdf0:	0800bfed 	.word	0x0800bfed
 800cdf4:	08003621 	.word	0x08003621
 800cdf8:	08014731 	.word	0x08014731
 800cdfc:	0801527c 	.word	0x0801527c
 800ce00:	080152ec 	.word	0x080152ec
 800ce04:	0801528c 	.word	0x0801528c
 800ce08:	08015304 	.word	0x08015304
 800ce0c:	08015290 	.word	0x08015290
 800ce10:	08014635 	.word	0x08014635
 800ce14:	0800c031 	.word	0x0800c031
 800ce18:	200092fa 	.word	0x200092fa
 800ce1c:	08015298 	.word	0x08015298
 800ce20:	0800edb5 	.word	0x0800edb5
 800ce24:	200072ba 	.word	0x200072ba
 800ce28:	080152ac 	.word	0x080152ac
 800ce2c:	080152b8 	.word	0x080152b8
 800ce30:	080152cc 	.word	0x080152cc
 800ce34:	200092f0 	.word	0x200092f0
 800ce38:	0800c63d 	.word	0x0800c63d
			break;
 800ce3c:	bf00      	nop
	}

	i_OPEN = 0;
 800ce3e:	4b0f      	ldr	r3, [pc, #60]	; (800ce7c <WaitGprsConnectUC15+0x320>)
 800ce40:	2200      	movs	r2, #0
 800ce42:	601a      	str	r2, [r3, #0]

	ModemWrite("AT+QILOCIP\r\n"); // IP
 800ce44:	480e      	ldr	r0, [pc, #56]	; (800ce80 <WaitGprsConnectUC15+0x324>)
 800ce46:	4b0f      	ldr	r3, [pc, #60]	; (800ce84 <WaitGprsConnectUC15+0x328>)
 800ce48:	4798      	blx	r3
	WaitAnsver(MA_UNKNOWN, 10);
 800ce4a:	210a      	movs	r1, #10
 800ce4c:	2000      	movs	r0, #0
 800ce4e:	4b0e      	ldr	r3, [pc, #56]	; (800ce88 <WaitGprsConnectUC15+0x32c>)
 800ce50:	4798      	blx	r3
	vTaskDelay(100);
 800ce52:	2064      	movs	r0, #100	; 0x64
 800ce54:	4b0d      	ldr	r3, [pc, #52]	; (800ce8c <WaitGprsConnectUC15+0x330>)
 800ce56:	4798      	blx	r3
	 ModemWrite("AT+QISRVC=2\r\n"); // 
	 if (WaitAnsver(MA_OK,10) == false)
	 return false;*/

	//vTaskDelay(200);
	if (pxConfig->devcfg.GSMtime == 1)  //   
 800ce58:	f8d7 3154 	ldr.w	r3, [r7, #340]	; 0x154
 800ce5c:	f8b3 3100 	ldrh.w	r3, [r3, #256]	; 0x100
 800ce60:	b29b      	uxth	r3, r3
 800ce62:	2b01      	cmp	r3, #1
 800ce64:	d104      	bne.n	800ce70 <WaitGprsConnectUC15+0x314>
			{

		GSM_clock();
 800ce66:	4b0a      	ldr	r3, [pc, #40]	; (800ce90 <WaitGprsConnectUC15+0x334>)
 800ce68:	4798      	blx	r3
		FlagGSMtime = 0;
 800ce6a:	4b0a      	ldr	r3, [pc, #40]	; (800ce94 <WaitGprsConnectUC15+0x338>)
 800ce6c:	2200      	movs	r2, #0
 800ce6e:	701a      	strb	r2, [r3, #0]

	}

	return true;
 800ce70:	2301      	movs	r3, #1
}
 800ce72:	4618      	mov	r0, r3
 800ce74:	f507 77ac 	add.w	r7, r7, #344	; 0x158
 800ce78:	46bd      	mov	sp, r7
 800ce7a:	bdb0      	pop	{r4, r5, r7, pc}
 800ce7c:	200092f0 	.word	0x200092f0
 800ce80:	080152dc 	.word	0x080152dc
 800ce84:	0800bfed 	.word	0x0800bfed
 800ce88:	0800c031 	.word	0x0800c031
 800ce8c:	08001529 	.word	0x08001529
 800ce90:	0800c1ed 	.word	0x0800c1ed
 800ce94:	200070fc 	.word	0x200070fc

0800ce98 <WaitGprsConnectM66>:
//======================================================
bool WaitGprsConnectM66() {
 800ce98:	b5b0      	push	{r4, r5, r7, lr}
 800ce9a:	b0d8      	sub	sp, #352	; 0x160
 800ce9c:	af00      	add	r7, sp, #0
	char myIp[17];
	char strsipstart[256];
	char buf[64];
	char header[] = "IPD";
 800ce9e:	f507 73b0 	add.w	r3, r7, #352	; 0x160
 800cea2:	f5a3 73ae 	sub.w	r3, r3, #348	; 0x15c
 800cea6:	4aab      	ldr	r2, [pc, #684]	; (800d154 <WaitGprsConnectM66+0x2bc>)
 800cea8:	601a      	str	r2, [r3, #0]
	int packSize;
	int headerSize;
	FLASHMEM *pxConfig = (FLASHMEM*) DEVICE_FLASHMEM_LOCATION;
 800ceaa:	4bab      	ldr	r3, [pc, #684]	; (800d158 <WaitGprsConnectM66+0x2c0>)
 800ceac:	f8c7 315c 	str.w	r3, [r7, #348]	; 0x15c
	//		BKP_WriteBackupRegister(BKP_DR7, 31);
	//		if (!WaitAte())
	//			continue;
	//		vTaskDelay(100);
	//		BKP_WriteBackupRegister(BKP_DR7, 32);
	vTaskDelay(100);
 800ceb0:	2064      	movs	r0, #100	; 0x64
 800ceb2:	4baa      	ldr	r3, [pc, #680]	; (800d15c <WaitGprsConnectM66+0x2c4>)
 800ceb4:	4798      	blx	r3
	ModemWrite("AT+QIDEACT\r\n");    // 
 800ceb6:	48aa      	ldr	r0, [pc, #680]	; (800d160 <WaitGprsConnectM66+0x2c8>)
 800ceb8:	4baa      	ldr	r3, [pc, #680]	; (800d164 <WaitGprsConnectM66+0x2cc>)
 800ceba:	4798      	blx	r3
	vTaskDelay(4000);
 800cebc:	f44f 607a 	mov.w	r0, #4000	; 0xfa0
 800cec0:	4ba6      	ldr	r3, [pc, #664]	; (800d15c <WaitGprsConnectM66+0x2c4>)
 800cec2:	4798      	blx	r3
	/*if (WaitAnsver(MA_OK,400) == false)
	 return false;
	 vTaskDelay(100);*/
	ModemWrite("AT+QIMODE=0\r\n");  //
 800cec4:	48a8      	ldr	r0, [pc, #672]	; (800d168 <WaitGprsConnectM66+0x2d0>)
 800cec6:	4ba7      	ldr	r3, [pc, #668]	; (800d164 <WaitGprsConnectM66+0x2cc>)
 800cec8:	4798      	blx	r3
	if (WaitAnsver(MA_OK, 50) == false)
 800ceca:	2132      	movs	r1, #50	; 0x32
 800cecc:	2002      	movs	r0, #2
 800cece:	4ba7      	ldr	r3, [pc, #668]	; (800d16c <WaitGprsConnectM66+0x2d4>)
 800ced0:	4798      	blx	r3
 800ced2:	4603      	mov	r3, r0
 800ced4:	f083 0301 	eor.w	r3, r3, #1
 800ced8:	b2db      	uxtb	r3, r3
 800ceda:	2b00      	cmp	r3, #0
 800cedc:	d001      	beq.n	800cee2 <WaitGprsConnectM66+0x4a>
		return false;
 800cede:	2300      	movs	r3, #0
 800cee0:	e1b5      	b.n	800d24e <WaitGprsConnectM66+0x3b6>
	/*strcpy(buf, "AT+CGDCONT=1,\"IP\",\"");
	 strcat(buf, PPP_ADPARAM);
	 strcat(buf, "\"\r");*/
//	vTaskDelay(100);
//	ModemWrite(buf);
	if (WaitAnsver(MA_OK, 50) == false)
 800cee2:	2132      	movs	r1, #50	; 0x32
 800cee4:	2002      	movs	r0, #2
 800cee6:	4ba1      	ldr	r3, [pc, #644]	; (800d16c <WaitGprsConnectM66+0x2d4>)
 800cee8:	4798      	blx	r3
 800ceea:	4603      	mov	r3, r0
 800ceec:	f083 0301 	eor.w	r3, r3, #1
 800cef0:	b2db      	uxtb	r3, r3
 800cef2:	2b00      	cmp	r3, #0
 800cef4:	d001      	beq.n	800cefa <WaitGprsConnectM66+0x62>
		return false;
 800cef6:	2300      	movs	r3, #0
 800cef8:	e1a9      	b.n	800d24e <WaitGprsConnectM66+0x3b6>

//LedAPN = 1;
	if (strlen(pxConfig->devcfg.gprs.login) > 16
 800cefa:	f8d7 315c 	ldr.w	r3, [r7, #348]	; 0x15c
 800cefe:	3380      	adds	r3, #128	; 0x80
 800cf00:	4618      	mov	r0, r3
 800cf02:	4b9b      	ldr	r3, [pc, #620]	; (800d170 <WaitGprsConnectM66+0x2d8>)
 800cf04:	4798      	blx	r3
 800cf06:	4603      	mov	r3, r0
 800cf08:	2b10      	cmp	r3, #16
 800cf0a:	d810      	bhi.n	800cf2e <WaitGprsConnectM66+0x96>
			|| strlen(pxConfig->devcfg.gprs.password) > 16
 800cf0c:	f8d7 315c 	ldr.w	r3, [r7, #348]	; 0x15c
 800cf10:	33c0      	adds	r3, #192	; 0xc0
 800cf12:	4618      	mov	r0, r3
 800cf14:	4b96      	ldr	r3, [pc, #600]	; (800d170 <WaitGprsConnectM66+0x2d8>)
 800cf16:	4798      	blx	r3
 800cf18:	4603      	mov	r3, r0
 800cf1a:	2b10      	cmp	r3, #16
 800cf1c:	d807      	bhi.n	800cf2e <WaitGprsConnectM66+0x96>
			|| strlen(pxConfig->devcfg.gprs.adparam) > 32) {
 800cf1e:	f8d7 315c 	ldr.w	r3, [r7, #348]	; 0x15c
 800cf22:	4618      	mov	r0, r3
 800cf24:	4b92      	ldr	r3, [pc, #584]	; (800d170 <WaitGprsConnectM66+0x2d8>)
 800cf26:	4798      	blx	r3
 800cf28:	4603      	mov	r3, r0
 800cf2a:	2b20      	cmp	r3, #32
 800cf2c:	d963      	bls.n	800cff6 <WaitGprsConnectM66+0x15e>
		strcpy(buf, "AT+QIREGAPP=\"");
 800cf2e:	f107 0308 	add.w	r3, r7, #8
 800cf32:	4a90      	ldr	r2, [pc, #576]	; (800d174 <WaitGprsConnectM66+0x2dc>)
 800cf34:	461c      	mov	r4, r3
 800cf36:	4613      	mov	r3, r2
 800cf38:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 800cf3a:	c407      	stmia	r4!, {r0, r1, r2}
 800cf3c:	8023      	strh	r3, [r4, #0]
		strcat(buf, PPP_ADPARAM);
 800cf3e:	f107 0308 	add.w	r3, r7, #8
 800cf42:	4618      	mov	r0, r3
 800cf44:	4b8a      	ldr	r3, [pc, #552]	; (800d170 <WaitGprsConnectM66+0x2d8>)
 800cf46:	4798      	blx	r3
 800cf48:	4603      	mov	r3, r0
 800cf4a:	461a      	mov	r2, r3
 800cf4c:	f107 0308 	add.w	r3, r7, #8
 800cf50:	4413      	add	r3, r2
 800cf52:	4a89      	ldr	r2, [pc, #548]	; (800d178 <WaitGprsConnectM66+0x2e0>)
 800cf54:	461d      	mov	r5, r3
 800cf56:	4614      	mov	r4, r2
 800cf58:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800cf5a:	6028      	str	r0, [r5, #0]
 800cf5c:	6069      	str	r1, [r5, #4]
 800cf5e:	60aa      	str	r2, [r5, #8]
 800cf60:	60eb      	str	r3, [r5, #12]
 800cf62:	6820      	ldr	r0, [r4, #0]
 800cf64:	6128      	str	r0, [r5, #16]
 800cf66:	7923      	ldrb	r3, [r4, #4]
 800cf68:	752b      	strb	r3, [r5, #20]
		strcat(buf, "\",\"");
 800cf6a:	f107 0308 	add.w	r3, r7, #8
 800cf6e:	4618      	mov	r0, r3
 800cf70:	4b7f      	ldr	r3, [pc, #508]	; (800d170 <WaitGprsConnectM66+0x2d8>)
 800cf72:	4798      	blx	r3
 800cf74:	4603      	mov	r3, r0
 800cf76:	461a      	mov	r2, r3
 800cf78:	f107 0308 	add.w	r3, r7, #8
 800cf7c:	4413      	add	r3, r2
 800cf7e:	4a7f      	ldr	r2, [pc, #508]	; (800d17c <WaitGprsConnectM66+0x2e4>)
 800cf80:	6810      	ldr	r0, [r2, #0]
 800cf82:	6018      	str	r0, [r3, #0]
		strcat(buf, PPP_USER);
 800cf84:	f107 0308 	add.w	r3, r7, #8
 800cf88:	4618      	mov	r0, r3
 800cf8a:	4b79      	ldr	r3, [pc, #484]	; (800d170 <WaitGprsConnectM66+0x2d8>)
 800cf8c:	4798      	blx	r3
 800cf8e:	4603      	mov	r3, r0
 800cf90:	461a      	mov	r2, r3
 800cf92:	f107 0308 	add.w	r3, r7, #8
 800cf96:	4413      	add	r3, r2
 800cf98:	4979      	ldr	r1, [pc, #484]	; (800d180 <WaitGprsConnectM66+0x2e8>)
 800cf9a:	461a      	mov	r2, r3
 800cf9c:	460b      	mov	r3, r1
 800cf9e:	881b      	ldrh	r3, [r3, #0]
 800cfa0:	8013      	strh	r3, [r2, #0]
		strcat(buf, "\",\"");
 800cfa2:	f107 0308 	add.w	r3, r7, #8
 800cfa6:	4618      	mov	r0, r3
 800cfa8:	4b71      	ldr	r3, [pc, #452]	; (800d170 <WaitGprsConnectM66+0x2d8>)
 800cfaa:	4798      	blx	r3
 800cfac:	4603      	mov	r3, r0
 800cfae:	461a      	mov	r2, r3
 800cfb0:	f107 0308 	add.w	r3, r7, #8
 800cfb4:	4413      	add	r3, r2
 800cfb6:	4a71      	ldr	r2, [pc, #452]	; (800d17c <WaitGprsConnectM66+0x2e4>)
 800cfb8:	6810      	ldr	r0, [r2, #0]
 800cfba:	6018      	str	r0, [r3, #0]
		strcat(buf, PPP_PASS);
 800cfbc:	f107 0308 	add.w	r3, r7, #8
 800cfc0:	4618      	mov	r0, r3
 800cfc2:	4b6b      	ldr	r3, [pc, #428]	; (800d170 <WaitGprsConnectM66+0x2d8>)
 800cfc4:	4798      	blx	r3
 800cfc6:	4603      	mov	r3, r0
 800cfc8:	461a      	mov	r2, r3
 800cfca:	f107 0308 	add.w	r3, r7, #8
 800cfce:	4413      	add	r3, r2
 800cfd0:	496b      	ldr	r1, [pc, #428]	; (800d180 <WaitGprsConnectM66+0x2e8>)
 800cfd2:	461a      	mov	r2, r3
 800cfd4:	460b      	mov	r3, r1
 800cfd6:	881b      	ldrh	r3, [r3, #0]
 800cfd8:	8013      	strh	r3, [r2, #0]
		strcat(buf, "\"\r\n");
 800cfda:	f107 0308 	add.w	r3, r7, #8
 800cfde:	4618      	mov	r0, r3
 800cfe0:	4b63      	ldr	r3, [pc, #396]	; (800d170 <WaitGprsConnectM66+0x2d8>)
 800cfe2:	4798      	blx	r3
 800cfe4:	4603      	mov	r3, r0
 800cfe6:	461a      	mov	r2, r3
 800cfe8:	f107 0308 	add.w	r3, r7, #8
 800cfec:	4413      	add	r3, r2
 800cfee:	4a65      	ldr	r2, [pc, #404]	; (800d184 <WaitGprsConnectM66+0x2ec>)
 800cff0:	6810      	ldr	r0, [r2, #0]
 800cff2:	6018      	str	r0, [r3, #0]
 800cff4:	e04a      	b.n	800d08c <WaitGprsConnectM66+0x1f4>
	} else {
		strcpy(buf, "AT+QIREGAPP=\"");
 800cff6:	f107 0308 	add.w	r3, r7, #8
 800cffa:	4a5e      	ldr	r2, [pc, #376]	; (800d174 <WaitGprsConnectM66+0x2dc>)
 800cffc:	461c      	mov	r4, r3
 800cffe:	4613      	mov	r3, r2
 800d000:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 800d002:	c407      	stmia	r4!, {r0, r1, r2}
 800d004:	8023      	strh	r3, [r4, #0]
		strcat(buf, pxConfig->devcfg.gprs.adparam);
 800d006:	f8d7 215c 	ldr.w	r2, [r7, #348]	; 0x15c
 800d00a:	f107 0308 	add.w	r3, r7, #8
 800d00e:	4611      	mov	r1, r2
 800d010:	4618      	mov	r0, r3
 800d012:	4b5d      	ldr	r3, [pc, #372]	; (800d188 <WaitGprsConnectM66+0x2f0>)
 800d014:	4798      	blx	r3
		strcat(buf, "\",\"");
 800d016:	f107 0308 	add.w	r3, r7, #8
 800d01a:	4618      	mov	r0, r3
 800d01c:	4b54      	ldr	r3, [pc, #336]	; (800d170 <WaitGprsConnectM66+0x2d8>)
 800d01e:	4798      	blx	r3
 800d020:	4603      	mov	r3, r0
 800d022:	461a      	mov	r2, r3
 800d024:	f107 0308 	add.w	r3, r7, #8
 800d028:	4413      	add	r3, r2
 800d02a:	4a54      	ldr	r2, [pc, #336]	; (800d17c <WaitGprsConnectM66+0x2e4>)
 800d02c:	6810      	ldr	r0, [r2, #0]
 800d02e:	6018      	str	r0, [r3, #0]
		strcat(buf, pxConfig->devcfg.gprs.login);
 800d030:	f8d7 315c 	ldr.w	r3, [r7, #348]	; 0x15c
 800d034:	f103 0280 	add.w	r2, r3, #128	; 0x80
 800d038:	f107 0308 	add.w	r3, r7, #8
 800d03c:	4611      	mov	r1, r2
 800d03e:	4618      	mov	r0, r3
 800d040:	4b51      	ldr	r3, [pc, #324]	; (800d188 <WaitGprsConnectM66+0x2f0>)
 800d042:	4798      	blx	r3
		strcat(buf, "\",\"");
 800d044:	f107 0308 	add.w	r3, r7, #8
 800d048:	4618      	mov	r0, r3
 800d04a:	4b49      	ldr	r3, [pc, #292]	; (800d170 <WaitGprsConnectM66+0x2d8>)
 800d04c:	4798      	blx	r3
 800d04e:	4603      	mov	r3, r0
 800d050:	461a      	mov	r2, r3
 800d052:	f107 0308 	add.w	r3, r7, #8
 800d056:	4413      	add	r3, r2
 800d058:	4a48      	ldr	r2, [pc, #288]	; (800d17c <WaitGprsConnectM66+0x2e4>)
 800d05a:	6810      	ldr	r0, [r2, #0]
 800d05c:	6018      	str	r0, [r3, #0]
		strcat(buf, pxConfig->devcfg.gprs.password);
 800d05e:	f8d7 315c 	ldr.w	r3, [r7, #348]	; 0x15c
 800d062:	f103 02c0 	add.w	r2, r3, #192	; 0xc0
 800d066:	f107 0308 	add.w	r3, r7, #8
 800d06a:	4611      	mov	r1, r2
 800d06c:	4618      	mov	r0, r3
 800d06e:	4b46      	ldr	r3, [pc, #280]	; (800d188 <WaitGprsConnectM66+0x2f0>)
 800d070:	4798      	blx	r3
		strcat(buf, "\"\r\n");
 800d072:	f107 0308 	add.w	r3, r7, #8
 800d076:	4618      	mov	r0, r3
 800d078:	4b3d      	ldr	r3, [pc, #244]	; (800d170 <WaitGprsConnectM66+0x2d8>)
 800d07a:	4798      	blx	r3
 800d07c:	4603      	mov	r3, r0
 800d07e:	461a      	mov	r2, r3
 800d080:	f107 0308 	add.w	r3, r7, #8
 800d084:	4413      	add	r3, r2
 800d086:	4a3f      	ldr	r2, [pc, #252]	; (800d184 <WaitGprsConnectM66+0x2ec>)
 800d088:	6810      	ldr	r0, [r2, #0]
 800d08a:	6018      	str	r0, [r3, #0]
	}
	vTaskDelay(100);
 800d08c:	2064      	movs	r0, #100	; 0x64
 800d08e:	4b33      	ldr	r3, [pc, #204]	; (800d15c <WaitGprsConnectM66+0x2c4>)
 800d090:	4798      	blx	r3
	ModemWrite(buf);
 800d092:	f107 0308 	add.w	r3, r7, #8
 800d096:	4618      	mov	r0, r3
 800d098:	4b32      	ldr	r3, [pc, #200]	; (800d164 <WaitGprsConnectM66+0x2cc>)
 800d09a:	4798      	blx	r3
	if (WaitAnsver(MA_OK, 50) == false) {
 800d09c:	2132      	movs	r1, #50	; 0x32
 800d09e:	2002      	movs	r0, #2
 800d0a0:	4b32      	ldr	r3, [pc, #200]	; (800d16c <WaitGprsConnectM66+0x2d4>)
 800d0a2:	4798      	blx	r3
 800d0a4:	4603      	mov	r3, r0
 800d0a6:	f083 0301 	eor.w	r3, r3, #1
 800d0aa:	b2db      	uxtb	r3, r3
 800d0ac:	2b00      	cmp	r3, #0
 800d0ae:	d001      	beq.n	800d0b4 <WaitGprsConnectM66+0x21c>
		/*	if (!LedAPN_Journal)
		 {
		 JrnlWrite("GSM: .");
		 LedAPN_Journal=1;
		 }*/
		return false;
 800d0b0:	2300      	movs	r3, #0
 800d0b2:	e0cc      	b.n	800d24e <WaitGprsConnectM66+0x3b6>
	}
	vTaskDelay(200);
 800d0b4:	20c8      	movs	r0, #200	; 0xc8
 800d0b6:	4b29      	ldr	r3, [pc, #164]	; (800d15c <WaitGprsConnectM66+0x2c4>)
 800d0b8:	4798      	blx	r3
	LedAPN = 0;
 800d0ba:	4b34      	ldr	r3, [pc, #208]	; (800d18c <WaitGprsConnectM66+0x2f4>)
 800d0bc:	2200      	movs	r2, #0
 800d0be:	701a      	strb	r2, [r3, #0]
	ModemWrite("AT+CMGF=1\r\n");
 800d0c0:	4833      	ldr	r0, [pc, #204]	; (800d190 <WaitGprsConnectM66+0x2f8>)
 800d0c2:	4b28      	ldr	r3, [pc, #160]	; (800d164 <WaitGprsConnectM66+0x2cc>)
 800d0c4:	4798      	blx	r3
	if (WaitAnsver(MA_OK, 50) == false)
 800d0c6:	2132      	movs	r1, #50	; 0x32
 800d0c8:	2002      	movs	r0, #2
 800d0ca:	4b28      	ldr	r3, [pc, #160]	; (800d16c <WaitGprsConnectM66+0x2d4>)
 800d0cc:	4798      	blx	r3
 800d0ce:	4603      	mov	r3, r0
 800d0d0:	f083 0301 	eor.w	r3, r3, #1
 800d0d4:	b2db      	uxtb	r3, r3
 800d0d6:	2b00      	cmp	r3, #0
 800d0d8:	d001      	beq.n	800d0de <WaitGprsConnectM66+0x246>
		return false;
 800d0da:	2300      	movs	r3, #0
 800d0dc:	e0b7      	b.n	800d24e <WaitGprsConnectM66+0x3b6>
	vTaskDelay(200);
 800d0de:	20c8      	movs	r0, #200	; 0xc8
 800d0e0:	4b1e      	ldr	r3, [pc, #120]	; (800d15c <WaitGprsConnectM66+0x2c4>)
 800d0e2:	4798      	blx	r3
	ModemWrite("AT+QIPROMPT=2\r\n");
 800d0e4:	482b      	ldr	r0, [pc, #172]	; (800d194 <WaitGprsConnectM66+0x2fc>)
 800d0e6:	4b1f      	ldr	r3, [pc, #124]	; (800d164 <WaitGprsConnectM66+0x2cc>)
 800d0e8:	4798      	blx	r3
	if (WaitAnsver(MA_OK, 50) == false)
 800d0ea:	2132      	movs	r1, #50	; 0x32
 800d0ec:	2002      	movs	r0, #2
 800d0ee:	4b1f      	ldr	r3, [pc, #124]	; (800d16c <WaitGprsConnectM66+0x2d4>)
 800d0f0:	4798      	blx	r3
 800d0f2:	4603      	mov	r3, r0
 800d0f4:	f083 0301 	eor.w	r3, r3, #1
 800d0f8:	b2db      	uxtb	r3, r3
 800d0fa:	2b00      	cmp	r3, #0
 800d0fc:	d001      	beq.n	800d102 <WaitGprsConnectM66+0x26a>
		return false;
 800d0fe:	2300      	movs	r3, #0
 800d100:	e0a5      	b.n	800d24e <WaitGprsConnectM66+0x3b6>
	vTaskDelay(200);
 800d102:	20c8      	movs	r0, #200	; 0xc8
 800d104:	4b15      	ldr	r3, [pc, #84]	; (800d15c <WaitGprsConnectM66+0x2c4>)
 800d106:	4798      	blx	r3
	ModemWrite("AT+QIHEAD=1\r\n");
 800d108:	4823      	ldr	r0, [pc, #140]	; (800d198 <WaitGprsConnectM66+0x300>)
 800d10a:	4b16      	ldr	r3, [pc, #88]	; (800d164 <WaitGprsConnectM66+0x2cc>)
 800d10c:	4798      	blx	r3
	if (WaitAnsver(MA_OK, 50) == false)
 800d10e:	2132      	movs	r1, #50	; 0x32
 800d110:	2002      	movs	r0, #2
 800d112:	4b16      	ldr	r3, [pc, #88]	; (800d16c <WaitGprsConnectM66+0x2d4>)
 800d114:	4798      	blx	r3
 800d116:	4603      	mov	r3, r0
 800d118:	f083 0301 	eor.w	r3, r3, #1
 800d11c:	b2db      	uxtb	r3, r3
 800d11e:	2b00      	cmp	r3, #0
 800d120:	d001      	beq.n	800d126 <WaitGprsConnectM66+0x28e>
		return false;
 800d122:	2300      	movs	r3, #0
 800d124:	e093      	b.n	800d24e <WaitGprsConnectM66+0x3b6>

	vTaskDelay(200);
 800d126:	20c8      	movs	r0, #200	; 0xc8
 800d128:	4b0c      	ldr	r3, [pc, #48]	; (800d15c <WaitGprsConnectM66+0x2c4>)
 800d12a:	4798      	blx	r3
	ModemWrite("AT+QIACT\r\n"); // 
 800d12c:	481b      	ldr	r0, [pc, #108]	; (800d19c <WaitGprsConnectM66+0x304>)
 800d12e:	4b0d      	ldr	r3, [pc, #52]	; (800d164 <WaitGprsConnectM66+0x2cc>)
 800d130:	4798      	blx	r3
	vTaskDelay(100);
 800d132:	2064      	movs	r0, #100	; 0x64
 800d134:	4b09      	ldr	r3, [pc, #36]	; (800d15c <WaitGprsConnectM66+0x2c4>)
 800d136:	4798      	blx	r3
	if (WaitAnsver(MA_OK, 1500) == false)
 800d138:	f240 51dc 	movw	r1, #1500	; 0x5dc
 800d13c:	2002      	movs	r0, #2
 800d13e:	4b0b      	ldr	r3, [pc, #44]	; (800d16c <WaitGprsConnectM66+0x2d4>)
 800d140:	4798      	blx	r3
 800d142:	4603      	mov	r3, r0
 800d144:	f083 0301 	eor.w	r3, r3, #1
 800d148:	b2db      	uxtb	r3, r3
 800d14a:	2b00      	cmp	r3, #0
 800d14c:	d028      	beq.n	800d1a0 <WaitGprsConnectM66+0x308>
		return false;
 800d14e:	2300      	movs	r3, #0
 800d150:	e07d      	b.n	800d24e <WaitGprsConnectM66+0x3b6>
 800d152:	bf00      	nop
 800d154:	00445049 	.word	0x00445049
 800d158:	0802b000 	.word	0x0802b000
 800d15c:	08001529 	.word	0x08001529
 800d160:	08015308 	.word	0x08015308
 800d164:	0800bfed 	.word	0x0800bfed
 800d168:	08015318 	.word	0x08015318
 800d16c:	0800c031 	.word	0x0800c031
 800d170:	08014731 	.word	0x08014731
 800d174:	08015328 	.word	0x08015328
 800d178:	080152ec 	.word	0x080152ec
 800d17c:	0801528c 	.word	0x0801528c
 800d180:	08015304 	.word	0x08015304
 800d184:	08015338 	.word	0x08015338
 800d188:	08014635 	.word	0x08014635
 800d18c:	200072ba 	.word	0x200072ba
 800d190:	080152ac 	.word	0x080152ac
 800d194:	0801533c 	.word	0x0801533c
 800d198:	0801534c 	.word	0x0801534c
 800d19c:	0801535c 	.word	0x0801535c
	vTaskDelay(500);
 800d1a0:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 800d1a4:	4b2c      	ldr	r3, [pc, #176]	; (800d258 <WaitGprsConnectM66+0x3c0>)
 800d1a6:	4798      	blx	r3

	ModemWrite("AT+QICSGP=1,\"CMNET\"\r\n");
 800d1a8:	482c      	ldr	r0, [pc, #176]	; (800d25c <WaitGprsConnectM66+0x3c4>)
 800d1aa:	4b2d      	ldr	r3, [pc, #180]	; (800d260 <WaitGprsConnectM66+0x3c8>)
 800d1ac:	4798      	blx	r3
	if (WaitAnsver(MA_OK, 50) == false)
 800d1ae:	2132      	movs	r1, #50	; 0x32
 800d1b0:	2002      	movs	r0, #2
 800d1b2:	4b2c      	ldr	r3, [pc, #176]	; (800d264 <WaitGprsConnectM66+0x3cc>)
 800d1b4:	4798      	blx	r3
 800d1b6:	4603      	mov	r3, r0
 800d1b8:	f083 0301 	eor.w	r3, r3, #1
 800d1bc:	b2db      	uxtb	r3, r3
 800d1be:	2b00      	cmp	r3, #0
 800d1c0:	d001      	beq.n	800d1c6 <WaitGprsConnectM66+0x32e>
		return false;
 800d1c2:	2300      	movs	r3, #0
 800d1c4:	e043      	b.n	800d24e <WaitGprsConnectM66+0x3b6>
	vTaskDelay(200);
 800d1c6:	20c8      	movs	r0, #200	; 0xc8
 800d1c8:	4b23      	ldr	r3, [pc, #140]	; (800d258 <WaitGprsConnectM66+0x3c0>)
 800d1ca:	4798      	blx	r3
	ModemWrite("AT+QILPORT=\"TCP\",\"4444\"\r\n");
 800d1cc:	4826      	ldr	r0, [pc, #152]	; (800d268 <WaitGprsConnectM66+0x3d0>)
 800d1ce:	4b24      	ldr	r3, [pc, #144]	; (800d260 <WaitGprsConnectM66+0x3c8>)
 800d1d0:	4798      	blx	r3
	if (WaitAnsver(MA_OK, 50) == false)
 800d1d2:	2132      	movs	r1, #50	; 0x32
 800d1d4:	2002      	movs	r0, #2
 800d1d6:	4b23      	ldr	r3, [pc, #140]	; (800d264 <WaitGprsConnectM66+0x3cc>)
 800d1d8:	4798      	blx	r3
 800d1da:	4603      	mov	r3, r0
 800d1dc:	f083 0301 	eor.w	r3, r3, #1
 800d1e0:	b2db      	uxtb	r3, r3
 800d1e2:	2b00      	cmp	r3, #0
 800d1e4:	d001      	beq.n	800d1ea <WaitGprsConnectM66+0x352>
		return false;
 800d1e6:	2300      	movs	r3, #0
 800d1e8:	e031      	b.n	800d24e <WaitGprsConnectM66+0x3b6>
	vTaskDelay(200);
 800d1ea:	20c8      	movs	r0, #200	; 0xc8
 800d1ec:	4b1a      	ldr	r3, [pc, #104]	; (800d258 <WaitGprsConnectM66+0x3c0>)
 800d1ee:	4798      	blx	r3
	ModemWrite("AT+QILOCIP\r\n");
 800d1f0:	481e      	ldr	r0, [pc, #120]	; (800d26c <WaitGprsConnectM66+0x3d4>)
 800d1f2:	4b1b      	ldr	r3, [pc, #108]	; (800d260 <WaitGprsConnectM66+0x3c8>)
 800d1f4:	4798      	blx	r3
	WaitAnsver(MA_UNKNOWN, 50);
 800d1f6:	2132      	movs	r1, #50	; 0x32
 800d1f8:	2000      	movs	r0, #0
 800d1fa:	4b1a      	ldr	r3, [pc, #104]	; (800d264 <WaitGprsConnectM66+0x3cc>)
 800d1fc:	4798      	blx	r3
	vTaskDelay(200);
 800d1fe:	20c8      	movs	r0, #200	; 0xc8
 800d200:	4b15      	ldr	r3, [pc, #84]	; (800d258 <WaitGprsConnectM66+0x3c0>)
 800d202:	4798      	blx	r3
	ModemWrite("AT+QISERVER\r\n"); //   (=0 -  TCP )
 800d204:	481a      	ldr	r0, [pc, #104]	; (800d270 <WaitGprsConnectM66+0x3d8>)
 800d206:	4b16      	ldr	r3, [pc, #88]	; (800d260 <WaitGprsConnectM66+0x3c8>)
 800d208:	4798      	blx	r3
	vTaskDelay(200);
 800d20a:	20c8      	movs	r0, #200	; 0xc8
 800d20c:	4b12      	ldr	r3, [pc, #72]	; (800d258 <WaitGprsConnectM66+0x3c0>)
 800d20e:	4798      	blx	r3
	if (WaitAnsver(MA_OK, 50) == false)
 800d210:	2132      	movs	r1, #50	; 0x32
 800d212:	2002      	movs	r0, #2
 800d214:	4b13      	ldr	r3, [pc, #76]	; (800d264 <WaitGprsConnectM66+0x3cc>)
 800d216:	4798      	blx	r3
 800d218:	4603      	mov	r3, r0
 800d21a:	f083 0301 	eor.w	r3, r3, #1
 800d21e:	b2db      	uxtb	r3, r3
 800d220:	2b00      	cmp	r3, #0
 800d222:	d001      	beq.n	800d228 <WaitGprsConnectM66+0x390>
		return false;
 800d224:	2300      	movs	r3, #0
 800d226:	e012      	b.n	800d24e <WaitGprsConnectM66+0x3b6>
	vTaskDelay(200);
 800d228:	20c8      	movs	r0, #200	; 0xc8
 800d22a:	4b0b      	ldr	r3, [pc, #44]	; (800d258 <WaitGprsConnectM66+0x3c0>)
 800d22c:	4798      	blx	r3

	ModemWrite("AT+QISRVC=2\r\n"); // 
 800d22e:	4811      	ldr	r0, [pc, #68]	; (800d274 <WaitGprsConnectM66+0x3dc>)
 800d230:	4b0b      	ldr	r3, [pc, #44]	; (800d260 <WaitGprsConnectM66+0x3c8>)
 800d232:	4798      	blx	r3
	if (WaitAnsver(MA_OK, 50) == false)
 800d234:	2132      	movs	r1, #50	; 0x32
 800d236:	2002      	movs	r0, #2
 800d238:	4b0a      	ldr	r3, [pc, #40]	; (800d264 <WaitGprsConnectM66+0x3cc>)
 800d23a:	4798      	blx	r3
 800d23c:	4603      	mov	r3, r0
 800d23e:	f083 0301 	eor.w	r3, r3, #1
 800d242:	b2db      	uxtb	r3, r3
 800d244:	2b00      	cmp	r3, #0
 800d246:	d001      	beq.n	800d24c <WaitGprsConnectM66+0x3b4>
		return false;
 800d248:	2300      	movs	r3, #0
 800d24a:	e000      	b.n	800d24e <WaitGprsConnectM66+0x3b6>
	 GSM_clock();
	 FlagGSMtime = 0;

	 }*/

	return true;
 800d24c:	2301      	movs	r3, #1
}
 800d24e:	4618      	mov	r0, r3
 800d250:	f507 77b0 	add.w	r7, r7, #352	; 0x160
 800d254:	46bd      	mov	sp, r7
 800d256:	bdb0      	pop	{r4, r5, r7, pc}
 800d258:	08001529 	.word	0x08001529
 800d25c:	08015368 	.word	0x08015368
 800d260:	0800bfed 	.word	0x0800bfed
 800d264:	0800c031 	.word	0x0800c031
 800d268:	08015380 	.word	0x08015380
 800d26c:	080152dc 	.word	0x080152dc
 800d270:	0801539c 	.word	0x0801539c
 800d274:	080153ac 	.word	0x080153ac

0800d278 <WaitGprsConnectN715>:
bool WaitGprsConnectN715() {
 800d278:	b5b0      	push	{r4, r5, r7, lr}
 800d27a:	b0de      	sub	sp, #376	; 0x178
 800d27c:	af00      	add	r7, sp, #0
	char myIp[17];
	char strsipstart[256];
	char buf[64];
	char header[] = "IPD";
 800d27e:	f507 73bc 	add.w	r3, r7, #376	; 0x178
 800d282:	f5a3 73bc 	sub.w	r3, r3, #376	; 0x178
 800d286:	4aab      	ldr	r2, [pc, #684]	; (800d534 <WaitGprsConnectN715+0x2bc>)
 800d288:	601a      	str	r2, [r3, #0]
	int packSize;
	int headerSize;
	int fl = 0, con = 10;
 800d28a:	2300      	movs	r3, #0
 800d28c:	f8c7 3174 	str.w	r3, [r7, #372]	; 0x174
 800d290:	230a      	movs	r3, #10
 800d292:	f8c7 3170 	str.w	r3, [r7, #368]	; 0x170
	FLASHMEM *pxConfig = (FLASHMEM*) DEVICE_FLASHMEM_LOCATION;
 800d296:	4ba8      	ldr	r3, [pc, #672]	; (800d538 <WaitGprsConnectN715+0x2c0>)
 800d298:	f8c7 3158 	str.w	r3, [r7, #344]	; 0x158
	int i;

	vTaskDelay(100);
 800d29c:	2064      	movs	r0, #100	; 0x64
 800d29e:	4ba7      	ldr	r3, [pc, #668]	; (800d53c <WaitGprsConnectN715+0x2c4>)
 800d2a0:	4798      	blx	r3
	ModemWrite("AT+XISP=0\r\n");   //  TCP
 800d2a2:	48a7      	ldr	r0, [pc, #668]	; (800d540 <WaitGprsConnectN715+0x2c8>)
 800d2a4:	4ba7      	ldr	r3, [pc, #668]	; (800d544 <WaitGprsConnectN715+0x2cc>)
 800d2a6:	4798      	blx	r3
	vTaskDelay(100);
 800d2a8:	2064      	movs	r0, #100	; 0x64
 800d2aa:	4ba4      	ldr	r3, [pc, #656]	; (800d53c <WaitGprsConnectN715+0x2c4>)
 800d2ac:	4798      	blx	r3
	if (WaitAnsver(MA_OK, 400) == false)
 800d2ae:	f44f 71c8 	mov.w	r1, #400	; 0x190
 800d2b2:	2002      	movs	r0, #2
 800d2b4:	4ba4      	ldr	r3, [pc, #656]	; (800d548 <WaitGprsConnectN715+0x2d0>)
 800d2b6:	4798      	blx	r3
 800d2b8:	4603      	mov	r3, r0
 800d2ba:	f083 0301 	eor.w	r3, r3, #1
 800d2be:	b2db      	uxtb	r3, r3
 800d2c0:	2b00      	cmp	r3, #0
 800d2c2:	d001      	beq.n	800d2c8 <WaitGprsConnectN715+0x50>
		return false;
 800d2c4:	2300      	movs	r3, #0
 800d2c6:	e223      	b.n	800d710 <WaitGprsConnectN715+0x498>
	vTaskDelay(100);
 800d2c8:	2064      	movs	r0, #100	; 0x64
 800d2ca:	4b9c      	ldr	r3, [pc, #624]	; (800d53c <WaitGprsConnectN715+0x2c4>)
 800d2cc:	4798      	blx	r3

	if (strlen(pxConfig->devcfg.gprs.login) > 16
 800d2ce:	f8d7 3158 	ldr.w	r3, [r7, #344]	; 0x158
 800d2d2:	3380      	adds	r3, #128	; 0x80
 800d2d4:	4618      	mov	r0, r3
 800d2d6:	4b9d      	ldr	r3, [pc, #628]	; (800d54c <WaitGprsConnectN715+0x2d4>)
 800d2d8:	4798      	blx	r3
 800d2da:	4603      	mov	r3, r0
 800d2dc:	2b10      	cmp	r3, #16
 800d2de:	d810      	bhi.n	800d302 <WaitGprsConnectN715+0x8a>
			|| strlen(pxConfig->devcfg.gprs.password) > 16
 800d2e0:	f8d7 3158 	ldr.w	r3, [r7, #344]	; 0x158
 800d2e4:	33c0      	adds	r3, #192	; 0xc0
 800d2e6:	4618      	mov	r0, r3
 800d2e8:	4b98      	ldr	r3, [pc, #608]	; (800d54c <WaitGprsConnectN715+0x2d4>)
 800d2ea:	4798      	blx	r3
 800d2ec:	4603      	mov	r3, r0
 800d2ee:	2b10      	cmp	r3, #16
 800d2f0:	d807      	bhi.n	800d302 <WaitGprsConnectN715+0x8a>
			|| strlen(pxConfig->devcfg.gprs.adparam) > 32) {
 800d2f2:	f8d7 3158 	ldr.w	r3, [r7, #344]	; 0x158
 800d2f6:	4618      	mov	r0, r3
 800d2f8:	4b94      	ldr	r3, [pc, #592]	; (800d54c <WaitGprsConnectN715+0x2d4>)
 800d2fa:	4798      	blx	r3
 800d2fc:	4603      	mov	r3, r0
 800d2fe:	2b20      	cmp	r3, #32
 800d300:	d927      	bls.n	800d352 <WaitGprsConnectN715+0xda>
		strcpy(buf, "AT+CGDCONT=1,\"IP\",\""); //AT+CGDCONT=1,IP,"vmi.velcom.by"," "," ",1
 800d302:	1d3b      	adds	r3, r7, #4
 800d304:	4a92      	ldr	r2, [pc, #584]	; (800d550 <WaitGprsConnectN715+0x2d8>)
 800d306:	461c      	mov	r4, r3
 800d308:	4615      	mov	r5, r2
 800d30a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800d30c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 800d30e:	682b      	ldr	r3, [r5, #0]
 800d310:	6023      	str	r3, [r4, #0]
		strcat(buf, PPP_ADPARAM);
 800d312:	1d3b      	adds	r3, r7, #4
 800d314:	4618      	mov	r0, r3
 800d316:	4b8d      	ldr	r3, [pc, #564]	; (800d54c <WaitGprsConnectN715+0x2d4>)
 800d318:	4798      	blx	r3
 800d31a:	4603      	mov	r3, r0
 800d31c:	461a      	mov	r2, r3
 800d31e:	1d3b      	adds	r3, r7, #4
 800d320:	4413      	add	r3, r2
 800d322:	4a8c      	ldr	r2, [pc, #560]	; (800d554 <WaitGprsConnectN715+0x2dc>)
 800d324:	461d      	mov	r5, r3
 800d326:	4614      	mov	r4, r2
 800d328:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 800d32a:	6028      	str	r0, [r5, #0]
 800d32c:	6069      	str	r1, [r5, #4]
 800d32e:	60aa      	str	r2, [r5, #8]
 800d330:	60eb      	str	r3, [r5, #12]
 800d332:	6820      	ldr	r0, [r4, #0]
 800d334:	6128      	str	r0, [r5, #16]
 800d336:	7923      	ldrb	r3, [r4, #4]
 800d338:	752b      	strb	r3, [r5, #20]
		strcat(buf, "\"\r\n");
 800d33a:	1d3b      	adds	r3, r7, #4
 800d33c:	4618      	mov	r0, r3
 800d33e:	4b83      	ldr	r3, [pc, #524]	; (800d54c <WaitGprsConnectN715+0x2d4>)
 800d340:	4798      	blx	r3
 800d342:	4603      	mov	r3, r0
 800d344:	461a      	mov	r2, r3
 800d346:	1d3b      	adds	r3, r7, #4
 800d348:	4413      	add	r3, r2
 800d34a:	4a83      	ldr	r2, [pc, #524]	; (800d558 <WaitGprsConnectN715+0x2e0>)
 800d34c:	6810      	ldr	r0, [r2, #0]
 800d34e:	6018      	str	r0, [r3, #0]
 800d350:	e01c      	b.n	800d38c <WaitGprsConnectN715+0x114>
	} else {
		strcpy(buf, "AT+CGDCONT=1,\"PPP\",\"");
 800d352:	1d3b      	adds	r3, r7, #4
 800d354:	4a81      	ldr	r2, [pc, #516]	; (800d55c <WaitGprsConnectN715+0x2e4>)
 800d356:	461c      	mov	r4, r3
 800d358:	4615      	mov	r5, r2
 800d35a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800d35c:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 800d35e:	e895 0003 	ldmia.w	r5, {r0, r1}
 800d362:	6020      	str	r0, [r4, #0]
 800d364:	3404      	adds	r4, #4
 800d366:	7021      	strb	r1, [r4, #0]
		strcat(buf, pxConfig->devcfg.gprs.adparam);
 800d368:	f8d7 2158 	ldr.w	r2, [r7, #344]	; 0x158
 800d36c:	1d3b      	adds	r3, r7, #4
 800d36e:	4611      	mov	r1, r2
 800d370:	4618      	mov	r0, r3
 800d372:	4b7b      	ldr	r3, [pc, #492]	; (800d560 <WaitGprsConnectN715+0x2e8>)
 800d374:	4798      	blx	r3
		strcat(buf, "\"\r\n");
 800d376:	1d3b      	adds	r3, r7, #4
 800d378:	4618      	mov	r0, r3
 800d37a:	4b74      	ldr	r3, [pc, #464]	; (800d54c <WaitGprsConnectN715+0x2d4>)
 800d37c:	4798      	blx	r3
 800d37e:	4603      	mov	r3, r0
 800d380:	461a      	mov	r2, r3
 800d382:	1d3b      	adds	r3, r7, #4
 800d384:	4413      	add	r3, r2
 800d386:	4a74      	ldr	r2, [pc, #464]	; (800d558 <WaitGprsConnectN715+0x2e0>)
 800d388:	6810      	ldr	r0, [r2, #0]
 800d38a:	6018      	str	r0, [r3, #0]
	}

	vTaskDelay(100);
 800d38c:	2064      	movs	r0, #100	; 0x64
 800d38e:	4b6b      	ldr	r3, [pc, #428]	; (800d53c <WaitGprsConnectN715+0x2c4>)
 800d390:	4798      	blx	r3

	while (1) {
		ModemWrite(buf);
 800d392:	1d3b      	adds	r3, r7, #4
 800d394:	4618      	mov	r0, r3
 800d396:	4b6b      	ldr	r3, [pc, #428]	; (800d544 <WaitGprsConnectN715+0x2cc>)
 800d398:	4798      	blx	r3
		vTaskDelay(100);
 800d39a:	2064      	movs	r0, #100	; 0x64
 800d39c:	4b67      	ldr	r3, [pc, #412]	; (800d53c <WaitGprsConnectN715+0x2c4>)
 800d39e:	4798      	blx	r3
		bufsize2 = uart2Read(sio_buf2, 256);
 800d3a0:	f44f 7180 	mov.w	r1, #256	; 0x100
 800d3a4:	486f      	ldr	r0, [pc, #444]	; (800d564 <WaitGprsConnectN715+0x2ec>)
 800d3a6:	4b70      	ldr	r3, [pc, #448]	; (800d568 <WaitGprsConnectN715+0x2f0>)
 800d3a8:	4798      	blx	r3
 800d3aa:	4603      	mov	r3, r0
 800d3ac:	b29a      	uxth	r2, r3
 800d3ae:	4b6f      	ldr	r3, [pc, #444]	; (800d56c <WaitGprsConnectN715+0x2f4>)
 800d3b0:	801a      	strh	r2, [r3, #0]
		for (int i = 0; i < bufsize2; i++) {
 800d3b2:	2300      	movs	r3, #0
 800d3b4:	f8c7 316c 	str.w	r3, [r7, #364]	; 0x16c
 800d3b8:	e016      	b.n	800d3e8 <WaitGprsConnectN715+0x170>
			if ((sio_buf2[i] == 'O') && (sio_buf2[i + 1] == 'K')) {
 800d3ba:	4a6a      	ldr	r2, [pc, #424]	; (800d564 <WaitGprsConnectN715+0x2ec>)
 800d3bc:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 800d3c0:	4413      	add	r3, r2
 800d3c2:	781b      	ldrb	r3, [r3, #0]
 800d3c4:	2b4f      	cmp	r3, #79	; 0x4f
 800d3c6:	d10a      	bne.n	800d3de <WaitGprsConnectN715+0x166>
 800d3c8:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 800d3cc:	3301      	adds	r3, #1
 800d3ce:	4a65      	ldr	r2, [pc, #404]	; (800d564 <WaitGprsConnectN715+0x2ec>)
 800d3d0:	5cd3      	ldrb	r3, [r2, r3]
 800d3d2:	2b4b      	cmp	r3, #75	; 0x4b
 800d3d4:	d103      	bne.n	800d3de <WaitGprsConnectN715+0x166>
				fl = 1;
 800d3d6:	2301      	movs	r3, #1
 800d3d8:	f8c7 3174 	str.w	r3, [r7, #372]	; 0x174
				break;
 800d3dc:	e00c      	b.n	800d3f8 <WaitGprsConnectN715+0x180>
		for (int i = 0; i < bufsize2; i++) {
 800d3de:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 800d3e2:	3301      	adds	r3, #1
 800d3e4:	f8c7 316c 	str.w	r3, [r7, #364]	; 0x16c
 800d3e8:	4b60      	ldr	r3, [pc, #384]	; (800d56c <WaitGprsConnectN715+0x2f4>)
 800d3ea:	881b      	ldrh	r3, [r3, #0]
 800d3ec:	b29b      	uxth	r3, r3
 800d3ee:	461a      	mov	r2, r3
 800d3f0:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 800d3f4:	4293      	cmp	r3, r2
 800d3f6:	dbe0      	blt.n	800d3ba <WaitGprsConnectN715+0x142>
			}

		}
		con--;
 800d3f8:	f8d7 3170 	ldr.w	r3, [r7, #368]	; 0x170
 800d3fc:	3b01      	subs	r3, #1
 800d3fe:	f8c7 3170 	str.w	r3, [r7, #368]	; 0x170
		if (!con)
 800d402:	f8d7 3170 	ldr.w	r3, [r7, #368]	; 0x170
 800d406:	2b00      	cmp	r3, #0
 800d408:	d101      	bne.n	800d40e <WaitGprsConnectN715+0x196>
			return false;
 800d40a:	2300      	movs	r3, #0
 800d40c:	e180      	b.n	800d710 <WaitGprsConnectN715+0x498>
		else if (fl)
 800d40e:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 800d412:	2b00      	cmp	r3, #0
 800d414:	d100      	bne.n	800d418 <WaitGprsConnectN715+0x1a0>
		ModemWrite(buf);
 800d416:	e7bc      	b.n	800d392 <WaitGprsConnectN715+0x11a>
			break;
 800d418:	bf00      	nop
	}
	fl = 0;
 800d41a:	2300      	movs	r3, #0
 800d41c:	f8c7 3174 	str.w	r3, [r7, #372]	; 0x174
	vTaskDelay(200);
 800d420:	20c8      	movs	r0, #200	; 0xc8
 800d422:	4b46      	ldr	r3, [pc, #280]	; (800d53c <WaitGprsConnectN715+0x2c4>)
 800d424:	4798      	blx	r3
	while (1) {
		vTaskDelay(100);
 800d426:	2064      	movs	r0, #100	; 0x64
 800d428:	4b44      	ldr	r3, [pc, #272]	; (800d53c <WaitGprsConnectN715+0x2c4>)
 800d42a:	4798      	blx	r3
		ModemWrite("AT+XIIC=1\r\n");
 800d42c:	4850      	ldr	r0, [pc, #320]	; (800d570 <WaitGprsConnectN715+0x2f8>)
 800d42e:	4b45      	ldr	r3, [pc, #276]	; (800d544 <WaitGprsConnectN715+0x2cc>)
 800d430:	4798      	blx	r3
		vTaskDelay(100);
 800d432:	2064      	movs	r0, #100	; 0x64
 800d434:	4b41      	ldr	r3, [pc, #260]	; (800d53c <WaitGprsConnectN715+0x2c4>)
 800d436:	4798      	blx	r3
		bufsize2 = uart2Read(sio_buf2, 256);
 800d438:	f44f 7180 	mov.w	r1, #256	; 0x100
 800d43c:	4849      	ldr	r0, [pc, #292]	; (800d564 <WaitGprsConnectN715+0x2ec>)
 800d43e:	4b4a      	ldr	r3, [pc, #296]	; (800d568 <WaitGprsConnectN715+0x2f0>)
 800d440:	4798      	blx	r3
 800d442:	4603      	mov	r3, r0
 800d444:	b29a      	uxth	r2, r3
 800d446:	4b49      	ldr	r3, [pc, #292]	; (800d56c <WaitGprsConnectN715+0x2f4>)
 800d448:	801a      	strh	r2, [r3, #0]
		for (int i = 0; i < bufsize2; i++) {
 800d44a:	2300      	movs	r3, #0
 800d44c:	f8c7 3168 	str.w	r3, [r7, #360]	; 0x168
 800d450:	e016      	b.n	800d480 <WaitGprsConnectN715+0x208>
			if ((sio_buf2[i] == 'O') && (sio_buf2[i + 1] == 'K')) {
 800d452:	4a44      	ldr	r2, [pc, #272]	; (800d564 <WaitGprsConnectN715+0x2ec>)
 800d454:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 800d458:	4413      	add	r3, r2
 800d45a:	781b      	ldrb	r3, [r3, #0]
 800d45c:	2b4f      	cmp	r3, #79	; 0x4f
 800d45e:	d10a      	bne.n	800d476 <WaitGprsConnectN715+0x1fe>
 800d460:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 800d464:	3301      	adds	r3, #1
 800d466:	4a3f      	ldr	r2, [pc, #252]	; (800d564 <WaitGprsConnectN715+0x2ec>)
 800d468:	5cd3      	ldrb	r3, [r2, r3]
 800d46a:	2b4b      	cmp	r3, #75	; 0x4b
 800d46c:	d103      	bne.n	800d476 <WaitGprsConnectN715+0x1fe>
				fl = 1;
 800d46e:	2301      	movs	r3, #1
 800d470:	f8c7 3174 	str.w	r3, [r7, #372]	; 0x174
				break;
 800d474:	e00c      	b.n	800d490 <WaitGprsConnectN715+0x218>
		for (int i = 0; i < bufsize2; i++) {
 800d476:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 800d47a:	3301      	adds	r3, #1
 800d47c:	f8c7 3168 	str.w	r3, [r7, #360]	; 0x168
 800d480:	4b3a      	ldr	r3, [pc, #232]	; (800d56c <WaitGprsConnectN715+0x2f4>)
 800d482:	881b      	ldrh	r3, [r3, #0]
 800d484:	b29b      	uxth	r3, r3
 800d486:	461a      	mov	r2, r3
 800d488:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 800d48c:	4293      	cmp	r3, r2
 800d48e:	dbe0      	blt.n	800d452 <WaitGprsConnectN715+0x1da>
			}

		}
		con--;
 800d490:	f8d7 3170 	ldr.w	r3, [r7, #368]	; 0x170
 800d494:	3b01      	subs	r3, #1
 800d496:	f8c7 3170 	str.w	r3, [r7, #368]	; 0x170
		if (!con)
 800d49a:	f8d7 3170 	ldr.w	r3, [r7, #368]	; 0x170
 800d49e:	2b00      	cmp	r3, #0
 800d4a0:	d101      	bne.n	800d4a6 <WaitGprsConnectN715+0x22e>
			return false;
 800d4a2:	2300      	movs	r3, #0
 800d4a4:	e134      	b.n	800d710 <WaitGprsConnectN715+0x498>
		if (fl)
 800d4a6:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 800d4aa:	2b00      	cmp	r3, #0
 800d4ac:	d100      	bne.n	800d4b0 <WaitGprsConnectN715+0x238>
		vTaskDelay(100);
 800d4ae:	e7ba      	b.n	800d426 <WaitGprsConnectN715+0x1ae>
			break;
 800d4b0:	bf00      	nop
	}

	fl = 0;
 800d4b2:	2300      	movs	r3, #0
 800d4b4:	f8c7 3174 	str.w	r3, [r7, #372]	; 0x174
	con = 15;
 800d4b8:	230f      	movs	r3, #15
 800d4ba:	f8c7 3170 	str.w	r3, [r7, #368]	; 0x170
	while (1) {
		vTaskDelay(100);
 800d4be:	2064      	movs	r0, #100	; 0x64
 800d4c0:	4b1e      	ldr	r3, [pc, #120]	; (800d53c <WaitGprsConnectN715+0x2c4>)
 800d4c2:	4798      	blx	r3
		ModemWrite("AT+XIIC?\r\n");
 800d4c4:	482b      	ldr	r0, [pc, #172]	; (800d574 <WaitGprsConnectN715+0x2fc>)
 800d4c6:	4b1f      	ldr	r3, [pc, #124]	; (800d544 <WaitGprsConnectN715+0x2cc>)
 800d4c8:	4798      	blx	r3
		vTaskDelay(100);
 800d4ca:	2064      	movs	r0, #100	; 0x64
 800d4cc:	4b1b      	ldr	r3, [pc, #108]	; (800d53c <WaitGprsConnectN715+0x2c4>)
 800d4ce:	4798      	blx	r3
		bufsize2 = uart2Read(sio_buf2, 256);
 800d4d0:	f44f 7180 	mov.w	r1, #256	; 0x100
 800d4d4:	4823      	ldr	r0, [pc, #140]	; (800d564 <WaitGprsConnectN715+0x2ec>)
 800d4d6:	4b24      	ldr	r3, [pc, #144]	; (800d568 <WaitGprsConnectN715+0x2f0>)
 800d4d8:	4798      	blx	r3
 800d4da:	4603      	mov	r3, r0
 800d4dc:	b29a      	uxth	r2, r3
 800d4de:	4b23      	ldr	r3, [pc, #140]	; (800d56c <WaitGprsConnectN715+0x2f4>)
 800d4e0:	801a      	strh	r2, [r3, #0]
		for (int i = 0; i < bufsize2; i++) {
 800d4e2:	2300      	movs	r3, #0
 800d4e4:	f8c7 3164 	str.w	r3, [r7, #356]	; 0x164
 800d4e8:	e016      	b.n	800d518 <WaitGprsConnectN715+0x2a0>
			if ((sio_buf2[i] == 'O') && (sio_buf2[i + 1] == 'K')) {
 800d4ea:	4a1e      	ldr	r2, [pc, #120]	; (800d564 <WaitGprsConnectN715+0x2ec>)
 800d4ec:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 800d4f0:	4413      	add	r3, r2
 800d4f2:	781b      	ldrb	r3, [r3, #0]
 800d4f4:	2b4f      	cmp	r3, #79	; 0x4f
 800d4f6:	d10a      	bne.n	800d50e <WaitGprsConnectN715+0x296>
 800d4f8:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 800d4fc:	3301      	adds	r3, #1
 800d4fe:	4a19      	ldr	r2, [pc, #100]	; (800d564 <WaitGprsConnectN715+0x2ec>)
 800d500:	5cd3      	ldrb	r3, [r2, r3]
 800d502:	2b4b      	cmp	r3, #75	; 0x4b
 800d504:	d103      	bne.n	800d50e <WaitGprsConnectN715+0x296>
				fl = 1;
 800d506:	2301      	movs	r3, #1
 800d508:	f8c7 3174 	str.w	r3, [r7, #372]	; 0x174
				break;
 800d50c:	e00c      	b.n	800d528 <WaitGprsConnectN715+0x2b0>
		for (int i = 0; i < bufsize2; i++) {
 800d50e:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 800d512:	3301      	adds	r3, #1
 800d514:	f8c7 3164 	str.w	r3, [r7, #356]	; 0x164
 800d518:	4b14      	ldr	r3, [pc, #80]	; (800d56c <WaitGprsConnectN715+0x2f4>)
 800d51a:	881b      	ldrh	r3, [r3, #0]
 800d51c:	b29b      	uxth	r3, r3
 800d51e:	461a      	mov	r2, r3
 800d520:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 800d524:	4293      	cmp	r3, r2
 800d526:	dbe0      	blt.n	800d4ea <WaitGprsConnectN715+0x272>
			}

		}
		if (fl)
 800d528:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 800d52c:	2b00      	cmp	r3, #0
 800d52e:	d123      	bne.n	800d578 <WaitGprsConnectN715+0x300>
		vTaskDelay(100);
 800d530:	e7c5      	b.n	800d4be <WaitGprsConnectN715+0x246>
 800d532:	bf00      	nop
 800d534:	00445049 	.word	0x00445049
 800d538:	0802b000 	.word	0x0802b000
 800d53c:	08001529 	.word	0x08001529
 800d540:	080153bc 	.word	0x080153bc
 800d544:	0800bfed 	.word	0x0800bfed
 800d548:	0800c031 	.word	0x0800c031
 800d54c:	08014731 	.word	0x08014731
 800d550:	080153c8 	.word	0x080153c8
 800d554:	080152ec 	.word	0x080152ec
 800d558:	08015338 	.word	0x08015338
 800d55c:	080153dc 	.word	0x080153dc
 800d560:	08014635 	.word	0x08014635
 800d564:	20008ae0 	.word	0x20008ae0
 800d568:	080048e5 	.word	0x080048e5
 800d56c:	200092e6 	.word	0x200092e6
 800d570:	080153f4 	.word	0x080153f4
 800d574:	08015400 	.word	0x08015400
			break;
 800d578:	bf00      	nop
	}

	vTaskDelay(200);
 800d57a:	20c8      	movs	r0, #200	; 0xc8
 800d57c:	4b67      	ldr	r3, [pc, #412]	; (800d71c <WaitGprsConnectN715+0x4a4>)
 800d57e:	4798      	blx	r3
	fl = 0;
 800d580:	2300      	movs	r3, #0
 800d582:	f8c7 3174 	str.w	r3, [r7, #372]	; 0x174

	while (1) {
		ModemWrite("AT+TCPLISTEN=4444\r\n");
 800d586:	4866      	ldr	r0, [pc, #408]	; (800d720 <WaitGprsConnectN715+0x4a8>)
 800d588:	4b66      	ldr	r3, [pc, #408]	; (800d724 <WaitGprsConnectN715+0x4ac>)
 800d58a:	4798      	blx	r3
		vTaskDelay(200);
 800d58c:	20c8      	movs	r0, #200	; 0xc8
 800d58e:	4b63      	ldr	r3, [pc, #396]	; (800d71c <WaitGprsConnectN715+0x4a4>)
 800d590:	4798      	blx	r3
		bufsize2 = uart2Read(sio_buf2, 256);
 800d592:	f44f 7180 	mov.w	r1, #256	; 0x100
 800d596:	4864      	ldr	r0, [pc, #400]	; (800d728 <WaitGprsConnectN715+0x4b0>)
 800d598:	4b64      	ldr	r3, [pc, #400]	; (800d72c <WaitGprsConnectN715+0x4b4>)
 800d59a:	4798      	blx	r3
 800d59c:	4603      	mov	r3, r0
 800d59e:	b29a      	uxth	r2, r3
 800d5a0:	4b63      	ldr	r3, [pc, #396]	; (800d730 <WaitGprsConnectN715+0x4b8>)
 800d5a2:	801a      	strh	r2, [r3, #0]
		for (int i = 0; i < bufsize2; i++) {
 800d5a4:	2300      	movs	r3, #0
 800d5a6:	f8c7 3160 	str.w	r3, [r7, #352]	; 0x160
 800d5aa:	e044      	b.n	800d636 <WaitGprsConnectN715+0x3be>
			if ((sio_buf2[i] == '0') && (sio_buf2[i + 1] == ',')
 800d5ac:	4a5e      	ldr	r2, [pc, #376]	; (800d728 <WaitGprsConnectN715+0x4b0>)
 800d5ae:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 800d5b2:	4413      	add	r3, r2
 800d5b4:	781b      	ldrb	r3, [r3, #0]
 800d5b6:	2b30      	cmp	r3, #48	; 0x30
 800d5b8:	d118      	bne.n	800d5ec <WaitGprsConnectN715+0x374>
 800d5ba:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 800d5be:	3301      	adds	r3, #1
 800d5c0:	4a59      	ldr	r2, [pc, #356]	; (800d728 <WaitGprsConnectN715+0x4b0>)
 800d5c2:	5cd3      	ldrb	r3, [r2, r3]
 800d5c4:	2b2c      	cmp	r3, #44	; 0x2c
 800d5c6:	d111      	bne.n	800d5ec <WaitGprsConnectN715+0x374>
					&& (sio_buf2[i + 2] == 'O') && (sio_buf2[i + 3] == 'K')) {
 800d5c8:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 800d5cc:	3302      	adds	r3, #2
 800d5ce:	4a56      	ldr	r2, [pc, #344]	; (800d728 <WaitGprsConnectN715+0x4b0>)
 800d5d0:	5cd3      	ldrb	r3, [r2, r3]
 800d5d2:	2b4f      	cmp	r3, #79	; 0x4f
 800d5d4:	d10a      	bne.n	800d5ec <WaitGprsConnectN715+0x374>
 800d5d6:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 800d5da:	3303      	adds	r3, #3
 800d5dc:	4a52      	ldr	r2, [pc, #328]	; (800d728 <WaitGprsConnectN715+0x4b0>)
 800d5de:	5cd3      	ldrb	r3, [r2, r3]
 800d5e0:	2b4b      	cmp	r3, #75	; 0x4b
 800d5e2:	d103      	bne.n	800d5ec <WaitGprsConnectN715+0x374>
				fl = 1;
 800d5e4:	2301      	movs	r3, #1
 800d5e6:	f8c7 3174 	str.w	r3, [r7, #372]	; 0x174
				break;
 800d5ea:	e02c      	b.n	800d646 <WaitGprsConnectN715+0x3ce>
			}
			if ((sio_buf2[i] == 'L') && (sio_buf2[i + 1] == 'i')
 800d5ec:	4a4e      	ldr	r2, [pc, #312]	; (800d728 <WaitGprsConnectN715+0x4b0>)
 800d5ee:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 800d5f2:	4413      	add	r3, r2
 800d5f4:	781b      	ldrb	r3, [r3, #0]
 800d5f6:	2b4c      	cmp	r3, #76	; 0x4c
 800d5f8:	d118      	bne.n	800d62c <WaitGprsConnectN715+0x3b4>
 800d5fa:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 800d5fe:	3301      	adds	r3, #1
 800d600:	4a49      	ldr	r2, [pc, #292]	; (800d728 <WaitGprsConnectN715+0x4b0>)
 800d602:	5cd3      	ldrb	r3, [r2, r3]
 800d604:	2b69      	cmp	r3, #105	; 0x69
 800d606:	d111      	bne.n	800d62c <WaitGprsConnectN715+0x3b4>
					&& (sio_buf2[i + 2] == 's') && (sio_buf2[i + 3] == 't')) {
 800d608:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 800d60c:	3302      	adds	r3, #2
 800d60e:	4a46      	ldr	r2, [pc, #280]	; (800d728 <WaitGprsConnectN715+0x4b0>)
 800d610:	5cd3      	ldrb	r3, [r2, r3]
 800d612:	2b73      	cmp	r3, #115	; 0x73
 800d614:	d10a      	bne.n	800d62c <WaitGprsConnectN715+0x3b4>
 800d616:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 800d61a:	3303      	adds	r3, #3
 800d61c:	4a42      	ldr	r2, [pc, #264]	; (800d728 <WaitGprsConnectN715+0x4b0>)
 800d61e:	5cd3      	ldrb	r3, [r2, r3]
 800d620:	2b74      	cmp	r3, #116	; 0x74
 800d622:	d103      	bne.n	800d62c <WaitGprsConnectN715+0x3b4>
				fl = 1;
 800d624:	2301      	movs	r3, #1
 800d626:	f8c7 3174 	str.w	r3, [r7, #372]	; 0x174
				break;
 800d62a:	e00c      	b.n	800d646 <WaitGprsConnectN715+0x3ce>
		for (int i = 0; i < bufsize2; i++) {
 800d62c:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 800d630:	3301      	adds	r3, #1
 800d632:	f8c7 3160 	str.w	r3, [r7, #352]	; 0x160
 800d636:	4b3e      	ldr	r3, [pc, #248]	; (800d730 <WaitGprsConnectN715+0x4b8>)
 800d638:	881b      	ldrh	r3, [r3, #0]
 800d63a:	b29b      	uxth	r3, r3
 800d63c:	461a      	mov	r2, r3
 800d63e:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 800d642:	4293      	cmp	r3, r2
 800d644:	dbb2      	blt.n	800d5ac <WaitGprsConnectN715+0x334>
			}

		}
		con--;
 800d646:	f8d7 3170 	ldr.w	r3, [r7, #368]	; 0x170
 800d64a:	3b01      	subs	r3, #1
 800d64c:	f8c7 3170 	str.w	r3, [r7, #368]	; 0x170
		if (!con)
 800d650:	f8d7 3170 	ldr.w	r3, [r7, #368]	; 0x170
 800d654:	2b00      	cmp	r3, #0
 800d656:	d101      	bne.n	800d65c <WaitGprsConnectN715+0x3e4>
			return false;
 800d658:	2300      	movs	r3, #0
 800d65a:	e059      	b.n	800d710 <WaitGprsConnectN715+0x498>
		if (fl)
 800d65c:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 800d660:	2b00      	cmp	r3, #0
 800d662:	d100      	bne.n	800d666 <WaitGprsConnectN715+0x3ee>
		ModemWrite("AT+TCPLISTEN=4444\r\n");
 800d664:	e78f      	b.n	800d586 <WaitGprsConnectN715+0x30e>
			break;
 800d666:	bf00      	nop
	}
	vTaskDelay(200);
 800d668:	20c8      	movs	r0, #200	; 0xc8
 800d66a:	4b2c      	ldr	r3, [pc, #176]	; (800d71c <WaitGprsConnectN715+0x4a4>)
 800d66c:	4798      	blx	r3
	fl = 0;
 800d66e:	2300      	movs	r3, #0
 800d670:	f8c7 3174 	str.w	r3, [r7, #372]	; 0x174
	con = 15;
 800d674:	230f      	movs	r3, #15
 800d676:	f8c7 3170 	str.w	r3, [r7, #368]	; 0x170
	while (1) {
		vTaskDelay(200);
 800d67a:	20c8      	movs	r0, #200	; 0xc8
 800d67c:	4b27      	ldr	r3, [pc, #156]	; (800d71c <WaitGprsConnectN715+0x4a4>)
 800d67e:	4798      	blx	r3
		ModemWrite("AT+IPSTATUS=0\r\n");
 800d680:	482c      	ldr	r0, [pc, #176]	; (800d734 <WaitGprsConnectN715+0x4bc>)
 800d682:	4b28      	ldr	r3, [pc, #160]	; (800d724 <WaitGprsConnectN715+0x4ac>)
 800d684:	4798      	blx	r3
		bufsize2 = uart2Read(sio_buf2, 256);
 800d686:	f44f 7180 	mov.w	r1, #256	; 0x100
 800d68a:	4827      	ldr	r0, [pc, #156]	; (800d728 <WaitGprsConnectN715+0x4b0>)
 800d68c:	4b27      	ldr	r3, [pc, #156]	; (800d72c <WaitGprsConnectN715+0x4b4>)
 800d68e:	4798      	blx	r3
 800d690:	4603      	mov	r3, r0
 800d692:	b29a      	uxth	r2, r3
 800d694:	4b26      	ldr	r3, [pc, #152]	; (800d730 <WaitGprsConnectN715+0x4b8>)
 800d696:	801a      	strh	r2, [r3, #0]
		for (int i = 0; i < bufsize2; i++) {
 800d698:	2300      	movs	r3, #0
 800d69a:	f8c7 315c 	str.w	r3, [r7, #348]	; 0x15c
 800d69e:	e01d      	b.n	800d6dc <WaitGprsConnectN715+0x464>
			if ((sio_buf2[i] == 'S') && (sio_buf2[i + 1] == 'R')
 800d6a0:	4a21      	ldr	r2, [pc, #132]	; (800d728 <WaitGprsConnectN715+0x4b0>)
 800d6a2:	f8d7 315c 	ldr.w	r3, [r7, #348]	; 0x15c
 800d6a6:	4413      	add	r3, r2
 800d6a8:	781b      	ldrb	r3, [r3, #0]
 800d6aa:	2b53      	cmp	r3, #83	; 0x53
 800d6ac:	d111      	bne.n	800d6d2 <WaitGprsConnectN715+0x45a>
 800d6ae:	f8d7 315c 	ldr.w	r3, [r7, #348]	; 0x15c
 800d6b2:	3301      	adds	r3, #1
 800d6b4:	4a1c      	ldr	r2, [pc, #112]	; (800d728 <WaitGprsConnectN715+0x4b0>)
 800d6b6:	5cd3      	ldrb	r3, [r2, r3]
 800d6b8:	2b52      	cmp	r3, #82	; 0x52
 800d6ba:	d10a      	bne.n	800d6d2 <WaitGprsConnectN715+0x45a>
					&& (sio_buf2[i + 2] == 'V')) {
 800d6bc:	f8d7 315c 	ldr.w	r3, [r7, #348]	; 0x15c
 800d6c0:	3302      	adds	r3, #2
 800d6c2:	4a19      	ldr	r2, [pc, #100]	; (800d728 <WaitGprsConnectN715+0x4b0>)
 800d6c4:	5cd3      	ldrb	r3, [r2, r3]
 800d6c6:	2b56      	cmp	r3, #86	; 0x56
 800d6c8:	d103      	bne.n	800d6d2 <WaitGprsConnectN715+0x45a>
				fl = 1;
 800d6ca:	2301      	movs	r3, #1
 800d6cc:	f8c7 3174 	str.w	r3, [r7, #372]	; 0x174
				break;
 800d6d0:	e00c      	b.n	800d6ec <WaitGprsConnectN715+0x474>
		for (int i = 0; i < bufsize2; i++) {
 800d6d2:	f8d7 315c 	ldr.w	r3, [r7, #348]	; 0x15c
 800d6d6:	3301      	adds	r3, #1
 800d6d8:	f8c7 315c 	str.w	r3, [r7, #348]	; 0x15c
 800d6dc:	4b14      	ldr	r3, [pc, #80]	; (800d730 <WaitGprsConnectN715+0x4b8>)
 800d6de:	881b      	ldrh	r3, [r3, #0]
 800d6e0:	b29b      	uxth	r3, r3
 800d6e2:	461a      	mov	r2, r3
 800d6e4:	f8d7 315c 	ldr.w	r3, [r7, #348]	; 0x15c
 800d6e8:	4293      	cmp	r3, r2
 800d6ea:	dbd9      	blt.n	800d6a0 <WaitGprsConnectN715+0x428>
			}

		}
		con--;
 800d6ec:	f8d7 3170 	ldr.w	r3, [r7, #368]	; 0x170
 800d6f0:	3b01      	subs	r3, #1
 800d6f2:	f8c7 3170 	str.w	r3, [r7, #368]	; 0x170
		if (!con)
 800d6f6:	f8d7 3170 	ldr.w	r3, [r7, #368]	; 0x170
 800d6fa:	2b00      	cmp	r3, #0
 800d6fc:	d101      	bne.n	800d702 <WaitGprsConnectN715+0x48a>
			return false;
 800d6fe:	2300      	movs	r3, #0
 800d700:	e006      	b.n	800d710 <WaitGprsConnectN715+0x498>
		if (fl)
 800d702:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 800d706:	2b00      	cmp	r3, #0
 800d708:	d100      	bne.n	800d70c <WaitGprsConnectN715+0x494>
		vTaskDelay(200);
 800d70a:	e7b6      	b.n	800d67a <WaitGprsConnectN715+0x402>
			break;
 800d70c:	bf00      	nop
	}

	return true;
 800d70e:	2301      	movs	r3, #1
}
 800d710:	4618      	mov	r0, r3
 800d712:	f507 77bc 	add.w	r7, r7, #376	; 0x178
 800d716:	46bd      	mov	sp, r7
 800d718:	bdb0      	pop	{r4, r5, r7, pc}
 800d71a:	bf00      	nop
 800d71c:	08001529 	.word	0x08001529
 800d720:	0801540c 	.word	0x0801540c
 800d724:	0800bfed 	.word	0x0800bfed
 800d728:	20008ae0 	.word	0x20008ae0
 800d72c:	080048e5 	.word	0x080048e5
 800d730:	200092e6 	.word	0x200092e6
 800d734:	08015420 	.word	0x08015420

0800d738 <SelectModem>:
//==========================================================================
bool SelectModem() {
 800d738:	b580      	push	{r7, lr}
 800d73a:	b082      	sub	sp, #8
 800d73c:	af00      	add	r7, sp, #0
	int count = 0;
 800d73e:	2300      	movs	r3, #0
 800d740:	607b      	str	r3, [r7, #4]

	vTaskDelay(100);
 800d742:	2064      	movs	r0, #100	; 0x64
 800d744:	4b7e      	ldr	r3, [pc, #504]	; (800d940 <SelectModem+0x208>)
 800d746:	4798      	blx	r3
	while (count < 50) {
 800d748:	e016      	b.n	800d778 <SelectModem+0x40>
		ModemWrite("AT+GMM\r\n");
 800d74a:	487e      	ldr	r0, [pc, #504]	; (800d944 <SelectModem+0x20c>)
 800d74c:	4b7e      	ldr	r3, [pc, #504]	; (800d948 <SelectModem+0x210>)
 800d74e:	4798      	blx	r3
		bufsize4 = uart2Read(sio_buf4, 256);
 800d750:	f44f 7180 	mov.w	r1, #256	; 0x100
 800d754:	487d      	ldr	r0, [pc, #500]	; (800d94c <SelectModem+0x214>)
 800d756:	4b7e      	ldr	r3, [pc, #504]	; (800d950 <SelectModem+0x218>)
 800d758:	4798      	blx	r3
 800d75a:	4603      	mov	r3, r0
 800d75c:	b29a      	uxth	r2, r3
 800d75e:	4b7d      	ldr	r3, [pc, #500]	; (800d954 <SelectModem+0x21c>)
 800d760:	801a      	strh	r2, [r3, #0]
		if (bufsize4 > 4)
 800d762:	4b7c      	ldr	r3, [pc, #496]	; (800d954 <SelectModem+0x21c>)
 800d764:	881b      	ldrh	r3, [r3, #0]
 800d766:	b29b      	uxth	r3, r3
 800d768:	2b04      	cmp	r3, #4
 800d76a:	d809      	bhi.n	800d780 <SelectModem+0x48>
			break;
		count++;
 800d76c:	687b      	ldr	r3, [r7, #4]
 800d76e:	3301      	adds	r3, #1
 800d770:	607b      	str	r3, [r7, #4]
		vTaskDelay(100);
 800d772:	2064      	movs	r0, #100	; 0x64
 800d774:	4b72      	ldr	r3, [pc, #456]	; (800d940 <SelectModem+0x208>)
 800d776:	4798      	blx	r3
	while (count < 50) {
 800d778:	687b      	ldr	r3, [r7, #4]
 800d77a:	2b31      	cmp	r3, #49	; 0x31
 800d77c:	dde5      	ble.n	800d74a <SelectModem+0x12>
 800d77e:	e000      	b.n	800d782 <SelectModem+0x4a>
			break;
 800d780:	bf00      	nop
	}
	if (bufsize4 != 0) {
 800d782:	4b74      	ldr	r3, [pc, #464]	; (800d954 <SelectModem+0x21c>)
 800d784:	881b      	ldrh	r3, [r3, #0]
 800d786:	b29b      	uxth	r3, r3
 800d788:	2b00      	cmp	r3, #0
 800d78a:	f000 80d4 	beq.w	800d936 <SelectModem+0x1fe>
		for (int i = 0; i < bufsize4; i++) {
 800d78e:	2300      	movs	r3, #0
 800d790:	603b      	str	r3, [r7, #0]
 800d792:	e0c8      	b.n	800d926 <SelectModem+0x1ee>
			if ((sio_buf4[i] == 'U') && (sio_buf4[i + 1] == 'C')
 800d794:	4a6d      	ldr	r2, [pc, #436]	; (800d94c <SelectModem+0x214>)
 800d796:	683b      	ldr	r3, [r7, #0]
 800d798:	4413      	add	r3, r2
 800d79a:	781b      	ldrb	r3, [r3, #0]
 800d79c:	2b55      	cmp	r3, #85	; 0x55
 800d79e:	d122      	bne.n	800d7e6 <SelectModem+0xae>
 800d7a0:	683b      	ldr	r3, [r7, #0]
 800d7a2:	3301      	adds	r3, #1
 800d7a4:	4a69      	ldr	r2, [pc, #420]	; (800d94c <SelectModem+0x214>)
 800d7a6:	5cd3      	ldrb	r3, [r2, r3]
 800d7a8:	2b43      	cmp	r3, #67	; 0x43
 800d7aa:	d11c      	bne.n	800d7e6 <SelectModem+0xae>
					&& (sio_buf4[i + 2] == '2') && (sio_buf4[i + 3] == '0')) //UC20
 800d7ac:	683b      	ldr	r3, [r7, #0]
 800d7ae:	3302      	adds	r3, #2
 800d7b0:	4a66      	ldr	r2, [pc, #408]	; (800d94c <SelectModem+0x214>)
 800d7b2:	5cd3      	ldrb	r3, [r2, r3]
 800d7b4:	2b32      	cmp	r3, #50	; 0x32
 800d7b6:	d116      	bne.n	800d7e6 <SelectModem+0xae>
 800d7b8:	683b      	ldr	r3, [r7, #0]
 800d7ba:	3303      	adds	r3, #3
 800d7bc:	4a63      	ldr	r2, [pc, #396]	; (800d94c <SelectModem+0x214>)
 800d7be:	5cd3      	ldrb	r3, [r2, r3]
 800d7c0:	2b30      	cmp	r3, #48	; 0x30
 800d7c2:	d110      	bne.n	800d7e6 <SelectModem+0xae>
					{
				DeviceID = 1;
 800d7c4:	4b64      	ldr	r3, [pc, #400]	; (800d958 <SelectModem+0x220>)
 800d7c6:	2201      	movs	r2, #1
 800d7c8:	601a      	str	r2, [r3, #0]

				 break;
				 }
				 else
				 {*/
				if (!WaitGprsConnectUC20()) //  UC20
 800d7ca:	4b64      	ldr	r3, [pc, #400]	; (800d95c <SelectModem+0x224>)
 800d7cc:	4798      	blx	r3
 800d7ce:	4603      	mov	r3, r0
 800d7d0:	f083 0301 	eor.w	r3, r3, #1
 800d7d4:	b2db      	uxtb	r3, r3
 800d7d6:	2b00      	cmp	r3, #0
 800d7d8:	f040 809b 	bne.w	800d912 <SelectModem+0x1da>
					continue;
				vTaskDelay(50);
 800d7dc:	2032      	movs	r0, #50	; 0x32
 800d7de:	4b58      	ldr	r3, [pc, #352]	; (800d940 <SelectModem+0x208>)
 800d7e0:	4798      	blx	r3
				return true;
 800d7e2:	2301      	movs	r3, #1
 800d7e4:	e0a8      	b.n	800d938 <SelectModem+0x200>
				//}
			} else if ((sio_buf4[i] == 'U') && (sio_buf4[i + 1] == 'C')
 800d7e6:	4a59      	ldr	r2, [pc, #356]	; (800d94c <SelectModem+0x214>)
 800d7e8:	683b      	ldr	r3, [r7, #0]
 800d7ea:	4413      	add	r3, r2
 800d7ec:	781b      	ldrb	r3, [r3, #0]
 800d7ee:	2b55      	cmp	r3, #85	; 0x55
 800d7f0:	d121      	bne.n	800d836 <SelectModem+0xfe>
 800d7f2:	683b      	ldr	r3, [r7, #0]
 800d7f4:	3301      	adds	r3, #1
 800d7f6:	4a55      	ldr	r2, [pc, #340]	; (800d94c <SelectModem+0x214>)
 800d7f8:	5cd3      	ldrb	r3, [r2, r3]
 800d7fa:	2b43      	cmp	r3, #67	; 0x43
 800d7fc:	d11b      	bne.n	800d836 <SelectModem+0xfe>
					&& (sio_buf4[i + 2] == '1') && (sio_buf4[i + 3] == '5')) //UC15
 800d7fe:	683b      	ldr	r3, [r7, #0]
 800d800:	3302      	adds	r3, #2
 800d802:	4a52      	ldr	r2, [pc, #328]	; (800d94c <SelectModem+0x214>)
 800d804:	5cd3      	ldrb	r3, [r2, r3]
 800d806:	2b31      	cmp	r3, #49	; 0x31
 800d808:	d115      	bne.n	800d836 <SelectModem+0xfe>
 800d80a:	683b      	ldr	r3, [r7, #0]
 800d80c:	3303      	adds	r3, #3
 800d80e:	4a4f      	ldr	r2, [pc, #316]	; (800d94c <SelectModem+0x214>)
 800d810:	5cd3      	ldrb	r3, [r2, r3]
 800d812:	2b35      	cmp	r3, #53	; 0x35
 800d814:	d10f      	bne.n	800d836 <SelectModem+0xfe>
					{
				//if (DeviceID != 3)

				//{
				DeviceID = 3;
 800d816:	4b50      	ldr	r3, [pc, #320]	; (800d958 <SelectModem+0x220>)
 800d818:	2203      	movs	r2, #3
 800d81a:	601a      	str	r2, [r3, #0]
				 i_Select = 0;
				 break;
				 }
				 else
				 {*/
				if (!WaitGprsConnectUC15()) //  UC15
 800d81c:	4b50      	ldr	r3, [pc, #320]	; (800d960 <SelectModem+0x228>)
 800d81e:	4798      	blx	r3
 800d820:	4603      	mov	r3, r0
 800d822:	f083 0301 	eor.w	r3, r3, #1
 800d826:	b2db      	uxtb	r3, r3
 800d828:	2b00      	cmp	r3, #0
 800d82a:	d174      	bne.n	800d916 <SelectModem+0x1de>
					continue;
				vTaskDelay(50);
 800d82c:	2032      	movs	r0, #50	; 0x32
 800d82e:	4b44      	ldr	r3, [pc, #272]	; (800d940 <SelectModem+0x208>)
 800d830:	4798      	blx	r3
				return true;
 800d832:	2301      	movs	r3, #1
 800d834:	e080      	b.n	800d938 <SelectModem+0x200>

				 vTaskDelay(50);
				 return true;
				 }*/

			} else if ((sio_buf4[i] == 'Q')
 800d836:	4a45      	ldr	r2, [pc, #276]	; (800d94c <SelectModem+0x214>)
 800d838:	683b      	ldr	r3, [r7, #0]
 800d83a:	4413      	add	r3, r2
 800d83c:	781b      	ldrb	r3, [r3, #0]
 800d83e:	2b51      	cmp	r3, #81	; 0x51
 800d840:	d13f      	bne.n	800d8c2 <SelectModem+0x18a>
					&& (sio_buf4[i + 1] == 'u')  			//Quectel_M66
 800d842:	683b      	ldr	r3, [r7, #0]
 800d844:	3301      	adds	r3, #1
 800d846:	4a41      	ldr	r2, [pc, #260]	; (800d94c <SelectModem+0x214>)
 800d848:	5cd3      	ldrb	r3, [r2, r3]
 800d84a:	2b75      	cmp	r3, #117	; 0x75
 800d84c:	d139      	bne.n	800d8c2 <SelectModem+0x18a>
					&& (sio_buf4[i + 2] == 'e') && (sio_buf4[i + 3] == 'c')
 800d84e:	683b      	ldr	r3, [r7, #0]
 800d850:	3302      	adds	r3, #2
 800d852:	4a3e      	ldr	r2, [pc, #248]	; (800d94c <SelectModem+0x214>)
 800d854:	5cd3      	ldrb	r3, [r2, r3]
 800d856:	2b65      	cmp	r3, #101	; 0x65
 800d858:	d133      	bne.n	800d8c2 <SelectModem+0x18a>
 800d85a:	683b      	ldr	r3, [r7, #0]
 800d85c:	3303      	adds	r3, #3
 800d85e:	4a3b      	ldr	r2, [pc, #236]	; (800d94c <SelectModem+0x214>)
 800d860:	5cd3      	ldrb	r3, [r2, r3]
 800d862:	2b63      	cmp	r3, #99	; 0x63
 800d864:	d12d      	bne.n	800d8c2 <SelectModem+0x18a>
					&& (sio_buf4[i + 4] == 't') && (sio_buf4[i + 5] == 'e')
 800d866:	683b      	ldr	r3, [r7, #0]
 800d868:	3304      	adds	r3, #4
 800d86a:	4a38      	ldr	r2, [pc, #224]	; (800d94c <SelectModem+0x214>)
 800d86c:	5cd3      	ldrb	r3, [r2, r3]
 800d86e:	2b74      	cmp	r3, #116	; 0x74
 800d870:	d127      	bne.n	800d8c2 <SelectModem+0x18a>
 800d872:	683b      	ldr	r3, [r7, #0]
 800d874:	3305      	adds	r3, #5
 800d876:	4a35      	ldr	r2, [pc, #212]	; (800d94c <SelectModem+0x214>)
 800d878:	5cd3      	ldrb	r3, [r2, r3]
 800d87a:	2b65      	cmp	r3, #101	; 0x65
 800d87c:	d121      	bne.n	800d8c2 <SelectModem+0x18a>
					&& (sio_buf4[i + 6] == 'l') && (sio_buf4[i + 7] == '_')
 800d87e:	683b      	ldr	r3, [r7, #0]
 800d880:	3306      	adds	r3, #6
 800d882:	4a32      	ldr	r2, [pc, #200]	; (800d94c <SelectModem+0x214>)
 800d884:	5cd3      	ldrb	r3, [r2, r3]
 800d886:	2b6c      	cmp	r3, #108	; 0x6c
 800d888:	d11b      	bne.n	800d8c2 <SelectModem+0x18a>
 800d88a:	683b      	ldr	r3, [r7, #0]
 800d88c:	3307      	adds	r3, #7
 800d88e:	4a2f      	ldr	r2, [pc, #188]	; (800d94c <SelectModem+0x214>)
 800d890:	5cd3      	ldrb	r3, [r2, r3]
 800d892:	2b5f      	cmp	r3, #95	; 0x5f
 800d894:	d115      	bne.n	800d8c2 <SelectModem+0x18a>
					&& (sio_buf4[i + 8] == 'M')/*&&(sio_buf4[i + 9] == '6')
 800d896:	683b      	ldr	r3, [r7, #0]
 800d898:	3308      	adds	r3, #8
 800d89a:	4a2c      	ldr	r2, [pc, #176]	; (800d94c <SelectModem+0x214>)
 800d89c:	5cd3      	ldrb	r3, [r2, r3]
 800d89e:	2b4d      	cmp	r3, #77	; 0x4d
 800d8a0:	d10f      	bne.n	800d8c2 <SelectModem+0x18a>
					 && (sio_buf4[i + 10] == '6')*/) //  4.49.0  66,   12 
					{
				DeviceID = 2;
 800d8a2:	4b2d      	ldr	r3, [pc, #180]	; (800d958 <SelectModem+0x220>)
 800d8a4:	2202      	movs	r2, #2
 800d8a6:	601a      	str	r2, [r3, #0]
				 break;
				 }
				 i_GprsCon--;
				 }
				 i_GprsCon = 0;*/
				if (!WaitGprsConnectM66()) //  M66
 800d8a8:	4b2e      	ldr	r3, [pc, #184]	; (800d964 <SelectModem+0x22c>)
 800d8aa:	4798      	blx	r3
 800d8ac:	4603      	mov	r3, r0
 800d8ae:	f083 0301 	eor.w	r3, r3, #1
 800d8b2:	b2db      	uxtb	r3, r3
 800d8b4:	2b00      	cmp	r3, #0
 800d8b6:	d130      	bne.n	800d91a <SelectModem+0x1e2>
					continue;

				vTaskDelay(50);
 800d8b8:	2032      	movs	r0, #50	; 0x32
 800d8ba:	4b21      	ldr	r3, [pc, #132]	; (800d940 <SelectModem+0x208>)
 800d8bc:	4798      	blx	r3
				return true;
 800d8be:	2301      	movs	r3, #1
 800d8c0:	e03a      	b.n	800d938 <SelectModem+0x200>
				//}
			} else if ((sio_buf4[i] == 'N') && (sio_buf4[i + 1] == '7')
 800d8c2:	4a22      	ldr	r2, [pc, #136]	; (800d94c <SelectModem+0x214>)
 800d8c4:	683b      	ldr	r3, [r7, #0]
 800d8c6:	4413      	add	r3, r2
 800d8c8:	781b      	ldrb	r3, [r3, #0]
 800d8ca:	2b4e      	cmp	r3, #78	; 0x4e
 800d8cc:	d128      	bne.n	800d920 <SelectModem+0x1e8>
 800d8ce:	683b      	ldr	r3, [r7, #0]
 800d8d0:	3301      	adds	r3, #1
 800d8d2:	4a1e      	ldr	r2, [pc, #120]	; (800d94c <SelectModem+0x214>)
 800d8d4:	5cd3      	ldrb	r3, [r2, r3]
 800d8d6:	2b37      	cmp	r3, #55	; 0x37
 800d8d8:	d122      	bne.n	800d920 <SelectModem+0x1e8>
					&& (sio_buf4[i + 2] == '1') && (sio_buf4[i + 3] == '5')) //UC15
 800d8da:	683b      	ldr	r3, [r7, #0]
 800d8dc:	3302      	adds	r3, #2
 800d8de:	4a1b      	ldr	r2, [pc, #108]	; (800d94c <SelectModem+0x214>)
 800d8e0:	5cd3      	ldrb	r3, [r2, r3]
 800d8e2:	2b31      	cmp	r3, #49	; 0x31
 800d8e4:	d11c      	bne.n	800d920 <SelectModem+0x1e8>
 800d8e6:	683b      	ldr	r3, [r7, #0]
 800d8e8:	3303      	adds	r3, #3
 800d8ea:	4a18      	ldr	r2, [pc, #96]	; (800d94c <SelectModem+0x214>)
 800d8ec:	5cd3      	ldrb	r3, [r2, r3]
 800d8ee:	2b35      	cmp	r3, #53	; 0x35
 800d8f0:	d116      	bne.n	800d920 <SelectModem+0x1e8>
					{
				DeviceID = 4;
 800d8f2:	4b19      	ldr	r3, [pc, #100]	; (800d958 <SelectModem+0x220>)
 800d8f4:	2204      	movs	r2, #4
 800d8f6:	601a      	str	r2, [r3, #0]
				if (!WaitGprsConnectN715()) //  M66
 800d8f8:	4b1b      	ldr	r3, [pc, #108]	; (800d968 <SelectModem+0x230>)
 800d8fa:	4798      	blx	r3
 800d8fc:	4603      	mov	r3, r0
 800d8fe:	f083 0301 	eor.w	r3, r3, #1
 800d902:	b2db      	uxtb	r3, r3
 800d904:	2b00      	cmp	r3, #0
 800d906:	d10a      	bne.n	800d91e <SelectModem+0x1e6>
					continue;

				vTaskDelay(50);
 800d908:	2032      	movs	r0, #50	; 0x32
 800d90a:	4b0d      	ldr	r3, [pc, #52]	; (800d940 <SelectModem+0x208>)
 800d90c:	4798      	blx	r3
				return true;
 800d90e:	2301      	movs	r3, #1
 800d910:	e012      	b.n	800d938 <SelectModem+0x200>
					continue;
 800d912:	bf00      	nop
 800d914:	e004      	b.n	800d920 <SelectModem+0x1e8>
					continue;
 800d916:	bf00      	nop
 800d918:	e002      	b.n	800d920 <SelectModem+0x1e8>
					continue;
 800d91a:	bf00      	nop
 800d91c:	e000      	b.n	800d920 <SelectModem+0x1e8>
					continue;
 800d91e:	bf00      	nop
		for (int i = 0; i < bufsize4; i++) {
 800d920:	683b      	ldr	r3, [r7, #0]
 800d922:	3301      	adds	r3, #1
 800d924:	603b      	str	r3, [r7, #0]
 800d926:	4b0b      	ldr	r3, [pc, #44]	; (800d954 <SelectModem+0x21c>)
 800d928:	881b      	ldrh	r3, [r3, #0]
 800d92a:	b29b      	uxth	r3, r3
 800d92c:	461a      	mov	r2, r3
 800d92e:	683b      	ldr	r3, [r7, #0]
 800d930:	4293      	cmp	r3, r2
 800d932:	f6ff af2f 	blt.w	800d794 <SelectModem+0x5c>

			}
		}
	}

	return false;
 800d936:	2300      	movs	r3, #0

}
 800d938:	4618      	mov	r0, r3
 800d93a:	3708      	adds	r7, #8
 800d93c:	46bd      	mov	sp, r7
 800d93e:	bd80      	pop	{r7, pc}
 800d940:	08001529 	.word	0x08001529
 800d944:	08015430 	.word	0x08015430
 800d948:	0800bfed 	.word	0x0800bfed
 800d94c:	20008ee0 	.word	0x20008ee0
 800d950:	080048e5 	.word	0x080048e5
 800d954:	200092e8 	.word	0x200092e8
 800d958:	20008468 	.word	0x20008468
 800d95c:	0800c925 	.word	0x0800c925
 800d960:	0800cb5d 	.word	0x0800cb5d
 800d964:	0800ce99 	.word	0x0800ce99
 800d968:	0800d279 	.word	0x0800d279

0800d96c <ModemInit>:

void ModemInit() {
 800d96c:	b580      	push	{r7, lr}
 800d96e:	b084      	sub	sp, #16
 800d970:	af00      	add	r7, sp, #0

	/*USART_DeInit(USART3);
	 DMA_DeInit(DMA1_Channel2);
	 DMA_DeInit(DMA1_Channel3);*/
	uart2Init(115200);
 800d972:	f44f 30e1 	mov.w	r0, #115200	; 0x1c200
 800d976:	4b78      	ldr	r3, [pc, #480]	; (800db58 <ModemInit+0x1ec>)
 800d978:	4798      	blx	r3

	USART2TIMConfigure(50);
 800d97a:	2032      	movs	r0, #50	; 0x32
 800d97c:	4b77      	ldr	r3, [pc, #476]	; (800db5c <ModemInit+0x1f0>)
 800d97e:	4798      	blx	r3

//------------------------------------------------------------
	BKP_WriteBackupRegister(BKP_DR7, 30);
 800d980:	211e      	movs	r1, #30
 800d982:	201c      	movs	r0, #28
 800d984:	4b76      	ldr	r3, [pc, #472]	; (800db60 <ModemInit+0x1f4>)
 800d986:	4798      	blx	r3
	while (1) {
		int heapSize = 0;
 800d988:	2300      	movs	r3, #0
 800d98a:	607b      	str	r3, [r7, #4]
		heapSize = xPortGetFreeHeapSize();
 800d98c:	4b75      	ldr	r3, [pc, #468]	; (800db64 <ModemInit+0x1f8>)
 800d98e:	4798      	blx	r3
 800d990:	4603      	mov	r3, r0
 800d992:	607b      	str	r3, [r7, #4]
		heapSize += 0;

		LedNoModem = 1;
 800d994:	4b74      	ldr	r3, [pc, #464]	; (800db68 <ModemInit+0x1fc>)
 800d996:	2201      	movs	r2, #1
 800d998:	701a      	strb	r2, [r3, #0]
		if (initMK == 1) {
 800d99a:	4b74      	ldr	r3, [pc, #464]	; (800db6c <ModemInit+0x200>)
 800d99c:	681b      	ldr	r3, [r3, #0]
 800d99e:	2b01      	cmp	r3, #1
 800d9a0:	d118      	bne.n	800d9d4 <ModemInit+0x68>
			MODEM_ENABLE
 800d9a2:	2101      	movs	r1, #1
 800d9a4:	4872      	ldr	r0, [pc, #456]	; (800db70 <ModemInit+0x204>)
 800d9a6:	4b73      	ldr	r3, [pc, #460]	; (800db74 <ModemInit+0x208>)
 800d9a8:	4798      	blx	r3
			;
			vTaskDelay(4000);
 800d9aa:	f44f 607a 	mov.w	r0, #4000	; 0xfa0
 800d9ae:	4b72      	ldr	r3, [pc, #456]	; (800db78 <ModemInit+0x20c>)
 800d9b0:	4798      	blx	r3
			MODEM_DISABLE
 800d9b2:	2101      	movs	r1, #1
 800d9b4:	486e      	ldr	r0, [pc, #440]	; (800db70 <ModemInit+0x204>)
 800d9b6:	4b71      	ldr	r3, [pc, #452]	; (800db7c <ModemInit+0x210>)
 800d9b8:	4798      	blx	r3
			;
			vTaskDelay(5000);
 800d9ba:	f241 3088 	movw	r0, #5000	; 0x1388
 800d9be:	4b6e      	ldr	r3, [pc, #440]	; (800db78 <ModemInit+0x20c>)
 800d9c0:	4798      	blx	r3
			MODEM_ENABLE
 800d9c2:	2101      	movs	r1, #1
 800d9c4:	486a      	ldr	r0, [pc, #424]	; (800db70 <ModemInit+0x204>)
 800d9c6:	4b6b      	ldr	r3, [pc, #428]	; (800db74 <ModemInit+0x208>)
 800d9c8:	4798      	blx	r3
			;
			vTaskDelay(10000);
 800d9ca:	f242 7010 	movw	r0, #10000	; 0x2710
 800d9ce:	4b6a      	ldr	r3, [pc, #424]	; (800db78 <ModemInit+0x20c>)
 800d9d0:	4798      	blx	r3
 800d9d2:	e017      	b.n	800da04 <ModemInit+0x98>
		} else {
			MODEM_ENABLE
 800d9d4:	2101      	movs	r1, #1
 800d9d6:	4866      	ldr	r0, [pc, #408]	; (800db70 <ModemInit+0x204>)
 800d9d8:	4b66      	ldr	r3, [pc, #408]	; (800db74 <ModemInit+0x208>)
 800d9da:	4798      	blx	r3
			;
			vTaskDelay(3000);
 800d9dc:	f640 30b8 	movw	r0, #3000	; 0xbb8
 800d9e0:	4b65      	ldr	r3, [pc, #404]	; (800db78 <ModemInit+0x20c>)
 800d9e2:	4798      	blx	r3
			MODEM_DISABLE
 800d9e4:	2101      	movs	r1, #1
 800d9e6:	4862      	ldr	r0, [pc, #392]	; (800db70 <ModemInit+0x204>)
 800d9e8:	4b64      	ldr	r3, [pc, #400]	; (800db7c <ModemInit+0x210>)
 800d9ea:	4798      	blx	r3
			;
			vTaskDelay(2500);
 800d9ec:	f640 10c4 	movw	r0, #2500	; 0x9c4
 800d9f0:	4b61      	ldr	r3, [pc, #388]	; (800db78 <ModemInit+0x20c>)
 800d9f2:	4798      	blx	r3
			MODEM_ENABLE
 800d9f4:	2101      	movs	r1, #1
 800d9f6:	485e      	ldr	r0, [pc, #376]	; (800db70 <ModemInit+0x204>)
 800d9f8:	4b5e      	ldr	r3, [pc, #376]	; (800db74 <ModemInit+0x208>)
 800d9fa:	4798      	blx	r3
			;
			vTaskDelay(5000);
 800d9fc:	f241 3088 	movw	r0, #5000	; 0x1388
 800da00:	4b5d      	ldr	r3, [pc, #372]	; (800db78 <ModemInit+0x20c>)
 800da02:	4798      	blx	r3
		}

		//LedNoModem = 1;

		if (!WaitAtd()) {
 800da04:	4b5e      	ldr	r3, [pc, #376]	; (800db80 <ModemInit+0x214>)
 800da06:	4798      	blx	r3
 800da08:	4603      	mov	r3, r0
 800da0a:	f083 0301 	eor.w	r3, r3, #1
 800da0e:	b2db      	uxtb	r3, r3
 800da10:	2b00      	cmp	r3, #0
 800da12:	d008      	beq.n	800da26 <ModemInit+0xba>
			if (!WaitAtd1())
 800da14:	4b5b      	ldr	r3, [pc, #364]	; (800db84 <ModemInit+0x218>)
 800da16:	4798      	blx	r3
 800da18:	4603      	mov	r3, r0
 800da1a:	f083 0301 	eor.w	r3, r3, #1
 800da1e:	b2db      	uxtb	r3, r3
 800da20:	2b00      	cmp	r3, #0
 800da22:	f040 8091 	bne.w	800db48 <ModemInit+0x1dc>
				continue;
		}

		if (!WaitOk())
 800da26:	4b58      	ldr	r3, [pc, #352]	; (800db88 <ModemInit+0x21c>)
 800da28:	4798      	blx	r3
 800da2a:	4603      	mov	r3, r0
 800da2c:	f083 0301 	eor.w	r3, r3, #1
 800da30:	b2db      	uxtb	r3, r3
 800da32:	2b00      	cmp	r3, #0
 800da34:	f040 808a 	bne.w	800db4c <ModemInit+0x1e0>
			continue;
		vTaskDelay(100);
 800da38:	2064      	movs	r0, #100	; 0x64
 800da3a:	4b4f      	ldr	r3, [pc, #316]	; (800db78 <ModemInit+0x20c>)
 800da3c:	4798      	blx	r3

		LedNoModem = 0;
 800da3e:	4b4a      	ldr	r3, [pc, #296]	; (800db68 <ModemInit+0x1fc>)
 800da40:	2200      	movs	r2, #0
 800da42:	701a      	strb	r2, [r3, #0]

		int i_CPIN = 50;
 800da44:	2332      	movs	r3, #50	; 0x32
 800da46:	60fb      	str	r3, [r7, #12]

		vTaskDelay(100);
 800da48:	2064      	movs	r0, #100	; 0x64
 800da4a:	4b4b      	ldr	r3, [pc, #300]	; (800db78 <ModemInit+0x20c>)
 800da4c:	4798      	blx	r3
		BKP_WriteBackupRegister(BKP_DR7, 32);
 800da4e:	2120      	movs	r1, #32
 800da50:	201c      	movs	r0, #28
 800da52:	4b43      	ldr	r3, [pc, #268]	; (800db60 <ModemInit+0x1f4>)
 800da54:	4798      	blx	r3

		while (!ATCPIN()) //  -
 800da56:	e015      	b.n	800da84 <ModemInit+0x118>
		{
			if (i_CPIN == 0) {
 800da58:	68fb      	ldr	r3, [r7, #12]
 800da5a:	2b00      	cmp	r3, #0
 800da5c:	d10f      	bne.n	800da7e <ModemInit+0x112>
				if (!LedSIM_Journal) {
 800da5e:	4b4b      	ldr	r3, [pc, #300]	; (800db8c <ModemInit+0x220>)
 800da60:	781b      	ldrb	r3, [r3, #0]
 800da62:	f083 0301 	eor.w	r3, r3, #1
 800da66:	b2db      	uxtb	r3, r3
 800da68:	2b00      	cmp	r3, #0
 800da6a:	d005      	beq.n	800da78 <ModemInit+0x10c>
					JrnlWrite("GSM: -");
 800da6c:	4848      	ldr	r0, [pc, #288]	; (800db90 <ModemInit+0x224>)
 800da6e:	4b49      	ldr	r3, [pc, #292]	; (800db94 <ModemInit+0x228>)
 800da70:	4798      	blx	r3
					LedSIM_Journal = 1;
 800da72:	4b46      	ldr	r3, [pc, #280]	; (800db8c <ModemInit+0x220>)
 800da74:	2201      	movs	r2, #1
 800da76:	701a      	strb	r2, [r3, #0]
				}
				LedSIM = 1;
 800da78:	4b47      	ldr	r3, [pc, #284]	; (800db98 <ModemInit+0x22c>)
 800da7a:	2201      	movs	r2, #1
 800da7c:	701a      	strb	r2, [r3, #0]
				// break;
			}
			i_CPIN--;
 800da7e:	68fb      	ldr	r3, [r7, #12]
 800da80:	3b01      	subs	r3, #1
 800da82:	60fb      	str	r3, [r7, #12]
		while (!ATCPIN()) //  -
 800da84:	4b45      	ldr	r3, [pc, #276]	; (800db9c <ModemInit+0x230>)
 800da86:	4798      	blx	r3
 800da88:	4603      	mov	r3, r0
 800da8a:	f083 0301 	eor.w	r3, r3, #1
 800da8e:	b2db      	uxtb	r3, r3
 800da90:	2b00      	cmp	r3, #0
 800da92:	d1e1      	bne.n	800da58 <ModemInit+0xec>
		}
		if (!LedSIM) {
 800da94:	4b40      	ldr	r3, [pc, #256]	; (800db98 <ModemInit+0x22c>)
 800da96:	781b      	ldrb	r3, [r3, #0]
 800da98:	f083 0301 	eor.w	r3, r3, #1
 800da9c:	b2db      	uxtb	r3, r3
 800da9e:	2b00      	cmp	r3, #0
 800daa0:	d04d      	beq.n	800db3e <ModemInit+0x1d2>
			i_CPIN = 0;
 800daa2:	2300      	movs	r3, #0
 800daa4:	60fb      	str	r3, [r7, #12]

			LedReg = 1;
 800daa6:	4b3e      	ldr	r3, [pc, #248]	; (800dba0 <ModemInit+0x234>)
 800daa8:	2201      	movs	r2, #1
 800daaa:	701a      	strb	r2, [r3, #0]
			vTaskDelay(50);
 800daac:	2032      	movs	r0, #50	; 0x32
 800daae:	4b32      	ldr	r3, [pc, #200]	; (800db78 <ModemInit+0x20c>)
 800dab0:	4798      	blx	r3

			while (!CSQ())
 800dab2:	e000      	b.n	800dab6 <ModemInit+0x14a>
				continue; //  
 800dab4:	bf00      	nop
			while (!CSQ())
 800dab6:	4b3b      	ldr	r3, [pc, #236]	; (800dba4 <ModemInit+0x238>)
 800dab8:	4798      	blx	r3
 800daba:	4603      	mov	r3, r0
 800dabc:	f083 0301 	eor.w	r3, r3, #1
 800dac0:	b2db      	uxtb	r3, r3
 800dac2:	2b00      	cmp	r3, #0
 800dac4:	d1f6      	bne.n	800dab4 <ModemInit+0x148>

			vTaskDelay(50);
 800dac6:	2032      	movs	r0, #50	; 0x32
 800dac8:	4b2b      	ldr	r3, [pc, #172]	; (800db78 <ModemInit+0x20c>)
 800daca:	4798      	blx	r3
			BKP_WriteBackupRegister(BKP_DR7, 33);
 800dacc:	2121      	movs	r1, #33	; 0x21
 800dace:	201c      	movs	r0, #28
 800dad0:	4b23      	ldr	r3, [pc, #140]	; (800db60 <ModemInit+0x1f4>)
 800dad2:	4798      	blx	r3

			int i_CREG = 60;
 800dad4:	233c      	movs	r3, #60	; 0x3c
 800dad6:	60bb      	str	r3, [r7, #8]

			while (!ATCREG()) //    
 800dad8:	e005      	b.n	800dae6 <ModemInit+0x17a>
			{
				if (i_CREG == 0) {
 800dada:	68bb      	ldr	r3, [r7, #8]
 800dadc:	2b00      	cmp	r3, #0
 800dade:	d00b      	beq.n	800daf8 <ModemInit+0x18c>
					break;
				}
				i_CREG--;
 800dae0:	68bb      	ldr	r3, [r7, #8]
 800dae2:	3b01      	subs	r3, #1
 800dae4:	60bb      	str	r3, [r7, #8]
			while (!ATCREG()) //    
 800dae6:	4b30      	ldr	r3, [pc, #192]	; (800dba8 <ModemInit+0x23c>)
 800dae8:	4798      	blx	r3
 800daea:	4603      	mov	r3, r0
 800daec:	f083 0301 	eor.w	r3, r3, #1
 800daf0:	b2db      	uxtb	r3, r3
 800daf2:	2b00      	cmp	r3, #0
 800daf4:	d1f1      	bne.n	800dada <ModemInit+0x16e>
 800daf6:	e000      	b.n	800dafa <ModemInit+0x18e>
					break;
 800daf8:	bf00      	nop
			}

			i_CREG = 0;
 800dafa:	2300      	movs	r3, #0
 800dafc:	60bb      	str	r3, [r7, #8]

			vTaskDelay(50);
 800dafe:	2032      	movs	r0, #50	; 0x32
 800db00:	4b1d      	ldr	r3, [pc, #116]	; (800db78 <ModemInit+0x20c>)
 800db02:	4798      	blx	r3

			i_Select = 100;
 800db04:	4b29      	ldr	r3, [pc, #164]	; (800dbac <ModemInit+0x240>)
 800db06:	2264      	movs	r2, #100	; 0x64
 800db08:	601a      	str	r2, [r3, #0]

			while (!SelectModem()) {
 800db0a:	e008      	b.n	800db1e <ModemInit+0x1b2>

				if (i_Select == 0) {
 800db0c:	4b27      	ldr	r3, [pc, #156]	; (800dbac <ModemInit+0x240>)
 800db0e:	681b      	ldr	r3, [r3, #0]
 800db10:	2b00      	cmp	r3, #0
 800db12:	d00d      	beq.n	800db30 <ModemInit+0x1c4>
					break;
				}
				i_Select--;
 800db14:	4b25      	ldr	r3, [pc, #148]	; (800dbac <ModemInit+0x240>)
 800db16:	681b      	ldr	r3, [r3, #0]
 800db18:	3b01      	subs	r3, #1
 800db1a:	4a24      	ldr	r2, [pc, #144]	; (800dbac <ModemInit+0x240>)
 800db1c:	6013      	str	r3, [r2, #0]
			while (!SelectModem()) {
 800db1e:	4b24      	ldr	r3, [pc, #144]	; (800dbb0 <ModemInit+0x244>)
 800db20:	4798      	blx	r3
 800db22:	4603      	mov	r3, r0
 800db24:	f083 0301 	eor.w	r3, r3, #1
 800db28:	b2db      	uxtb	r3, r3
 800db2a:	2b00      	cmp	r3, #0
 800db2c:	d1ee      	bne.n	800db0c <ModemInit+0x1a0>
 800db2e:	e000      	b.n	800db32 <ModemInit+0x1c6>
					break;
 800db30:	bf00      	nop
			}
			i_Select = 0;
 800db32:	4b1e      	ldr	r3, [pc, #120]	; (800dbac <ModemInit+0x240>)
 800db34:	2200      	movs	r2, #0
 800db36:	601a      	str	r2, [r3, #0]

			vTaskDelay(50);
 800db38:	2032      	movs	r0, #50	; 0x32
 800db3a:	4b0f      	ldr	r3, [pc, #60]	; (800db78 <ModemInit+0x20c>)
 800db3c:	4798      	blx	r3
		}

		BKP_WriteBackupRegister(BKP_DR7, 34);
 800db3e:	2122      	movs	r1, #34	; 0x22
 800db40:	201c      	movs	r0, #28
 800db42:	4b07      	ldr	r3, [pc, #28]	; (800db60 <ModemInit+0x1f4>)
 800db44:	4798      	blx	r3
		return;
 800db46:	e003      	b.n	800db50 <ModemInit+0x1e4>
				continue;
 800db48:	bf00      	nop
 800db4a:	e71d      	b.n	800d988 <ModemInit+0x1c>
			continue;
 800db4c:	bf00      	nop
	while (1) {
 800db4e:	e71b      	b.n	800d988 <ModemInit+0x1c>
	}
}
 800db50:	3710      	adds	r7, #16
 800db52:	46bd      	mov	sp, r7
 800db54:	bd80      	pop	{r7, pc}
 800db56:	bf00      	nop
 800db58:	080046a9 	.word	0x080046a9
 800db5c:	0800bc95 	.word	0x0800bc95
 800db60:	08003621 	.word	0x08003621
 800db64:	080028b5 	.word	0x080028b5
 800db68:	200072b8 	.word	0x200072b8
 800db6c:	20007194 	.word	0x20007194
 800db70:	40010c00 	.word	0x40010c00
 800db74:	08002f89 	.word	0x08002f89
 800db78:	08001529 	.word	0x08001529
 800db7c:	08002f6d 	.word	0x08002f6d
 800db80:	0800c09d 	.word	0x0800c09d
 800db84:	0800c0cd 	.word	0x0800c0cd
 800db88:	0800c06d 	.word	0x0800c06d
 800db8c:	200092f9 	.word	0x200092f9
 800db90:	0801543c 	.word	0x0801543c
 800db94:	0800edb5 	.word	0x0800edb5
 800db98:	200072b9 	.word	0x200072b9
 800db9c:	0800c421 	.word	0x0800c421
 800dba0:	200072b4 	.word	0x200072b4
 800dba4:	0800c0fd 	.word	0x0800c0fd
 800dba8:	0800c551 	.word	0x0800c551
 800dbac:	200092f4 	.word	0x200092f4
 800dbb0:	0800d739 	.word	0x0800d739

0800dbb4 <ModemReceiveData>:
//=========================================================================
int ModemReceiveData(uint8 *buf, int maxsize) {
 800dbb4:	b580      	push	{r7, lr}
 800dbb6:	b0ea      	sub	sp, #424	; 0x1a8
 800dbb8:	af00      	add	r7, sp, #0
 800dbba:	f507 73d4 	add.w	r3, r7, #424	; 0x1a8
 800dbbe:	f5a3 73d2 	sub.w	r3, r3, #420	; 0x1a4
 800dbc2:	6018      	str	r0, [r3, #0]
 800dbc4:	f507 73d4 	add.w	r3, r7, #424	; 0x1a8
 800dbc8:	f5a3 73d4 	sub.w	r3, r3, #424	; 0x1a8
 800dbcc:	6019      	str	r1, [r3, #0]

	int packSize;
	int headerSize;
	int i;
	int res = 0;
 800dbce:	2300      	movs	r3, #0
 800dbd0:	f8c7 319c 	str.w	r3, [r7, #412]	; 0x19c

	BKP_WriteBackupRegister(BKP_DR7, 35);
 800dbd4:	2123      	movs	r1, #35	; 0x23
 800dbd6:	201c      	movs	r0, #28
 800dbd8:	4bb4      	ldr	r3, [pc, #720]	; (800deac <ModemReceiveData+0x2f8>)
 800dbda:	4798      	blx	r3
	if (DeviceID == 4) {
		//ModemWrite("+TCPRECV: 1,12\r\n");
	}
	FillBuf();
 800dbdc:	4bb4      	ldr	r3, [pc, #720]	; (800deb0 <ModemReceiveData+0x2fc>)
 800dbde:	4798      	blx	r3
	if (bufsize == 0)
 800dbe0:	4bb4      	ldr	r3, [pc, #720]	; (800deb4 <ModemReceiveData+0x300>)
 800dbe2:	881b      	ldrh	r3, [r3, #0]
 800dbe4:	b29b      	uxth	r3, r3
 800dbe6:	2b00      	cmp	r3, #0
 800dbe8:	d102      	bne.n	800dbf0 <ModemReceiveData+0x3c>
		return 0;
 800dbea:	2300      	movs	r3, #0
 800dbec:	f000 bce8 	b.w	800e5c0 <ModemReceiveData+0xa0c>

	int k = 0;
 800dbf0:	2300      	movs	r3, #0
 800dbf2:	f8c7 3198 	str.w	r3, [r7, #408]	; 0x198
	//-------------UC15-----------------------
	//-------------UC20-----------------------
	if ((DeviceID == 1) || (DeviceID == 3)) {
 800dbf6:	4bb0      	ldr	r3, [pc, #704]	; (800deb8 <ModemReceiveData+0x304>)
 800dbf8:	681b      	ldr	r3, [r3, #0]
 800dbfa:	2b01      	cmp	r3, #1
 800dbfc:	d004      	beq.n	800dc08 <ModemReceiveData+0x54>
 800dbfe:	4bae      	ldr	r3, [pc, #696]	; (800deb8 <ModemReceiveData+0x304>)
 800dc00:	681b      	ldr	r3, [r3, #0]
 800dc02:	2b03      	cmp	r3, #3
 800dc04:	f040 81c8 	bne.w	800df98 <ModemReceiveData+0x3e4>

		if ((bufsize > 0)) {
 800dc08:	4baa      	ldr	r3, [pc, #680]	; (800deb4 <ModemReceiveData+0x300>)
 800dc0a:	881b      	ldrh	r3, [r3, #0]
 800dc0c:	b29b      	uxth	r3, r3
 800dc0e:	2b00      	cmp	r3, #0
 800dc10:	f000 8146 	beq.w	800dea0 <ModemReceiveData+0x2ec>
			for (i = 0; i < bufsize; i++) {
 800dc14:	2300      	movs	r3, #0
 800dc16:	f8c7 31a4 	str.w	r3, [r7, #420]	; 0x1a4
 800dc1a:	e0d7      	b.n	800ddcc <ModemReceiveData+0x218>
				if ((sio_buf[i] == '+') && (sio_buf[i + 1] == 'Q')
 800dc1c:	4aa7      	ldr	r2, [pc, #668]	; (800debc <ModemReceiveData+0x308>)
 800dc1e:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800dc22:	4413      	add	r3, r2
 800dc24:	781b      	ldrb	r3, [r3, #0]
 800dc26:	2b2b      	cmp	r3, #43	; 0x2b
 800dc28:	f040 80cb 	bne.w	800ddc2 <ModemReceiveData+0x20e>
 800dc2c:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800dc30:	3301      	adds	r3, #1
 800dc32:	4aa2      	ldr	r2, [pc, #648]	; (800debc <ModemReceiveData+0x308>)
 800dc34:	5cd3      	ldrb	r3, [r2, r3]
 800dc36:	2b51      	cmp	r3, #81	; 0x51
 800dc38:	f040 80c3 	bne.w	800ddc2 <ModemReceiveData+0x20e>
						&& (sio_buf[i + 2] == 'I') && (sio_buf[i + 3] == 'U')
 800dc3c:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800dc40:	3302      	adds	r3, #2
 800dc42:	4a9e      	ldr	r2, [pc, #632]	; (800debc <ModemReceiveData+0x308>)
 800dc44:	5cd3      	ldrb	r3, [r2, r3]
 800dc46:	2b49      	cmp	r3, #73	; 0x49
 800dc48:	f040 80bb 	bne.w	800ddc2 <ModemReceiveData+0x20e>
 800dc4c:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800dc50:	3303      	adds	r3, #3
 800dc52:	4a9a      	ldr	r2, [pc, #616]	; (800debc <ModemReceiveData+0x308>)
 800dc54:	5cd3      	ldrb	r3, [r2, r3]
 800dc56:	2b55      	cmp	r3, #85	; 0x55
 800dc58:	f040 80b3 	bne.w	800ddc2 <ModemReceiveData+0x20e>
						&& (sio_buf[i + 4] == 'R') && (sio_buf[i + 5] == 'C')
 800dc5c:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800dc60:	3304      	adds	r3, #4
 800dc62:	4a96      	ldr	r2, [pc, #600]	; (800debc <ModemReceiveData+0x308>)
 800dc64:	5cd3      	ldrb	r3, [r2, r3]
 800dc66:	2b52      	cmp	r3, #82	; 0x52
 800dc68:	f040 80ab 	bne.w	800ddc2 <ModemReceiveData+0x20e>
 800dc6c:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800dc70:	3305      	adds	r3, #5
 800dc72:	4a92      	ldr	r2, [pc, #584]	; (800debc <ModemReceiveData+0x308>)
 800dc74:	5cd3      	ldrb	r3, [r2, r3]
 800dc76:	2b43      	cmp	r3, #67	; 0x43
 800dc78:	f040 80a3 	bne.w	800ddc2 <ModemReceiveData+0x20e>
						&& (sio_buf[i + 6] == ':') && (sio_buf[i + 7] == ' ')
 800dc7c:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800dc80:	3306      	adds	r3, #6
 800dc82:	4a8e      	ldr	r2, [pc, #568]	; (800debc <ModemReceiveData+0x308>)
 800dc84:	5cd3      	ldrb	r3, [r2, r3]
 800dc86:	2b3a      	cmp	r3, #58	; 0x3a
 800dc88:	f040 809b 	bne.w	800ddc2 <ModemReceiveData+0x20e>
 800dc8c:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800dc90:	3307      	adds	r3, #7
 800dc92:	4a8a      	ldr	r2, [pc, #552]	; (800debc <ModemReceiveData+0x308>)
 800dc94:	5cd3      	ldrb	r3, [r2, r3]
 800dc96:	2b20      	cmp	r3, #32
 800dc98:	f040 8093 	bne.w	800ddc2 <ModemReceiveData+0x20e>
						&& (sio_buf[i + 8] == '"') && (sio_buf[i + 9] == 'r')
 800dc9c:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800dca0:	3308      	adds	r3, #8
 800dca2:	4a86      	ldr	r2, [pc, #536]	; (800debc <ModemReceiveData+0x308>)
 800dca4:	5cd3      	ldrb	r3, [r2, r3]
 800dca6:	2b22      	cmp	r3, #34	; 0x22
 800dca8:	f040 808b 	bne.w	800ddc2 <ModemReceiveData+0x20e>
 800dcac:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800dcb0:	3309      	adds	r3, #9
 800dcb2:	4a82      	ldr	r2, [pc, #520]	; (800debc <ModemReceiveData+0x308>)
 800dcb4:	5cd3      	ldrb	r3, [r2, r3]
 800dcb6:	2b72      	cmp	r3, #114	; 0x72
 800dcb8:	f040 8083 	bne.w	800ddc2 <ModemReceiveData+0x20e>
						&& (sio_buf[i + 10] == 'e') && (sio_buf[i + 11] == 'c')
 800dcbc:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800dcc0:	330a      	adds	r3, #10
 800dcc2:	4a7e      	ldr	r2, [pc, #504]	; (800debc <ModemReceiveData+0x308>)
 800dcc4:	5cd3      	ldrb	r3, [r2, r3]
 800dcc6:	2b65      	cmp	r3, #101	; 0x65
 800dcc8:	d17b      	bne.n	800ddc2 <ModemReceiveData+0x20e>
 800dcca:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800dcce:	330b      	adds	r3, #11
 800dcd0:	4a7a      	ldr	r2, [pc, #488]	; (800debc <ModemReceiveData+0x308>)
 800dcd2:	5cd3      	ldrb	r3, [r2, r3]
 800dcd4:	2b63      	cmp	r3, #99	; 0x63
 800dcd6:	d174      	bne.n	800ddc2 <ModemReceiveData+0x20e>
						&& (sio_buf[i + 12] == 'v')
 800dcd8:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800dcdc:	330c      	adds	r3, #12
 800dcde:	4a77      	ldr	r2, [pc, #476]	; (800debc <ModemReceiveData+0x308>)
 800dce0:	5cd3      	ldrb	r3, [r2, r3]
 800dce2:	2b76      	cmp	r3, #118	; 0x76
 800dce4:	d16d      	bne.n	800ddc2 <ModemReceiveData+0x20e>
						&& (sio_buf[i + 13] == '"')) {
 800dce6:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800dcea:	330d      	adds	r3, #13
 800dcec:	4a73      	ldr	r2, [pc, #460]	; (800debc <ModemReceiveData+0x308>)
 800dcee:	5cd3      	ldrb	r3, [r2, r3]
 800dcf0:	2b22      	cmp	r3, #34	; 0x22
 800dcf2:	d166      	bne.n	800ddc2 <ModemReceiveData+0x20e>
					numRD = 0; //ID 
 800dcf4:	4b72      	ldr	r3, [pc, #456]	; (800dec0 <ModemReceiveData+0x30c>)
 800dcf6:	2200      	movs	r2, #0
 800dcf8:	601a      	str	r2, [r3, #0]

					while (sio_buf[i + 15] != '\r') {
 800dcfa:	e014      	b.n	800dd26 <ModemReceiveData+0x172>
						numRD = numRD * 10 + sio_buf[i + 15] - '0';
 800dcfc:	4b70      	ldr	r3, [pc, #448]	; (800dec0 <ModemReceiveData+0x30c>)
 800dcfe:	681a      	ldr	r2, [r3, #0]
 800dd00:	4613      	mov	r3, r2
 800dd02:	009b      	lsls	r3, r3, #2
 800dd04:	4413      	add	r3, r2
 800dd06:	005b      	lsls	r3, r3, #1
 800dd08:	4619      	mov	r1, r3
 800dd0a:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800dd0e:	330f      	adds	r3, #15
 800dd10:	4a6a      	ldr	r2, [pc, #424]	; (800debc <ModemReceiveData+0x308>)
 800dd12:	5cd3      	ldrb	r3, [r2, r3]
 800dd14:	440b      	add	r3, r1
 800dd16:	3b30      	subs	r3, #48	; 0x30
 800dd18:	4a69      	ldr	r2, [pc, #420]	; (800dec0 <ModemReceiveData+0x30c>)
 800dd1a:	6013      	str	r3, [r2, #0]
						i++;
 800dd1c:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800dd20:	3301      	adds	r3, #1
 800dd22:	f8c7 31a4 	str.w	r3, [r7, #420]	; 0x1a4
					while (sio_buf[i + 15] != '\r') {
 800dd26:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800dd2a:	330f      	adds	r3, #15
 800dd2c:	4a63      	ldr	r2, [pc, #396]	; (800debc <ModemReceiveData+0x308>)
 800dd2e:	5cd3      	ldrb	r3, [r2, r3]
 800dd30:	2b0d      	cmp	r3, #13
 800dd32:	d1e3      	bne.n	800dcfc <ModemReceiveData+0x148>
					}

					char buffer[256];
					char minbuf[32];
					for (int k = 0; k <= 32; k++) {
 800dd34:	2300      	movs	r3, #0
 800dd36:	f8c7 3194 	str.w	r3, [r7, #404]	; 0x194
 800dd3a:	e00d      	b.n	800dd58 <ModemReceiveData+0x1a4>
						minbuf[k] = '0';
 800dd3c:	f507 73d4 	add.w	r3, r7, #424	; 0x1a8
 800dd40:	f5a3 72ce 	sub.w	r2, r3, #412	; 0x19c
 800dd44:	f8d7 3194 	ldr.w	r3, [r7, #404]	; 0x194
 800dd48:	4413      	add	r3, r2
 800dd4a:	2230      	movs	r2, #48	; 0x30
 800dd4c:	701a      	strb	r2, [r3, #0]
					for (int k = 0; k <= 32; k++) {
 800dd4e:	f8d7 3194 	ldr.w	r3, [r7, #404]	; 0x194
 800dd52:	3301      	adds	r3, #1
 800dd54:	f8c7 3194 	str.w	r3, [r7, #404]	; 0x194
 800dd58:	f8d7 3194 	ldr.w	r3, [r7, #404]	; 0x194
 800dd5c:	2b20      	cmp	r3, #32
 800dd5e:	dded      	ble.n	800dd3c <ModemReceiveData+0x188>
					}

					itoa1(numRD, minbuf);
 800dd60:	4b57      	ldr	r3, [pc, #348]	; (800dec0 <ModemReceiveData+0x30c>)
 800dd62:	681b      	ldr	r3, [r3, #0]
 800dd64:	f107 020c 	add.w	r2, r7, #12
 800dd68:	4611      	mov	r1, r2
 800dd6a:	4618      	mov	r0, r3
 800dd6c:	4b55      	ldr	r3, [pc, #340]	; (800dec4 <ModemReceiveData+0x310>)
 800dd6e:	4798      	blx	r3
					strcpy(buffer, "AT+QIRD="); //    
 800dd70:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800dd74:	4a54      	ldr	r2, [pc, #336]	; (800dec8 <ModemReceiveData+0x314>)
 800dd76:	ca07      	ldmia	r2, {r0, r1, r2}
 800dd78:	c303      	stmia	r3!, {r0, r1}
 800dd7a:	701a      	strb	r2, [r3, #0]
					strcat(buffer, minbuf);
 800dd7c:	f107 020c 	add.w	r2, r7, #12
 800dd80:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800dd84:	4611      	mov	r1, r2
 800dd86:	4618      	mov	r0, r3
 800dd88:	4b50      	ldr	r3, [pc, #320]	; (800decc <ModemReceiveData+0x318>)
 800dd8a:	4798      	blx	r3
					strcat(buffer, "\r\n");
 800dd8c:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800dd90:	4618      	mov	r0, r3
 800dd92:	4b4f      	ldr	r3, [pc, #316]	; (800ded0 <ModemReceiveData+0x31c>)
 800dd94:	4798      	blx	r3
 800dd96:	4603      	mov	r3, r0
 800dd98:	461a      	mov	r2, r3
 800dd9a:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800dd9e:	4413      	add	r3, r2
 800dda0:	4a4c      	ldr	r2, [pc, #304]	; (800ded4 <ModemReceiveData+0x320>)
 800dda2:	8811      	ldrh	r1, [r2, #0]
 800dda4:	7892      	ldrb	r2, [r2, #2]
 800dda6:	8019      	strh	r1, [r3, #0]
 800dda8:	709a      	strb	r2, [r3, #2]
					ModemWrite(buffer);
 800ddaa:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800ddae:	4618      	mov	r0, r3
 800ddb0:	4b49      	ldr	r3, [pc, #292]	; (800ded8 <ModemReceiveData+0x324>)
 800ddb2:	4798      	blx	r3
					vTaskDelay(10);
 800ddb4:	200a      	movs	r0, #10
 800ddb6:	4b49      	ldr	r3, [pc, #292]	; (800dedc <ModemReceiveData+0x328>)
 800ddb8:	4798      	blx	r3
					k = 0;
 800ddba:	2300      	movs	r3, #0
 800ddbc:	f8c7 3198 	str.w	r3, [r7, #408]	; 0x198
					break;
 800ddc0:	e00d      	b.n	800ddde <ModemReceiveData+0x22a>
			for (i = 0; i < bufsize; i++) {
 800ddc2:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800ddc6:	3301      	adds	r3, #1
 800ddc8:	f8c7 31a4 	str.w	r3, [r7, #420]	; 0x1a4
 800ddcc:	4b39      	ldr	r3, [pc, #228]	; (800deb4 <ModemReceiveData+0x300>)
 800ddce:	881b      	ldrh	r3, [r3, #0]
 800ddd0:	b29b      	uxth	r3, r3
 800ddd2:	461a      	mov	r2, r3
 800ddd4:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800ddd8:	4293      	cmp	r3, r2
 800ddda:	f6ff af1f 	blt.w	800dc1c <ModemReceiveData+0x68>
				}
			}
			for (i = 0; i < bufsize; i++) { //   (  IPD) +QRD:<len>\r<data>
 800ddde:	2300      	movs	r3, #0
 800dde0:	f8c7 31a4 	str.w	r3, [r7, #420]	; 0x1a4
 800dde4:	e054      	b.n	800de90 <ModemReceiveData+0x2dc>
				if ((sio_buf[i] == '+') && (sio_buf[i + 1] == 'Q')
 800dde6:	4a35      	ldr	r2, [pc, #212]	; (800debc <ModemReceiveData+0x308>)
 800dde8:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800ddec:	4413      	add	r3, r2
 800ddee:	781b      	ldrb	r3, [r3, #0]
 800ddf0:	2b2b      	cmp	r3, #43	; 0x2b
 800ddf2:	d148      	bne.n	800de86 <ModemReceiveData+0x2d2>
 800ddf4:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800ddf8:	3301      	adds	r3, #1
 800ddfa:	4a30      	ldr	r2, [pc, #192]	; (800debc <ModemReceiveData+0x308>)
 800ddfc:	5cd3      	ldrb	r3, [r2, r3]
 800ddfe:	2b51      	cmp	r3, #81	; 0x51
 800de00:	d141      	bne.n	800de86 <ModemReceiveData+0x2d2>
						&& (sio_buf[i + 2] == 'I') && (sio_buf[i + 3] == 'R')
 800de02:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800de06:	3302      	adds	r3, #2
 800de08:	4a2c      	ldr	r2, [pc, #176]	; (800debc <ModemReceiveData+0x308>)
 800de0a:	5cd3      	ldrb	r3, [r2, r3]
 800de0c:	2b49      	cmp	r3, #73	; 0x49
 800de0e:	d13a      	bne.n	800de86 <ModemReceiveData+0x2d2>
 800de10:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800de14:	3303      	adds	r3, #3
 800de16:	4a29      	ldr	r2, [pc, #164]	; (800debc <ModemReceiveData+0x308>)
 800de18:	5cd3      	ldrb	r3, [r2, r3]
 800de1a:	2b52      	cmp	r3, #82	; 0x52
 800de1c:	d133      	bne.n	800de86 <ModemReceiveData+0x2d2>
						&& (sio_buf[i + 4] == 'D') && (sio_buf[i + 5] == ':')) {
 800de1e:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800de22:	3304      	adds	r3, #4
 800de24:	4a25      	ldr	r2, [pc, #148]	; (800debc <ModemReceiveData+0x308>)
 800de26:	5cd3      	ldrb	r3, [r2, r3]
 800de28:	2b44      	cmp	r3, #68	; 0x44
 800de2a:	d12c      	bne.n	800de86 <ModemReceiveData+0x2d2>
 800de2c:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800de30:	3305      	adds	r3, #5
 800de32:	4a22      	ldr	r2, [pc, #136]	; (800debc <ModemReceiveData+0x308>)
 800de34:	5cd3      	ldrb	r3, [r2, r3]
 800de36:	2b3a      	cmp	r3, #58	; 0x3a
 800de38:	d125      	bne.n	800de86 <ModemReceiveData+0x2d2>
					k = 1;
 800de3a:	2301      	movs	r3, #1
 800de3c:	f8c7 3198 	str.w	r3, [r7, #408]	; 0x198
					while (sio_buf[i + 7] != '\r') {
 800de40:	e014      	b.n	800de6c <ModemReceiveData+0x2b8>
						res = res * 10 + sio_buf[i + 7] - '0'; //<len>
 800de42:	f8d7 219c 	ldr.w	r2, [r7, #412]	; 0x19c
 800de46:	4613      	mov	r3, r2
 800de48:	009b      	lsls	r3, r3, #2
 800de4a:	4413      	add	r3, r2
 800de4c:	005b      	lsls	r3, r3, #1
 800de4e:	4619      	mov	r1, r3
 800de50:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800de54:	3307      	adds	r3, #7
 800de56:	4a19      	ldr	r2, [pc, #100]	; (800debc <ModemReceiveData+0x308>)
 800de58:	5cd3      	ldrb	r3, [r2, r3]
 800de5a:	440b      	add	r3, r1
 800de5c:	3b30      	subs	r3, #48	; 0x30
 800de5e:	f8c7 319c 	str.w	r3, [r7, #412]	; 0x19c
						i++;
 800de62:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800de66:	3301      	adds	r3, #1
 800de68:	f8c7 31a4 	str.w	r3, [r7, #420]	; 0x1a4
					while (sio_buf[i + 7] != '\r') {
 800de6c:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800de70:	3307      	adds	r3, #7
 800de72:	4a12      	ldr	r2, [pc, #72]	; (800debc <ModemReceiveData+0x308>)
 800de74:	5cd3      	ldrb	r3, [r2, r3]
 800de76:	2b0d      	cmp	r3, #13
 800de78:	d1e3      	bne.n	800de42 <ModemReceiveData+0x28e>
					}
					headerSize = i + 9;
 800de7a:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800de7e:	3309      	adds	r3, #9
 800de80:	f8c7 31a0 	str.w	r3, [r7, #416]	; 0x1a0

					break;
 800de84:	e00c      	b.n	800dea0 <ModemReceiveData+0x2ec>
			for (i = 0; i < bufsize; i++) { //   (  IPD) +QRD:<len>\r<data>
 800de86:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800de8a:	3301      	adds	r3, #1
 800de8c:	f8c7 31a4 	str.w	r3, [r7, #420]	; 0x1a4
 800de90:	4b08      	ldr	r3, [pc, #32]	; (800deb4 <ModemReceiveData+0x300>)
 800de92:	881b      	ldrh	r3, [r3, #0]
 800de94:	b29b      	uxth	r3, r3
 800de96:	461a      	mov	r2, r3
 800de98:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800de9c:	4293      	cmp	r3, r2
 800de9e:	dba2      	blt.n	800dde6 <ModemReceiveData+0x232>
				}
			}
		}

		if (k == 0)
 800dea0:	f8d7 3198 	ldr.w	r3, [r7, #408]	; 0x198
 800dea4:	2b00      	cmp	r3, #0
 800dea6:	d11b      	bne.n	800dee0 <ModemReceiveData+0x32c>
			return 0;
 800dea8:	2300      	movs	r3, #0
 800deaa:	e389      	b.n	800e5c0 <ModemReceiveData+0xa0c>
 800deac:	08003621 	.word	0x08003621
 800deb0:	0800be15 	.word	0x0800be15
 800deb4:	200092e4 	.word	0x200092e4
 800deb8:	20008468 	.word	0x20008468
 800debc:	200086e0 	.word	0x200086e0
 800dec0:	200092ec 	.word	0x200092ec
 800dec4:	0800e895 	.word	0x0800e895
 800dec8:	08015454 	.word	0x08015454
 800decc:	08014635 	.word	0x08014635
 800ded0:	08014731 	.word	0x08014731
 800ded4:	08015224 	.word	0x08015224
 800ded8:	0800bfed 	.word	0x0800bfed
 800dedc:	08001529 	.word	0x08001529

		BKP_WriteBackupRegister(BKP_DR7, 36);
 800dee0:	2124      	movs	r1, #36	; 0x24
 800dee2:	201c      	movs	r0, #28
 800dee4:	4bb9      	ldr	r3, [pc, #740]	; (800e1cc <ModemReceiveData+0x618>)
 800dee6:	4798      	blx	r3
		char *cmpbuf = "+QIRD";
 800dee8:	4bb9      	ldr	r3, [pc, #740]	; (800e1d0 <ModemReceiveData+0x61c>)
 800deea:	f8c7 314c 	str.w	r3, [r7, #332]	; 0x14c
		char *strbufsize[16];
		int cmpPoint = 0;
 800deee:	2300      	movs	r3, #0
 800def0:	f8c7 3148 	str.w	r3, [r7, #328]	; 0x148
		int strbufsizePoint = 0;
 800def4:	2300      	movs	r3, #0
 800def6:	f8c7 3144 	str.w	r3, [r7, #324]	; 0x144

		packSize = res;
 800defa:	f8d7 319c 	ldr.w	r3, [r7, #412]	; 0x19c
 800defe:	f8c7 3158 	str.w	r3, [r7, #344]	; 0x158

		//headerSize++;
		while (bufsize < (packSize + headerSize)) {
 800df02:	bf00      	nop
 800df04:	4bb3      	ldr	r3, [pc, #716]	; (800e1d4 <ModemReceiveData+0x620>)
 800df06:	881b      	ldrh	r3, [r3, #0]
 800df08:	b29b      	uxth	r3, r3
 800df0a:	4619      	mov	r1, r3
 800df0c:	f8d7 2158 	ldr.w	r2, [r7, #344]	; 0x158
 800df10:	f8d7 31a0 	ldr.w	r3, [r7, #416]	; 0x1a0
 800df14:	4413      	add	r3, r2
 800df16:	4299      	cmp	r1, r3
			if (tmpsize == 0) {
				break;
			}
			bufsize += tmpsize;
		}
		i = 0;
 800df18:	2300      	movs	r3, #0
 800df1a:	f8c7 31a4 	str.w	r3, [r7, #420]	; 0x1a4

		bufsize = res;
 800df1e:	f8d7 319c 	ldr.w	r3, [r7, #412]	; 0x19c
 800df22:	b29a      	uxth	r2, r3
 800df24:	4bab      	ldr	r3, [pc, #684]	; (800e1d4 <ModemReceiveData+0x620>)
 800df26:	801a      	strh	r2, [r3, #0]

		while (bufsize) {
 800df28:	e02e      	b.n	800df88 <ModemReceiveData+0x3d4>
			if (i >= maxsize) {
 800df2a:	f507 73d4 	add.w	r3, r7, #424	; 0x1a8
 800df2e:	f5a3 73d4 	sub.w	r3, r3, #424	; 0x1a8
 800df32:	f8d7 21a4 	ldr.w	r2, [r7, #420]	; 0x1a4
 800df36:	681b      	ldr	r3, [r3, #0]
 800df38:	429a      	cmp	r2, r3
 800df3a:	db01      	blt.n	800df40 <ModemReceiveData+0x38c>
				return 0;
 800df3c:	2300      	movs	r3, #0
 800df3e:	e33f      	b.n	800e5c0 <ModemReceiveData+0xa0c>
			}
			*buf = sio_buf[i + headerSize];
 800df40:	f8d7 21a4 	ldr.w	r2, [r7, #420]	; 0x1a4
 800df44:	f8d7 31a0 	ldr.w	r3, [r7, #416]	; 0x1a0
 800df48:	4413      	add	r3, r2
 800df4a:	4aa3      	ldr	r2, [pc, #652]	; (800e1d8 <ModemReceiveData+0x624>)
 800df4c:	5cd2      	ldrb	r2, [r2, r3]
 800df4e:	f507 73d4 	add.w	r3, r7, #424	; 0x1a8
 800df52:	f5a3 73d2 	sub.w	r3, r3, #420	; 0x1a4
 800df56:	681b      	ldr	r3, [r3, #0]
 800df58:	701a      	strb	r2, [r3, #0]
			buf++;
 800df5a:	f507 73d4 	add.w	r3, r7, #424	; 0x1a8
 800df5e:	f5a3 73d2 	sub.w	r3, r3, #420	; 0x1a4
 800df62:	f507 72d4 	add.w	r2, r7, #424	; 0x1a8
 800df66:	f5a2 72d2 	sub.w	r2, r2, #420	; 0x1a4
 800df6a:	6812      	ldr	r2, [r2, #0]
 800df6c:	3201      	adds	r2, #1
 800df6e:	601a      	str	r2, [r3, #0]
			i++;
 800df70:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800df74:	3301      	adds	r3, #1
 800df76:	f8c7 31a4 	str.w	r3, [r7, #420]	; 0x1a4
			bufsize--;
 800df7a:	4b96      	ldr	r3, [pc, #600]	; (800e1d4 <ModemReceiveData+0x620>)
 800df7c:	881b      	ldrh	r3, [r3, #0]
 800df7e:	b29b      	uxth	r3, r3
 800df80:	3b01      	subs	r3, #1
 800df82:	b29a      	uxth	r2, r3
 800df84:	4b93      	ldr	r3, [pc, #588]	; (800e1d4 <ModemReceiveData+0x620>)
 800df86:	801a      	strh	r2, [r3, #0]
		while (bufsize) {
 800df88:	4b92      	ldr	r3, [pc, #584]	; (800e1d4 <ModemReceiveData+0x620>)
 800df8a:	881b      	ldrh	r3, [r3, #0]
 800df8c:	b29b      	uxth	r3, r3
 800df8e:	2b00      	cmp	r3, #0
 800df90:	d1cb      	bne.n	800df2a <ModemReceiveData+0x376>
		}

		return packSize;
 800df92:	f8d7 3158 	ldr.w	r3, [r7, #344]	; 0x158
 800df96:	e313      	b.n	800e5c0 <ModemReceiveData+0xa0c>
	}
	//-------------N715-----------------------
	else if (DeviceID == 4) {
 800df98:	4b90      	ldr	r3, [pc, #576]	; (800e1dc <ModemReceiveData+0x628>)
 800df9a:	681b      	ldr	r3, [r3, #0]
 800df9c:	2b04      	cmp	r3, #4
 800df9e:	f040 81b6 	bne.w	800e30e <ModemReceiveData+0x75a>
		char header[] = "IPD";
 800dfa2:	4b8f      	ldr	r3, [pc, #572]	; (800e1e0 <ModemReceiveData+0x62c>)
 800dfa4:	f8c7 3140 	str.w	r3, [r7, #320]	; 0x140
		int numIPD = 0;
 800dfa8:	2300      	movs	r3, #0
 800dfaa:	f8c7 3190 	str.w	r3, [r7, #400]	; 0x190
		int k = 1;
 800dfae:	2301      	movs	r3, #1
 800dfb0:	f8c7 318c 	str.w	r3, [r7, #396]	; 0x18c

		for (i = 0; i < 3; i++) {
 800dfb4:	2300      	movs	r3, #0
 800dfb6:	f8c7 31a4 	str.w	r3, [r7, #420]	; 0x1a4
 800dfba:	e083      	b.n	800e0c4 <ModemReceiveData+0x510>
			if (sio_buf[i] != header[i]) {
 800dfbc:	4a86      	ldr	r2, [pc, #536]	; (800e1d8 <ModemReceiveData+0x624>)
 800dfbe:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800dfc2:	4413      	add	r3, r2
 800dfc4:	781a      	ldrb	r2, [r3, #0]
 800dfc6:	f507 71a0 	add.w	r1, r7, #320	; 0x140
 800dfca:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800dfce:	440b      	add	r3, r1
 800dfd0:	781b      	ldrb	r3, [r3, #0]
 800dfd2:	429a      	cmp	r2, r3
 800dfd4:	d071      	beq.n	800e0ba <ModemReceiveData+0x506>
				for (i = 0; i < bufsize; i++) {
 800dfd6:	2300      	movs	r3, #0
 800dfd8:	f8c7 31a4 	str.w	r3, [r7, #420]	; 0x1a4
 800dfdc:	e065      	b.n	800e0aa <ModemReceiveData+0x4f6>
					if ((sio_buf[i] == 'P') && (sio_buf[i + 1] == 'R')
 800dfde:	4a7e      	ldr	r2, [pc, #504]	; (800e1d8 <ModemReceiveData+0x624>)
 800dfe0:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800dfe4:	4413      	add	r3, r2
 800dfe6:	781b      	ldrb	r3, [r3, #0]
 800dfe8:	2b50      	cmp	r3, #80	; 0x50
 800dfea:	d156      	bne.n	800e09a <ModemReceiveData+0x4e6>
 800dfec:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800dff0:	3301      	adds	r3, #1
 800dff2:	4a79      	ldr	r2, [pc, #484]	; (800e1d8 <ModemReceiveData+0x624>)
 800dff4:	5cd3      	ldrb	r3, [r2, r3]
 800dff6:	2b52      	cmp	r3, #82	; 0x52
 800dff8:	d14f      	bne.n	800e09a <ModemReceiveData+0x4e6>
							&& (sio_buf[i + 2] == 'E')
 800dffa:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800dffe:	3302      	adds	r3, #2
 800e000:	4a75      	ldr	r2, [pc, #468]	; (800e1d8 <ModemReceiveData+0x624>)
 800e002:	5cd3      	ldrb	r3, [r2, r3]
 800e004:	2b45      	cmp	r3, #69	; 0x45
 800e006:	d148      	bne.n	800e09a <ModemReceiveData+0x4e6>
							&& (sio_buf[i + 3] == 'C')
 800e008:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800e00c:	3303      	adds	r3, #3
 800e00e:	4a72      	ldr	r2, [pc, #456]	; (800e1d8 <ModemReceiveData+0x624>)
 800e010:	5cd3      	ldrb	r3, [r2, r3]
 800e012:	2b43      	cmp	r3, #67	; 0x43
 800e014:	d141      	bne.n	800e09a <ModemReceiveData+0x4e6>
							&& (sio_buf[i + 4] == 'V')
 800e016:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800e01a:	3304      	adds	r3, #4
 800e01c:	4a6e      	ldr	r2, [pc, #440]	; (800e1d8 <ModemReceiveData+0x624>)
 800e01e:	5cd3      	ldrb	r3, [r2, r3]
 800e020:	2b56      	cmp	r3, #86	; 0x56
 800e022:	d13a      	bne.n	800e09a <ModemReceiveData+0x4e6>
							&& (sio_buf[i + 5] == '(')
 800e024:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800e028:	3305      	adds	r3, #5
 800e02a:	4a6b      	ldr	r2, [pc, #428]	; (800e1d8 <ModemReceiveData+0x624>)
 800e02c:	5cd3      	ldrb	r3, [r2, r3]
 800e02e:	2b28      	cmp	r3, #40	; 0x28
 800e030:	d133      	bne.n	800e09a <ModemReceiveData+0x4e6>
							&& (sio_buf[i + 6] == 'S')
 800e032:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800e036:	3306      	adds	r3, #6
 800e038:	4a67      	ldr	r2, [pc, #412]	; (800e1d8 <ModemReceiveData+0x624>)
 800e03a:	5cd3      	ldrb	r3, [r2, r3]
 800e03c:	2b53      	cmp	r3, #83	; 0x53
 800e03e:	d12c      	bne.n	800e09a <ModemReceiveData+0x4e6>
							&& (sio_buf[i + 7] == ')')
 800e040:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800e044:	3307      	adds	r3, #7
 800e046:	4a64      	ldr	r2, [pc, #400]	; (800e1d8 <ModemReceiveData+0x624>)
 800e048:	5cd3      	ldrb	r3, [r2, r3]
 800e04a:	2b29      	cmp	r3, #41	; 0x29
 800e04c:	d125      	bne.n	800e09a <ModemReceiveData+0x4e6>
							&& (sio_buf[i + 8] == ':')
 800e04e:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800e052:	3308      	adds	r3, #8
 800e054:	4a60      	ldr	r2, [pc, #384]	; (800e1d8 <ModemReceiveData+0x624>)
 800e056:	5cd3      	ldrb	r3, [r2, r3]
 800e058:	2b3a      	cmp	r3, #58	; 0x3a
 800e05a:	d11e      	bne.n	800e09a <ModemReceiveData+0x4e6>
							&& (sio_buf[i + 9] == ' ')
 800e05c:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800e060:	3309      	adds	r3, #9
 800e062:	4a5d      	ldr	r2, [pc, #372]	; (800e1d8 <ModemReceiveData+0x624>)
 800e064:	5cd3      	ldrb	r3, [r2, r3]
 800e066:	2b20      	cmp	r3, #32
 800e068:	d117      	bne.n	800e09a <ModemReceiveData+0x4e6>
							&& (sio_buf[i + 11] == ',')) {
 800e06a:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800e06e:	330b      	adds	r3, #11
 800e070:	4a59      	ldr	r2, [pc, #356]	; (800e1d8 <ModemReceiveData+0x624>)
 800e072:	5cd3      	ldrb	r3, [r2, r3]
 800e074:	2b2c      	cmp	r3, #44	; 0x2c
 800e076:	d110      	bne.n	800e09a <ModemReceiveData+0x4e6>
						numIPD = i + 12;
 800e078:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800e07c:	330c      	adds	r3, #12
 800e07e:	f8c7 3190 	str.w	r3, [r7, #400]	; 0x190
						numRD = sio_buf[i + 10] - 48;
 800e082:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800e086:	330a      	adds	r3, #10
 800e088:	4a53      	ldr	r2, [pc, #332]	; (800e1d8 <ModemReceiveData+0x624>)
 800e08a:	5cd3      	ldrb	r3, [r2, r3]
 800e08c:	3b30      	subs	r3, #48	; 0x30
 800e08e:	4a55      	ldr	r2, [pc, #340]	; (800e1e4 <ModemReceiveData+0x630>)
 800e090:	6013      	str	r3, [r2, #0]
						k = 1;
 800e092:	2301      	movs	r3, #1
 800e094:	f8c7 318c 	str.w	r3, [r7, #396]	; 0x18c
						break;
 800e098:	e00f      	b.n	800e0ba <ModemReceiveData+0x506>
					} else
						k = 0;
 800e09a:	2300      	movs	r3, #0
 800e09c:	f8c7 318c 	str.w	r3, [r7, #396]	; 0x18c
				for (i = 0; i < bufsize; i++) {
 800e0a0:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800e0a4:	3301      	adds	r3, #1
 800e0a6:	f8c7 31a4 	str.w	r3, [r7, #420]	; 0x1a4
 800e0aa:	4b4a      	ldr	r3, [pc, #296]	; (800e1d4 <ModemReceiveData+0x620>)
 800e0ac:	881b      	ldrh	r3, [r3, #0]
 800e0ae:	b29b      	uxth	r3, r3
 800e0b0:	461a      	mov	r2, r3
 800e0b2:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800e0b6:	4293      	cmp	r3, r2
 800e0b8:	db91      	blt.n	800dfde <ModemReceiveData+0x42a>
		for (i = 0; i < 3; i++) {
 800e0ba:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800e0be:	3301      	adds	r3, #1
 800e0c0:	f8c7 31a4 	str.w	r3, [r7, #420]	; 0x1a4
 800e0c4:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800e0c8:	2b02      	cmp	r3, #2
 800e0ca:	f77f af77 	ble.w	800dfbc <ModemReceiveData+0x408>
				}
			}

		};

		if (k == 0)
 800e0ce:	f8d7 318c 	ldr.w	r3, [r7, #396]	; 0x18c
 800e0d2:	2b00      	cmp	r3, #0
 800e0d4:	d101      	bne.n	800e0da <ModemReceiveData+0x526>
			return 0;
 800e0d6:	2300      	movs	r3, #0
 800e0d8:	e272      	b.n	800e5c0 <ModemReceiveData+0xa0c>
		if (numIPD != 0) {
 800e0da:	f8d7 3190 	ldr.w	r3, [r7, #400]	; 0x190
 800e0de:	2b00      	cmp	r3, #0
 800e0e0:	d01c      	beq.n	800e11c <ModemReceiveData+0x568>
			for (i = 0; i < numIPD + 40; i++)
 800e0e2:	2300      	movs	r3, #0
 800e0e4:	f8c7 31a4 	str.w	r3, [r7, #420]	; 0x1a4
 800e0e8:	e011      	b.n	800e10e <ModemReceiveData+0x55a>
				sio_buf[i] = sio_buf[i + numIPD];
 800e0ea:	f8d7 21a4 	ldr.w	r2, [r7, #420]	; 0x1a4
 800e0ee:	f8d7 3190 	ldr.w	r3, [r7, #400]	; 0x190
 800e0f2:	4413      	add	r3, r2
 800e0f4:	4a38      	ldr	r2, [pc, #224]	; (800e1d8 <ModemReceiveData+0x624>)
 800e0f6:	5cd1      	ldrb	r1, [r2, r3]
 800e0f8:	4a37      	ldr	r2, [pc, #220]	; (800e1d8 <ModemReceiveData+0x624>)
 800e0fa:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800e0fe:	4413      	add	r3, r2
 800e100:	460a      	mov	r2, r1
 800e102:	701a      	strb	r2, [r3, #0]
			for (i = 0; i < numIPD + 40; i++)
 800e104:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800e108:	3301      	adds	r3, #1
 800e10a:	f8c7 31a4 	str.w	r3, [r7, #420]	; 0x1a4
 800e10e:	f8d7 3190 	ldr.w	r3, [r7, #400]	; 0x190
 800e112:	3327      	adds	r3, #39	; 0x27
 800e114:	f8d7 21a4 	ldr.w	r2, [r7, #420]	; 0x1a4
 800e118:	429a      	cmp	r2, r3
 800e11a:	dde6      	ble.n	800e0ea <ModemReceiveData+0x536>
		}
		int len_pack = 0;
 800e11c:	2300      	movs	r3, #0
 800e11e:	f8c7 3188 	str.w	r3, [r7, #392]	; 0x188
		while (sio_buf[len_pack] != ',') {
 800e122:	e004      	b.n	800e12e <ModemReceiveData+0x57a>
			len_pack++;
 800e124:	f8d7 3188 	ldr.w	r3, [r7, #392]	; 0x188
 800e128:	3301      	adds	r3, #1
 800e12a:	f8c7 3188 	str.w	r3, [r7, #392]	; 0x188
		while (sio_buf[len_pack] != ',') {
 800e12e:	4a2a      	ldr	r2, [pc, #168]	; (800e1d8 <ModemReceiveData+0x624>)
 800e130:	f8d7 3188 	ldr.w	r3, [r7, #392]	; 0x188
 800e134:	4413      	add	r3, r2
 800e136:	781b      	ldrb	r3, [r3, #0]
 800e138:	2b2c      	cmp	r3, #44	; 0x2c
 800e13a:	d1f3      	bne.n	800e124 <ModemReceiveData+0x570>
		}

		BKP_WriteBackupRegister(BKP_DR7, 36);
 800e13c:	2124      	movs	r1, #36	; 0x24
 800e13e:	201c      	movs	r0, #28
 800e140:	4b22      	ldr	r3, [pc, #136]	; (800e1cc <ModemReceiveData+0x618>)
 800e142:	4798      	blx	r3
		char *cmpbuf = "IPD";
 800e144:	4b28      	ldr	r3, [pc, #160]	; (800e1e8 <ModemReceiveData+0x634>)
 800e146:	f8c7 3154 	str.w	r3, [r7, #340]	; 0x154
		char strbufsize[16];
		int cmpPoint = 0;
 800e14a:	2300      	movs	r3, #0
 800e14c:	f8c7 3150 	str.w	r3, [r7, #336]	; 0x150
		int strbufsizePoint = 0;
 800e150:	2300      	movs	r3, #0
 800e152:	f8c7 3184 	str.w	r3, [r7, #388]	; 0x184

		headerSize = 0;
 800e156:	2300      	movs	r3, #0
 800e158:	f8c7 31a0 	str.w	r3, [r7, #416]	; 0x1a0
		for (int k = 0; k <= 16; k++) {
 800e15c:	2300      	movs	r3, #0
 800e15e:	f8c7 3180 	str.w	r3, [r7, #384]	; 0x180
 800e162:	e00b      	b.n	800e17c <ModemReceiveData+0x5c8>
			strbufsize[k] = '0';
 800e164:	f507 7298 	add.w	r2, r7, #304	; 0x130
 800e168:	f8d7 3180 	ldr.w	r3, [r7, #384]	; 0x180
 800e16c:	4413      	add	r3, r2
 800e16e:	2230      	movs	r2, #48	; 0x30
 800e170:	701a      	strb	r2, [r3, #0]
		for (int k = 0; k <= 16; k++) {
 800e172:	f8d7 3180 	ldr.w	r3, [r7, #384]	; 0x180
 800e176:	3301      	adds	r3, #1
 800e178:	f8c7 3180 	str.w	r3, [r7, #384]	; 0x180
 800e17c:	f8d7 3180 	ldr.w	r3, [r7, #384]	; 0x180
 800e180:	2b10      	cmp	r3, #16
 800e182:	ddef      	ble.n	800e164 <ModemReceiveData+0x5b0>
		}
		while (sio_buf[headerSize] != ',') {
 800e184:	e013      	b.n	800e1ae <ModemReceiveData+0x5fa>

			strbufsize[strbufsizePoint++] = sio_buf[headerSize];
 800e186:	f8d7 3184 	ldr.w	r3, [r7, #388]	; 0x184
 800e18a:	1c5a      	adds	r2, r3, #1
 800e18c:	f8c7 2184 	str.w	r2, [r7, #388]	; 0x184
 800e190:	4911      	ldr	r1, [pc, #68]	; (800e1d8 <ModemReceiveData+0x624>)
 800e192:	f8d7 21a0 	ldr.w	r2, [r7, #416]	; 0x1a0
 800e196:	440a      	add	r2, r1
 800e198:	7812      	ldrb	r2, [r2, #0]
 800e19a:	f503 73d4 	add.w	r3, r3, #424	; 0x1a8
 800e19e:	443b      	add	r3, r7
 800e1a0:	f803 2c78 	strb.w	r2, [r3, #-120]
			headerSize++;
 800e1a4:	f8d7 31a0 	ldr.w	r3, [r7, #416]	; 0x1a0
 800e1a8:	3301      	adds	r3, #1
 800e1aa:	f8c7 31a0 	str.w	r3, [r7, #416]	; 0x1a0
		while (sio_buf[headerSize] != ',') {
 800e1ae:	4a0a      	ldr	r2, [pc, #40]	; (800e1d8 <ModemReceiveData+0x624>)
 800e1b0:	f8d7 31a0 	ldr.w	r3, [r7, #416]	; 0x1a0
 800e1b4:	4413      	add	r3, r2
 800e1b6:	781b      	ldrb	r3, [r3, #0]
 800e1b8:	2b2c      	cmp	r3, #44	; 0x2c
 800e1ba:	d1e4      	bne.n	800e186 <ModemReceiveData+0x5d2>
		}
		int it = 0;
 800e1bc:	2300      	movs	r3, #0
 800e1be:	f8c7 317c 	str.w	r3, [r7, #380]	; 0x17c
		int res = 0;
 800e1c2:	2300      	movs	r3, #0
 800e1c4:	f8c7 3178 	str.w	r3, [r7, #376]	; 0x178
		while (strbufsize[it] >= '0' && strbufsize[it] <= '9') {
 800e1c8:	e02c      	b.n	800e224 <ModemReceiveData+0x670>
 800e1ca:	bf00      	nop
 800e1cc:	08003621 	.word	0x08003621
 800e1d0:	08015460 	.word	0x08015460
 800e1d4:	200092e4 	.word	0x200092e4
 800e1d8:	200086e0 	.word	0x200086e0
 800e1dc:	20008468 	.word	0x20008468
 800e1e0:	00445049 	.word	0x00445049
 800e1e4:	200092ec 	.word	0x200092ec
 800e1e8:	08015468 	.word	0x08015468
			res = res * 10 + (strbufsize[it] - '0');
 800e1ec:	f8d7 2178 	ldr.w	r2, [r7, #376]	; 0x178
 800e1f0:	4613      	mov	r3, r2
 800e1f2:	009b      	lsls	r3, r3, #2
 800e1f4:	4413      	add	r3, r2
 800e1f6:	005b      	lsls	r3, r3, #1
 800e1f8:	4619      	mov	r1, r3
 800e1fa:	f507 7298 	add.w	r2, r7, #304	; 0x130
 800e1fe:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 800e202:	4413      	add	r3, r2
 800e204:	781b      	ldrb	r3, [r3, #0]
 800e206:	3b30      	subs	r3, #48	; 0x30
 800e208:	440b      	add	r3, r1
 800e20a:	f8c7 3178 	str.w	r3, [r7, #376]	; 0x178
			it++;
 800e20e:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 800e212:	3301      	adds	r3, #1
 800e214:	f8c7 317c 	str.w	r3, [r7, #380]	; 0x17c
			if (it == headerSize)
 800e218:	f8d7 217c 	ldr.w	r2, [r7, #380]	; 0x17c
 800e21c:	f8d7 31a0 	ldr.w	r3, [r7, #416]	; 0x1a0
 800e220:	429a      	cmp	r2, r3
 800e222:	d010      	beq.n	800e246 <ModemReceiveData+0x692>
		while (strbufsize[it] >= '0' && strbufsize[it] <= '9') {
 800e224:	f507 7298 	add.w	r2, r7, #304	; 0x130
 800e228:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 800e22c:	4413      	add	r3, r2
 800e22e:	781b      	ldrb	r3, [r3, #0]
 800e230:	2b2f      	cmp	r3, #47	; 0x2f
 800e232:	d909      	bls.n	800e248 <ModemReceiveData+0x694>
 800e234:	f507 7298 	add.w	r2, r7, #304	; 0x130
 800e238:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 800e23c:	4413      	add	r3, r2
 800e23e:	781b      	ldrb	r3, [r3, #0]
 800e240:	2b39      	cmp	r3, #57	; 0x39
 800e242:	d9d3      	bls.n	800e1ec <ModemReceiveData+0x638>
 800e244:	e000      	b.n	800e248 <ModemReceiveData+0x694>
				break;
 800e246:	bf00      	nop
		}

		packSize = res;
 800e248:	f8d7 3178 	ldr.w	r3, [r7, #376]	; 0x178
 800e24c:	f8c7 3158 	str.w	r3, [r7, #344]	; 0x158

		headerSize++;
 800e250:	f8d7 31a0 	ldr.w	r3, [r7, #416]	; 0x1a0
 800e254:	3301      	adds	r3, #1
 800e256:	f8c7 31a0 	str.w	r3, [r7, #416]	; 0x1a0

		while (bufsize < (packSize + headerSize)) {
 800e25a:	bf00      	nop
 800e25c:	4bbc      	ldr	r3, [pc, #752]	; (800e550 <ModemReceiveData+0x99c>)
 800e25e:	881b      	ldrh	r3, [r3, #0]
 800e260:	b29b      	uxth	r3, r3
 800e262:	4619      	mov	r1, r3
 800e264:	f8d7 2158 	ldr.w	r2, [r7, #344]	; 0x158
 800e268:	f8d7 31a0 	ldr.w	r3, [r7, #416]	; 0x1a0
 800e26c:	4413      	add	r3, r2
 800e26e:	4299      	cmp	r1, r3
			if (tmpsize == 0) {
				break;
			}
			bufsize += tmpsize;
		}
		i = 0;
 800e270:	2300      	movs	r3, #0
 800e272:	f8c7 31a4 	str.w	r3, [r7, #420]	; 0x1a4

		bufsize -= headerSize;
 800e276:	4bb6      	ldr	r3, [pc, #728]	; (800e550 <ModemReceiveData+0x99c>)
 800e278:	881b      	ldrh	r3, [r3, #0]
 800e27a:	b29a      	uxth	r2, r3
 800e27c:	f8d7 31a0 	ldr.w	r3, [r7, #416]	; 0x1a0
 800e280:	b29b      	uxth	r3, r3
 800e282:	1ad3      	subs	r3, r2, r3
 800e284:	b29a      	uxth	r2, r3
 800e286:	4bb2      	ldr	r3, [pc, #712]	; (800e550 <ModemReceiveData+0x99c>)
 800e288:	801a      	strh	r2, [r3, #0]
		bufsize -= numIPD;
 800e28a:	4bb1      	ldr	r3, [pc, #708]	; (800e550 <ModemReceiveData+0x99c>)
 800e28c:	881b      	ldrh	r3, [r3, #0]
 800e28e:	b29a      	uxth	r2, r3
 800e290:	f8d7 3190 	ldr.w	r3, [r7, #400]	; 0x190
 800e294:	b29b      	uxth	r3, r3
 800e296:	1ad3      	subs	r3, r2, r3
 800e298:	b29a      	uxth	r2, r3
 800e29a:	4bad      	ldr	r3, [pc, #692]	; (800e550 <ModemReceiveData+0x99c>)
 800e29c:	801a      	strh	r2, [r3, #0]

		while (bufsize) {
 800e29e:	e02e      	b.n	800e2fe <ModemReceiveData+0x74a>
			if (i >= maxsize) {
 800e2a0:	f507 73d4 	add.w	r3, r7, #424	; 0x1a8
 800e2a4:	f5a3 73d4 	sub.w	r3, r3, #424	; 0x1a8
 800e2a8:	f8d7 21a4 	ldr.w	r2, [r7, #420]	; 0x1a4
 800e2ac:	681b      	ldr	r3, [r3, #0]
 800e2ae:	429a      	cmp	r2, r3
 800e2b0:	db01      	blt.n	800e2b6 <ModemReceiveData+0x702>
				return 0;
 800e2b2:	2300      	movs	r3, #0
 800e2b4:	e184      	b.n	800e5c0 <ModemReceiveData+0xa0c>
			}
			*buf = sio_buf[i + headerSize];
 800e2b6:	f8d7 21a4 	ldr.w	r2, [r7, #420]	; 0x1a4
 800e2ba:	f8d7 31a0 	ldr.w	r3, [r7, #416]	; 0x1a0
 800e2be:	4413      	add	r3, r2
 800e2c0:	4aa4      	ldr	r2, [pc, #656]	; (800e554 <ModemReceiveData+0x9a0>)
 800e2c2:	5cd2      	ldrb	r2, [r2, r3]
 800e2c4:	f507 73d4 	add.w	r3, r7, #424	; 0x1a8
 800e2c8:	f5a3 73d2 	sub.w	r3, r3, #420	; 0x1a4
 800e2cc:	681b      	ldr	r3, [r3, #0]
 800e2ce:	701a      	strb	r2, [r3, #0]
			buf++;
 800e2d0:	f507 73d4 	add.w	r3, r7, #424	; 0x1a8
 800e2d4:	f5a3 73d2 	sub.w	r3, r3, #420	; 0x1a4
 800e2d8:	f507 72d4 	add.w	r2, r7, #424	; 0x1a8
 800e2dc:	f5a2 72d2 	sub.w	r2, r2, #420	; 0x1a4
 800e2e0:	6812      	ldr	r2, [r2, #0]
 800e2e2:	3201      	adds	r2, #1
 800e2e4:	601a      	str	r2, [r3, #0]
			i++;
 800e2e6:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800e2ea:	3301      	adds	r3, #1
 800e2ec:	f8c7 31a4 	str.w	r3, [r7, #420]	; 0x1a4
			bufsize--;
 800e2f0:	4b97      	ldr	r3, [pc, #604]	; (800e550 <ModemReceiveData+0x99c>)
 800e2f2:	881b      	ldrh	r3, [r3, #0]
 800e2f4:	b29b      	uxth	r3, r3
 800e2f6:	3b01      	subs	r3, #1
 800e2f8:	b29a      	uxth	r2, r3
 800e2fa:	4b95      	ldr	r3, [pc, #596]	; (800e550 <ModemReceiveData+0x99c>)
 800e2fc:	801a      	strh	r2, [r3, #0]
		while (bufsize) {
 800e2fe:	4b94      	ldr	r3, [pc, #592]	; (800e550 <ModemReceiveData+0x99c>)
 800e300:	881b      	ldrh	r3, [r3, #0]
 800e302:	b29b      	uxth	r3, r3
 800e304:	2b00      	cmp	r3, #0
 800e306:	d1cb      	bne.n	800e2a0 <ModemReceiveData+0x6ec>
		}

		return packSize;
 800e308:	f8d7 3158 	ldr.w	r3, [r7, #344]	; 0x158
 800e30c:	e158      	b.n	800e5c0 <ModemReceiveData+0xa0c>
	}
	//-------------M66-----------------------
	else if (DeviceID == 2) {
 800e30e:	4b92      	ldr	r3, [pc, #584]	; (800e558 <ModemReceiveData+0x9a4>)
 800e310:	681b      	ldr	r3, [r3, #0]
 800e312:	2b02      	cmp	r3, #2
 800e314:	f040 8154 	bne.w	800e5c0 <ModemReceiveData+0xa0c>
		char header[] = "IPD";
 800e318:	4b90      	ldr	r3, [pc, #576]	; (800e55c <ModemReceiveData+0x9a8>)
 800e31a:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
		int numIPD = 0;
 800e31e:	2300      	movs	r3, #0
 800e320:	f8c7 3174 	str.w	r3, [r7, #372]	; 0x174
		int k = 1;
 800e324:	2301      	movs	r3, #1
 800e326:	f8c7 3170 	str.w	r3, [r7, #368]	; 0x170

		for (i = 0; i < 3; i++) {
 800e32a:	2300      	movs	r3, #0
 800e32c:	f8c7 31a4 	str.w	r3, [r7, #420]	; 0x1a4
 800e330:	e03e      	b.n	800e3b0 <ModemReceiveData+0x7fc>
			if (sio_buf[i] != header[i]) {
 800e332:	4a88      	ldr	r2, [pc, #544]	; (800e554 <ModemReceiveData+0x9a0>)
 800e334:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800e338:	4413      	add	r3, r2
 800e33a:	781a      	ldrb	r2, [r3, #0]
 800e33c:	f507 7196 	add.w	r1, r7, #300	; 0x12c
 800e340:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800e344:	440b      	add	r3, r1
 800e346:	781b      	ldrb	r3, [r3, #0]
 800e348:	429a      	cmp	r2, r3
 800e34a:	d02c      	beq.n	800e3a6 <ModemReceiveData+0x7f2>
				for (i = 0; i < 50; i++) {
 800e34c:	2300      	movs	r3, #0
 800e34e:	f8c7 31a4 	str.w	r3, [r7, #420]	; 0x1a4
 800e352:	e024      	b.n	800e39e <ModemReceiveData+0x7ea>
					if ((sio_buf[i] == 'I') && (sio_buf[i + 1] == 'P')
 800e354:	4a7f      	ldr	r2, [pc, #508]	; (800e554 <ModemReceiveData+0x9a0>)
 800e356:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800e35a:	4413      	add	r3, r2
 800e35c:	781b      	ldrb	r3, [r3, #0]
 800e35e:	2b49      	cmp	r3, #73	; 0x49
 800e360:	d115      	bne.n	800e38e <ModemReceiveData+0x7da>
 800e362:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800e366:	3301      	adds	r3, #1
 800e368:	4a7a      	ldr	r2, [pc, #488]	; (800e554 <ModemReceiveData+0x9a0>)
 800e36a:	5cd3      	ldrb	r3, [r2, r3]
 800e36c:	2b50      	cmp	r3, #80	; 0x50
 800e36e:	d10e      	bne.n	800e38e <ModemReceiveData+0x7da>
							&& (sio_buf[i + 2] == 'D')) {
 800e370:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800e374:	3302      	adds	r3, #2
 800e376:	4a77      	ldr	r2, [pc, #476]	; (800e554 <ModemReceiveData+0x9a0>)
 800e378:	5cd3      	ldrb	r3, [r2, r3]
 800e37a:	2b44      	cmp	r3, #68	; 0x44
 800e37c:	d107      	bne.n	800e38e <ModemReceiveData+0x7da>
						numIPD = i;
 800e37e:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800e382:	f8c7 3174 	str.w	r3, [r7, #372]	; 0x174
						k = 1;
 800e386:	2301      	movs	r3, #1
 800e388:	f8c7 3170 	str.w	r3, [r7, #368]	; 0x170
						break;
 800e38c:	e00b      	b.n	800e3a6 <ModemReceiveData+0x7f2>
					} else
						k = 0;
 800e38e:	2300      	movs	r3, #0
 800e390:	f8c7 3170 	str.w	r3, [r7, #368]	; 0x170
				for (i = 0; i < 50; i++) {
 800e394:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800e398:	3301      	adds	r3, #1
 800e39a:	f8c7 31a4 	str.w	r3, [r7, #420]	; 0x1a4
 800e39e:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800e3a2:	2b31      	cmp	r3, #49	; 0x31
 800e3a4:	ddd6      	ble.n	800e354 <ModemReceiveData+0x7a0>
		for (i = 0; i < 3; i++) {
 800e3a6:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800e3aa:	3301      	adds	r3, #1
 800e3ac:	f8c7 31a4 	str.w	r3, [r7, #420]	; 0x1a4
 800e3b0:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800e3b4:	2b02      	cmp	r3, #2
 800e3b6:	ddbc      	ble.n	800e332 <ModemReceiveData+0x77e>
				}
			}

		};
		if (k == 0)
 800e3b8:	f8d7 3170 	ldr.w	r3, [r7, #368]	; 0x170
 800e3bc:	2b00      	cmp	r3, #0
 800e3be:	d101      	bne.n	800e3c4 <ModemReceiveData+0x810>
			return 0;
 800e3c0:	2300      	movs	r3, #0
 800e3c2:	e0fd      	b.n	800e5c0 <ModemReceiveData+0xa0c>
		if (numIPD != 0) {
 800e3c4:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 800e3c8:	2b00      	cmp	r3, #0
 800e3ca:	d01c      	beq.n	800e406 <ModemReceiveData+0x852>
			for (i = 0; i < numIPD + 40; i++)
 800e3cc:	2300      	movs	r3, #0
 800e3ce:	f8c7 31a4 	str.w	r3, [r7, #420]	; 0x1a4
 800e3d2:	e011      	b.n	800e3f8 <ModemReceiveData+0x844>
				sio_buf[i] = sio_buf[i + numIPD];
 800e3d4:	f8d7 21a4 	ldr.w	r2, [r7, #420]	; 0x1a4
 800e3d8:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 800e3dc:	4413      	add	r3, r2
 800e3de:	4a5d      	ldr	r2, [pc, #372]	; (800e554 <ModemReceiveData+0x9a0>)
 800e3e0:	5cd1      	ldrb	r1, [r2, r3]
 800e3e2:	4a5c      	ldr	r2, [pc, #368]	; (800e554 <ModemReceiveData+0x9a0>)
 800e3e4:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800e3e8:	4413      	add	r3, r2
 800e3ea:	460a      	mov	r2, r1
 800e3ec:	701a      	strb	r2, [r3, #0]
			for (i = 0; i < numIPD + 40; i++)
 800e3ee:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800e3f2:	3301      	adds	r3, #1
 800e3f4:	f8c7 31a4 	str.w	r3, [r7, #420]	; 0x1a4
 800e3f8:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 800e3fc:	3327      	adds	r3, #39	; 0x27
 800e3fe:	f8d7 21a4 	ldr.w	r2, [r7, #420]	; 0x1a4
 800e402:	429a      	cmp	r2, r3
 800e404:	dde6      	ble.n	800e3d4 <ModemReceiveData+0x820>
		}

		BKP_WriteBackupRegister(BKP_DR7, 36);
 800e406:	2124      	movs	r1, #36	; 0x24
 800e408:	201c      	movs	r0, #28
 800e40a:	4b55      	ldr	r3, [pc, #340]	; (800e560 <ModemReceiveData+0x9ac>)
 800e40c:	4798      	blx	r3
		char *cmpbuf = "IPD";
 800e40e:	4b55      	ldr	r3, [pc, #340]	; (800e564 <ModemReceiveData+0x9b0>)
 800e410:	f8c7 315c 	str.w	r3, [r7, #348]	; 0x15c
		char *strbufsize[16];
		int cmpPoint = 0;
 800e414:	2300      	movs	r3, #0
 800e416:	f8c7 316c 	str.w	r3, [r7, #364]	; 0x16c
		int strbufsizePoint = 0;
 800e41a:	2300      	movs	r3, #0
 800e41c:	f8c7 3168 	str.w	r3, [r7, #360]	; 0x168

		headerSize = 0;
 800e420:	2300      	movs	r3, #0
 800e422:	f8c7 31a0 	str.w	r3, [r7, #416]	; 0x1a0
		while (sio_buf[headerSize] != ':') {
 800e426:	e02c      	b.n	800e482 <ModemReceiveData+0x8ce>
			if (cmpPoint < 3) {
 800e428:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 800e42c:	2b02      	cmp	r3, #2
 800e42e:	dc12      	bgt.n	800e456 <ModemReceiveData+0x8a2>
				if (cmpbuf[cmpPoint] == sio_buf[headerSize]) {
 800e430:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 800e434:	f8d7 215c 	ldr.w	r2, [r7, #348]	; 0x15c
 800e438:	4413      	add	r3, r2
 800e43a:	781a      	ldrb	r2, [r3, #0]
 800e43c:	4945      	ldr	r1, [pc, #276]	; (800e554 <ModemReceiveData+0x9a0>)
 800e43e:	f8d7 31a0 	ldr.w	r3, [r7, #416]	; 0x1a0
 800e442:	440b      	add	r3, r1
 800e444:	781b      	ldrb	r3, [r3, #0]
 800e446:	429a      	cmp	r2, r3
 800e448:	d116      	bne.n	800e478 <ModemReceiveData+0x8c4>
					cmpPoint++;
 800e44a:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 800e44e:	3301      	adds	r3, #1
 800e450:	f8c7 316c 	str.w	r3, [r7, #364]	; 0x16c
 800e454:	e010      	b.n	800e478 <ModemReceiveData+0x8c4>
				}
			} else {
				strbufsize[strbufsizePoint++] = sio_buf[headerSize];
 800e456:	4a3f      	ldr	r2, [pc, #252]	; (800e554 <ModemReceiveData+0x9a0>)
 800e458:	f8d7 31a0 	ldr.w	r3, [r7, #416]	; 0x1a0
 800e45c:	4413      	add	r3, r2
 800e45e:	781b      	ldrb	r3, [r3, #0]
 800e460:	4619      	mov	r1, r3
 800e462:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 800e466:	1c5a      	adds	r2, r3, #1
 800e468:	f8c7 2168 	str.w	r2, [r7, #360]	; 0x168
 800e46c:	f507 72d4 	add.w	r2, r7, #424	; 0x1a8
 800e470:	f5a2 72be 	sub.w	r2, r2, #380	; 0x17c
 800e474:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
			}
			headerSize++;
 800e478:	f8d7 31a0 	ldr.w	r3, [r7, #416]	; 0x1a0
 800e47c:	3301      	adds	r3, #1
 800e47e:	f8c7 31a0 	str.w	r3, [r7, #416]	; 0x1a0
		while (sio_buf[headerSize] != ':') {
 800e482:	4a34      	ldr	r2, [pc, #208]	; (800e554 <ModemReceiveData+0x9a0>)
 800e484:	f8d7 31a0 	ldr.w	r3, [r7, #416]	; 0x1a0
 800e488:	4413      	add	r3, r2
 800e48a:	781b      	ldrb	r3, [r3, #0]
 800e48c:	2b3a      	cmp	r3, #58	; 0x3a
 800e48e:	d1cb      	bne.n	800e428 <ModemReceiveData+0x874>
		}
		int it = 0;
 800e490:	2300      	movs	r3, #0
 800e492:	f8c7 3164 	str.w	r3, [r7, #356]	; 0x164
		int res = 0;
 800e496:	2300      	movs	r3, #0
 800e498:	f8c7 3160 	str.w	r3, [r7, #352]	; 0x160
		while (strbufsize[it] >= '0' && strbufsize[it] <= '9') {
 800e49c:	e016      	b.n	800e4cc <ModemReceiveData+0x918>
			res = res * 10 + strbufsize[it] - '0';
 800e49e:	f507 73d4 	add.w	r3, r7, #424	; 0x1a8
 800e4a2:	f5a3 73be 	sub.w	r3, r3, #380	; 0x17c
 800e4a6:	f8d7 2164 	ldr.w	r2, [r7, #356]	; 0x164
 800e4aa:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 800e4ae:	f8d7 2160 	ldr.w	r2, [r7, #352]	; 0x160
 800e4b2:	4613      	mov	r3, r2
 800e4b4:	009b      	lsls	r3, r3, #2
 800e4b6:	4413      	add	r3, r2
 800e4b8:	005b      	lsls	r3, r3, #1
 800e4ba:	3b30      	subs	r3, #48	; 0x30
 800e4bc:	440b      	add	r3, r1
 800e4be:	f8c7 3160 	str.w	r3, [r7, #352]	; 0x160
			it++;
 800e4c2:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 800e4c6:	3301      	adds	r3, #1
 800e4c8:	f8c7 3164 	str.w	r3, [r7, #356]	; 0x164
		while (strbufsize[it] >= '0' && strbufsize[it] <= '9') {
 800e4cc:	f507 73d4 	add.w	r3, r7, #424	; 0x1a8
 800e4d0:	f5a3 73be 	sub.w	r3, r3, #380	; 0x17c
 800e4d4:	f8d7 2164 	ldr.w	r2, [r7, #356]	; 0x164
 800e4d8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800e4dc:	2b2f      	cmp	r3, #47	; 0x2f
 800e4de:	d909      	bls.n	800e4f4 <ModemReceiveData+0x940>
 800e4e0:	f507 73d4 	add.w	r3, r7, #424	; 0x1a8
 800e4e4:	f5a3 73be 	sub.w	r3, r3, #380	; 0x17c
 800e4e8:	f8d7 2164 	ldr.w	r2, [r7, #356]	; 0x164
 800e4ec:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800e4f0:	2b39      	cmp	r3, #57	; 0x39
 800e4f2:	d9d4      	bls.n	800e49e <ModemReceiveData+0x8ea>
		}

		packSize = res;
 800e4f4:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 800e4f8:	f8c7 3158 	str.w	r3, [r7, #344]	; 0x158

		headerSize++;
 800e4fc:	f8d7 31a0 	ldr.w	r3, [r7, #416]	; 0x1a0
 800e500:	3301      	adds	r3, #1
 800e502:	f8c7 31a0 	str.w	r3, [r7, #416]	; 0x1a0
		while (bufsize < (packSize + headerSize)) {
 800e506:	bf00      	nop
 800e508:	4b11      	ldr	r3, [pc, #68]	; (800e550 <ModemReceiveData+0x99c>)
 800e50a:	881b      	ldrh	r3, [r3, #0]
 800e50c:	b29b      	uxth	r3, r3
 800e50e:	4619      	mov	r1, r3
 800e510:	f8d7 2158 	ldr.w	r2, [r7, #344]	; 0x158
 800e514:	f8d7 31a0 	ldr.w	r3, [r7, #416]	; 0x1a0
 800e518:	4413      	add	r3, r2
 800e51a:	4299      	cmp	r1, r3
			if (tmpsize == 0) {
				break;
			}
			bufsize += tmpsize;
		}
		i = 0;
 800e51c:	2300      	movs	r3, #0
 800e51e:	f8c7 31a4 	str.w	r3, [r7, #420]	; 0x1a4

		bufsize -= headerSize;
 800e522:	4b0b      	ldr	r3, [pc, #44]	; (800e550 <ModemReceiveData+0x99c>)
 800e524:	881b      	ldrh	r3, [r3, #0]
 800e526:	b29a      	uxth	r2, r3
 800e528:	f8d7 31a0 	ldr.w	r3, [r7, #416]	; 0x1a0
 800e52c:	b29b      	uxth	r3, r3
 800e52e:	1ad3      	subs	r3, r2, r3
 800e530:	b29a      	uxth	r2, r3
 800e532:	4b07      	ldr	r3, [pc, #28]	; (800e550 <ModemReceiveData+0x99c>)
 800e534:	801a      	strh	r2, [r3, #0]

		while (bufsize) {
 800e536:	e03b      	b.n	800e5b0 <ModemReceiveData+0x9fc>
			if (i >= maxsize) {
 800e538:	f507 73d4 	add.w	r3, r7, #424	; 0x1a8
 800e53c:	f5a3 73d4 	sub.w	r3, r3, #424	; 0x1a8
 800e540:	f8d7 21a4 	ldr.w	r2, [r7, #420]	; 0x1a4
 800e544:	681b      	ldr	r3, [r3, #0]
 800e546:	429a      	cmp	r2, r3
 800e548:	db0e      	blt.n	800e568 <ModemReceiveData+0x9b4>
				return 0;
 800e54a:	2300      	movs	r3, #0
 800e54c:	e038      	b.n	800e5c0 <ModemReceiveData+0xa0c>
 800e54e:	bf00      	nop
 800e550:	200092e4 	.word	0x200092e4
 800e554:	200086e0 	.word	0x200086e0
 800e558:	20008468 	.word	0x20008468
 800e55c:	00445049 	.word	0x00445049
 800e560:	08003621 	.word	0x08003621
 800e564:	08015468 	.word	0x08015468
			}
			*buf = sio_buf[i + headerSize];
 800e568:	f8d7 21a4 	ldr.w	r2, [r7, #420]	; 0x1a4
 800e56c:	f8d7 31a0 	ldr.w	r3, [r7, #416]	; 0x1a0
 800e570:	4413      	add	r3, r2
 800e572:	4a16      	ldr	r2, [pc, #88]	; (800e5cc <ModemReceiveData+0xa18>)
 800e574:	5cd2      	ldrb	r2, [r2, r3]
 800e576:	f507 73d4 	add.w	r3, r7, #424	; 0x1a8
 800e57a:	f5a3 73d2 	sub.w	r3, r3, #420	; 0x1a4
 800e57e:	681b      	ldr	r3, [r3, #0]
 800e580:	701a      	strb	r2, [r3, #0]
			buf++;
 800e582:	f507 73d4 	add.w	r3, r7, #424	; 0x1a8
 800e586:	f5a3 73d2 	sub.w	r3, r3, #420	; 0x1a4
 800e58a:	f507 72d4 	add.w	r2, r7, #424	; 0x1a8
 800e58e:	f5a2 72d2 	sub.w	r2, r2, #420	; 0x1a4
 800e592:	6812      	ldr	r2, [r2, #0]
 800e594:	3201      	adds	r2, #1
 800e596:	601a      	str	r2, [r3, #0]
			i++;
 800e598:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 800e59c:	3301      	adds	r3, #1
 800e59e:	f8c7 31a4 	str.w	r3, [r7, #420]	; 0x1a4
			bufsize--;
 800e5a2:	4b0b      	ldr	r3, [pc, #44]	; (800e5d0 <ModemReceiveData+0xa1c>)
 800e5a4:	881b      	ldrh	r3, [r3, #0]
 800e5a6:	b29b      	uxth	r3, r3
 800e5a8:	3b01      	subs	r3, #1
 800e5aa:	b29a      	uxth	r2, r3
 800e5ac:	4b08      	ldr	r3, [pc, #32]	; (800e5d0 <ModemReceiveData+0xa1c>)
 800e5ae:	801a      	strh	r2, [r3, #0]
		while (bufsize) {
 800e5b0:	4b07      	ldr	r3, [pc, #28]	; (800e5d0 <ModemReceiveData+0xa1c>)
 800e5b2:	881b      	ldrh	r3, [r3, #0]
 800e5b4:	b29b      	uxth	r3, r3
 800e5b6:	2b00      	cmp	r3, #0
 800e5b8:	d1be      	bne.n	800e538 <ModemReceiveData+0x984>
		}

		return packSize;
 800e5ba:	f8d7 3158 	ldr.w	r3, [r7, #344]	; 0x158
 800e5be:	e7ff      	b.n	800e5c0 <ModemReceiveData+0xa0c>
	}

}
 800e5c0:	4618      	mov	r0, r3
 800e5c2:	f507 77d4 	add.w	r7, r7, #424	; 0x1a8
 800e5c6:	46bd      	mov	sp, r7
 800e5c8:	bd80      	pop	{r7, pc}
 800e5ca:	bf00      	nop
 800e5cc:	200086e0 	.word	0x200086e0
 800e5d0:	200092e4 	.word	0x200092e4

0800e5d4 <ModemSendData>:

//=========================================================================+QILOCIP
void ModemSendData(uint8 *buf, uint8 size, int IDserv) {
 800e5d4:	b590      	push	{r4, r7, lr}
 800e5d6:	b093      	sub	sp, #76	; 0x4c
 800e5d8:	af00      	add	r7, sp, #0
 800e5da:	60f8      	str	r0, [r7, #12]
 800e5dc:	460b      	mov	r3, r1
 800e5de:	607a      	str	r2, [r7, #4]
 800e5e0:	72fb      	strb	r3, [r7, #11]
	BKP_WriteBackupRegister(BKP_DR7, 37);
 800e5e2:	2125      	movs	r1, #37	; 0x25
 800e5e4:	201c      	movs	r0, #28
 800e5e6:	4b7e      	ldr	r3, [pc, #504]	; (800e7e0 <ModemSendData+0x20c>)
 800e5e8:	4798      	blx	r3
	char tempbuf2[4];
	char strCipsend[20];

	//-------------UC15-----------------------
	//-------------UC20-----------------------
	if ((DeviceID == 1) || (DeviceID == 3))
 800e5ea:	4b7e      	ldr	r3, [pc, #504]	; (800e7e4 <ModemSendData+0x210>)
 800e5ec:	681b      	ldr	r3, [r3, #0]
 800e5ee:	2b01      	cmp	r3, #1
 800e5f0:	d003      	beq.n	800e5fa <ModemSendData+0x26>
 800e5f2:	4b7c      	ldr	r3, [pc, #496]	; (800e7e4 <ModemSendData+0x210>)
 800e5f4:	681b      	ldr	r3, [r3, #0]
 800e5f6:	2b03      	cmp	r3, #3
 800e5f8:	d14f      	bne.n	800e69a <ModemSendData+0xc6>

	{
		strcpy(strCipsend, "AT+QISEND=");
 800e5fa:	f107 0314 	add.w	r3, r7, #20
 800e5fe:	4a7a      	ldr	r2, [pc, #488]	; (800e7e8 <ModemSendData+0x214>)
 800e600:	ca07      	ldmia	r2, {r0, r1, r2}
 800e602:	c303      	stmia	r3!, {r0, r1}
 800e604:	801a      	strh	r2, [r3, #0]
 800e606:	3302      	adds	r3, #2
 800e608:	0c12      	lsrs	r2, r2, #16
 800e60a:	701a      	strb	r2, [r3, #0]
		itoa1(IDserv, tempbuf1);
 800e60c:	f107 032c 	add.w	r3, r7, #44	; 0x2c
 800e610:	4619      	mov	r1, r3
 800e612:	6878      	ldr	r0, [r7, #4]
 800e614:	4b75      	ldr	r3, [pc, #468]	; (800e7ec <ModemSendData+0x218>)
 800e616:	4798      	blx	r3
		itoa1(size, tempbuf2);
 800e618:	7afb      	ldrb	r3, [r7, #11]
 800e61a:	f107 0228 	add.w	r2, r7, #40	; 0x28
 800e61e:	4611      	mov	r1, r2
 800e620:	4618      	mov	r0, r3
 800e622:	4b72      	ldr	r3, [pc, #456]	; (800e7ec <ModemSendData+0x218>)
 800e624:	4798      	blx	r3
		strcat(strCipsend, tempbuf1);
 800e626:	f107 022c 	add.w	r2, r7, #44	; 0x2c
 800e62a:	f107 0314 	add.w	r3, r7, #20
 800e62e:	4611      	mov	r1, r2
 800e630:	4618      	mov	r0, r3
 800e632:	4b6f      	ldr	r3, [pc, #444]	; (800e7f0 <ModemSendData+0x21c>)
 800e634:	4798      	blx	r3
		strcat(strCipsend, ",");
 800e636:	f107 0314 	add.w	r3, r7, #20
 800e63a:	4618      	mov	r0, r3
 800e63c:	4b6d      	ldr	r3, [pc, #436]	; (800e7f4 <ModemSendData+0x220>)
 800e63e:	4798      	blx	r3
 800e640:	4603      	mov	r3, r0
 800e642:	461a      	mov	r2, r3
 800e644:	f107 0314 	add.w	r3, r7, #20
 800e648:	4413      	add	r3, r2
 800e64a:	496b      	ldr	r1, [pc, #428]	; (800e7f8 <ModemSendData+0x224>)
 800e64c:	461a      	mov	r2, r3
 800e64e:	460b      	mov	r3, r1
 800e650:	881b      	ldrh	r3, [r3, #0]
 800e652:	8013      	strh	r3, [r2, #0]
		strcat(strCipsend, tempbuf2);
 800e654:	f107 0228 	add.w	r2, r7, #40	; 0x28
 800e658:	f107 0314 	add.w	r3, r7, #20
 800e65c:	4611      	mov	r1, r2
 800e65e:	4618      	mov	r0, r3
 800e660:	4b63      	ldr	r3, [pc, #396]	; (800e7f0 <ModemSendData+0x21c>)
 800e662:	4798      	blx	r3
		strcat(strCipsend, "\r\n>");
 800e664:	f107 0314 	add.w	r3, r7, #20
 800e668:	4618      	mov	r0, r3
 800e66a:	4b62      	ldr	r3, [pc, #392]	; (800e7f4 <ModemSendData+0x220>)
 800e66c:	4798      	blx	r3
 800e66e:	4603      	mov	r3, r0
 800e670:	461a      	mov	r2, r3
 800e672:	f107 0314 	add.w	r3, r7, #20
 800e676:	4413      	add	r3, r2
 800e678:	4a60      	ldr	r2, [pc, #384]	; (800e7fc <ModemSendData+0x228>)
 800e67a:	6810      	ldr	r0, [r2, #0]
 800e67c:	6018      	str	r0, [r3, #0]
		ModemWrite(strCipsend);
 800e67e:	f107 0314 	add.w	r3, r7, #20
 800e682:	4618      	mov	r0, r3
 800e684:	4b5e      	ldr	r3, [pc, #376]	; (800e800 <ModemSendData+0x22c>)
 800e686:	4798      	blx	r3
		vTaskDelay(10);
 800e688:	200a      	movs	r0, #10
 800e68a:	4b5e      	ldr	r3, [pc, #376]	; (800e804 <ModemSendData+0x230>)
 800e68c:	4798      	blx	r3
		//BKP_WriteBackupRegister(BKP_DR7, 38);
		uart2Write(buf, size);
 800e68e:	7afb      	ldrb	r3, [r7, #11]
 800e690:	4619      	mov	r1, r3
 800e692:	68f8      	ldr	r0, [r7, #12]
 800e694:	4b5c      	ldr	r3, [pc, #368]	; (800e808 <ModemSendData+0x234>)
 800e696:	4798      	blx	r3
 800e698:	e09f      	b.n	800e7da <ModemSendData+0x206>
		//uart2Write(buf, size);
	}
	//-------------N715-----------------------
	else if (DeviceID == 4) {
 800e69a:	4b52      	ldr	r3, [pc, #328]	; (800e7e4 <ModemSendData+0x210>)
 800e69c:	681b      	ldr	r3, [r3, #0]
 800e69e:	2b04      	cmp	r3, #4
 800e6a0:	d15d      	bne.n	800e75e <ModemSendData+0x18a>
		//	ModemWrite("\r\n");
		strcpy(strCipsend, "AT+TCPSENDS=");
 800e6a2:	f107 0314 	add.w	r3, r7, #20
 800e6a6:	4a59      	ldr	r2, [pc, #356]	; (800e80c <ModemSendData+0x238>)
 800e6a8:	461c      	mov	r4, r3
 800e6aa:	4613      	mov	r3, r2
 800e6ac:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 800e6ae:	c407      	stmia	r4!, {r0, r1, r2}
 800e6b0:	7023      	strb	r3, [r4, #0]
		itoa1(numRD, tempbuf1);
 800e6b2:	4b57      	ldr	r3, [pc, #348]	; (800e810 <ModemSendData+0x23c>)
 800e6b4:	681b      	ldr	r3, [r3, #0]
 800e6b6:	f107 022c 	add.w	r2, r7, #44	; 0x2c
 800e6ba:	4611      	mov	r1, r2
 800e6bc:	4618      	mov	r0, r3
 800e6be:	4b4b      	ldr	r3, [pc, #300]	; (800e7ec <ModemSendData+0x218>)
 800e6c0:	4798      	blx	r3
		itoa1(size, tempbuf2);
 800e6c2:	7afb      	ldrb	r3, [r7, #11]
 800e6c4:	f107 0228 	add.w	r2, r7, #40	; 0x28
 800e6c8:	4611      	mov	r1, r2
 800e6ca:	4618      	mov	r0, r3
 800e6cc:	4b47      	ldr	r3, [pc, #284]	; (800e7ec <ModemSendData+0x218>)
 800e6ce:	4798      	blx	r3
		strcat(strCipsend, tempbuf1);
 800e6d0:	f107 022c 	add.w	r2, r7, #44	; 0x2c
 800e6d4:	f107 0314 	add.w	r3, r7, #20
 800e6d8:	4611      	mov	r1, r2
 800e6da:	4618      	mov	r0, r3
 800e6dc:	4b44      	ldr	r3, [pc, #272]	; (800e7f0 <ModemSendData+0x21c>)
 800e6de:	4798      	blx	r3
		strcat(strCipsend, ",");
 800e6e0:	f107 0314 	add.w	r3, r7, #20
 800e6e4:	4618      	mov	r0, r3
 800e6e6:	4b43      	ldr	r3, [pc, #268]	; (800e7f4 <ModemSendData+0x220>)
 800e6e8:	4798      	blx	r3
 800e6ea:	4603      	mov	r3, r0
 800e6ec:	461a      	mov	r2, r3
 800e6ee:	f107 0314 	add.w	r3, r7, #20
 800e6f2:	4413      	add	r3, r2
 800e6f4:	4940      	ldr	r1, [pc, #256]	; (800e7f8 <ModemSendData+0x224>)
 800e6f6:	461a      	mov	r2, r3
 800e6f8:	460b      	mov	r3, r1
 800e6fa:	881b      	ldrh	r3, [r3, #0]
 800e6fc:	8013      	strh	r3, [r2, #0]
		strcat(strCipsend, tempbuf2);
 800e6fe:	f107 0228 	add.w	r2, r7, #40	; 0x28
 800e702:	f107 0314 	add.w	r3, r7, #20
 800e706:	4611      	mov	r1, r2
 800e708:	4618      	mov	r0, r3
 800e70a:	4b39      	ldr	r3, [pc, #228]	; (800e7f0 <ModemSendData+0x21c>)
 800e70c:	4798      	blx	r3
		strcat(strCipsend, "\r\n");
 800e70e:	f107 0314 	add.w	r3, r7, #20
 800e712:	4618      	mov	r0, r3
 800e714:	4b37      	ldr	r3, [pc, #220]	; (800e7f4 <ModemSendData+0x220>)
 800e716:	4798      	blx	r3
 800e718:	4603      	mov	r3, r0
 800e71a:	461a      	mov	r2, r3
 800e71c:	f107 0314 	add.w	r3, r7, #20
 800e720:	4413      	add	r3, r2
 800e722:	4a3c      	ldr	r2, [pc, #240]	; (800e814 <ModemSendData+0x240>)
 800e724:	8811      	ldrh	r1, [r2, #0]
 800e726:	7892      	ldrb	r2, [r2, #2]
 800e728:	8019      	strh	r1, [r3, #0]
 800e72a:	709a      	strb	r2, [r3, #2]
		ModemWrite(strCipsend);
 800e72c:	f107 0314 	add.w	r3, r7, #20
 800e730:	4618      	mov	r0, r3
 800e732:	4b33      	ldr	r3, [pc, #204]	; (800e800 <ModemSendData+0x22c>)
 800e734:	4798      	blx	r3
		if (WaitAnsver(MA_CIPSENDREADY, 2) == false)
 800e736:	2102      	movs	r1, #2
 800e738:	200a      	movs	r0, #10
 800e73a:	4b37      	ldr	r3, [pc, #220]	; (800e818 <ModemSendData+0x244>)
 800e73c:	4798      	blx	r3
 800e73e:	4603      	mov	r3, r0
 800e740:	f083 0301 	eor.w	r3, r3, #1
 800e744:	b2db      	uxtb	r3, r3
 800e746:	2b00      	cmp	r3, #0
 800e748:	d146      	bne.n	800e7d8 <ModemSendData+0x204>
			return;
		BKP_WriteBackupRegister(BKP_DR7, 38);
 800e74a:	2126      	movs	r1, #38	; 0x26
 800e74c:	201c      	movs	r0, #28
 800e74e:	4b24      	ldr	r3, [pc, #144]	; (800e7e0 <ModemSendData+0x20c>)
 800e750:	4798      	blx	r3
		uart2Write(buf, size);
 800e752:	7afb      	ldrb	r3, [r7, #11]
 800e754:	4619      	mov	r1, r3
 800e756:	68f8      	ldr	r0, [r7, #12]
 800e758:	4b2b      	ldr	r3, [pc, #172]	; (800e808 <ModemSendData+0x234>)
 800e75a:	4798      	blx	r3
 800e75c:	e03d      	b.n	800e7da <ModemSendData+0x206>
		//	uart2Write("\n", 1);
		//-------------M66-----------------------
	} else if (DeviceID == 2) {
 800e75e:	4b21      	ldr	r3, [pc, #132]	; (800e7e4 <ModemSendData+0x210>)
 800e760:	681b      	ldr	r3, [r3, #0]
 800e762:	2b02      	cmp	r3, #2
 800e764:	d139      	bne.n	800e7da <ModemSendData+0x206>
		strcpy(strCipsend, "AT+QISEND=");
 800e766:	f107 0314 	add.w	r3, r7, #20
 800e76a:	4a1f      	ldr	r2, [pc, #124]	; (800e7e8 <ModemSendData+0x214>)
 800e76c:	ca07      	ldmia	r2, {r0, r1, r2}
 800e76e:	c303      	stmia	r3!, {r0, r1}
 800e770:	801a      	strh	r2, [r3, #0]
 800e772:	3302      	adds	r3, #2
 800e774:	0c12      	lsrs	r2, r2, #16
 800e776:	701a      	strb	r2, [r3, #0]
		itoa1(size, tempbuf);
 800e778:	7afb      	ldrb	r3, [r7, #11]
 800e77a:	f107 0230 	add.w	r2, r7, #48	; 0x30
 800e77e:	4611      	mov	r1, r2
 800e780:	4618      	mov	r0, r3
 800e782:	4b1a      	ldr	r3, [pc, #104]	; (800e7ec <ModemSendData+0x218>)
 800e784:	4798      	blx	r3
		strcat(strCipsend, tempbuf);
 800e786:	f107 0230 	add.w	r2, r7, #48	; 0x30
 800e78a:	f107 0314 	add.w	r3, r7, #20
 800e78e:	4611      	mov	r1, r2
 800e790:	4618      	mov	r0, r3
 800e792:	4b17      	ldr	r3, [pc, #92]	; (800e7f0 <ModemSendData+0x21c>)
 800e794:	4798      	blx	r3
		strcat(strCipsend, "\r");
 800e796:	f107 0314 	add.w	r3, r7, #20
 800e79a:	4618      	mov	r0, r3
 800e79c:	4b15      	ldr	r3, [pc, #84]	; (800e7f4 <ModemSendData+0x220>)
 800e79e:	4798      	blx	r3
 800e7a0:	4603      	mov	r3, r0
 800e7a2:	461a      	mov	r2, r3
 800e7a4:	f107 0314 	add.w	r3, r7, #20
 800e7a8:	4413      	add	r3, r2
 800e7aa:	491c      	ldr	r1, [pc, #112]	; (800e81c <ModemSendData+0x248>)
 800e7ac:	461a      	mov	r2, r3
 800e7ae:	460b      	mov	r3, r1
 800e7b0:	881b      	ldrh	r3, [r3, #0]
 800e7b2:	8013      	strh	r3, [r2, #0]
		ModemWrite(strCipsend);
 800e7b4:	f107 0314 	add.w	r3, r7, #20
 800e7b8:	4618      	mov	r0, r3
 800e7ba:	4b11      	ldr	r3, [pc, #68]	; (800e800 <ModemSendData+0x22c>)
 800e7bc:	4798      	blx	r3
		vTaskDelay(50);
 800e7be:	2032      	movs	r0, #50	; 0x32
 800e7c0:	4b10      	ldr	r3, [pc, #64]	; (800e804 <ModemSendData+0x230>)
 800e7c2:	4798      	blx	r3
		BKP_WriteBackupRegister(BKP_DR7, 38);
 800e7c4:	2126      	movs	r1, #38	; 0x26
 800e7c6:	201c      	movs	r0, #28
 800e7c8:	4b05      	ldr	r3, [pc, #20]	; (800e7e0 <ModemSendData+0x20c>)
 800e7ca:	4798      	blx	r3
		uart2Write(buf, size);
 800e7cc:	7afb      	ldrb	r3, [r7, #11]
 800e7ce:	4619      	mov	r1, r3
 800e7d0:	68f8      	ldr	r0, [r7, #12]
 800e7d2:	4b0d      	ldr	r3, [pc, #52]	; (800e808 <ModemSendData+0x234>)
 800e7d4:	4798      	blx	r3
 800e7d6:	e000      	b.n	800e7da <ModemSendData+0x206>
			return;
 800e7d8:	bf00      	nop
	}

}
 800e7da:	374c      	adds	r7, #76	; 0x4c
 800e7dc:	46bd      	mov	sp, r7
 800e7de:	bd90      	pop	{r4, r7, pc}
 800e7e0:	08003621 	.word	0x08003621
 800e7e4:	20008468 	.word	0x20008468
 800e7e8:	0801546c 	.word	0x0801546c
 800e7ec:	0800e895 	.word	0x0800e895
 800e7f0:	08014635 	.word	0x08014635
 800e7f4:	08014731 	.word	0x08014731
 800e7f8:	08015478 	.word	0x08015478
 800e7fc:	0801547c 	.word	0x0801547c
 800e800:	0800bfed 	.word	0x0800bfed
 800e804:	08001529 	.word	0x08001529
 800e808:	08004941 	.word	0x08004941
 800e80c:	08015480 	.word	0x08015480
 800e810:	200092ec 	.word	0x200092ec
 800e814:	08015224 	.word	0x08015224
 800e818:	0800c031 	.word	0x0800c031
 800e81c:	08015490 	.word	0x08015490

0800e820 <reverse>:
uint16 jrnlLength;



void reverse(char *str)
    {
 800e820:	b580      	push	{r7, lr}
 800e822:	b086      	sub	sp, #24
 800e824:	af00      	add	r7, sp, #0
 800e826:	6078      	str	r0, [r7, #4]
    char c;
    int size=strlen(str)/2;
 800e828:	6878      	ldr	r0, [r7, #4]
 800e82a:	4b19      	ldr	r3, [pc, #100]	; (800e890 <reverse+0x70>)
 800e82c:	4798      	blx	r3
 800e82e:	4603      	mov	r3, r0
 800e830:	085b      	lsrs	r3, r3, #1
 800e832:	613b      	str	r3, [r7, #16]
    for(int i=0;i<size;i++)
 800e834:	2300      	movs	r3, #0
 800e836:	617b      	str	r3, [r7, #20]
 800e838:	e020      	b.n	800e87c <reverse+0x5c>
	{
	c=str[i];
 800e83a:	697b      	ldr	r3, [r7, #20]
 800e83c:	687a      	ldr	r2, [r7, #4]
 800e83e:	4413      	add	r3, r2
 800e840:	781b      	ldrb	r3, [r3, #0]
 800e842:	73fb      	strb	r3, [r7, #15]
	str[i]=str[strlen(str)-i-1];
 800e844:	6878      	ldr	r0, [r7, #4]
 800e846:	4b12      	ldr	r3, [pc, #72]	; (800e890 <reverse+0x70>)
 800e848:	4798      	blx	r3
 800e84a:	4602      	mov	r2, r0
 800e84c:	697b      	ldr	r3, [r7, #20]
 800e84e:	1ad3      	subs	r3, r2, r3
 800e850:	3b01      	subs	r3, #1
 800e852:	687a      	ldr	r2, [r7, #4]
 800e854:	441a      	add	r2, r3
 800e856:	697b      	ldr	r3, [r7, #20]
 800e858:	6879      	ldr	r1, [r7, #4]
 800e85a:	440b      	add	r3, r1
 800e85c:	7812      	ldrb	r2, [r2, #0]
 800e85e:	701a      	strb	r2, [r3, #0]
	str[strlen(str)-i-1]=c;
 800e860:	6878      	ldr	r0, [r7, #4]
 800e862:	4b0b      	ldr	r3, [pc, #44]	; (800e890 <reverse+0x70>)
 800e864:	4798      	blx	r3
 800e866:	4602      	mov	r2, r0
 800e868:	697b      	ldr	r3, [r7, #20]
 800e86a:	1ad3      	subs	r3, r2, r3
 800e86c:	3b01      	subs	r3, #1
 800e86e:	687a      	ldr	r2, [r7, #4]
 800e870:	4413      	add	r3, r2
 800e872:	7bfa      	ldrb	r2, [r7, #15]
 800e874:	701a      	strb	r2, [r3, #0]
    for(int i=0;i<size;i++)
 800e876:	697b      	ldr	r3, [r7, #20]
 800e878:	3301      	adds	r3, #1
 800e87a:	617b      	str	r3, [r7, #20]
 800e87c:	697a      	ldr	r2, [r7, #20]
 800e87e:	693b      	ldr	r3, [r7, #16]
 800e880:	429a      	cmp	r2, r3
 800e882:	dbda      	blt.n	800e83a <reverse+0x1a>
	}
    }
 800e884:	bf00      	nop
 800e886:	bf00      	nop
 800e888:	3718      	adds	r7, #24
 800e88a:	46bd      	mov	sp, r7
 800e88c:	bd80      	pop	{r7, pc}
 800e88e:	bf00      	nop
 800e890:	08014731 	.word	0x08014731

0800e894 <itoa1>:

/* itoa:   n    s */
void itoa1(int n, char s[])
    {
 800e894:	b580      	push	{r7, lr}
 800e896:	b084      	sub	sp, #16
 800e898:	af00      	add	r7, sp, #0
 800e89a:	6078      	str	r0, [r7, #4]
 800e89c:	6039      	str	r1, [r7, #0]
    int i=0;
 800e89e:	2300      	movs	r3, #0
 800e8a0:	60fb      	str	r3, [r7, #12]
    int sign = 0;
 800e8a2:	2300      	movs	r3, #0
 800e8a4:	60bb      	str	r3, [r7, #8]

    if ((sign = n) < 0) /*   */
 800e8a6:	687b      	ldr	r3, [r7, #4]
 800e8a8:	60bb      	str	r3, [r7, #8]
 800e8aa:	68bb      	ldr	r3, [r7, #8]
 800e8ac:	2b00      	cmp	r3, #0
 800e8ae:	da02      	bge.n	800e8b6 <itoa1+0x22>
    {
    	n = -n; /*  n   */
 800e8b0:	687b      	ldr	r3, [r7, #4]
 800e8b2:	425b      	negs	r3, r3
 800e8b4:	607b      	str	r3, [r7, #4]
    }

    do
	{ /*      */
	s[i++] = n % 10 + '0'; /*    */
 800e8b6:	687a      	ldr	r2, [r7, #4]
 800e8b8:	4b1b      	ldr	r3, [pc, #108]	; (800e928 <itoa1+0x94>)
 800e8ba:	fb83 1302 	smull	r1, r3, r3, r2
 800e8be:	1099      	asrs	r1, r3, #2
 800e8c0:	17d3      	asrs	r3, r2, #31
 800e8c2:	1ac9      	subs	r1, r1, r3
 800e8c4:	460b      	mov	r3, r1
 800e8c6:	009b      	lsls	r3, r3, #2
 800e8c8:	440b      	add	r3, r1
 800e8ca:	005b      	lsls	r3, r3, #1
 800e8cc:	1ad1      	subs	r1, r2, r3
 800e8ce:	b2ca      	uxtb	r2, r1
 800e8d0:	68fb      	ldr	r3, [r7, #12]
 800e8d2:	1c59      	adds	r1, r3, #1
 800e8d4:	60f9      	str	r1, [r7, #12]
 800e8d6:	4619      	mov	r1, r3
 800e8d8:	683b      	ldr	r3, [r7, #0]
 800e8da:	440b      	add	r3, r1
 800e8dc:	3230      	adds	r2, #48	; 0x30
 800e8de:	b2d2      	uxtb	r2, r2
 800e8e0:	701a      	strb	r2, [r3, #0]
	}
    while ((n /= 10) > 0); /*  */
 800e8e2:	687b      	ldr	r3, [r7, #4]
 800e8e4:	4a10      	ldr	r2, [pc, #64]	; (800e928 <itoa1+0x94>)
 800e8e6:	fb82 1203 	smull	r1, r2, r2, r3
 800e8ea:	1092      	asrs	r2, r2, #2
 800e8ec:	17db      	asrs	r3, r3, #31
 800e8ee:	1ad3      	subs	r3, r2, r3
 800e8f0:	607b      	str	r3, [r7, #4]
 800e8f2:	687b      	ldr	r3, [r7, #4]
 800e8f4:	2b00      	cmp	r3, #0
 800e8f6:	dcde      	bgt.n	800e8b6 <itoa1+0x22>
    if (sign < 0)
 800e8f8:	68bb      	ldr	r3, [r7, #8]
 800e8fa:	2b00      	cmp	r3, #0
 800e8fc:	da07      	bge.n	800e90e <itoa1+0x7a>
	s[i++] = '-';
 800e8fe:	68fb      	ldr	r3, [r7, #12]
 800e900:	1c5a      	adds	r2, r3, #1
 800e902:	60fa      	str	r2, [r7, #12]
 800e904:	461a      	mov	r2, r3
 800e906:	683b      	ldr	r3, [r7, #0]
 800e908:	4413      	add	r3, r2
 800e90a:	222d      	movs	r2, #45	; 0x2d
 800e90c:	701a      	strb	r2, [r3, #0]
    s[i] = '\0';
 800e90e:	68fb      	ldr	r3, [r7, #12]
 800e910:	683a      	ldr	r2, [r7, #0]
 800e912:	4413      	add	r3, r2
 800e914:	2200      	movs	r2, #0
 800e916:	701a      	strb	r2, [r3, #0]
    reverse(s);
 800e918:	6838      	ldr	r0, [r7, #0]
 800e91a:	4b04      	ldr	r3, [pc, #16]	; (800e92c <itoa1+0x98>)
 800e91c:	4798      	blx	r3
    }
 800e91e:	bf00      	nop
 800e920:	3710      	adds	r7, #16
 800e922:	46bd      	mov	sp, r7
 800e924:	bd80      	pop	{r7, pc}
 800e926:	bf00      	nop
 800e928:	66666667 	.word	0x66666667
 800e92c:	0800e821 	.word	0x0800e821

0800e930 <itoa_n>:

/* itoa:   n    s */
void itoa_n(int n, char s[], int nums)
    {
 800e930:	b580      	push	{r7, lr}
 800e932:	b086      	sub	sp, #24
 800e934:	af00      	add	r7, sp, #0
 800e936:	60f8      	str	r0, [r7, #12]
 800e938:	60b9      	str	r1, [r7, #8]
 800e93a:	607a      	str	r2, [r7, #4]
    int i, sign;

    if ((sign = n) < 0) /*   */
 800e93c:	68fb      	ldr	r3, [r7, #12]
 800e93e:	613b      	str	r3, [r7, #16]
 800e940:	693b      	ldr	r3, [r7, #16]
 800e942:	2b00      	cmp	r3, #0
 800e944:	da02      	bge.n	800e94c <itoa_n+0x1c>
	n = -n; /*  n   */
 800e946:	68fb      	ldr	r3, [r7, #12]
 800e948:	425b      	negs	r3, r3
 800e94a:	60fb      	str	r3, [r7, #12]
    i = 0;
 800e94c:	2300      	movs	r3, #0
 800e94e:	617b      	str	r3, [r7, #20]
    do
	{ /*      */
	s[i++] = n % 10 + '0'; /*    */
 800e950:	68fa      	ldr	r2, [r7, #12]
 800e952:	4b22      	ldr	r3, [pc, #136]	; (800e9dc <itoa_n+0xac>)
 800e954:	fb83 1302 	smull	r1, r3, r3, r2
 800e958:	1099      	asrs	r1, r3, #2
 800e95a:	17d3      	asrs	r3, r2, #31
 800e95c:	1ac9      	subs	r1, r1, r3
 800e95e:	460b      	mov	r3, r1
 800e960:	009b      	lsls	r3, r3, #2
 800e962:	440b      	add	r3, r1
 800e964:	005b      	lsls	r3, r3, #1
 800e966:	1ad1      	subs	r1, r2, r3
 800e968:	b2ca      	uxtb	r2, r1
 800e96a:	697b      	ldr	r3, [r7, #20]
 800e96c:	1c59      	adds	r1, r3, #1
 800e96e:	6179      	str	r1, [r7, #20]
 800e970:	4619      	mov	r1, r3
 800e972:	68bb      	ldr	r3, [r7, #8]
 800e974:	440b      	add	r3, r1
 800e976:	3230      	adds	r2, #48	; 0x30
 800e978:	b2d2      	uxtb	r2, r2
 800e97a:	701a      	strb	r2, [r3, #0]
	}
    while ((n /= 10) > 0); /*  */
 800e97c:	68fb      	ldr	r3, [r7, #12]
 800e97e:	4a17      	ldr	r2, [pc, #92]	; (800e9dc <itoa_n+0xac>)
 800e980:	fb82 1203 	smull	r1, r2, r2, r3
 800e984:	1092      	asrs	r2, r2, #2
 800e986:	17db      	asrs	r3, r3, #31
 800e988:	1ad3      	subs	r3, r2, r3
 800e98a:	60fb      	str	r3, [r7, #12]
 800e98c:	68fb      	ldr	r3, [r7, #12]
 800e98e:	2b00      	cmp	r3, #0
 800e990:	dcde      	bgt.n	800e950 <itoa_n+0x20>

    while(i < nums)
 800e992:	e007      	b.n	800e9a4 <itoa_n+0x74>
    {
    	s[i++] = '0';
 800e994:	697b      	ldr	r3, [r7, #20]
 800e996:	1c5a      	adds	r2, r3, #1
 800e998:	617a      	str	r2, [r7, #20]
 800e99a:	461a      	mov	r2, r3
 800e99c:	68bb      	ldr	r3, [r7, #8]
 800e99e:	4413      	add	r3, r2
 800e9a0:	2230      	movs	r2, #48	; 0x30
 800e9a2:	701a      	strb	r2, [r3, #0]
    while(i < nums)
 800e9a4:	697a      	ldr	r2, [r7, #20]
 800e9a6:	687b      	ldr	r3, [r7, #4]
 800e9a8:	429a      	cmp	r2, r3
 800e9aa:	dbf3      	blt.n	800e994 <itoa_n+0x64>
    }

    if (sign < 0)
 800e9ac:	693b      	ldr	r3, [r7, #16]
 800e9ae:	2b00      	cmp	r3, #0
 800e9b0:	da07      	bge.n	800e9c2 <itoa_n+0x92>
	s[i++] = '-';
 800e9b2:	697b      	ldr	r3, [r7, #20]
 800e9b4:	1c5a      	adds	r2, r3, #1
 800e9b6:	617a      	str	r2, [r7, #20]
 800e9b8:	461a      	mov	r2, r3
 800e9ba:	68bb      	ldr	r3, [r7, #8]
 800e9bc:	4413      	add	r3, r2
 800e9be:	222d      	movs	r2, #45	; 0x2d
 800e9c0:	701a      	strb	r2, [r3, #0]
    s[i] = '\0';
 800e9c2:	697b      	ldr	r3, [r7, #20]
 800e9c4:	68ba      	ldr	r2, [r7, #8]
 800e9c6:	4413      	add	r3, r2
 800e9c8:	2200      	movs	r2, #0
 800e9ca:	701a      	strb	r2, [r3, #0]
    reverse(s);
 800e9cc:	68b8      	ldr	r0, [r7, #8]
 800e9ce:	4b04      	ldr	r3, [pc, #16]	; (800e9e0 <itoa_n+0xb0>)
 800e9d0:	4798      	blx	r3
    }
 800e9d2:	bf00      	nop
 800e9d4:	3718      	adds	r7, #24
 800e9d6:	46bd      	mov	sp, r7
 800e9d8:	bd80      	pop	{r7, pc}
 800e9da:	bf00      	nop
 800e9dc:	66666667 	.word	0x66666667
 800e9e0:	0800e821 	.word	0x0800e821

0800e9e4 <atoi1>:

int atoi1(char *c) {
 800e9e4:	b480      	push	{r7}
 800e9e6:	b085      	sub	sp, #20
 800e9e8:	af00      	add	r7, sp, #0
 800e9ea:	6078      	str	r0, [r7, #4]
      int res = 0;
 800e9ec:	2300      	movs	r3, #0
 800e9ee:	60fb      	str	r3, [r7, #12]
      while (*c >= '0' && *c <= '9')
 800e9f0:	e00c      	b.n	800ea0c <atoi1+0x28>
      {
        res = res * 10 + *c++ - '0';
 800e9f2:	68fa      	ldr	r2, [r7, #12]
 800e9f4:	4613      	mov	r3, r2
 800e9f6:	009b      	lsls	r3, r3, #2
 800e9f8:	4413      	add	r3, r2
 800e9fa:	005b      	lsls	r3, r3, #1
 800e9fc:	4619      	mov	r1, r3
 800e9fe:	687b      	ldr	r3, [r7, #4]
 800ea00:	1c5a      	adds	r2, r3, #1
 800ea02:	607a      	str	r2, [r7, #4]
 800ea04:	781b      	ldrb	r3, [r3, #0]
 800ea06:	440b      	add	r3, r1
 800ea08:	3b30      	subs	r3, #48	; 0x30
 800ea0a:	60fb      	str	r3, [r7, #12]
      while (*c >= '0' && *c <= '9')
 800ea0c:	687b      	ldr	r3, [r7, #4]
 800ea0e:	781b      	ldrb	r3, [r3, #0]
 800ea10:	2b2f      	cmp	r3, #47	; 0x2f
 800ea12:	d903      	bls.n	800ea1c <atoi1+0x38>
 800ea14:	687b      	ldr	r3, [r7, #4]
 800ea16:	781b      	ldrb	r3, [r3, #0]
 800ea18:	2b39      	cmp	r3, #57	; 0x39
 800ea1a:	d9ea      	bls.n	800e9f2 <atoi1+0xe>
      }
      return res;
 800ea1c:	68fb      	ldr	r3, [r7, #12]
    }
 800ea1e:	4618      	mov	r0, r3
 800ea20:	3714      	adds	r7, #20
 800ea22:	46bd      	mov	sp, r7
 800ea24:	bc80      	pop	{r7}
 800ea26:	4770      	bx	lr

0800ea28 <GetTimeString>:

void GetTimeString(char *aBuf)
    {
 800ea28:	b580      	push	{r7, lr}
 800ea2a:	b088      	sub	sp, #32
 800ea2c:	af00      	add	r7, sp, #0
 800ea2e:	6078      	str	r0, [r7, #4]
	DATATIME dtl;

	rtcGetDataTime(&dtl);
 800ea30:	f107 0310 	add.w	r3, r7, #16
 800ea34:	4618      	mov	r0, r3
 800ea36:	4b24      	ldr	r3, [pc, #144]	; (800eac8 <GetTimeString+0xa0>)
 800ea38:	4798      	blx	r3
	char conv_buf[8];
	itoa_n(dtl.Hour,conv_buf,2);
 800ea3a:	8b3b      	ldrh	r3, [r7, #24]
 800ea3c:	4618      	mov	r0, r3
 800ea3e:	f107 0308 	add.w	r3, r7, #8
 800ea42:	2202      	movs	r2, #2
 800ea44:	4619      	mov	r1, r3
 800ea46:	4b21      	ldr	r3, [pc, #132]	; (800eacc <GetTimeString+0xa4>)
 800ea48:	4798      	blx	r3
	strcpy(aBuf,conv_buf);
 800ea4a:	f107 0308 	add.w	r3, r7, #8
 800ea4e:	4619      	mov	r1, r3
 800ea50:	6878      	ldr	r0, [r7, #4]
 800ea52:	4b1f      	ldr	r3, [pc, #124]	; (800ead0 <GetTimeString+0xa8>)
 800ea54:	4798      	blx	r3
	strcat(aBuf,":");
 800ea56:	6878      	ldr	r0, [r7, #4]
 800ea58:	4b1e      	ldr	r3, [pc, #120]	; (800ead4 <GetTimeString+0xac>)
 800ea5a:	4798      	blx	r3
 800ea5c:	4603      	mov	r3, r0
 800ea5e:	461a      	mov	r2, r3
 800ea60:	687b      	ldr	r3, [r7, #4]
 800ea62:	4413      	add	r3, r2
 800ea64:	491c      	ldr	r1, [pc, #112]	; (800ead8 <GetTimeString+0xb0>)
 800ea66:	461a      	mov	r2, r3
 800ea68:	460b      	mov	r3, r1
 800ea6a:	881b      	ldrh	r3, [r3, #0]
 800ea6c:	8013      	strh	r3, [r2, #0]
	itoa_n(dtl.Min,conv_buf,2);
 800ea6e:	8b7b      	ldrh	r3, [r7, #26]
 800ea70:	4618      	mov	r0, r3
 800ea72:	f107 0308 	add.w	r3, r7, #8
 800ea76:	2202      	movs	r2, #2
 800ea78:	4619      	mov	r1, r3
 800ea7a:	4b14      	ldr	r3, [pc, #80]	; (800eacc <GetTimeString+0xa4>)
 800ea7c:	4798      	blx	r3
	strcat(aBuf,conv_buf);
 800ea7e:	f107 0308 	add.w	r3, r7, #8
 800ea82:	4619      	mov	r1, r3
 800ea84:	6878      	ldr	r0, [r7, #4]
 800ea86:	4b15      	ldr	r3, [pc, #84]	; (800eadc <GetTimeString+0xb4>)
 800ea88:	4798      	blx	r3
	strcat(aBuf,":");
 800ea8a:	6878      	ldr	r0, [r7, #4]
 800ea8c:	4b11      	ldr	r3, [pc, #68]	; (800ead4 <GetTimeString+0xac>)
 800ea8e:	4798      	blx	r3
 800ea90:	4603      	mov	r3, r0
 800ea92:	461a      	mov	r2, r3
 800ea94:	687b      	ldr	r3, [r7, #4]
 800ea96:	4413      	add	r3, r2
 800ea98:	490f      	ldr	r1, [pc, #60]	; (800ead8 <GetTimeString+0xb0>)
 800ea9a:	461a      	mov	r2, r3
 800ea9c:	460b      	mov	r3, r1
 800ea9e:	881b      	ldrh	r3, [r3, #0]
 800eaa0:	8013      	strh	r3, [r2, #0]
	itoa_n(dtl.Sec,conv_buf,2);
 800eaa2:	8bbb      	ldrh	r3, [r7, #28]
 800eaa4:	4618      	mov	r0, r3
 800eaa6:	f107 0308 	add.w	r3, r7, #8
 800eaaa:	2202      	movs	r2, #2
 800eaac:	4619      	mov	r1, r3
 800eaae:	4b07      	ldr	r3, [pc, #28]	; (800eacc <GetTimeString+0xa4>)
 800eab0:	4798      	blx	r3
	strcat(aBuf,conv_buf);
 800eab2:	f107 0308 	add.w	r3, r7, #8
 800eab6:	4619      	mov	r1, r3
 800eab8:	6878      	ldr	r0, [r7, #4]
 800eaba:	4b08      	ldr	r3, [pc, #32]	; (800eadc <GetTimeString+0xb4>)
 800eabc:	4798      	blx	r3
    }
 800eabe:	bf00      	nop
 800eac0:	3720      	adds	r7, #32
 800eac2:	46bd      	mov	sp, r7
 800eac4:	bd80      	pop	{r7, pc}
 800eac6:	bf00      	nop
 800eac8:	0800548d 	.word	0x0800548d
 800eacc:	0800e931 	.word	0x0800e931
 800ead0:	08014675 	.word	0x08014675
 800ead4:	08014731 	.word	0x08014731
 800ead8:	080154f4 	.word	0x080154f4
 800eadc:	08014635 	.word	0x08014635

0800eae0 <GetDateString>:

void GetDateString(char *aBuf)
    {
 800eae0:	b580      	push	{r7, lr}
 800eae2:	b088      	sub	sp, #32
 800eae4:	af00      	add	r7, sp, #0
 800eae6:	6078      	str	r0, [r7, #4]
	DATATIME dtl;
	rtcGetDataTime(&dtl);
 800eae8:	f107 0310 	add.w	r3, r7, #16
 800eaec:	4618      	mov	r0, r3
 800eaee:	4b24      	ldr	r3, [pc, #144]	; (800eb80 <GetDateString+0xa0>)
 800eaf0:	4798      	blx	r3
	char conv_buf[8];
	itoa_n(dtl.Data,conv_buf,2);
 800eaf2:	8abb      	ldrh	r3, [r7, #20]
 800eaf4:	4618      	mov	r0, r3
 800eaf6:	f107 0308 	add.w	r3, r7, #8
 800eafa:	2202      	movs	r2, #2
 800eafc:	4619      	mov	r1, r3
 800eafe:	4b21      	ldr	r3, [pc, #132]	; (800eb84 <GetDateString+0xa4>)
 800eb00:	4798      	blx	r3
	strcpy(aBuf,conv_buf);
 800eb02:	f107 0308 	add.w	r3, r7, #8
 800eb06:	4619      	mov	r1, r3
 800eb08:	6878      	ldr	r0, [r7, #4]
 800eb0a:	4b1f      	ldr	r3, [pc, #124]	; (800eb88 <GetDateString+0xa8>)
 800eb0c:	4798      	blx	r3
	strcat(aBuf,"/");
 800eb0e:	6878      	ldr	r0, [r7, #4]
 800eb10:	4b1e      	ldr	r3, [pc, #120]	; (800eb8c <GetDateString+0xac>)
 800eb12:	4798      	blx	r3
 800eb14:	4603      	mov	r3, r0
 800eb16:	461a      	mov	r2, r3
 800eb18:	687b      	ldr	r3, [r7, #4]
 800eb1a:	4413      	add	r3, r2
 800eb1c:	491c      	ldr	r1, [pc, #112]	; (800eb90 <GetDateString+0xb0>)
 800eb1e:	461a      	mov	r2, r3
 800eb20:	460b      	mov	r3, r1
 800eb22:	881b      	ldrh	r3, [r3, #0]
 800eb24:	8013      	strh	r3, [r2, #0]
	itoa_n(dtl.Month,conv_buf,2);
 800eb26:	8a7b      	ldrh	r3, [r7, #18]
 800eb28:	4618      	mov	r0, r3
 800eb2a:	f107 0308 	add.w	r3, r7, #8
 800eb2e:	2202      	movs	r2, #2
 800eb30:	4619      	mov	r1, r3
 800eb32:	4b14      	ldr	r3, [pc, #80]	; (800eb84 <GetDateString+0xa4>)
 800eb34:	4798      	blx	r3
	strcat(aBuf,conv_buf);
 800eb36:	f107 0308 	add.w	r3, r7, #8
 800eb3a:	4619      	mov	r1, r3
 800eb3c:	6878      	ldr	r0, [r7, #4]
 800eb3e:	4b15      	ldr	r3, [pc, #84]	; (800eb94 <GetDateString+0xb4>)
 800eb40:	4798      	blx	r3
	strcat(aBuf,"/");
 800eb42:	6878      	ldr	r0, [r7, #4]
 800eb44:	4b11      	ldr	r3, [pc, #68]	; (800eb8c <GetDateString+0xac>)
 800eb46:	4798      	blx	r3
 800eb48:	4603      	mov	r3, r0
 800eb4a:	461a      	mov	r2, r3
 800eb4c:	687b      	ldr	r3, [r7, #4]
 800eb4e:	4413      	add	r3, r2
 800eb50:	490f      	ldr	r1, [pc, #60]	; (800eb90 <GetDateString+0xb0>)
 800eb52:	461a      	mov	r2, r3
 800eb54:	460b      	mov	r3, r1
 800eb56:	881b      	ldrh	r3, [r3, #0]
 800eb58:	8013      	strh	r3, [r2, #0]
	itoa1(dtl.Years,conv_buf);
 800eb5a:	8a3b      	ldrh	r3, [r7, #16]
 800eb5c:	461a      	mov	r2, r3
 800eb5e:	f107 0308 	add.w	r3, r7, #8
 800eb62:	4619      	mov	r1, r3
 800eb64:	4610      	mov	r0, r2
 800eb66:	4b0c      	ldr	r3, [pc, #48]	; (800eb98 <GetDateString+0xb8>)
 800eb68:	4798      	blx	r3
	strcat(aBuf,conv_buf);
 800eb6a:	f107 0308 	add.w	r3, r7, #8
 800eb6e:	4619      	mov	r1, r3
 800eb70:	6878      	ldr	r0, [r7, #4]
 800eb72:	4b08      	ldr	r3, [pc, #32]	; (800eb94 <GetDateString+0xb4>)
 800eb74:	4798      	blx	r3

    }
 800eb76:	bf00      	nop
 800eb78:	3720      	adds	r7, #32
 800eb7a:	46bd      	mov	sp, r7
 800eb7c:	bd80      	pop	{r7, pc}
 800eb7e:	bf00      	nop
 800eb80:	0800548d 	.word	0x0800548d
 800eb84:	0800e931 	.word	0x0800e931
 800eb88:	08014675 	.word	0x08014675
 800eb8c:	08014731 	.word	0x08014731
 800eb90:	080154f8 	.word	0x080154f8
 800eb94:	08014635 	.word	0x08014635
 800eb98:	0800e895 	.word	0x0800e895

0800eb9c <GetTimeStringOff>:

void GetTimeStringOff(char *aBuf)
    {
 800eb9c:	b580      	push	{r7, lr}
 800eb9e:	b088      	sub	sp, #32
 800eba0:	af00      	add	r7, sp, #0
 800eba2:	6078      	str	r0, [r7, #4]
	DATATIME dtl;

	rtcGetDataTimeOff(&dtl);
 800eba4:	f107 0310 	add.w	r3, r7, #16
 800eba8:	4618      	mov	r0, r3
 800ebaa:	4b24      	ldr	r3, [pc, #144]	; (800ec3c <GetTimeStringOff+0xa0>)
 800ebac:	4798      	blx	r3
	char conv_buf[8];
	itoa_n(dtl.Hour,conv_buf,2);
 800ebae:	8b3b      	ldrh	r3, [r7, #24]
 800ebb0:	4618      	mov	r0, r3
 800ebb2:	f107 0308 	add.w	r3, r7, #8
 800ebb6:	2202      	movs	r2, #2
 800ebb8:	4619      	mov	r1, r3
 800ebba:	4b21      	ldr	r3, [pc, #132]	; (800ec40 <GetTimeStringOff+0xa4>)
 800ebbc:	4798      	blx	r3
	strcpy(aBuf,conv_buf);
 800ebbe:	f107 0308 	add.w	r3, r7, #8
 800ebc2:	4619      	mov	r1, r3
 800ebc4:	6878      	ldr	r0, [r7, #4]
 800ebc6:	4b1f      	ldr	r3, [pc, #124]	; (800ec44 <GetTimeStringOff+0xa8>)
 800ebc8:	4798      	blx	r3
	strcat(aBuf,":");
 800ebca:	6878      	ldr	r0, [r7, #4]
 800ebcc:	4b1e      	ldr	r3, [pc, #120]	; (800ec48 <GetTimeStringOff+0xac>)
 800ebce:	4798      	blx	r3
 800ebd0:	4603      	mov	r3, r0
 800ebd2:	461a      	mov	r2, r3
 800ebd4:	687b      	ldr	r3, [r7, #4]
 800ebd6:	4413      	add	r3, r2
 800ebd8:	491c      	ldr	r1, [pc, #112]	; (800ec4c <GetTimeStringOff+0xb0>)
 800ebda:	461a      	mov	r2, r3
 800ebdc:	460b      	mov	r3, r1
 800ebde:	881b      	ldrh	r3, [r3, #0]
 800ebe0:	8013      	strh	r3, [r2, #0]
	itoa_n(dtl.Min,conv_buf,2);
 800ebe2:	8b7b      	ldrh	r3, [r7, #26]
 800ebe4:	4618      	mov	r0, r3
 800ebe6:	f107 0308 	add.w	r3, r7, #8
 800ebea:	2202      	movs	r2, #2
 800ebec:	4619      	mov	r1, r3
 800ebee:	4b14      	ldr	r3, [pc, #80]	; (800ec40 <GetTimeStringOff+0xa4>)
 800ebf0:	4798      	blx	r3
	strcat(aBuf,conv_buf);
 800ebf2:	f107 0308 	add.w	r3, r7, #8
 800ebf6:	4619      	mov	r1, r3
 800ebf8:	6878      	ldr	r0, [r7, #4]
 800ebfa:	4b15      	ldr	r3, [pc, #84]	; (800ec50 <GetTimeStringOff+0xb4>)
 800ebfc:	4798      	blx	r3
	strcat(aBuf,":");
 800ebfe:	6878      	ldr	r0, [r7, #4]
 800ec00:	4b11      	ldr	r3, [pc, #68]	; (800ec48 <GetTimeStringOff+0xac>)
 800ec02:	4798      	blx	r3
 800ec04:	4603      	mov	r3, r0
 800ec06:	461a      	mov	r2, r3
 800ec08:	687b      	ldr	r3, [r7, #4]
 800ec0a:	4413      	add	r3, r2
 800ec0c:	490f      	ldr	r1, [pc, #60]	; (800ec4c <GetTimeStringOff+0xb0>)
 800ec0e:	461a      	mov	r2, r3
 800ec10:	460b      	mov	r3, r1
 800ec12:	881b      	ldrh	r3, [r3, #0]
 800ec14:	8013      	strh	r3, [r2, #0]
	itoa_n(dtl.Sec,conv_buf,2);
 800ec16:	8bbb      	ldrh	r3, [r7, #28]
 800ec18:	4618      	mov	r0, r3
 800ec1a:	f107 0308 	add.w	r3, r7, #8
 800ec1e:	2202      	movs	r2, #2
 800ec20:	4619      	mov	r1, r3
 800ec22:	4b07      	ldr	r3, [pc, #28]	; (800ec40 <GetTimeStringOff+0xa4>)
 800ec24:	4798      	blx	r3
	strcat(aBuf,conv_buf);
 800ec26:	f107 0308 	add.w	r3, r7, #8
 800ec2a:	4619      	mov	r1, r3
 800ec2c:	6878      	ldr	r0, [r7, #4]
 800ec2e:	4b08      	ldr	r3, [pc, #32]	; (800ec50 <GetTimeStringOff+0xb4>)
 800ec30:	4798      	blx	r3

    }
 800ec32:	bf00      	nop
 800ec34:	3720      	adds	r7, #32
 800ec36:	46bd      	mov	sp, r7
 800ec38:	bd80      	pop	{r7, pc}
 800ec3a:	bf00      	nop
 800ec3c:	080053f1 	.word	0x080053f1
 800ec40:	0800e931 	.word	0x0800e931
 800ec44:	08014675 	.word	0x08014675
 800ec48:	08014731 	.word	0x08014731
 800ec4c:	080154f4 	.word	0x080154f4
 800ec50:	08014635 	.word	0x08014635

0800ec54 <GetDateStringOff>:

void GetDateStringOff(char *aBuf)
    {
 800ec54:	b580      	push	{r7, lr}
 800ec56:	b088      	sub	sp, #32
 800ec58:	af00      	add	r7, sp, #0
 800ec5a:	6078      	str	r0, [r7, #4]
	DATATIME dtl;
	rtcGetDataTimeOff(&dtl);
 800ec5c:	f107 0310 	add.w	r3, r7, #16
 800ec60:	4618      	mov	r0, r3
 800ec62:	4b24      	ldr	r3, [pc, #144]	; (800ecf4 <GetDateStringOff+0xa0>)
 800ec64:	4798      	blx	r3
	char conv_buf[8];
	itoa_n(dtl.Data,conv_buf,2);
 800ec66:	8abb      	ldrh	r3, [r7, #20]
 800ec68:	4618      	mov	r0, r3
 800ec6a:	f107 0308 	add.w	r3, r7, #8
 800ec6e:	2202      	movs	r2, #2
 800ec70:	4619      	mov	r1, r3
 800ec72:	4b21      	ldr	r3, [pc, #132]	; (800ecf8 <GetDateStringOff+0xa4>)
 800ec74:	4798      	blx	r3
	strcpy(aBuf,conv_buf);
 800ec76:	f107 0308 	add.w	r3, r7, #8
 800ec7a:	4619      	mov	r1, r3
 800ec7c:	6878      	ldr	r0, [r7, #4]
 800ec7e:	4b1f      	ldr	r3, [pc, #124]	; (800ecfc <GetDateStringOff+0xa8>)
 800ec80:	4798      	blx	r3
	strcat(aBuf,"/");
 800ec82:	6878      	ldr	r0, [r7, #4]
 800ec84:	4b1e      	ldr	r3, [pc, #120]	; (800ed00 <GetDateStringOff+0xac>)
 800ec86:	4798      	blx	r3
 800ec88:	4603      	mov	r3, r0
 800ec8a:	461a      	mov	r2, r3
 800ec8c:	687b      	ldr	r3, [r7, #4]
 800ec8e:	4413      	add	r3, r2
 800ec90:	491c      	ldr	r1, [pc, #112]	; (800ed04 <GetDateStringOff+0xb0>)
 800ec92:	461a      	mov	r2, r3
 800ec94:	460b      	mov	r3, r1
 800ec96:	881b      	ldrh	r3, [r3, #0]
 800ec98:	8013      	strh	r3, [r2, #0]
	itoa_n(dtl.Month,conv_buf,2);
 800ec9a:	8a7b      	ldrh	r3, [r7, #18]
 800ec9c:	4618      	mov	r0, r3
 800ec9e:	f107 0308 	add.w	r3, r7, #8
 800eca2:	2202      	movs	r2, #2
 800eca4:	4619      	mov	r1, r3
 800eca6:	4b14      	ldr	r3, [pc, #80]	; (800ecf8 <GetDateStringOff+0xa4>)
 800eca8:	4798      	blx	r3
	strcat(aBuf,conv_buf);
 800ecaa:	f107 0308 	add.w	r3, r7, #8
 800ecae:	4619      	mov	r1, r3
 800ecb0:	6878      	ldr	r0, [r7, #4]
 800ecb2:	4b15      	ldr	r3, [pc, #84]	; (800ed08 <GetDateStringOff+0xb4>)
 800ecb4:	4798      	blx	r3
	strcat(aBuf,"/");
 800ecb6:	6878      	ldr	r0, [r7, #4]
 800ecb8:	4b11      	ldr	r3, [pc, #68]	; (800ed00 <GetDateStringOff+0xac>)
 800ecba:	4798      	blx	r3
 800ecbc:	4603      	mov	r3, r0
 800ecbe:	461a      	mov	r2, r3
 800ecc0:	687b      	ldr	r3, [r7, #4]
 800ecc2:	4413      	add	r3, r2
 800ecc4:	490f      	ldr	r1, [pc, #60]	; (800ed04 <GetDateStringOff+0xb0>)
 800ecc6:	461a      	mov	r2, r3
 800ecc8:	460b      	mov	r3, r1
 800ecca:	881b      	ldrh	r3, [r3, #0]
 800eccc:	8013      	strh	r3, [r2, #0]
	itoa1(dtl.Years,conv_buf);
 800ecce:	8a3b      	ldrh	r3, [r7, #16]
 800ecd0:	461a      	mov	r2, r3
 800ecd2:	f107 0308 	add.w	r3, r7, #8
 800ecd6:	4619      	mov	r1, r3
 800ecd8:	4610      	mov	r0, r2
 800ecda:	4b0c      	ldr	r3, [pc, #48]	; (800ed0c <GetDateStringOff+0xb8>)
 800ecdc:	4798      	blx	r3
	strcat(aBuf,conv_buf);
 800ecde:	f107 0308 	add.w	r3, r7, #8
 800ece2:	4619      	mov	r1, r3
 800ece4:	6878      	ldr	r0, [r7, #4]
 800ece6:	4b08      	ldr	r3, [pc, #32]	; (800ed08 <GetDateStringOff+0xb4>)
 800ece8:	4798      	blx	r3
    }
 800ecea:	bf00      	nop
 800ecec:	3720      	adds	r7, #32
 800ecee:	46bd      	mov	sp, r7
 800ecf0:	bd80      	pop	{r7, pc}
 800ecf2:	bf00      	nop
 800ecf4:	080053f1 	.word	0x080053f1
 800ecf8:	0800e931 	.word	0x0800e931
 800ecfc:	08014675 	.word	0x08014675
 800ed00:	08014731 	.word	0x08014731
 800ed04:	080154f8 	.word	0x080154f8
 800ed08:	08014635 	.word	0x08014635
 800ed0c:	0800e895 	.word	0x0800e895

0800ed10 <JrnlClear>:




int JrnlClear()
    {
 800ed10:	b580      	push	{r7, lr}
 800ed12:	f5ad 6d81 	sub.w	sp, sp, #1032	; 0x408
 800ed16:	af00      	add	r7, sp, #0
    jrnlLength = 1;
 800ed18:	4b1f      	ldr	r3, [pc, #124]	; (800ed98 <JrnlClear+0x88>)
 800ed1a:	2201      	movs	r2, #1
 800ed1c:	801a      	strh	r2, [r3, #0]
    uint32 buf[0x100]={0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,
 800ed1e:	f507 6381 	add.w	r3, r7, #1032	; 0x408
 800ed22:	f2a3 4304 	subw	r3, r3, #1028	; 0x404
 800ed26:	4618      	mov	r0, r3
 800ed28:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800ed2c:	461a      	mov	r2, r3
 800ed2e:	2100      	movs	r1, #0
 800ed30:	4b1a      	ldr	r3, [pc, #104]	; (800ed9c <JrnlClear+0x8c>)
 800ed32:	4798      	blx	r3
	    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,
	    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,
	    0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0
    };

    portENTER_CRITICAL();
 800ed34:	4b1a      	ldr	r3, [pc, #104]	; (800eda0 <JrnlClear+0x90>)
 800ed36:	4798      	blx	r3
    for(int i=0;i<JSIZE;i++)
 800ed38:	2300      	movs	r3, #0
 800ed3a:	f8c7 3404 	str.w	r3, [r7, #1028]	; 0x404
 800ed3e:	e016      	b.n	800ed6e <JrnlClear+0x5e>
	{

	    MemSetWords((uint16)(0x2001+0x17*i), (uint16*)buf, 0x17);
 800ed40:	f8d7 3404 	ldr.w	r3, [r7, #1028]	; 0x404
 800ed44:	b29b      	uxth	r3, r3
 800ed46:	461a      	mov	r2, r3
 800ed48:	0052      	lsls	r2, r2, #1
 800ed4a:	441a      	add	r2, r3
 800ed4c:	00d2      	lsls	r2, r2, #3
 800ed4e:	1ad3      	subs	r3, r2, r3
 800ed50:	b29b      	uxth	r3, r3
 800ed52:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
 800ed56:	3301      	adds	r3, #1
 800ed58:	b29b      	uxth	r3, r3
 800ed5a:	1d39      	adds	r1, r7, #4
 800ed5c:	2217      	movs	r2, #23
 800ed5e:	4618      	mov	r0, r3
 800ed60:	4b10      	ldr	r3, [pc, #64]	; (800eda4 <JrnlClear+0x94>)
 800ed62:	4798      	blx	r3
    for(int i=0;i<JSIZE;i++)
 800ed64:	f8d7 3404 	ldr.w	r3, [r7, #1028]	; 0x404
 800ed68:	3301      	adds	r3, #1
 800ed6a:	f8c7 3404 	str.w	r3, [r7, #1028]	; 0x404
 800ed6e:	f8d7 3404 	ldr.w	r3, [r7, #1028]	; 0x404
 800ed72:	2bf9      	cmp	r3, #249	; 0xf9
 800ed74:	dde4      	ble.n	800ed40 <JrnlClear+0x30>

	   // vTaskDelay(10);
	}

    MemSetWords(0x2000, &jrnlLength, 1);
 800ed76:	2201      	movs	r2, #1
 800ed78:	4907      	ldr	r1, [pc, #28]	; (800ed98 <JrnlClear+0x88>)
 800ed7a:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 800ed7e:	4b09      	ldr	r3, [pc, #36]	; (800eda4 <JrnlClear+0x94>)
 800ed80:	4798      	blx	r3
    portEXIT_CRITICAL();
 800ed82:	4b09      	ldr	r3, [pc, #36]	; (800eda8 <JrnlClear+0x98>)
 800ed84:	4798      	blx	r3
    JrnlWrite(" ");
 800ed86:	4809      	ldr	r0, [pc, #36]	; (800edac <JrnlClear+0x9c>)
 800ed88:	4b09      	ldr	r3, [pc, #36]	; (800edb0 <JrnlClear+0xa0>)
 800ed8a:	4798      	blx	r3
    return true;
 800ed8c:	2301      	movs	r3, #1
    }
 800ed8e:	4618      	mov	r0, r3
 800ed90:	f507 6781 	add.w	r7, r7, #1032	; 0x408
 800ed94:	46bd      	mov	sp, r7
 800ed96:	bd80      	pop	{r7, pc}
 800ed98:	200093fc 	.word	0x200093fc
 800ed9c:	08014591 	.word	0x08014591
 800eda0:	080025f9 	.word	0x080025f9
 800eda4:	08006ca1 	.word	0x08006ca1
 800eda8:	0800261d 	.word	0x0800261d
 800edac:	080154fc 	.word	0x080154fc
 800edb0:	0800edb5 	.word	0x0800edb5

0800edb4 <JrnlWrite>:

int JrnlWrite(char *aMsg)
    {
 800edb4:	b580      	push	{r7, lr}
 800edb6:	b09e      	sub	sp, #120	; 0x78
 800edb8:	af00      	add	r7, sp, #0
 800edba:	6078      	str	r0, [r7, #4]
    uint16 testlen,wrLen;
    char buffer[64];
    char Date[16];
    char Time[16];
    BKP_WriteBackupRegister(BKP_DR7, 23);
 800edbc:	2117      	movs	r1, #23
 800edbe:	201c      	movs	r0, #28
 800edc0:	4b69      	ldr	r3, [pc, #420]	; (800ef68 <JrnlWrite+0x1b4>)
 800edc2:	4798      	blx	r3
    GetDateString(Date);
 800edc4:	f107 0320 	add.w	r3, r7, #32
 800edc8:	4618      	mov	r0, r3
 800edca:	4b68      	ldr	r3, [pc, #416]	; (800ef6c <JrnlWrite+0x1b8>)
 800edcc:	4798      	blx	r3
    GetTimeString(Time);
 800edce:	f107 0310 	add.w	r3, r7, #16
 800edd2:	4618      	mov	r0, r3
 800edd4:	4b66      	ldr	r3, [pc, #408]	; (800ef70 <JrnlWrite+0x1bc>)
 800edd6:	4798      	blx	r3

	char conv_buf[8];
	strcpy(buffer,"<");
 800edd8:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800eddc:	223c      	movs	r2, #60	; 0x3c
 800edde:	801a      	strh	r2, [r3, #0]
	strcat(buffer,Date);
 800ede0:	f107 0220 	add.w	r2, r7, #32
 800ede4:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800ede8:	4611      	mov	r1, r2
 800edea:	4618      	mov	r0, r3
 800edec:	4b61      	ldr	r3, [pc, #388]	; (800ef74 <JrnlWrite+0x1c0>)
 800edee:	4798      	blx	r3
	strcat(buffer,"><");
 800edf0:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800edf4:	4618      	mov	r0, r3
 800edf6:	4b60      	ldr	r3, [pc, #384]	; (800ef78 <JrnlWrite+0x1c4>)
 800edf8:	4798      	blx	r3
 800edfa:	4603      	mov	r3, r0
 800edfc:	461a      	mov	r2, r3
 800edfe:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800ee02:	4413      	add	r3, r2
 800ee04:	4a5d      	ldr	r2, [pc, #372]	; (800ef7c <JrnlWrite+0x1c8>)
 800ee06:	8811      	ldrh	r1, [r2, #0]
 800ee08:	7892      	ldrb	r2, [r2, #2]
 800ee0a:	8019      	strh	r1, [r3, #0]
 800ee0c:	709a      	strb	r2, [r3, #2]
	strcat(buffer,Time);
 800ee0e:	f107 0210 	add.w	r2, r7, #16
 800ee12:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800ee16:	4611      	mov	r1, r2
 800ee18:	4618      	mov	r0, r3
 800ee1a:	4b56      	ldr	r3, [pc, #344]	; (800ef74 <JrnlWrite+0x1c0>)
 800ee1c:	4798      	blx	r3
	strcat(buffer,"><");
 800ee1e:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800ee22:	4618      	mov	r0, r3
 800ee24:	4b54      	ldr	r3, [pc, #336]	; (800ef78 <JrnlWrite+0x1c4>)
 800ee26:	4798      	blx	r3
 800ee28:	4603      	mov	r3, r0
 800ee2a:	461a      	mov	r2, r3
 800ee2c:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800ee30:	4413      	add	r3, r2
 800ee32:	4a52      	ldr	r2, [pc, #328]	; (800ef7c <JrnlWrite+0x1c8>)
 800ee34:	8811      	ldrh	r1, [r2, #0]
 800ee36:	7892      	ldrb	r2, [r2, #2]
 800ee38:	8019      	strh	r1, [r3, #0]
 800ee3a:	709a      	strb	r2, [r3, #2]
	strcat(buffer,aMsg);
 800ee3c:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800ee40:	6879      	ldr	r1, [r7, #4]
 800ee42:	4618      	mov	r0, r3
 800ee44:	4b4b      	ldr	r3, [pc, #300]	; (800ef74 <JrnlWrite+0x1c0>)
 800ee46:	4798      	blx	r3
	int len = strlen(aMsg);
 800ee48:	6878      	ldr	r0, [r7, #4]
 800ee4a:	4b4b      	ldr	r3, [pc, #300]	; (800ef78 <JrnlWrite+0x1c4>)
 800ee4c:	4798      	blx	r3
 800ee4e:	4603      	mov	r3, r0
 800ee50:	677b      	str	r3, [r7, #116]	; 0x74
	while(len++ < 22)
 800ee52:	e00e      	b.n	800ee72 <JrnlWrite+0xbe>
	{
		strcat(buffer," ");
 800ee54:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800ee58:	4618      	mov	r0, r3
 800ee5a:	4b47      	ldr	r3, [pc, #284]	; (800ef78 <JrnlWrite+0x1c4>)
 800ee5c:	4798      	blx	r3
 800ee5e:	4603      	mov	r3, r0
 800ee60:	461a      	mov	r2, r3
 800ee62:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800ee66:	4413      	add	r3, r2
 800ee68:	4945      	ldr	r1, [pc, #276]	; (800ef80 <JrnlWrite+0x1cc>)
 800ee6a:	461a      	mov	r2, r3
 800ee6c:	460b      	mov	r3, r1
 800ee6e:	881b      	ldrh	r3, [r3, #0]
 800ee70:	8013      	strh	r3, [r2, #0]
	while(len++ < 22)
 800ee72:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800ee74:	1c5a      	adds	r2, r3, #1
 800ee76:	677a      	str	r2, [r7, #116]	; 0x74
 800ee78:	2b15      	cmp	r3, #21
 800ee7a:	ddeb      	ble.n	800ee54 <JrnlWrite+0xa0>
	}
	strcat(buffer,">");
 800ee7c:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800ee80:	4618      	mov	r0, r3
 800ee82:	4b3d      	ldr	r3, [pc, #244]	; (800ef78 <JrnlWrite+0x1c4>)
 800ee84:	4798      	blx	r3
 800ee86:	4603      	mov	r3, r0
 800ee88:	461a      	mov	r2, r3
 800ee8a:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800ee8e:	4413      	add	r3, r2
 800ee90:	493c      	ldr	r1, [pc, #240]	; (800ef84 <JrnlWrite+0x1d0>)
 800ee92:	461a      	mov	r2, r3
 800ee94:	460b      	mov	r3, r1
 800ee96:	881b      	ldrh	r3, [r3, #0]
 800ee98:	8013      	strh	r3, [r2, #0]


    vTaskDelay(20);
 800ee9a:	2014      	movs	r0, #20
 800ee9c:	4b3a      	ldr	r3, [pc, #232]	; (800ef88 <JrnlWrite+0x1d4>)
 800ee9e:	4798      	blx	r3
    jrnlLength=GetJrnlLength();
 800eea0:	4b3a      	ldr	r3, [pc, #232]	; (800ef8c <JrnlWrite+0x1d8>)
 800eea2:	4798      	blx	r3
 800eea4:	4603      	mov	r3, r0
 800eea6:	461a      	mov	r2, r3
 800eea8:	4b39      	ldr	r3, [pc, #228]	; (800ef90 <JrnlWrite+0x1dc>)
 800eeaa:	801a      	strh	r2, [r3, #0]

    testlen =(strlen(buffer));
 800eeac:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800eeb0:	4618      	mov	r0, r3
 800eeb2:	4b31      	ldr	r3, [pc, #196]	; (800ef78 <JrnlWrite+0x1c4>)
 800eeb4:	4798      	blx	r3
 800eeb6:	4603      	mov	r3, r0
 800eeb8:	f8a7 3072 	strh.w	r3, [r7, #114]	; 0x72

    if (jrnlLength > JRNLSIZE)
 800eebc:	4b34      	ldr	r3, [pc, #208]	; (800ef90 <JrnlWrite+0x1dc>)
 800eebe:	881b      	ldrh	r3, [r3, #0]
 800eec0:	f241 6276 	movw	r2, #5750	; 0x1676
 800eec4:	4293      	cmp	r3, r2
 800eec6:	d903      	bls.n	800eed0 <JrnlWrite+0x11c>
	{
	    JrnlClear();
 800eec8:	4b32      	ldr	r3, [pc, #200]	; (800ef94 <JrnlWrite+0x1e0>)
 800eeca:	4798      	blx	r3
	    return false;
 800eecc:	2300      	movs	r3, #0
 800eece:	e046      	b.n	800ef5e <JrnlWrite+0x1aa>
	}
    vTaskDelay(20);
 800eed0:	2014      	movs	r0, #20
 800eed2:	4b2d      	ldr	r3, [pc, #180]	; (800ef88 <JrnlWrite+0x1d4>)
 800eed4:	4798      	blx	r3
    BKP_WriteBackupRegister(BKP_DR7, 24);
 800eed6:	2118      	movs	r1, #24
 800eed8:	201c      	movs	r0, #28
 800eeda:	4b23      	ldr	r3, [pc, #140]	; (800ef68 <JrnlWrite+0x1b4>)
 800eedc:	4798      	blx	r3
    portENTER_CRITICAL();
 800eede:	4b2e      	ldr	r3, [pc, #184]	; (800ef98 <JrnlWrite+0x1e4>)
 800eee0:	4798      	blx	r3
    MemSetWords((uint16)(0x2000 + jrnlLength), (uint16*) (buffer), 0x17);
 800eee2:	4b2b      	ldr	r3, [pc, #172]	; (800ef90 <JrnlWrite+0x1dc>)
 800eee4:	881b      	ldrh	r3, [r3, #0]
 800eee6:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
 800eeea:	b29b      	uxth	r3, r3
 800eeec:	f107 0130 	add.w	r1, r7, #48	; 0x30
 800eef0:	2217      	movs	r2, #23
 800eef2:	4618      	mov	r0, r3
 800eef4:	4b29      	ldr	r3, [pc, #164]	; (800ef9c <JrnlWrite+0x1e8>)
 800eef6:	4798      	blx	r3
    portEXIT_CRITICAL();
 800eef8:	4b29      	ldr	r3, [pc, #164]	; (800efa0 <JrnlWrite+0x1ec>)
 800eefa:	4798      	blx	r3
    vTaskDelay(20);
 800eefc:	2014      	movs	r0, #20
 800eefe:	4b22      	ldr	r3, [pc, #136]	; (800ef88 <JrnlWrite+0x1d4>)
 800ef00:	4798      	blx	r3

    jrnlLength += 0x17;
 800ef02:	4b23      	ldr	r3, [pc, #140]	; (800ef90 <JrnlWrite+0x1dc>)
 800ef04:	881b      	ldrh	r3, [r3, #0]
 800ef06:	3317      	adds	r3, #23
 800ef08:	b29a      	uxth	r2, r3
 800ef0a:	4b21      	ldr	r3, [pc, #132]	; (800ef90 <JrnlWrite+0x1dc>)
 800ef0c:	801a      	strh	r2, [r3, #0]
    vTaskDelay(20);
 800ef0e:	2014      	movs	r0, #20
 800ef10:	4b1d      	ldr	r3, [pc, #116]	; (800ef88 <JrnlWrite+0x1d4>)
 800ef12:	4798      	blx	r3
    if (jrnlLength > JRNLSIZE)
 800ef14:	4b1e      	ldr	r3, [pc, #120]	; (800ef90 <JrnlWrite+0x1dc>)
 800ef16:	881b      	ldrh	r3, [r3, #0]
 800ef18:	f241 6276 	movw	r2, #5750	; 0x1676
 800ef1c:	4293      	cmp	r3, r2
 800ef1e:	d902      	bls.n	800ef26 <JrnlWrite+0x172>
   	{
	    jrnlLength=1;
 800ef20:	4b1b      	ldr	r3, [pc, #108]	; (800ef90 <JrnlWrite+0x1dc>)
 800ef22:	2201      	movs	r2, #1
 800ef24:	801a      	strh	r2, [r3, #0]
   	}
    portENTER_CRITICAL();
 800ef26:	4b1c      	ldr	r3, [pc, #112]	; (800ef98 <JrnlWrite+0x1e4>)
 800ef28:	4798      	blx	r3
    BKP_WriteBackupRegister(BKP_DR7, 25);
 800ef2a:	2119      	movs	r1, #25
 800ef2c:	201c      	movs	r0, #28
 800ef2e:	4b0e      	ldr	r3, [pc, #56]	; (800ef68 <JrnlWrite+0x1b4>)
 800ef30:	4798      	blx	r3
    bool x = MemSetWords(0x2000, &jrnlLength, 1);
 800ef32:	2201      	movs	r2, #1
 800ef34:	4916      	ldr	r1, [pc, #88]	; (800ef90 <JrnlWrite+0x1dc>)
 800ef36:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 800ef3a:	4b18      	ldr	r3, [pc, #96]	; (800ef9c <JrnlWrite+0x1e8>)
 800ef3c:	4798      	blx	r3
 800ef3e:	4603      	mov	r3, r0
 800ef40:	f887 3071 	strb.w	r3, [r7, #113]	; 0x71
    portEXIT_CRITICAL();
 800ef44:	4b16      	ldr	r3, [pc, #88]	; (800efa0 <JrnlWrite+0x1ec>)
 800ef46:	4798      	blx	r3
    BKP_WriteBackupRegister(BKP_DR7, 26);
 800ef48:	211a      	movs	r1, #26
 800ef4a:	201c      	movs	r0, #28
 800ef4c:	4b06      	ldr	r3, [pc, #24]	; (800ef68 <JrnlWrite+0x1b4>)
 800ef4e:	4798      	blx	r3
    if(x)
 800ef50:	f897 3071 	ldrb.w	r3, [r7, #113]	; 0x71
 800ef54:	2b00      	cmp	r3, #0
 800ef56:	d001      	beq.n	800ef5c <JrnlWrite+0x1a8>
	{
	return true;
 800ef58:	2301      	movs	r3, #1
 800ef5a:	e000      	b.n	800ef5e <JrnlWrite+0x1aa>
	}else
	    {
	    return false;
 800ef5c:	2300      	movs	r3, #0
	    }
    }
 800ef5e:	4618      	mov	r0, r3
 800ef60:	3778      	adds	r7, #120	; 0x78
 800ef62:	46bd      	mov	sp, r7
 800ef64:	bd80      	pop	{r7, pc}
 800ef66:	bf00      	nop
 800ef68:	08003621 	.word	0x08003621
 800ef6c:	0800eae1 	.word	0x0800eae1
 800ef70:	0800ea29 	.word	0x0800ea29
 800ef74:	08014635 	.word	0x08014635
 800ef78:	08014731 	.word	0x08014731
 800ef7c:	0801550c 	.word	0x0801550c
 800ef80:	08015510 	.word	0x08015510
 800ef84:	08015514 	.word	0x08015514
 800ef88:	08001529 	.word	0x08001529
 800ef8c:	0800f171 	.word	0x0800f171
 800ef90:	200093fc 	.word	0x200093fc
 800ef94:	0800ed11 	.word	0x0800ed11
 800ef98:	080025f9 	.word	0x080025f9
 800ef9c:	08006ca1 	.word	0x08006ca1
 800efa0:	0800261d 	.word	0x0800261d

0800efa4 <JrnlWriteOff>:


int JrnlWriteOff(char *aMsg)
    {
 800efa4:	b580      	push	{r7, lr}
 800efa6:	b09e      	sub	sp, #120	; 0x78
 800efa8:	af00      	add	r7, sp, #0
 800efaa:	6078      	str	r0, [r7, #4]
    uint16 testlen,wrLen;
    char buffer[64];
    char Date[16];
    char Time[16];

    GetDateStringOff(Date);
 800efac:	f107 0320 	add.w	r3, r7, #32
 800efb0:	4618      	mov	r0, r3
 800efb2:	4b61      	ldr	r3, [pc, #388]	; (800f138 <JrnlWriteOff+0x194>)
 800efb4:	4798      	blx	r3
    GetTimeStringOff(Time);
 800efb6:	f107 0310 	add.w	r3, r7, #16
 800efba:	4618      	mov	r0, r3
 800efbc:	4b5f      	ldr	r3, [pc, #380]	; (800f13c <JrnlWriteOff+0x198>)
 800efbe:	4798      	blx	r3

	char conv_buf[8];
	strcpy(buffer,"<");
 800efc0:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800efc4:	223c      	movs	r2, #60	; 0x3c
 800efc6:	801a      	strh	r2, [r3, #0]
	strcat(buffer,Date);
 800efc8:	f107 0220 	add.w	r2, r7, #32
 800efcc:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800efd0:	4611      	mov	r1, r2
 800efd2:	4618      	mov	r0, r3
 800efd4:	4b5a      	ldr	r3, [pc, #360]	; (800f140 <JrnlWriteOff+0x19c>)
 800efd6:	4798      	blx	r3
	strcat(buffer,"><");
 800efd8:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800efdc:	4618      	mov	r0, r3
 800efde:	4b59      	ldr	r3, [pc, #356]	; (800f144 <JrnlWriteOff+0x1a0>)
 800efe0:	4798      	blx	r3
 800efe2:	4603      	mov	r3, r0
 800efe4:	461a      	mov	r2, r3
 800efe6:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800efea:	4413      	add	r3, r2
 800efec:	4a56      	ldr	r2, [pc, #344]	; (800f148 <JrnlWriteOff+0x1a4>)
 800efee:	8811      	ldrh	r1, [r2, #0]
 800eff0:	7892      	ldrb	r2, [r2, #2]
 800eff2:	8019      	strh	r1, [r3, #0]
 800eff4:	709a      	strb	r2, [r3, #2]
	strcat(buffer,Time);
 800eff6:	f107 0210 	add.w	r2, r7, #16
 800effa:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800effe:	4611      	mov	r1, r2
 800f000:	4618      	mov	r0, r3
 800f002:	4b4f      	ldr	r3, [pc, #316]	; (800f140 <JrnlWriteOff+0x19c>)
 800f004:	4798      	blx	r3
	strcat(buffer,"><");
 800f006:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800f00a:	4618      	mov	r0, r3
 800f00c:	4b4d      	ldr	r3, [pc, #308]	; (800f144 <JrnlWriteOff+0x1a0>)
 800f00e:	4798      	blx	r3
 800f010:	4603      	mov	r3, r0
 800f012:	461a      	mov	r2, r3
 800f014:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800f018:	4413      	add	r3, r2
 800f01a:	4a4b      	ldr	r2, [pc, #300]	; (800f148 <JrnlWriteOff+0x1a4>)
 800f01c:	8811      	ldrh	r1, [r2, #0]
 800f01e:	7892      	ldrb	r2, [r2, #2]
 800f020:	8019      	strh	r1, [r3, #0]
 800f022:	709a      	strb	r2, [r3, #2]
	strcat(buffer,aMsg);
 800f024:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800f028:	6879      	ldr	r1, [r7, #4]
 800f02a:	4618      	mov	r0, r3
 800f02c:	4b44      	ldr	r3, [pc, #272]	; (800f140 <JrnlWriteOff+0x19c>)
 800f02e:	4798      	blx	r3
	int len = strlen(aMsg);
 800f030:	6878      	ldr	r0, [r7, #4]
 800f032:	4b44      	ldr	r3, [pc, #272]	; (800f144 <JrnlWriteOff+0x1a0>)
 800f034:	4798      	blx	r3
 800f036:	4603      	mov	r3, r0
 800f038:	677b      	str	r3, [r7, #116]	; 0x74
	while(len++ < 22)
 800f03a:	e00e      	b.n	800f05a <JrnlWriteOff+0xb6>
	{
		strcat(buffer," ");
 800f03c:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800f040:	4618      	mov	r0, r3
 800f042:	4b40      	ldr	r3, [pc, #256]	; (800f144 <JrnlWriteOff+0x1a0>)
 800f044:	4798      	blx	r3
 800f046:	4603      	mov	r3, r0
 800f048:	461a      	mov	r2, r3
 800f04a:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800f04e:	4413      	add	r3, r2
 800f050:	493e      	ldr	r1, [pc, #248]	; (800f14c <JrnlWriteOff+0x1a8>)
 800f052:	461a      	mov	r2, r3
 800f054:	460b      	mov	r3, r1
 800f056:	881b      	ldrh	r3, [r3, #0]
 800f058:	8013      	strh	r3, [r2, #0]
	while(len++ < 22)
 800f05a:	6f7b      	ldr	r3, [r7, #116]	; 0x74
 800f05c:	1c5a      	adds	r2, r3, #1
 800f05e:	677a      	str	r2, [r7, #116]	; 0x74
 800f060:	2b15      	cmp	r3, #21
 800f062:	ddeb      	ble.n	800f03c <JrnlWriteOff+0x98>
	}
	strcat(buffer,">");
 800f064:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800f068:	4618      	mov	r0, r3
 800f06a:	4b36      	ldr	r3, [pc, #216]	; (800f144 <JrnlWriteOff+0x1a0>)
 800f06c:	4798      	blx	r3
 800f06e:	4603      	mov	r3, r0
 800f070:	461a      	mov	r2, r3
 800f072:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800f076:	4413      	add	r3, r2
 800f078:	4935      	ldr	r1, [pc, #212]	; (800f150 <JrnlWriteOff+0x1ac>)
 800f07a:	461a      	mov	r2, r3
 800f07c:	460b      	mov	r3, r1
 800f07e:	881b      	ldrh	r3, [r3, #0]
 800f080:	8013      	strh	r3, [r2, #0]

    vTaskDelay(20);
 800f082:	2014      	movs	r0, #20
 800f084:	4b33      	ldr	r3, [pc, #204]	; (800f154 <JrnlWriteOff+0x1b0>)
 800f086:	4798      	blx	r3
    jrnlLength=GetJrnlLength();
 800f088:	4b33      	ldr	r3, [pc, #204]	; (800f158 <JrnlWriteOff+0x1b4>)
 800f08a:	4798      	blx	r3
 800f08c:	4603      	mov	r3, r0
 800f08e:	461a      	mov	r2, r3
 800f090:	4b32      	ldr	r3, [pc, #200]	; (800f15c <JrnlWriteOff+0x1b8>)
 800f092:	801a      	strh	r2, [r3, #0]

    testlen =(strlen(buffer));
 800f094:	f107 0330 	add.w	r3, r7, #48	; 0x30
 800f098:	4618      	mov	r0, r3
 800f09a:	4b2a      	ldr	r3, [pc, #168]	; (800f144 <JrnlWriteOff+0x1a0>)
 800f09c:	4798      	blx	r3
 800f09e:	4603      	mov	r3, r0
 800f0a0:	f8a7 3072 	strh.w	r3, [r7, #114]	; 0x72

    if (jrnlLength > JRNLSIZE)
 800f0a4:	4b2d      	ldr	r3, [pc, #180]	; (800f15c <JrnlWriteOff+0x1b8>)
 800f0a6:	881b      	ldrh	r3, [r3, #0]
 800f0a8:	f241 6276 	movw	r2, #5750	; 0x1676
 800f0ac:	4293      	cmp	r3, r2
 800f0ae:	d903      	bls.n	800f0b8 <JrnlWriteOff+0x114>
	{
	    JrnlClear();
 800f0b0:	4b2b      	ldr	r3, [pc, #172]	; (800f160 <JrnlWriteOff+0x1bc>)
 800f0b2:	4798      	blx	r3
	    return false;
 800f0b4:	2300      	movs	r3, #0
 800f0b6:	e03a      	b.n	800f12e <JrnlWriteOff+0x18a>
	}
    vTaskDelay(20);
 800f0b8:	2014      	movs	r0, #20
 800f0ba:	4b26      	ldr	r3, [pc, #152]	; (800f154 <JrnlWriteOff+0x1b0>)
 800f0bc:	4798      	blx	r3
    portENTER_CRITICAL();
 800f0be:	4b29      	ldr	r3, [pc, #164]	; (800f164 <JrnlWriteOff+0x1c0>)
 800f0c0:	4798      	blx	r3
    MemSetWords((uint16)(0x2000 + jrnlLength), (uint16*) (buffer), 0x17);
 800f0c2:	4b26      	ldr	r3, [pc, #152]	; (800f15c <JrnlWriteOff+0x1b8>)
 800f0c4:	881b      	ldrh	r3, [r3, #0]
 800f0c6:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
 800f0ca:	b29b      	uxth	r3, r3
 800f0cc:	f107 0130 	add.w	r1, r7, #48	; 0x30
 800f0d0:	2217      	movs	r2, #23
 800f0d2:	4618      	mov	r0, r3
 800f0d4:	4b24      	ldr	r3, [pc, #144]	; (800f168 <JrnlWriteOff+0x1c4>)
 800f0d6:	4798      	blx	r3
    portEXIT_CRITICAL();
 800f0d8:	4b24      	ldr	r3, [pc, #144]	; (800f16c <JrnlWriteOff+0x1c8>)
 800f0da:	4798      	blx	r3
    vTaskDelay(20);
 800f0dc:	2014      	movs	r0, #20
 800f0de:	4b1d      	ldr	r3, [pc, #116]	; (800f154 <JrnlWriteOff+0x1b0>)
 800f0e0:	4798      	blx	r3

    jrnlLength += 0x17;
 800f0e2:	4b1e      	ldr	r3, [pc, #120]	; (800f15c <JrnlWriteOff+0x1b8>)
 800f0e4:	881b      	ldrh	r3, [r3, #0]
 800f0e6:	3317      	adds	r3, #23
 800f0e8:	b29a      	uxth	r2, r3
 800f0ea:	4b1c      	ldr	r3, [pc, #112]	; (800f15c <JrnlWriteOff+0x1b8>)
 800f0ec:	801a      	strh	r2, [r3, #0]
    vTaskDelay(20);
 800f0ee:	2014      	movs	r0, #20
 800f0f0:	4b18      	ldr	r3, [pc, #96]	; (800f154 <JrnlWriteOff+0x1b0>)
 800f0f2:	4798      	blx	r3
    if (jrnlLength > JRNLSIZE)
 800f0f4:	4b19      	ldr	r3, [pc, #100]	; (800f15c <JrnlWriteOff+0x1b8>)
 800f0f6:	881b      	ldrh	r3, [r3, #0]
 800f0f8:	f241 6276 	movw	r2, #5750	; 0x1676
 800f0fc:	4293      	cmp	r3, r2
 800f0fe:	d902      	bls.n	800f106 <JrnlWriteOff+0x162>
   	{
	    jrnlLength=1;
 800f100:	4b16      	ldr	r3, [pc, #88]	; (800f15c <JrnlWriteOff+0x1b8>)
 800f102:	2201      	movs	r2, #1
 800f104:	801a      	strh	r2, [r3, #0]
   	}
    portENTER_CRITICAL();
 800f106:	4b17      	ldr	r3, [pc, #92]	; (800f164 <JrnlWriteOff+0x1c0>)
 800f108:	4798      	blx	r3
    bool x = MemSetWords(0x2000, &jrnlLength, 1);
 800f10a:	2201      	movs	r2, #1
 800f10c:	4913      	ldr	r1, [pc, #76]	; (800f15c <JrnlWriteOff+0x1b8>)
 800f10e:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 800f112:	4b15      	ldr	r3, [pc, #84]	; (800f168 <JrnlWriteOff+0x1c4>)
 800f114:	4798      	blx	r3
 800f116:	4603      	mov	r3, r0
 800f118:	f887 3071 	strb.w	r3, [r7, #113]	; 0x71
    portEXIT_CRITICAL();
 800f11c:	4b13      	ldr	r3, [pc, #76]	; (800f16c <JrnlWriteOff+0x1c8>)
 800f11e:	4798      	blx	r3
    if(x)
 800f120:	f897 3071 	ldrb.w	r3, [r7, #113]	; 0x71
 800f124:	2b00      	cmp	r3, #0
 800f126:	d001      	beq.n	800f12c <JrnlWriteOff+0x188>
	{
	return true;
 800f128:	2301      	movs	r3, #1
 800f12a:	e000      	b.n	800f12e <JrnlWriteOff+0x18a>
	}else
	    {
	    return false;
 800f12c:	2300      	movs	r3, #0
	    }
    }
 800f12e:	4618      	mov	r0, r3
 800f130:	3778      	adds	r7, #120	; 0x78
 800f132:	46bd      	mov	sp, r7
 800f134:	bd80      	pop	{r7, pc}
 800f136:	bf00      	nop
 800f138:	0800ec55 	.word	0x0800ec55
 800f13c:	0800eb9d 	.word	0x0800eb9d
 800f140:	08014635 	.word	0x08014635
 800f144:	08014731 	.word	0x08014731
 800f148:	0801550c 	.word	0x0801550c
 800f14c:	08015510 	.word	0x08015510
 800f150:	08015514 	.word	0x08015514
 800f154:	08001529 	.word	0x08001529
 800f158:	0800f171 	.word	0x0800f171
 800f15c:	200093fc 	.word	0x200093fc
 800f160:	0800ed11 	.word	0x0800ed11
 800f164:	080025f9 	.word	0x080025f9
 800f168:	08006ca1 	.word	0x08006ca1
 800f16c:	0800261d 	.word	0x0800261d

0800f170 <GetJrnlLength>:


uint16 GetJrnlLength()
    {
 800f170:	b580      	push	{r7, lr}
 800f172:	af00      	add	r7, sp, #0

	portENTER_CRITICAL();
 800f174:	4b06      	ldr	r3, [pc, #24]	; (800f190 <GetJrnlLength+0x20>)
 800f176:	4798      	blx	r3
	MemGetWords(0x2000, &jrnlLength, 1);
 800f178:	2201      	movs	r2, #1
 800f17a:	4906      	ldr	r1, [pc, #24]	; (800f194 <GetJrnlLength+0x24>)
 800f17c:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 800f180:	4b05      	ldr	r3, [pc, #20]	; (800f198 <GetJrnlLength+0x28>)
 800f182:	4798      	blx	r3
	portEXIT_CRITICAL();
 800f184:	4b05      	ldr	r3, [pc, #20]	; (800f19c <GetJrnlLength+0x2c>)
 800f186:	4798      	blx	r3
    return jrnlLength;
 800f188:	4b02      	ldr	r3, [pc, #8]	; (800f194 <GetJrnlLength+0x24>)
 800f18a:	881b      	ldrh	r3, [r3, #0]

    }
 800f18c:	4618      	mov	r0, r3
 800f18e:	bd80      	pop	{r7, pc}
 800f190:	080025f9 	.word	0x080025f9
 800f194:	200093fc 	.word	0x200093fc
 800f198:	08006bfd 	.word	0x08006bfd
 800f19c:	0800261d 	.word	0x0800261d

0800f1a0 <JournalConf>:

void JournalConf(int confadr)
{
 800f1a0:	b580      	push	{r7, lr}
 800f1a2:	b082      	sub	sp, #8
 800f1a4:	af00      	add	r7, sp, #0
 800f1a6:	6078      	str	r0, [r7, #4]
	if (confadr==0x200)
 800f1a8:	687b      	ldr	r3, [r7, #4]
 800f1aa:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800f1ae:	d103      	bne.n	800f1b8 <JournalConf+0x18>
	{JrnlWrite(" ");}
 800f1b0:	4820      	ldr	r0, [pc, #128]	; (800f234 <JournalConf+0x94>)
 800f1b2:	4b21      	ldr	r3, [pc, #132]	; (800f238 <JournalConf+0x98>)
 800f1b4:	4798      	blx	r3
			{JrnlWrite(" . ");}
		else if (confadr==0x0)
			{JrnlWrite(".  ");}
		else if (confadr==0x90)
			{JrnlWrite(".  ");}
	}
 800f1b6:	e038      	b.n	800f22a <JournalConf+0x8a>
		else if (confadr==0x500)
 800f1b8:	687b      	ldr	r3, [r7, #4]
 800f1ba:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 800f1be:	d103      	bne.n	800f1c8 <JournalConf+0x28>
			{JrnlWrite(" . ");}
 800f1c0:	481e      	ldr	r0, [pc, #120]	; (800f23c <JournalConf+0x9c>)
 800f1c2:	4b1d      	ldr	r3, [pc, #116]	; (800f238 <JournalConf+0x98>)
 800f1c4:	4798      	blx	r3
	}
 800f1c6:	e030      	b.n	800f22a <JournalConf+0x8a>
		else if (confadr==0x802)
 800f1c8:	687b      	ldr	r3, [r7, #4]
 800f1ca:	f640 0202 	movw	r2, #2050	; 0x802
 800f1ce:	4293      	cmp	r3, r2
 800f1d0:	d103      	bne.n	800f1da <JournalConf+0x3a>
			{JrnlWrite(" . ");}
 800f1d2:	481b      	ldr	r0, [pc, #108]	; (800f240 <JournalConf+0xa0>)
 800f1d4:	4b18      	ldr	r3, [pc, #96]	; (800f238 <JournalConf+0x98>)
 800f1d6:	4798      	blx	r3
	}
 800f1d8:	e027      	b.n	800f22a <JournalConf+0x8a>
		else if (confadr==0xb04)
 800f1da:	687b      	ldr	r3, [r7, #4]
 800f1dc:	f640 3204 	movw	r2, #2820	; 0xb04
 800f1e0:	4293      	cmp	r3, r2
 800f1e2:	d103      	bne.n	800f1ec <JournalConf+0x4c>
			{JrnlWrite(" . ");}
 800f1e4:	4817      	ldr	r0, [pc, #92]	; (800f244 <JournalConf+0xa4>)
 800f1e6:	4b14      	ldr	r3, [pc, #80]	; (800f238 <JournalConf+0x98>)
 800f1e8:	4798      	blx	r3
	}
 800f1ea:	e01e      	b.n	800f22a <JournalConf+0x8a>
		else if (confadr==0xe06)
 800f1ec:	687b      	ldr	r3, [r7, #4]
 800f1ee:	f640 6206 	movw	r2, #3590	; 0xe06
 800f1f2:	4293      	cmp	r3, r2
 800f1f4:	d103      	bne.n	800f1fe <JournalConf+0x5e>
			{JrnlWrite(" . ");}
 800f1f6:	4814      	ldr	r0, [pc, #80]	; (800f248 <JournalConf+0xa8>)
 800f1f8:	4b0f      	ldr	r3, [pc, #60]	; (800f238 <JournalConf+0x98>)
 800f1fa:	4798      	blx	r3
	}
 800f1fc:	e015      	b.n	800f22a <JournalConf+0x8a>
		else if (confadr==0x1108)
 800f1fe:	687b      	ldr	r3, [r7, #4]
 800f200:	f241 1208 	movw	r2, #4360	; 0x1108
 800f204:	4293      	cmp	r3, r2
 800f206:	d103      	bne.n	800f210 <JournalConf+0x70>
			{JrnlWrite(" . ");}
 800f208:	4810      	ldr	r0, [pc, #64]	; (800f24c <JournalConf+0xac>)
 800f20a:	4b0b      	ldr	r3, [pc, #44]	; (800f238 <JournalConf+0x98>)
 800f20c:	4798      	blx	r3
	}
 800f20e:	e00c      	b.n	800f22a <JournalConf+0x8a>
		else if (confadr==0x0)
 800f210:	687b      	ldr	r3, [r7, #4]
 800f212:	2b00      	cmp	r3, #0
 800f214:	d103      	bne.n	800f21e <JournalConf+0x7e>
			{JrnlWrite(".  ");}
 800f216:	480e      	ldr	r0, [pc, #56]	; (800f250 <JournalConf+0xb0>)
 800f218:	4b07      	ldr	r3, [pc, #28]	; (800f238 <JournalConf+0x98>)
 800f21a:	4798      	blx	r3
	}
 800f21c:	e005      	b.n	800f22a <JournalConf+0x8a>
		else if (confadr==0x90)
 800f21e:	687b      	ldr	r3, [r7, #4]
 800f220:	2b90      	cmp	r3, #144	; 0x90
 800f222:	d102      	bne.n	800f22a <JournalConf+0x8a>
			{JrnlWrite(".  ");}
 800f224:	480b      	ldr	r0, [pc, #44]	; (800f254 <JournalConf+0xb4>)
 800f226:	4b04      	ldr	r3, [pc, #16]	; (800f238 <JournalConf+0x98>)
 800f228:	4798      	blx	r3
	}
 800f22a:	bf00      	nop
 800f22c:	3708      	adds	r7, #8
 800f22e:	46bd      	mov	sp, r7
 800f230:	bd80      	pop	{r7, pc}
 800f232:	bf00      	nop
 800f234:	08015518 	.word	0x08015518
 800f238:	0800edb5 	.word	0x0800edb5
 800f23c:	08015530 	.word	0x08015530
 800f240:	08015544 	.word	0x08015544
 800f244:	0801555c 	.word	0x0801555c
 800f248:	08015574 	.word	0x08015574
 800f24c:	0801558c 	.word	0x0801558c
 800f250:	080155a4 	.word	0x080155a4
 800f254:	080155bc 	.word	0x080155bc

0800f258 <Reset>:
uint16 prevErrDiscretLogic[4] = { 0, 0, 0, 0 };
uint16 CountReset = 0;
int manualwork;


void Reset() {
 800f258:	b580      	push	{r7, lr}
 800f25a:	b082      	sub	sp, #8
 800f25c:	af00      	add	r7, sp, #0
	for (int i = 0; i < DEVICE_RAMMEM_WORDS; i++) {
 800f25e:	2300      	movs	r3, #0
 800f260:	607b      	str	r3, [r7, #4]
 800f262:	e00b      	b.n	800f27c <Reset+0x24>
		RAM.dwords[i] = 0;
 800f264:	4a12      	ldr	r2, [pc, #72]	; (800f2b0 <Reset+0x58>)
 800f266:	687b      	ldr	r3, [r7, #4]
 800f268:	2100      	movs	r1, #0
 800f26a:	f802 1013 	strb.w	r1, [r2, r3, lsl #1]
 800f26e:	005b      	lsls	r3, r3, #1
 800f270:	4413      	add	r3, r2
 800f272:	2200      	movs	r2, #0
 800f274:	705a      	strb	r2, [r3, #1]
	for (int i = 0; i < DEVICE_RAMMEM_WORDS; i++) {
 800f276:	687b      	ldr	r3, [r7, #4]
 800f278:	3301      	adds	r3, #1
 800f27a:	607b      	str	r3, [r7, #4]
 800f27c:	687b      	ldr	r3, [r7, #4]
 800f27e:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 800f282:	dbef      	blt.n	800f264 <Reset+0xc>

	}
	JrnlWrite(" ");
 800f284:	480b      	ldr	r0, [pc, #44]	; (800f2b4 <Reset+0x5c>)
 800f286:	4b0c      	ldr	r3, [pc, #48]	; (800f2b8 <Reset+0x60>)
 800f288:	4798      	blx	r3

	GprsIdleMSec = GPRS_IDLE_TIMEOUT_MS+1;
 800f28a:	4b0c      	ldr	r3, [pc, #48]	; (800f2bc <Reset+0x64>)
 800f28c:	4a0c      	ldr	r2, [pc, #48]	; (800f2c0 <Reset+0x68>)
 800f28e:	601a      	str	r2, [r3, #0]
	LedNoModem = 0;
 800f290:	4b0c      	ldr	r3, [pc, #48]	; (800f2c4 <Reset+0x6c>)
 800f292:	2200      	movs	r2, #0
 800f294:	701a      	strb	r2, [r3, #0]
	if (!LedSIM)
 800f296:	4b0c      	ldr	r3, [pc, #48]	; (800f2c8 <Reset+0x70>)
 800f298:	781b      	ldrb	r3, [r3, #0]
 800f29a:	f083 0301 	eor.w	r3, r3, #1
 800f29e:	b2db      	uxtb	r3, r3
 800f2a0:	2b00      	cmp	r3, #0
 800f2a2:	d001      	beq.n	800f2a8 <Reset+0x50>
	{
		CSQ();
 800f2a4:	4b09      	ldr	r3, [pc, #36]	; (800f2cc <Reset+0x74>)
 800f2a6:	4798      	blx	r3
	}
}
 800f2a8:	bf00      	nop
 800f2aa:	3708      	adds	r7, #8
 800f2ac:	46bd      	mov	sp, r7
 800f2ae:	bd80      	pop	{r7, pc}
 800f2b0:	2000745c 	.word	0x2000745c
 800f2b4:	080155d4 	.word	0x080155d4
 800f2b8:	0800edb5 	.word	0x0800edb5
 800f2bc:	200086dc 	.word	0x200086dc
 800f2c0:	0003a981 	.word	0x0003a981
 800f2c4:	200072b8 	.word	0x200072b8
 800f2c8:	200072b9 	.word	0x200072b9
 800f2cc:	0800c0fd 	.word	0x0800c0fd

0800f2d0 <GetChannelBitSignal>:

int GetChannelBitSignal(int channelNum, uint16* ChannelData) {
 800f2d0:	b480      	push	{r7}
 800f2d2:	b083      	sub	sp, #12
 800f2d4:	af00      	add	r7, sp, #0
 800f2d6:	6078      	str	r0, [r7, #4]
 800f2d8:	6039      	str	r1, [r7, #0]

	if (ChannelData[(int) (channelNum / 4)] & (1 << ((4 * channelNum) % 16))) {
 800f2da:	687b      	ldr	r3, [r7, #4]
 800f2dc:	2b00      	cmp	r3, #0
 800f2de:	da00      	bge.n	800f2e2 <GetChannelBitSignal+0x12>
 800f2e0:	3303      	adds	r3, #3
 800f2e2:	109b      	asrs	r3, r3, #2
 800f2e4:	005b      	lsls	r3, r3, #1
 800f2e6:	683a      	ldr	r2, [r7, #0]
 800f2e8:	4413      	add	r3, r2
 800f2ea:	881b      	ldrh	r3, [r3, #0]
 800f2ec:	4619      	mov	r1, r3
 800f2ee:	687b      	ldr	r3, [r7, #4]
 800f2f0:	009b      	lsls	r3, r3, #2
 800f2f2:	425a      	negs	r2, r3
 800f2f4:	f003 030f 	and.w	r3, r3, #15
 800f2f8:	f002 020f 	and.w	r2, r2, #15
 800f2fc:	bf58      	it	pl
 800f2fe:	4253      	negpl	r3, r2
 800f300:	fa41 f303 	asr.w	r3, r1, r3
 800f304:	f003 0301 	and.w	r3, r3, #1
 800f308:	2b00      	cmp	r3, #0
 800f30a:	d001      	beq.n	800f310 <GetChannelBitSignal+0x40>
		return 1;
 800f30c:	2301      	movs	r3, #1
 800f30e:	e000      	b.n	800f312 <GetChannelBitSignal+0x42>
	} else {
		return 0;
 800f310:	2300      	movs	r3, #0
	}
}
 800f312:	4618      	mov	r0, r3
 800f314:	370c      	adds	r7, #12
 800f316:	46bd      	mov	sp, r7
 800f318:	bc80      	pop	{r7}
 800f31a:	4770      	bx	lr

0800f31c <GetChannelBitRepare>:

int GetChannelBitRepare(int channelNum, uint16* ChannelData) {
 800f31c:	b480      	push	{r7}
 800f31e:	b083      	sub	sp, #12
 800f320:	af00      	add	r7, sp, #0
 800f322:	6078      	str	r0, [r7, #4]
 800f324:	6039      	str	r1, [r7, #0]
	else
	{
		return 0;
	}
#else
	if (ChannelData[(int) (channelNum / 4)]
 800f326:	687b      	ldr	r3, [r7, #4]
 800f328:	2b00      	cmp	r3, #0
 800f32a:	da00      	bge.n	800f32e <GetChannelBitRepare+0x12>
 800f32c:	3303      	adds	r3, #3
 800f32e:	109b      	asrs	r3, r3, #2
 800f330:	005b      	lsls	r3, r3, #1
 800f332:	683a      	ldr	r2, [r7, #0]
 800f334:	4413      	add	r3, r2
 800f336:	881b      	ldrh	r3, [r3, #0]
 800f338:	4619      	mov	r1, r3
			& (1 << ((4 * channelNum) % 16 + 3))) {
 800f33a:	687b      	ldr	r3, [r7, #4]
 800f33c:	009b      	lsls	r3, r3, #2
 800f33e:	425a      	negs	r2, r3
 800f340:	f003 030f 	and.w	r3, r3, #15
 800f344:	f002 020f 	and.w	r2, r2, #15
 800f348:	bf58      	it	pl
 800f34a:	4253      	negpl	r3, r2
 800f34c:	3303      	adds	r3, #3
	if (ChannelData[(int) (channelNum / 4)]
 800f34e:	fa41 f303 	asr.w	r3, r1, r3
 800f352:	f003 0301 	and.w	r3, r3, #1
 800f356:	2b00      	cmp	r3, #0
 800f358:	d001      	beq.n	800f35e <GetChannelBitRepare+0x42>
		return 1;
 800f35a:	2301      	movs	r3, #1
 800f35c:	e000      	b.n	800f360 <GetChannelBitRepare+0x44>
	} else {
		return 0;
 800f35e:	2300      	movs	r3, #0
	}
#endif
}
 800f360:	4618      	mov	r0, r3
 800f362:	370c      	adds	r7, #12
 800f364:	46bd      	mov	sp, r7
 800f366:	bc80      	pop	{r7}
 800f368:	4770      	bx	lr

0800f36a <GetChannelBitDirect>:

int GetChannelBitDirect(int channelNum, uint16* ChannelData) {
 800f36a:	b480      	push	{r7}
 800f36c:	b083      	sub	sp, #12
 800f36e:	af00      	add	r7, sp, #0
 800f370:	6078      	str	r0, [r7, #4]
 800f372:	6039      	str	r1, [r7, #0]
	if (ChannelData[(int) (channelNum / 4)]
 800f374:	687b      	ldr	r3, [r7, #4]
 800f376:	2b00      	cmp	r3, #0
 800f378:	da00      	bge.n	800f37c <GetChannelBitDirect+0x12>
 800f37a:	3303      	adds	r3, #3
 800f37c:	109b      	asrs	r3, r3, #2
 800f37e:	005b      	lsls	r3, r3, #1
 800f380:	683a      	ldr	r2, [r7, #0]
 800f382:	4413      	add	r3, r2
 800f384:	881b      	ldrh	r3, [r3, #0]
 800f386:	4619      	mov	r1, r3
			& (1 << ((4 * channelNum) % 16 + 2))) {
 800f388:	687b      	ldr	r3, [r7, #4]
 800f38a:	009b      	lsls	r3, r3, #2
 800f38c:	425a      	negs	r2, r3
 800f38e:	f003 030f 	and.w	r3, r3, #15
 800f392:	f002 020f 	and.w	r2, r2, #15
 800f396:	bf58      	it	pl
 800f398:	4253      	negpl	r3, r2
 800f39a:	3302      	adds	r3, #2
	if (ChannelData[(int) (channelNum / 4)]
 800f39c:	fa41 f303 	asr.w	r3, r1, r3
 800f3a0:	f003 0301 	and.w	r3, r3, #1
 800f3a4:	2b00      	cmp	r3, #0
 800f3a6:	d001      	beq.n	800f3ac <GetChannelBitDirect+0x42>
		return 1;
 800f3a8:	2301      	movs	r3, #1
 800f3aa:	e000      	b.n	800f3ae <GetChannelBitDirect+0x44>
	} else {
		return 0;
 800f3ac:	2300      	movs	r3, #0
	}
}
 800f3ae:	4618      	mov	r0, r3
 800f3b0:	370c      	adds	r7, #12
 800f3b2:	46bd      	mov	sp, r7
 800f3b4:	bc80      	pop	{r7}
 800f3b6:	4770      	bx	lr

0800f3b8 <GetChannelBitReserv>:

int GetChannelBitReserv(int channelNum, uint16* ChannelData) {
 800f3b8:	b480      	push	{r7}
 800f3ba:	b083      	sub	sp, #12
 800f3bc:	af00      	add	r7, sp, #0
 800f3be:	6078      	str	r0, [r7, #4]
 800f3c0:	6039      	str	r1, [r7, #0]
	else
	{
		return 0;
	}
#else
	if (ChannelData[(int) (channelNum / 4)]
 800f3c2:	687b      	ldr	r3, [r7, #4]
 800f3c4:	2b00      	cmp	r3, #0
 800f3c6:	da00      	bge.n	800f3ca <GetChannelBitReserv+0x12>
 800f3c8:	3303      	adds	r3, #3
 800f3ca:	109b      	asrs	r3, r3, #2
 800f3cc:	005b      	lsls	r3, r3, #1
 800f3ce:	683a      	ldr	r2, [r7, #0]
 800f3d0:	4413      	add	r3, r2
 800f3d2:	881b      	ldrh	r3, [r3, #0]
 800f3d4:	4619      	mov	r1, r3
			& (1 << ((4 * channelNum) % 16 + 1)))
 800f3d6:	687b      	ldr	r3, [r7, #4]
 800f3d8:	009b      	lsls	r3, r3, #2
 800f3da:	425a      	negs	r2, r3
 800f3dc:	f003 030f 	and.w	r3, r3, #15
 800f3e0:	f002 020f 	and.w	r2, r2, #15
 800f3e4:	bf58      	it	pl
 800f3e6:	4253      	negpl	r3, r2
 800f3e8:	3301      	adds	r3, #1
	if (ChannelData[(int) (channelNum / 4)]
 800f3ea:	fa41 f303 	asr.w	r3, r1, r3
 800f3ee:	f003 0301 	and.w	r3, r3, #1
 800f3f2:	2b00      	cmp	r3, #0
 800f3f4:	d001      	beq.n	800f3fa <GetChannelBitReserv+0x42>
		return 1;
 800f3f6:	2301      	movs	r3, #1
 800f3f8:	e000      	b.n	800f3fc <GetChannelBitReserv+0x44>
	else
		return 0;
 800f3fa:	2300      	movs	r3, #0
#endif
}
 800f3fc:	4618      	mov	r0, r3
 800f3fe:	370c      	adds	r7, #12
 800f400:	46bd      	mov	sp, r7
 800f402:	bc80      	pop	{r7}
 800f404:	4770      	bx	lr

0800f406 <SetChannelBitSignal>:

void SetChannelBitSignal(int channelNum, uint16* ChannelData, int bit) {
 800f406:	b480      	push	{r7}
 800f408:	b085      	sub	sp, #20
 800f40a:	af00      	add	r7, sp, #0
 800f40c:	60f8      	str	r0, [r7, #12]
 800f40e:	60b9      	str	r1, [r7, #8]
 800f410:	607a      	str	r2, [r7, #4]
	if (bit) {
 800f412:	687b      	ldr	r3, [r7, #4]
 800f414:	2b00      	cmp	r3, #0
 800f416:	d023      	beq.n	800f460 <SetChannelBitSignal+0x5a>
		ChannelData[(int) (channelNum / 4)] =
				ChannelData[(int) (channelNum / 4)]
 800f418:	68fb      	ldr	r3, [r7, #12]
 800f41a:	2b00      	cmp	r3, #0
 800f41c:	da00      	bge.n	800f420 <SetChannelBitSignal+0x1a>
 800f41e:	3303      	adds	r3, #3
 800f420:	109b      	asrs	r3, r3, #2
 800f422:	005b      	lsls	r3, r3, #1
 800f424:	68ba      	ldr	r2, [r7, #8]
 800f426:	4413      	add	r3, r2
 800f428:	881b      	ldrh	r3, [r3, #0]
 800f42a:	b21a      	sxth	r2, r3
						| (1 << (4 * channelNum) % 16);
 800f42c:	68fb      	ldr	r3, [r7, #12]
 800f42e:	009b      	lsls	r3, r3, #2
 800f430:	4259      	negs	r1, r3
 800f432:	f003 030f 	and.w	r3, r3, #15
 800f436:	f001 010f 	and.w	r1, r1, #15
 800f43a:	bf58      	it	pl
 800f43c:	424b      	negpl	r3, r1
 800f43e:	2101      	movs	r1, #1
 800f440:	fa01 f303 	lsl.w	r3, r1, r3
 800f444:	b21b      	sxth	r3, r3
 800f446:	4313      	orrs	r3, r2
 800f448:	b219      	sxth	r1, r3
		ChannelData[(int) (channelNum / 4)] =
 800f44a:	68fb      	ldr	r3, [r7, #12]
 800f44c:	2b00      	cmp	r3, #0
 800f44e:	da00      	bge.n	800f452 <SetChannelBitSignal+0x4c>
 800f450:	3303      	adds	r3, #3
 800f452:	109b      	asrs	r3, r3, #2
 800f454:	005b      	lsls	r3, r3, #1
 800f456:	68ba      	ldr	r2, [r7, #8]
 800f458:	4413      	add	r3, r2
						| (1 << (4 * channelNum) % 16);
 800f45a:	b28a      	uxth	r2, r1
		ChannelData[(int) (channelNum / 4)] =
 800f45c:	801a      	strh	r2, [r3, #0]
	} else {
		ChannelData[(int) (channelNum / 4)] =
				ChannelData[(int) (channelNum / 4)]
						& (~(1 << (4 * channelNum) % 16));
	}
}
 800f45e:	e024      	b.n	800f4aa <SetChannelBitSignal+0xa4>
				ChannelData[(int) (channelNum / 4)]
 800f460:	68fb      	ldr	r3, [r7, #12]
 800f462:	2b00      	cmp	r3, #0
 800f464:	da00      	bge.n	800f468 <SetChannelBitSignal+0x62>
 800f466:	3303      	adds	r3, #3
 800f468:	109b      	asrs	r3, r3, #2
 800f46a:	005b      	lsls	r3, r3, #1
 800f46c:	68ba      	ldr	r2, [r7, #8]
 800f46e:	4413      	add	r3, r2
 800f470:	881b      	ldrh	r3, [r3, #0]
 800f472:	b21a      	sxth	r2, r3
						& (~(1 << (4 * channelNum) % 16));
 800f474:	68fb      	ldr	r3, [r7, #12]
 800f476:	009b      	lsls	r3, r3, #2
 800f478:	4259      	negs	r1, r3
 800f47a:	f003 030f 	and.w	r3, r3, #15
 800f47e:	f001 010f 	and.w	r1, r1, #15
 800f482:	bf58      	it	pl
 800f484:	424b      	negpl	r3, r1
 800f486:	2101      	movs	r1, #1
 800f488:	fa01 f303 	lsl.w	r3, r1, r3
 800f48c:	b21b      	sxth	r3, r3
 800f48e:	43db      	mvns	r3, r3
 800f490:	b21b      	sxth	r3, r3
 800f492:	4013      	ands	r3, r2
 800f494:	b219      	sxth	r1, r3
		ChannelData[(int) (channelNum / 4)] =
 800f496:	68fb      	ldr	r3, [r7, #12]
 800f498:	2b00      	cmp	r3, #0
 800f49a:	da00      	bge.n	800f49e <SetChannelBitSignal+0x98>
 800f49c:	3303      	adds	r3, #3
 800f49e:	109b      	asrs	r3, r3, #2
 800f4a0:	005b      	lsls	r3, r3, #1
 800f4a2:	68ba      	ldr	r2, [r7, #8]
 800f4a4:	4413      	add	r3, r2
						& (~(1 << (4 * channelNum) % 16));
 800f4a6:	b28a      	uxth	r2, r1
		ChannelData[(int) (channelNum / 4)] =
 800f4a8:	801a      	strh	r2, [r3, #0]
}
 800f4aa:	bf00      	nop
 800f4ac:	3714      	adds	r7, #20
 800f4ae:	46bd      	mov	sp, r7
 800f4b0:	bc80      	pop	{r7}
 800f4b2:	4770      	bx	lr

0800f4b4 <SetChannelBitRepare>:
int block[8];
void SetChannelBitRepare(int channelNum, uint16* ChannelData, int bit) {
 800f4b4:	b480      	push	{r7}
 800f4b6:	b085      	sub	sp, #20
 800f4b8:	af00      	add	r7, sp, #0
 800f4ba:	60f8      	str	r0, [r7, #12]
 800f4bc:	60b9      	str	r1, [r7, #8]
 800f4be:	607a      	str	r2, [r7, #4]
		ChannelData[(int) (channelNum / 4)]
		= ChannelData[(int) (channelNum / 4)] & (~(1
						<< ((4* channelNum ) % 16 + 1)));
	}
#else
	if (bit) {
 800f4c0:	687b      	ldr	r3, [r7, #4]
 800f4c2:	2b00      	cmp	r3, #0
 800f4c4:	d029      	beq.n	800f51a <SetChannelBitRepare+0x66>
		ChannelData[(int) (channelNum / 4)] =
				ChannelData[(int) (channelNum / 4)]
 800f4c6:	68fb      	ldr	r3, [r7, #12]
 800f4c8:	2b00      	cmp	r3, #0
 800f4ca:	da00      	bge.n	800f4ce <SetChannelBitRepare+0x1a>
 800f4cc:	3303      	adds	r3, #3
 800f4ce:	109b      	asrs	r3, r3, #2
 800f4d0:	005b      	lsls	r3, r3, #1
 800f4d2:	68ba      	ldr	r2, [r7, #8]
 800f4d4:	4413      	add	r3, r2
 800f4d6:	881b      	ldrh	r3, [r3, #0]
 800f4d8:	b21a      	sxth	r2, r3
						| (1 << ((4 * channelNum) % 16 + 3));
 800f4da:	68fb      	ldr	r3, [r7, #12]
 800f4dc:	009b      	lsls	r3, r3, #2
 800f4de:	4259      	negs	r1, r3
 800f4e0:	f003 030f 	and.w	r3, r3, #15
 800f4e4:	f001 010f 	and.w	r1, r1, #15
 800f4e8:	bf58      	it	pl
 800f4ea:	424b      	negpl	r3, r1
 800f4ec:	3303      	adds	r3, #3
 800f4ee:	2101      	movs	r1, #1
 800f4f0:	fa01 f303 	lsl.w	r3, r1, r3
 800f4f4:	b21b      	sxth	r3, r3
 800f4f6:	4313      	orrs	r3, r2
 800f4f8:	b219      	sxth	r1, r3
		ChannelData[(int) (channelNum / 4)] =
 800f4fa:	68fb      	ldr	r3, [r7, #12]
 800f4fc:	2b00      	cmp	r3, #0
 800f4fe:	da00      	bge.n	800f502 <SetChannelBitRepare+0x4e>
 800f500:	3303      	adds	r3, #3
 800f502:	109b      	asrs	r3, r3, #2
 800f504:	005b      	lsls	r3, r3, #1
 800f506:	68ba      	ldr	r2, [r7, #8]
 800f508:	4413      	add	r3, r2
						| (1 << ((4 * channelNum) % 16 + 3));
 800f50a:	b28a      	uxth	r2, r1
		ChannelData[(int) (channelNum / 4)] =
 800f50c:	801a      	strh	r2, [r3, #0]
		block[channelNum] = 1;
 800f50e:	4a1b      	ldr	r2, [pc, #108]	; (800f57c <SetChannelBitRepare+0xc8>)
 800f510:	68fb      	ldr	r3, [r7, #12]
 800f512:	2101      	movs	r1, #1
 800f514:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
				ChannelData[(int) (channelNum / 4)]
						& (~(1 << ((4 * channelNum) % 16 + 3)));
		block[channelNum] = 0;
	}
#endif
}
 800f518:	e02a      	b.n	800f570 <SetChannelBitRepare+0xbc>
				ChannelData[(int) (channelNum / 4)]
 800f51a:	68fb      	ldr	r3, [r7, #12]
 800f51c:	2b00      	cmp	r3, #0
 800f51e:	da00      	bge.n	800f522 <SetChannelBitRepare+0x6e>
 800f520:	3303      	adds	r3, #3
 800f522:	109b      	asrs	r3, r3, #2
 800f524:	005b      	lsls	r3, r3, #1
 800f526:	68ba      	ldr	r2, [r7, #8]
 800f528:	4413      	add	r3, r2
 800f52a:	881b      	ldrh	r3, [r3, #0]
 800f52c:	b21a      	sxth	r2, r3
						& (~(1 << ((4 * channelNum) % 16 + 3)));
 800f52e:	68fb      	ldr	r3, [r7, #12]
 800f530:	009b      	lsls	r3, r3, #2
 800f532:	4259      	negs	r1, r3
 800f534:	f003 030f 	and.w	r3, r3, #15
 800f538:	f001 010f 	and.w	r1, r1, #15
 800f53c:	bf58      	it	pl
 800f53e:	424b      	negpl	r3, r1
 800f540:	3303      	adds	r3, #3
 800f542:	2101      	movs	r1, #1
 800f544:	fa01 f303 	lsl.w	r3, r1, r3
 800f548:	b21b      	sxth	r3, r3
 800f54a:	43db      	mvns	r3, r3
 800f54c:	b21b      	sxth	r3, r3
 800f54e:	4013      	ands	r3, r2
 800f550:	b219      	sxth	r1, r3
		ChannelData[(int) (channelNum / 4)] =
 800f552:	68fb      	ldr	r3, [r7, #12]
 800f554:	2b00      	cmp	r3, #0
 800f556:	da00      	bge.n	800f55a <SetChannelBitRepare+0xa6>
 800f558:	3303      	adds	r3, #3
 800f55a:	109b      	asrs	r3, r3, #2
 800f55c:	005b      	lsls	r3, r3, #1
 800f55e:	68ba      	ldr	r2, [r7, #8]
 800f560:	4413      	add	r3, r2
						& (~(1 << ((4 * channelNum) % 16 + 3)));
 800f562:	b28a      	uxth	r2, r1
		ChannelData[(int) (channelNum / 4)] =
 800f564:	801a      	strh	r2, [r3, #0]
		block[channelNum] = 0;
 800f566:	4a05      	ldr	r2, [pc, #20]	; (800f57c <SetChannelBitRepare+0xc8>)
 800f568:	68fb      	ldr	r3, [r7, #12]
 800f56a:	2100      	movs	r1, #0
 800f56c:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
}
 800f570:	bf00      	nop
 800f572:	3714      	adds	r7, #20
 800f574:	46bd      	mov	sp, r7
 800f576:	bc80      	pop	{r7}
 800f578:	4770      	bx	lr
 800f57a:	bf00      	nop
 800f57c:	20009434 	.word	0x20009434

0800f580 <SetChannelBitDirect>:

void SetChannelBitDirect(int channelNum, uint16* ChannelData, int bit) {
 800f580:	b480      	push	{r7}
 800f582:	b085      	sub	sp, #20
 800f584:	af00      	add	r7, sp, #0
 800f586:	60f8      	str	r0, [r7, #12]
 800f588:	60b9      	str	r1, [r7, #8]
 800f58a:	607a      	str	r2, [r7, #4]
	if (bit) {
 800f58c:	687b      	ldr	r3, [r7, #4]
 800f58e:	2b00      	cmp	r3, #0
 800f590:	d024      	beq.n	800f5dc <SetChannelBitDirect+0x5c>
		ChannelData[(int) (channelNum / 4)] =
				ChannelData[(int) (channelNum / 4)]
 800f592:	68fb      	ldr	r3, [r7, #12]
 800f594:	2b00      	cmp	r3, #0
 800f596:	da00      	bge.n	800f59a <SetChannelBitDirect+0x1a>
 800f598:	3303      	adds	r3, #3
 800f59a:	109b      	asrs	r3, r3, #2
 800f59c:	005b      	lsls	r3, r3, #1
 800f59e:	68ba      	ldr	r2, [r7, #8]
 800f5a0:	4413      	add	r3, r2
 800f5a2:	881b      	ldrh	r3, [r3, #0]
 800f5a4:	b21a      	sxth	r2, r3
						| (1 << ((4 * channelNum) % 16 + 2));
 800f5a6:	68fb      	ldr	r3, [r7, #12]
 800f5a8:	009b      	lsls	r3, r3, #2
 800f5aa:	4259      	negs	r1, r3
 800f5ac:	f003 030f 	and.w	r3, r3, #15
 800f5b0:	f001 010f 	and.w	r1, r1, #15
 800f5b4:	bf58      	it	pl
 800f5b6:	424b      	negpl	r3, r1
 800f5b8:	3302      	adds	r3, #2
 800f5ba:	2101      	movs	r1, #1
 800f5bc:	fa01 f303 	lsl.w	r3, r1, r3
 800f5c0:	b21b      	sxth	r3, r3
 800f5c2:	4313      	orrs	r3, r2
 800f5c4:	b219      	sxth	r1, r3
		ChannelData[(int) (channelNum / 4)] =
 800f5c6:	68fb      	ldr	r3, [r7, #12]
 800f5c8:	2b00      	cmp	r3, #0
 800f5ca:	da00      	bge.n	800f5ce <SetChannelBitDirect+0x4e>
 800f5cc:	3303      	adds	r3, #3
 800f5ce:	109b      	asrs	r3, r3, #2
 800f5d0:	005b      	lsls	r3, r3, #1
 800f5d2:	68ba      	ldr	r2, [r7, #8]
 800f5d4:	4413      	add	r3, r2
						| (1 << ((4 * channelNum) % 16 + 2));
 800f5d6:	b28a      	uxth	r2, r1
		ChannelData[(int) (channelNum / 4)] =
 800f5d8:	801a      	strh	r2, [r3, #0]
	} else {
		ChannelData[(int) (channelNum / 4)] =
				ChannelData[(int) (channelNum / 4)]
						& (~(1 << ((4 * channelNum) % 16 + 2)));
	}
}
 800f5da:	e025      	b.n	800f628 <SetChannelBitDirect+0xa8>
				ChannelData[(int) (channelNum / 4)]
 800f5dc:	68fb      	ldr	r3, [r7, #12]
 800f5de:	2b00      	cmp	r3, #0
 800f5e0:	da00      	bge.n	800f5e4 <SetChannelBitDirect+0x64>
 800f5e2:	3303      	adds	r3, #3
 800f5e4:	109b      	asrs	r3, r3, #2
 800f5e6:	005b      	lsls	r3, r3, #1
 800f5e8:	68ba      	ldr	r2, [r7, #8]
 800f5ea:	4413      	add	r3, r2
 800f5ec:	881b      	ldrh	r3, [r3, #0]
 800f5ee:	b21a      	sxth	r2, r3
						& (~(1 << ((4 * channelNum) % 16 + 2)));
 800f5f0:	68fb      	ldr	r3, [r7, #12]
 800f5f2:	009b      	lsls	r3, r3, #2
 800f5f4:	4259      	negs	r1, r3
 800f5f6:	f003 030f 	and.w	r3, r3, #15
 800f5fa:	f001 010f 	and.w	r1, r1, #15
 800f5fe:	bf58      	it	pl
 800f600:	424b      	negpl	r3, r1
 800f602:	3302      	adds	r3, #2
 800f604:	2101      	movs	r1, #1
 800f606:	fa01 f303 	lsl.w	r3, r1, r3
 800f60a:	b21b      	sxth	r3, r3
 800f60c:	43db      	mvns	r3, r3
 800f60e:	b21b      	sxth	r3, r3
 800f610:	4013      	ands	r3, r2
 800f612:	b219      	sxth	r1, r3
		ChannelData[(int) (channelNum / 4)] =
 800f614:	68fb      	ldr	r3, [r7, #12]
 800f616:	2b00      	cmp	r3, #0
 800f618:	da00      	bge.n	800f61c <SetChannelBitDirect+0x9c>
 800f61a:	3303      	adds	r3, #3
 800f61c:	109b      	asrs	r3, r3, #2
 800f61e:	005b      	lsls	r3, r3, #1
 800f620:	68ba      	ldr	r2, [r7, #8]
 800f622:	4413      	add	r3, r2
						& (~(1 << ((4 * channelNum) % 16 + 2)));
 800f624:	b28a      	uxth	r2, r1
		ChannelData[(int) (channelNum / 4)] =
 800f626:	801a      	strh	r2, [r3, #0]
}
 800f628:	bf00      	nop
 800f62a:	3714      	adds	r7, #20
 800f62c:	46bd      	mov	sp, r7
 800f62e:	bc80      	pop	{r7}
 800f630:	4770      	bx	lr

0800f632 <SetChannelBitReserv>:

void SetChannelBitReserv(int channelNum, uint16* ChannelData, int bit) {
 800f632:	b480      	push	{r7}
 800f634:	b085      	sub	sp, #20
 800f636:	af00      	add	r7, sp, #0
 800f638:	60f8      	str	r0, [r7, #12]
 800f63a:	60b9      	str	r1, [r7, #8]
 800f63c:	607a      	str	r2, [r7, #4]
		ChannelData[(int) (channelNum / 4)]
		= ChannelData[(int) (channelNum / 4)] & (~(1
						<< ((4* channelNum ) % 16 + 3)));
	}
#else
	if (bit) {
 800f63e:	687b      	ldr	r3, [r7, #4]
 800f640:	2b00      	cmp	r3, #0
 800f642:	d024      	beq.n	800f68e <SetChannelBitReserv+0x5c>
		ChannelData[(int) (channelNum / 4)] =
				ChannelData[(int) (channelNum / 4)]
 800f644:	68fb      	ldr	r3, [r7, #12]
 800f646:	2b00      	cmp	r3, #0
 800f648:	da00      	bge.n	800f64c <SetChannelBitReserv+0x1a>
 800f64a:	3303      	adds	r3, #3
 800f64c:	109b      	asrs	r3, r3, #2
 800f64e:	005b      	lsls	r3, r3, #1
 800f650:	68ba      	ldr	r2, [r7, #8]
 800f652:	4413      	add	r3, r2
 800f654:	881b      	ldrh	r3, [r3, #0]
 800f656:	b21a      	sxth	r2, r3
						| (1 << ((4 * channelNum) % 16 + 1));
 800f658:	68fb      	ldr	r3, [r7, #12]
 800f65a:	009b      	lsls	r3, r3, #2
 800f65c:	4259      	negs	r1, r3
 800f65e:	f003 030f 	and.w	r3, r3, #15
 800f662:	f001 010f 	and.w	r1, r1, #15
 800f666:	bf58      	it	pl
 800f668:	424b      	negpl	r3, r1
 800f66a:	3301      	adds	r3, #1
 800f66c:	2101      	movs	r1, #1
 800f66e:	fa01 f303 	lsl.w	r3, r1, r3
 800f672:	b21b      	sxth	r3, r3
 800f674:	4313      	orrs	r3, r2
 800f676:	b219      	sxth	r1, r3
		ChannelData[(int) (channelNum / 4)] =
 800f678:	68fb      	ldr	r3, [r7, #12]
 800f67a:	2b00      	cmp	r3, #0
 800f67c:	da00      	bge.n	800f680 <SetChannelBitReserv+0x4e>
 800f67e:	3303      	adds	r3, #3
 800f680:	109b      	asrs	r3, r3, #2
 800f682:	005b      	lsls	r3, r3, #1
 800f684:	68ba      	ldr	r2, [r7, #8]
 800f686:	4413      	add	r3, r2
						| (1 << ((4 * channelNum) % 16 + 1));
 800f688:	b28a      	uxth	r2, r1
		ChannelData[(int) (channelNum / 4)] =
 800f68a:	801a      	strh	r2, [r3, #0]
		ChannelData[(int) (channelNum / 4)] =
				ChannelData[(int) (channelNum / 4)]
						& (~(1 << ((4 * channelNum) % 16 + 1)));
	}
#endif
}
 800f68c:	e025      	b.n	800f6da <SetChannelBitReserv+0xa8>
				ChannelData[(int) (channelNum / 4)]
 800f68e:	68fb      	ldr	r3, [r7, #12]
 800f690:	2b00      	cmp	r3, #0
 800f692:	da00      	bge.n	800f696 <SetChannelBitReserv+0x64>
 800f694:	3303      	adds	r3, #3
 800f696:	109b      	asrs	r3, r3, #2
 800f698:	005b      	lsls	r3, r3, #1
 800f69a:	68ba      	ldr	r2, [r7, #8]
 800f69c:	4413      	add	r3, r2
 800f69e:	881b      	ldrh	r3, [r3, #0]
 800f6a0:	b21a      	sxth	r2, r3
						& (~(1 << ((4 * channelNum) % 16 + 1)));
 800f6a2:	68fb      	ldr	r3, [r7, #12]
 800f6a4:	009b      	lsls	r3, r3, #2
 800f6a6:	4259      	negs	r1, r3
 800f6a8:	f003 030f 	and.w	r3, r3, #15
 800f6ac:	f001 010f 	and.w	r1, r1, #15
 800f6b0:	bf58      	it	pl
 800f6b2:	424b      	negpl	r3, r1
 800f6b4:	3301      	adds	r3, #1
 800f6b6:	2101      	movs	r1, #1
 800f6b8:	fa01 f303 	lsl.w	r3, r1, r3
 800f6bc:	b21b      	sxth	r3, r3
 800f6be:	43db      	mvns	r3, r3
 800f6c0:	b21b      	sxth	r3, r3
 800f6c2:	4013      	ands	r3, r2
 800f6c4:	b219      	sxth	r1, r3
		ChannelData[(int) (channelNum / 4)] =
 800f6c6:	68fb      	ldr	r3, [r7, #12]
 800f6c8:	2b00      	cmp	r3, #0
 800f6ca:	da00      	bge.n	800f6ce <SetChannelBitReserv+0x9c>
 800f6cc:	3303      	adds	r3, #3
 800f6ce:	109b      	asrs	r3, r3, #2
 800f6d0:	005b      	lsls	r3, r3, #1
 800f6d2:	68ba      	ldr	r2, [r7, #8]
 800f6d4:	4413      	add	r3, r2
						& (~(1 << ((4 * channelNum) % 16 + 1)));
 800f6d6:	b28a      	uxth	r2, r1
		ChannelData[(int) (channelNum / 4)] =
 800f6d8:	801a      	strh	r2, [r3, #0]
}
 800f6da:	bf00      	nop
 800f6dc:	3714      	adds	r7, #20
 800f6de:	46bd      	mov	sp, r7
 800f6e0:	bc80      	pop	{r7}
 800f6e2:	4770      	bx	lr

0800f6e4 <GetDiskretFromRam>:

int GetDiskretFromRam(int i) {
 800f6e4:	b480      	push	{r7}
 800f6e6:	b083      	sub	sp, #12
 800f6e8:	af00      	add	r7, sp, #0
 800f6ea:	6078      	str	r0, [r7, #4]

	return ((RAM.diskrets[i / 11] >> (i % 11)) & 0x1);
 800f6ec:	687b      	ldr	r3, [r7, #4]
 800f6ee:	4a11      	ldr	r2, [pc, #68]	; (800f734 <GetDiskretFromRam+0x50>)
 800f6f0:	fb82 1203 	smull	r1, r2, r2, r3
 800f6f4:	1052      	asrs	r2, r2, #1
 800f6f6:	17db      	asrs	r3, r3, #31
 800f6f8:	1ad3      	subs	r3, r2, r3
 800f6fa:	4a0f      	ldr	r2, [pc, #60]	; (800f738 <GetDiskretFromRam+0x54>)
 800f6fc:	f503 7300 	add.w	r3, r3, #512	; 0x200
 800f700:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 800f704:	b29b      	uxth	r3, r3
 800f706:	4618      	mov	r0, r3
 800f708:	6879      	ldr	r1, [r7, #4]
 800f70a:	4b0a      	ldr	r3, [pc, #40]	; (800f734 <GetDiskretFromRam+0x50>)
 800f70c:	fb83 2301 	smull	r2, r3, r3, r1
 800f710:	105a      	asrs	r2, r3, #1
 800f712:	17cb      	asrs	r3, r1, #31
 800f714:	1ad2      	subs	r2, r2, r3
 800f716:	4613      	mov	r3, r2
 800f718:	009b      	lsls	r3, r3, #2
 800f71a:	4413      	add	r3, r2
 800f71c:	005b      	lsls	r3, r3, #1
 800f71e:	4413      	add	r3, r2
 800f720:	1aca      	subs	r2, r1, r3
 800f722:	fa40 f302 	asr.w	r3, r0, r2
 800f726:	f003 0301 	and.w	r3, r3, #1
}
 800f72a:	4618      	mov	r0, r3
 800f72c:	370c      	adds	r7, #12
 800f72e:	46bd      	mov	sp, r7
 800f730:	bc80      	pop	{r7}
 800f732:	4770      	bx	lr
 800f734:	2e8ba2e9 	.word	0x2e8ba2e9
 800f738:	2000745c 	.word	0x2000745c

0800f73c <SetRelayToRam>:
void SetRelayToRam(int i, int vol) {
 800f73c:	b480      	push	{r7}
 800f73e:	b083      	sub	sp, #12
 800f740:	af00      	add	r7, sp, #0
 800f742:	6078      	str	r0, [r7, #4]
 800f744:	6039      	str	r1, [r7, #0]
	if (vol != 0) {
 800f746:	683b      	ldr	r3, [r7, #0]
 800f748:	2b00      	cmp	r3, #0
 800f74a:	d022      	beq.n	800f792 <SetRelayToRam+0x56>
		RAM.relays[i / 16] |= (1 << (i % 16));
 800f74c:	687b      	ldr	r3, [r7, #4]
 800f74e:	2b00      	cmp	r3, #0
 800f750:	da00      	bge.n	800f754 <SetRelayToRam+0x18>
 800f752:	330f      	adds	r3, #15
 800f754:	111b      	asrs	r3, r3, #4
 800f756:	461a      	mov	r2, r3
 800f758:	4922      	ldr	r1, [pc, #136]	; (800f7e4 <SetRelayToRam+0xa8>)
 800f75a:	f502 7301 	add.w	r3, r2, #516	; 0x204
 800f75e:	f831 3013 	ldrh.w	r3, [r1, r3, lsl #1]
 800f762:	b29b      	uxth	r3, r3
 800f764:	b219      	sxth	r1, r3
 800f766:	687b      	ldr	r3, [r7, #4]
 800f768:	4258      	negs	r0, r3
 800f76a:	f003 030f 	and.w	r3, r3, #15
 800f76e:	f000 000f 	and.w	r0, r0, #15
 800f772:	bf58      	it	pl
 800f774:	4243      	negpl	r3, r0
 800f776:	2001      	movs	r0, #1
 800f778:	fa00 f303 	lsl.w	r3, r0, r3
 800f77c:	b21b      	sxth	r3, r3
 800f77e:	430b      	orrs	r3, r1
 800f780:	b21b      	sxth	r3, r3
 800f782:	b298      	uxth	r0, r3
 800f784:	4917      	ldr	r1, [pc, #92]	; (800f7e4 <SetRelayToRam+0xa8>)
 800f786:	f502 7301 	add.w	r3, r2, #516	; 0x204
 800f78a:	4602      	mov	r2, r0
 800f78c:	f821 2013 	strh.w	r2, [r1, r3, lsl #1]
	} else {
		RAM.relays[i / 16] &= ~(1 << (i % 16));
	}
}
 800f790:	e023      	b.n	800f7da <SetRelayToRam+0x9e>
		RAM.relays[i / 16] &= ~(1 << (i % 16));
 800f792:	687b      	ldr	r3, [r7, #4]
 800f794:	2b00      	cmp	r3, #0
 800f796:	da00      	bge.n	800f79a <SetRelayToRam+0x5e>
 800f798:	330f      	adds	r3, #15
 800f79a:	111b      	asrs	r3, r3, #4
 800f79c:	461a      	mov	r2, r3
 800f79e:	4911      	ldr	r1, [pc, #68]	; (800f7e4 <SetRelayToRam+0xa8>)
 800f7a0:	f502 7301 	add.w	r3, r2, #516	; 0x204
 800f7a4:	f831 3013 	ldrh.w	r3, [r1, r3, lsl #1]
 800f7a8:	b29b      	uxth	r3, r3
 800f7aa:	b219      	sxth	r1, r3
 800f7ac:	687b      	ldr	r3, [r7, #4]
 800f7ae:	4258      	negs	r0, r3
 800f7b0:	f003 030f 	and.w	r3, r3, #15
 800f7b4:	f000 000f 	and.w	r0, r0, #15
 800f7b8:	bf58      	it	pl
 800f7ba:	4243      	negpl	r3, r0
 800f7bc:	2001      	movs	r0, #1
 800f7be:	fa00 f303 	lsl.w	r3, r0, r3
 800f7c2:	b21b      	sxth	r3, r3
 800f7c4:	43db      	mvns	r3, r3
 800f7c6:	b21b      	sxth	r3, r3
 800f7c8:	400b      	ands	r3, r1
 800f7ca:	b21b      	sxth	r3, r3
 800f7cc:	b298      	uxth	r0, r3
 800f7ce:	4905      	ldr	r1, [pc, #20]	; (800f7e4 <SetRelayToRam+0xa8>)
 800f7d0:	f502 7301 	add.w	r3, r2, #516	; 0x204
 800f7d4:	4602      	mov	r2, r0
 800f7d6:	f821 2013 	strh.w	r2, [r1, r3, lsl #1]
}
 800f7da:	bf00      	nop
 800f7dc:	370c      	adds	r7, #12
 800f7de:	46bd      	mov	sp, r7
 800f7e0:	bc80      	pop	{r7}
 800f7e2:	4770      	bx	lr
 800f7e4:	2000745c 	.word	0x2000745c

0800f7e8 <CheckDiscretMask>:
int CheckDiscretMask(uint16 *mask) {
 800f7e8:	b480      	push	{r7}
 800f7ea:	b085      	sub	sp, #20
 800f7ec:	af00      	add	r7, sp, #0
 800f7ee:	6078      	str	r0, [r7, #4]
	int rezult = 1;
 800f7f0:	2301      	movs	r3, #1
 800f7f2:	60fb      	str	r3, [r7, #12]
	for (int i = 0; i < 4; i++) {
 800f7f4:	2300      	movs	r3, #0
 800f7f6:	60bb      	str	r3, [r7, #8]
 800f7f8:	e07f      	b.n	800f8fa <CheckDiscretMask+0x112>
		if ((RAM.diskrets[i] & mask[i]) != (mask[i])) {
 800f7fa:	4a45      	ldr	r2, [pc, #276]	; (800f910 <CheckDiscretMask+0x128>)
 800f7fc:	68bb      	ldr	r3, [r7, #8]
 800f7fe:	f503 7300 	add.w	r3, r3, #512	; 0x200
 800f802:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 800f806:	b29a      	uxth	r2, r3
 800f808:	68bb      	ldr	r3, [r7, #8]
 800f80a:	005b      	lsls	r3, r3, #1
 800f80c:	6879      	ldr	r1, [r7, #4]
 800f80e:	440b      	add	r3, r1
 800f810:	881b      	ldrh	r3, [r3, #0]
 800f812:	4013      	ands	r3, r2
 800f814:	b29a      	uxth	r2, r3
 800f816:	68bb      	ldr	r3, [r7, #8]
 800f818:	005b      	lsls	r3, r3, #1
 800f81a:	6879      	ldr	r1, [r7, #4]
 800f81c:	440b      	add	r3, r1
 800f81e:	881b      	ldrh	r3, [r3, #0]
 800f820:	429a      	cmp	r2, r3
 800f822:	d04b      	beq.n	800f8bc <CheckDiscretMask+0xd4>
			rezult = 0;
 800f824:	2300      	movs	r3, #0
 800f826:	60fb      	str	r3, [r7, #12]
			RAM.ErrorDiscretLogic[i] &= (~mask[i]);
 800f828:	4a39      	ldr	r2, [pc, #228]	; (800f910 <CheckDiscretMask+0x128>)
 800f82a:	68bb      	ldr	r3, [r7, #8]
 800f82c:	f503 7341 	add.w	r3, r3, #772	; 0x304
 800f830:	005b      	lsls	r3, r3, #1
 800f832:	4413      	add	r3, r2
 800f834:	885b      	ldrh	r3, [r3, #2]
 800f836:	b29b      	uxth	r3, r3
 800f838:	b21a      	sxth	r2, r3
 800f83a:	68bb      	ldr	r3, [r7, #8]
 800f83c:	005b      	lsls	r3, r3, #1
 800f83e:	6879      	ldr	r1, [r7, #4]
 800f840:	440b      	add	r3, r1
 800f842:	881b      	ldrh	r3, [r3, #0]
 800f844:	b21b      	sxth	r3, r3
 800f846:	43db      	mvns	r3, r3
 800f848:	b21b      	sxth	r3, r3
 800f84a:	4013      	ands	r3, r2
 800f84c:	b21b      	sxth	r3, r3
 800f84e:	b299      	uxth	r1, r3
 800f850:	4a2f      	ldr	r2, [pc, #188]	; (800f910 <CheckDiscretMask+0x128>)
 800f852:	68bb      	ldr	r3, [r7, #8]
 800f854:	f503 7341 	add.w	r3, r3, #772	; 0x304
 800f858:	005b      	lsls	r3, r3, #1
 800f85a:	4413      	add	r3, r2
 800f85c:	460a      	mov	r2, r1
 800f85e:	805a      	strh	r2, [r3, #2]
			RAM.ErrorDiscretLogic[i] |= ((~(RAM.diskrets[i] & mask[i]))
 800f860:	4a2b      	ldr	r2, [pc, #172]	; (800f910 <CheckDiscretMask+0x128>)
 800f862:	68bb      	ldr	r3, [r7, #8]
 800f864:	f503 7341 	add.w	r3, r3, #772	; 0x304
 800f868:	005b      	lsls	r3, r3, #1
 800f86a:	4413      	add	r3, r2
 800f86c:	885b      	ldrh	r3, [r3, #2]
 800f86e:	b29b      	uxth	r3, r3
 800f870:	b21a      	sxth	r2, r3
 800f872:	4927      	ldr	r1, [pc, #156]	; (800f910 <CheckDiscretMask+0x128>)
 800f874:	68bb      	ldr	r3, [r7, #8]
 800f876:	f503 7300 	add.w	r3, r3, #512	; 0x200
 800f87a:	f831 3013 	ldrh.w	r3, [r1, r3, lsl #1]
 800f87e:	b299      	uxth	r1, r3
 800f880:	68bb      	ldr	r3, [r7, #8]
 800f882:	005b      	lsls	r3, r3, #1
 800f884:	6878      	ldr	r0, [r7, #4]
 800f886:	4403      	add	r3, r0
 800f888:	881b      	ldrh	r3, [r3, #0]
					& mask[i]);
 800f88a:	400b      	ands	r3, r1
 800f88c:	b29b      	uxth	r3, r3
 800f88e:	b21b      	sxth	r3, r3
 800f890:	43db      	mvns	r3, r3
 800f892:	b219      	sxth	r1, r3
 800f894:	68bb      	ldr	r3, [r7, #8]
 800f896:	005b      	lsls	r3, r3, #1
 800f898:	6878      	ldr	r0, [r7, #4]
 800f89a:	4403      	add	r3, r0
 800f89c:	881b      	ldrh	r3, [r3, #0]
 800f89e:	b21b      	sxth	r3, r3
 800f8a0:	400b      	ands	r3, r1
 800f8a2:	b21b      	sxth	r3, r3
			RAM.ErrorDiscretLogic[i] |= ((~(RAM.diskrets[i] & mask[i]))
 800f8a4:	4313      	orrs	r3, r2
 800f8a6:	b21b      	sxth	r3, r3
 800f8a8:	b299      	uxth	r1, r3
 800f8aa:	4a19      	ldr	r2, [pc, #100]	; (800f910 <CheckDiscretMask+0x128>)
 800f8ac:	68bb      	ldr	r3, [r7, #8]
 800f8ae:	f503 7341 	add.w	r3, r3, #772	; 0x304
 800f8b2:	005b      	lsls	r3, r3, #1
 800f8b4:	4413      	add	r3, r2
 800f8b6:	460a      	mov	r2, r1
 800f8b8:	805a      	strh	r2, [r3, #2]
 800f8ba:	e01b      	b.n	800f8f4 <CheckDiscretMask+0x10c>
		} else {
			RAM.ErrorDiscretLogic[i] &= (~mask[i]);
 800f8bc:	4a14      	ldr	r2, [pc, #80]	; (800f910 <CheckDiscretMask+0x128>)
 800f8be:	68bb      	ldr	r3, [r7, #8]
 800f8c0:	f503 7341 	add.w	r3, r3, #772	; 0x304
 800f8c4:	005b      	lsls	r3, r3, #1
 800f8c6:	4413      	add	r3, r2
 800f8c8:	885b      	ldrh	r3, [r3, #2]
 800f8ca:	b29b      	uxth	r3, r3
 800f8cc:	b21a      	sxth	r2, r3
 800f8ce:	68bb      	ldr	r3, [r7, #8]
 800f8d0:	005b      	lsls	r3, r3, #1
 800f8d2:	6879      	ldr	r1, [r7, #4]
 800f8d4:	440b      	add	r3, r1
 800f8d6:	881b      	ldrh	r3, [r3, #0]
 800f8d8:	b21b      	sxth	r3, r3
 800f8da:	43db      	mvns	r3, r3
 800f8dc:	b21b      	sxth	r3, r3
 800f8de:	4013      	ands	r3, r2
 800f8e0:	b21b      	sxth	r3, r3
 800f8e2:	b299      	uxth	r1, r3
 800f8e4:	4a0a      	ldr	r2, [pc, #40]	; (800f910 <CheckDiscretMask+0x128>)
 800f8e6:	68bb      	ldr	r3, [r7, #8]
 800f8e8:	f503 7341 	add.w	r3, r3, #772	; 0x304
 800f8ec:	005b      	lsls	r3, r3, #1
 800f8ee:	4413      	add	r3, r2
 800f8f0:	460a      	mov	r2, r1
 800f8f2:	805a      	strh	r2, [r3, #2]
	for (int i = 0; i < 4; i++) {
 800f8f4:	68bb      	ldr	r3, [r7, #8]
 800f8f6:	3301      	adds	r3, #1
 800f8f8:	60bb      	str	r3, [r7, #8]
 800f8fa:	68bb      	ldr	r3, [r7, #8]
 800f8fc:	2b03      	cmp	r3, #3
 800f8fe:	f77f af7c 	ble.w	800f7fa <CheckDiscretMask+0x12>
		}
	}
	return rezult;
 800f902:	68fb      	ldr	r3, [r7, #12]
}
 800f904:	4618      	mov	r0, r3
 800f906:	3714      	adds	r7, #20
 800f908:	46bd      	mov	sp, r7
 800f90a:	bc80      	pop	{r7}
 800f90c:	4770      	bx	lr
 800f90e:	bf00      	nop
 800f910:	2000745c 	.word	0x2000745c

0800f914 <CheckDiscretMaskNegative>:

int CheckDiscretMaskNegative(uint16 *mask) {
 800f914:	b480      	push	{r7}
 800f916:	b085      	sub	sp, #20
 800f918:	af00      	add	r7, sp, #0
 800f91a:	6078      	str	r0, [r7, #4]
	int rezult = 1;
 800f91c:	2301      	movs	r3, #1
 800f91e:	60fb      	str	r3, [r7, #12]
	for (int i = 0; i < 4; i++) {
 800f920:	2300      	movs	r3, #0
 800f922:	60bb      	str	r3, [r7, #8]
 800f924:	e06d      	b.n	800fa02 <CheckDiscretMaskNegative+0xee>
		if ((RAM.diskrets[i] & mask[i]) == 0) {
 800f926:	4a3b      	ldr	r2, [pc, #236]	; (800fa14 <CheckDiscretMaskNegative+0x100>)
 800f928:	68bb      	ldr	r3, [r7, #8]
 800f92a:	f503 7300 	add.w	r3, r3, #512	; 0x200
 800f92e:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 800f932:	b29a      	uxth	r2, r3
 800f934:	68bb      	ldr	r3, [r7, #8]
 800f936:	005b      	lsls	r3, r3, #1
 800f938:	6879      	ldr	r1, [r7, #4]
 800f93a:	440b      	add	r3, r1
 800f93c:	881b      	ldrh	r3, [r3, #0]
 800f93e:	4013      	ands	r3, r2
 800f940:	b29b      	uxth	r3, r3
 800f942:	2b00      	cmp	r3, #0
 800f944:	d11c      	bne.n	800f980 <CheckDiscretMaskNegative+0x6c>
			RAM.ErrorDiscretLogic[i] &= (~mask[i]);
 800f946:	4a33      	ldr	r2, [pc, #204]	; (800fa14 <CheckDiscretMaskNegative+0x100>)
 800f948:	68bb      	ldr	r3, [r7, #8]
 800f94a:	f503 7341 	add.w	r3, r3, #772	; 0x304
 800f94e:	005b      	lsls	r3, r3, #1
 800f950:	4413      	add	r3, r2
 800f952:	885b      	ldrh	r3, [r3, #2]
 800f954:	b29b      	uxth	r3, r3
 800f956:	b21a      	sxth	r2, r3
 800f958:	68bb      	ldr	r3, [r7, #8]
 800f95a:	005b      	lsls	r3, r3, #1
 800f95c:	6879      	ldr	r1, [r7, #4]
 800f95e:	440b      	add	r3, r1
 800f960:	881b      	ldrh	r3, [r3, #0]
 800f962:	b21b      	sxth	r3, r3
 800f964:	43db      	mvns	r3, r3
 800f966:	b21b      	sxth	r3, r3
 800f968:	4013      	ands	r3, r2
 800f96a:	b21b      	sxth	r3, r3
 800f96c:	b299      	uxth	r1, r3
 800f96e:	4a29      	ldr	r2, [pc, #164]	; (800fa14 <CheckDiscretMaskNegative+0x100>)
 800f970:	68bb      	ldr	r3, [r7, #8]
 800f972:	f503 7341 	add.w	r3, r3, #772	; 0x304
 800f976:	005b      	lsls	r3, r3, #1
 800f978:	4413      	add	r3, r2
 800f97a:	460a      	mov	r2, r1
 800f97c:	805a      	strh	r2, [r3, #2]
 800f97e:	e03d      	b.n	800f9fc <CheckDiscretMaskNegative+0xe8>
		} else {
			rezult = 0;
 800f980:	2300      	movs	r3, #0
 800f982:	60fb      	str	r3, [r7, #12]
			RAM.ErrorDiscretLogic[i] &= (~mask[i]);
 800f984:	4a23      	ldr	r2, [pc, #140]	; (800fa14 <CheckDiscretMaskNegative+0x100>)
 800f986:	68bb      	ldr	r3, [r7, #8]
 800f988:	f503 7341 	add.w	r3, r3, #772	; 0x304
 800f98c:	005b      	lsls	r3, r3, #1
 800f98e:	4413      	add	r3, r2
 800f990:	885b      	ldrh	r3, [r3, #2]
 800f992:	b29b      	uxth	r3, r3
 800f994:	b21a      	sxth	r2, r3
 800f996:	68bb      	ldr	r3, [r7, #8]
 800f998:	005b      	lsls	r3, r3, #1
 800f99a:	6879      	ldr	r1, [r7, #4]
 800f99c:	440b      	add	r3, r1
 800f99e:	881b      	ldrh	r3, [r3, #0]
 800f9a0:	b21b      	sxth	r3, r3
 800f9a2:	43db      	mvns	r3, r3
 800f9a4:	b21b      	sxth	r3, r3
 800f9a6:	4013      	ands	r3, r2
 800f9a8:	b21b      	sxth	r3, r3
 800f9aa:	b299      	uxth	r1, r3
 800f9ac:	4a19      	ldr	r2, [pc, #100]	; (800fa14 <CheckDiscretMaskNegative+0x100>)
 800f9ae:	68bb      	ldr	r3, [r7, #8]
 800f9b0:	f503 7341 	add.w	r3, r3, #772	; 0x304
 800f9b4:	005b      	lsls	r3, r3, #1
 800f9b6:	4413      	add	r3, r2
 800f9b8:	460a      	mov	r2, r1
 800f9ba:	805a      	strh	r2, [r3, #2]
			RAM.ErrorDiscretLogic[i] |= ((RAM.diskrets[i] & mask[i]));
 800f9bc:	4a15      	ldr	r2, [pc, #84]	; (800fa14 <CheckDiscretMaskNegative+0x100>)
 800f9be:	68bb      	ldr	r3, [r7, #8]
 800f9c0:	f503 7341 	add.w	r3, r3, #772	; 0x304
 800f9c4:	005b      	lsls	r3, r3, #1
 800f9c6:	4413      	add	r3, r2
 800f9c8:	885b      	ldrh	r3, [r3, #2]
 800f9ca:	b29a      	uxth	r2, r3
 800f9cc:	4911      	ldr	r1, [pc, #68]	; (800fa14 <CheckDiscretMaskNegative+0x100>)
 800f9ce:	68bb      	ldr	r3, [r7, #8]
 800f9d0:	f503 7300 	add.w	r3, r3, #512	; 0x200
 800f9d4:	f831 3013 	ldrh.w	r3, [r1, r3, lsl #1]
 800f9d8:	b299      	uxth	r1, r3
 800f9da:	68bb      	ldr	r3, [r7, #8]
 800f9dc:	005b      	lsls	r3, r3, #1
 800f9de:	6878      	ldr	r0, [r7, #4]
 800f9e0:	4403      	add	r3, r0
 800f9e2:	881b      	ldrh	r3, [r3, #0]
 800f9e4:	400b      	ands	r3, r1
 800f9e6:	b29b      	uxth	r3, r3
 800f9e8:	4313      	orrs	r3, r2
 800f9ea:	b299      	uxth	r1, r3
 800f9ec:	4a09      	ldr	r2, [pc, #36]	; (800fa14 <CheckDiscretMaskNegative+0x100>)
 800f9ee:	68bb      	ldr	r3, [r7, #8]
 800f9f0:	f503 7341 	add.w	r3, r3, #772	; 0x304
 800f9f4:	005b      	lsls	r3, r3, #1
 800f9f6:	4413      	add	r3, r2
 800f9f8:	460a      	mov	r2, r1
 800f9fa:	805a      	strh	r2, [r3, #2]
	for (int i = 0; i < 4; i++) {
 800f9fc:	68bb      	ldr	r3, [r7, #8]
 800f9fe:	3301      	adds	r3, #1
 800fa00:	60bb      	str	r3, [r7, #8]
 800fa02:	68bb      	ldr	r3, [r7, #8]
 800fa04:	2b03      	cmp	r3, #3
 800fa06:	dd8e      	ble.n	800f926 <CheckDiscretMaskNegative+0x12>
		}
	}
	return rezult;
 800fa08:	68fb      	ldr	r3, [r7, #12]
}
 800fa0a:	4618      	mov	r0, r3
 800fa0c:	3714      	adds	r7, #20
 800fa0e:	46bd      	mov	sp, r7
 800fa10:	bc80      	pop	{r7}
 800fa12:	4770      	bx	lr
 800fa14:	2000745c 	.word	0x2000745c

0800fa18 <CheckCUSignal>:
void CheckCUSignal() {
 800fa18:	b590      	push	{r4, r7, lr}
 800fa1a:	b0cd      	sub	sp, #308	; 0x134
 800fa1c:	af00      	add	r7, sp, #0
	FLASHMEM *pxConfig = (FLASHMEM*) DEVICE_FLASHMEM_LOCATION;
 800fa1e:	4b44      	ldr	r3, [pc, #272]	; (800fb30 <CheckCUSignal+0x118>)
 800fa20:	f8c7 3128 	str.w	r3, [r7, #296]	; 0x128
	char buffer[256];
	char minbuf[32];
	for (int i = 0; i < 8; i++) {
 800fa24:	2300      	movs	r3, #0
 800fa26:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
 800fa2a:	e077      	b.n	800fb1c <CheckCUSignal+0x104>
		if (pxConfig->devcfg.logica.confCU[i].releNum == 0)
 800fa2c:	f8d7 1128 	ldr.w	r1, [r7, #296]	; 0x128
 800fa30:	f8d7 212c 	ldr.w	r2, [r7, #300]	; 0x12c
 800fa34:	4613      	mov	r3, r2
 800fa36:	005b      	lsls	r3, r3, #1
 800fa38:	4413      	add	r3, r2
 800fa3a:	009b      	lsls	r3, r3, #2
 800fa3c:	440b      	add	r3, r1
 800fa3e:	f203 4302 	addw	r3, r3, #1026	; 0x402
 800fa42:	781b      	ldrb	r3, [r3, #0]
 800fa44:	2b00      	cmp	r3, #0
 800fa46:	d063      	beq.n	800fb10 <CheckCUSignal+0xf8>
			continue;
		itoa1(i + 1, minbuf);
 800fa48:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 800fa4c:	3301      	adds	r3, #1
 800fa4e:	1d3a      	adds	r2, r7, #4
 800fa50:	4611      	mov	r1, r2
 800fa52:	4618      	mov	r0, r3
 800fa54:	4b37      	ldr	r3, [pc, #220]	; (800fb34 <CheckCUSignal+0x11c>)
 800fa56:	4798      	blx	r3
		uint8 TempReleInd = pxConfig->devcfg.logica.confCU[i].releNum - 1;
 800fa58:	f8d7 1128 	ldr.w	r1, [r7, #296]	; 0x128
 800fa5c:	f8d7 212c 	ldr.w	r2, [r7, #300]	; 0x12c
 800fa60:	4613      	mov	r3, r2
 800fa62:	005b      	lsls	r3, r3, #1
 800fa64:	4413      	add	r3, r2
 800fa66:	009b      	lsls	r3, r3, #2
 800fa68:	440b      	add	r3, r1
 800fa6a:	f203 4302 	addw	r3, r3, #1026	; 0x402
 800fa6e:	781b      	ldrb	r3, [r3, #0]
 800fa70:	3b01      	subs	r3, #1
 800fa72:	f887 3127 	strb.w	r3, [r7, #295]	; 0x127
		if (GetChannelBitSignal(i, RAM.OutputCommand)
 800fa76:	4930      	ldr	r1, [pc, #192]	; (800fb38 <CheckCUSignal+0x120>)
 800fa78:	f8d7 012c 	ldr.w	r0, [r7, #300]	; 0x12c
 800fa7c:	4b2f      	ldr	r3, [pc, #188]	; (800fb3c <CheckCUSignal+0x124>)
 800fa7e:	4798      	blx	r3
 800fa80:	4602      	mov	r2, r0
				!= ((RAM.relays[TempReleInd / 16] >> (TempReleInd % 16))
 800fa82:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 800fa86:	091b      	lsrs	r3, r3, #4
 800fa88:	b2db      	uxtb	r3, r3
 800fa8a:	492d      	ldr	r1, [pc, #180]	; (800fb40 <CheckCUSignal+0x128>)
 800fa8c:	f503 7301 	add.w	r3, r3, #516	; 0x204
 800fa90:	f831 3013 	ldrh.w	r3, [r1, r3, lsl #1]
 800fa94:	b29b      	uxth	r3, r3
 800fa96:	4619      	mov	r1, r3
 800fa98:	f897 3127 	ldrb.w	r3, [r7, #295]	; 0x127
 800fa9c:	f003 030f 	and.w	r3, r3, #15
 800faa0:	fa41 f303 	asr.w	r3, r1, r3
						& (0x0001))) {
 800faa4:	f003 0301 	and.w	r3, r3, #1
		if (GetChannelBitSignal(i, RAM.OutputCommand)
 800faa8:	429a      	cmp	r2, r3
 800faaa:	d032      	beq.n	800fb12 <CheckCUSignal+0xfa>
			if (GetChannelBitSignal(i, RAM.OutputCommand) == 1) {
 800faac:	4922      	ldr	r1, [pc, #136]	; (800fb38 <CheckCUSignal+0x120>)
 800faae:	f8d7 012c 	ldr.w	r0, [r7, #300]	; 0x12c
 800fab2:	4b22      	ldr	r3, [pc, #136]	; (800fb3c <CheckCUSignal+0x124>)
 800fab4:	4798      	blx	r3
 800fab6:	4603      	mov	r3, r0
 800fab8:	2b01      	cmp	r3, #1
 800faba:	d114      	bne.n	800fae6 <CheckCUSignal+0xce>
				strcpy(buffer, ". :");
 800fabc:	f107 0324 	add.w	r3, r7, #36	; 0x24
 800fac0:	4a20      	ldr	r2, [pc, #128]	; (800fb44 <CheckCUSignal+0x12c>)
 800fac2:	461c      	mov	r4, r3
 800fac4:	4613      	mov	r3, r2
 800fac6:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 800fac8:	c407      	stmia	r4!, {r0, r1, r2}
 800faca:	7023      	strb	r3, [r4, #0]
				strcat(buffer, minbuf);
 800facc:	1d3a      	adds	r2, r7, #4
 800face:	f107 0324 	add.w	r3, r7, #36	; 0x24
 800fad2:	4611      	mov	r1, r2
 800fad4:	4618      	mov	r0, r3
 800fad6:	4b1c      	ldr	r3, [pc, #112]	; (800fb48 <CheckCUSignal+0x130>)
 800fad8:	4798      	blx	r3

				JrnlWrite(buffer);
 800fada:	f107 0324 	add.w	r3, r7, #36	; 0x24
 800fade:	4618      	mov	r0, r3
 800fae0:	4b1a      	ldr	r3, [pc, #104]	; (800fb4c <CheckCUSignal+0x134>)
 800fae2:	4798      	blx	r3
 800fae4:	e015      	b.n	800fb12 <CheckCUSignal+0xfa>
			} else {
				strcpy(buffer, ". :");
 800fae6:	f107 0324 	add.w	r3, r7, #36	; 0x24
 800faea:	4a19      	ldr	r2, [pc, #100]	; (800fb50 <CheckCUSignal+0x138>)
 800faec:	461c      	mov	r4, r3
 800faee:	4613      	mov	r3, r2
 800faf0:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 800faf2:	c407      	stmia	r4!, {r0, r1, r2}
 800faf4:	8023      	strh	r3, [r4, #0]
				strcat(buffer, minbuf);
 800faf6:	1d3a      	adds	r2, r7, #4
 800faf8:	f107 0324 	add.w	r3, r7, #36	; 0x24
 800fafc:	4611      	mov	r1, r2
 800fafe:	4618      	mov	r0, r3
 800fb00:	4b11      	ldr	r3, [pc, #68]	; (800fb48 <CheckCUSignal+0x130>)
 800fb02:	4798      	blx	r3
				JrnlWrite(buffer);
 800fb04:	f107 0324 	add.w	r3, r7, #36	; 0x24
 800fb08:	4618      	mov	r0, r3
 800fb0a:	4b10      	ldr	r3, [pc, #64]	; (800fb4c <CheckCUSignal+0x134>)
 800fb0c:	4798      	blx	r3
 800fb0e:	e000      	b.n	800fb12 <CheckCUSignal+0xfa>
			continue;
 800fb10:	bf00      	nop
	for (int i = 0; i < 8; i++) {
 800fb12:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 800fb16:	3301      	adds	r3, #1
 800fb18:	f8c7 312c 	str.w	r3, [r7, #300]	; 0x12c
 800fb1c:	f8d7 312c 	ldr.w	r3, [r7, #300]	; 0x12c
 800fb20:	2b07      	cmp	r3, #7
 800fb22:	dd83      	ble.n	800fa2c <CheckCUSignal+0x14>
			}
		}
	}
}
 800fb24:	bf00      	nop
 800fb26:	bf00      	nop
 800fb28:	f507 779a 	add.w	r7, r7, #308	; 0x134
 800fb2c:	46bd      	mov	sp, r7
 800fb2e:	bd90      	pop	{r4, r7, pc}
 800fb30:	0802b000 	.word	0x0802b000
 800fb34:	0800e895 	.word	0x0800e895
 800fb38:	20007460 	.word	0x20007460
 800fb3c:	0800f2d1 	.word	0x0800f2d1
 800fb40:	2000745c 	.word	0x2000745c
 800fb44:	080155e8 	.word	0x080155e8
 800fb48:	08014635 	.word	0x08014635
 800fb4c:	0800edb5 	.word	0x0800edb5
 800fb50:	080155f8 	.word	0x080155f8

0800fb54 <CheckErrors>:
bool NeedWrite = false;
char message[30];
void CheckErrors() {
 800fb54:	b590      	push	{r4, r7, lr}
 800fb56:	b083      	sub	sp, #12
 800fb58:	af00      	add	r7, sp, #0

	uint8 diffMask;
	if (prevLogicFlags != RAM.LogicErrorFlags) {
 800fb5a:	4b76      	ldr	r3, [pc, #472]	; (800fd34 <CheckErrors+0x1e0>)
 800fb5c:	7a1a      	ldrb	r2, [r3, #8]
 800fb5e:	4b76      	ldr	r3, [pc, #472]	; (800fd38 <CheckErrors+0x1e4>)
 800fb60:	781b      	ldrb	r3, [r3, #0]
 800fb62:	429a      	cmp	r2, r3
 800fb64:	f000 80e1 	beq.w	800fd2a <CheckErrors+0x1d6>
		diffMask = (prevLogicFlags) ^ (RAM.LogicErrorFlags);
 800fb68:	4b72      	ldr	r3, [pc, #456]	; (800fd34 <CheckErrors+0x1e0>)
 800fb6a:	7a1a      	ldrb	r2, [r3, #8]
 800fb6c:	4b72      	ldr	r3, [pc, #456]	; (800fd38 <CheckErrors+0x1e4>)
 800fb6e:	781b      	ldrb	r3, [r3, #0]
 800fb70:	4053      	eors	r3, r2
 800fb72:	70fb      	strb	r3, [r7, #3]

		for (int i = 0; i < 8; i++) {
 800fb74:	2300      	movs	r3, #0
 800fb76:	607b      	str	r3, [r7, #4]
 800fb78:	e0cf      	b.n	800fd1a <CheckErrors+0x1c6>
			if (((diffMask >> i) & 0x01) == 0x01) {
 800fb7a:	78fa      	ldrb	r2, [r7, #3]
 800fb7c:	687b      	ldr	r3, [r7, #4]
 800fb7e:	fa42 f303 	asr.w	r3, r2, r3
 800fb82:	f003 0301 	and.w	r3, r3, #1
 800fb86:	2b00      	cmp	r3, #0
 800fb88:	f000 80c3 	beq.w	800fd12 <CheckErrors+0x1be>
				if (((RAM.LogicErrorFlags >> i) & 0x01) == 0x01) {
 800fb8c:	4b69      	ldr	r3, [pc, #420]	; (800fd34 <CheckErrors+0x1e0>)
 800fb8e:	7a1b      	ldrb	r3, [r3, #8]
 800fb90:	461a      	mov	r2, r3
 800fb92:	687b      	ldr	r3, [r7, #4]
 800fb94:	fa42 f303 	asr.w	r3, r2, r3
 800fb98:	f003 0301 	and.w	r3, r3, #1
 800fb9c:	2b00      	cmp	r3, #0
 800fb9e:	d058      	beq.n	800fc52 <CheckErrors+0xfe>
					switch (i) {
 800fba0:	687b      	ldr	r3, [r7, #4]
 800fba2:	2b04      	cmp	r3, #4
 800fba4:	d849      	bhi.n	800fc3a <CheckErrors+0xe6>
 800fba6:	a201      	add	r2, pc, #4	; (adr r2, 800fbac <CheckErrors+0x58>)
 800fba8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800fbac:	0800fbc1 	.word	0x0800fbc1
 800fbb0:	0800fbd7 	.word	0x0800fbd7
 800fbb4:	0800fbef 	.word	0x0800fbef
 800fbb8:	0800fc07 	.word	0x0800fc07
 800fbbc:	0800fc23 	.word	0x0800fc23
					case 0:
						strcpy(message, ". ");
 800fbc0:	4b5e      	ldr	r3, [pc, #376]	; (800fd3c <CheckErrors+0x1e8>)
 800fbc2:	4a5f      	ldr	r2, [pc, #380]	; (800fd40 <CheckErrors+0x1ec>)
 800fbc4:	ca07      	ldmia	r2, {r0, r1, r2}
 800fbc6:	e883 0007 	stmia.w	r3, {r0, r1, r2}
						NeedWrite = true;
 800fbca:	4b5e      	ldr	r3, [pc, #376]	; (800fd44 <CheckErrors+0x1f0>)
 800fbcc:	2201      	movs	r2, #1
 800fbce:	701a      	strb	r2, [r3, #0]
						CheckDiscretsErrors();
 800fbd0:	4b5d      	ldr	r3, [pc, #372]	; (800fd48 <CheckErrors+0x1f4>)
 800fbd2:	4798      	blx	r3
						break;
 800fbd4:	e09e      	b.n	800fd14 <CheckErrors+0x1c0>
					case 1:
						strcpy(message, ". . .");
 800fbd6:	4a59      	ldr	r2, [pc, #356]	; (800fd3c <CheckErrors+0x1e8>)
 800fbd8:	4b5c      	ldr	r3, [pc, #368]	; (800fd4c <CheckErrors+0x1f8>)
 800fbda:	4614      	mov	r4, r2
 800fbdc:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 800fbde:	c407      	stmia	r4!, {r0, r1, r2}
 800fbe0:	8023      	strh	r3, [r4, #0]
						NeedWrite = true;
 800fbe2:	4b58      	ldr	r3, [pc, #352]	; (800fd44 <CheckErrors+0x1f0>)
 800fbe4:	2201      	movs	r2, #1
 800fbe6:	701a      	strb	r2, [r3, #0]
						CheckDiscretsErrors();
 800fbe8:	4b57      	ldr	r3, [pc, #348]	; (800fd48 <CheckErrors+0x1f4>)
 800fbea:	4798      	blx	r3
						break;
 800fbec:	e092      	b.n	800fd14 <CheckErrors+0x1c0>
					case 2:
						strcpy(message, " ");
 800fbee:	4a53      	ldr	r2, [pc, #332]	; (800fd3c <CheckErrors+0x1e8>)
 800fbf0:	4b57      	ldr	r3, [pc, #348]	; (800fd50 <CheckErrors+0x1fc>)
 800fbf2:	4614      	mov	r4, r2
 800fbf4:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 800fbf6:	c407      	stmia	r4!, {r0, r1, r2}
 800fbf8:	8023      	strh	r3, [r4, #0]
						NeedWrite = true;
 800fbfa:	4b52      	ldr	r3, [pc, #328]	; (800fd44 <CheckErrors+0x1f0>)
 800fbfc:	2201      	movs	r2, #1
 800fbfe:	701a      	strb	r2, [r3, #0]
						CheckDiscretsErrors();
 800fc00:	4b51      	ldr	r3, [pc, #324]	; (800fd48 <CheckErrors+0x1f4>)
 800fc02:	4798      	blx	r3
						break;
 800fc04:	e086      	b.n	800fd14 <CheckErrors+0x1c0>
					case 3:
						strcpy(message, ". ");
 800fc06:	4b4d      	ldr	r3, [pc, #308]	; (800fd3c <CheckErrors+0x1e8>)
 800fc08:	4a52      	ldr	r2, [pc, #328]	; (800fd54 <CheckErrors+0x200>)
 800fc0a:	ca07      	ldmia	r2, {r0, r1, r2}
 800fc0c:	c303      	stmia	r3!, {r0, r1}
 800fc0e:	801a      	strh	r2, [r3, #0]
 800fc10:	3302      	adds	r3, #2
 800fc12:	0c12      	lsrs	r2, r2, #16
 800fc14:	701a      	strb	r2, [r3, #0]
						NeedWrite = true;
 800fc16:	4b4b      	ldr	r3, [pc, #300]	; (800fd44 <CheckErrors+0x1f0>)
 800fc18:	2201      	movs	r2, #1
 800fc1a:	701a      	strb	r2, [r3, #0]
						CheckDiscretsErrors();
 800fc1c:	4b4a      	ldr	r3, [pc, #296]	; (800fd48 <CheckErrors+0x1f4>)
 800fc1e:	4798      	blx	r3
						break;
 800fc20:	e078      	b.n	800fd14 <CheckErrors+0x1c0>
					case 4:
						strcpy(message, ". .");
 800fc22:	4a46      	ldr	r2, [pc, #280]	; (800fd3c <CheckErrors+0x1e8>)
 800fc24:	4b4c      	ldr	r3, [pc, #304]	; (800fd58 <CheckErrors+0x204>)
 800fc26:	4614      	mov	r4, r2
 800fc28:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 800fc2a:	c407      	stmia	r4!, {r0, r1, r2}
 800fc2c:	7023      	strb	r3, [r4, #0]
						NeedWrite = true;
 800fc2e:	4b45      	ldr	r3, [pc, #276]	; (800fd44 <CheckErrors+0x1f0>)
 800fc30:	2201      	movs	r2, #1
 800fc32:	701a      	strb	r2, [r3, #0]
						CheckDiscretsErrors();
 800fc34:	4b44      	ldr	r3, [pc, #272]	; (800fd48 <CheckErrors+0x1f4>)
 800fc36:	4798      	blx	r3
						break;
 800fc38:	e06c      	b.n	800fd14 <CheckErrors+0x1c0>
					default:
						strcpy(message, " !");
 800fc3a:	4a40      	ldr	r2, [pc, #256]	; (800fd3c <CheckErrors+0x1e8>)
 800fc3c:	4b47      	ldr	r3, [pc, #284]	; (800fd5c <CheckErrors+0x208>)
 800fc3e:	4614      	mov	r4, r2
 800fc40:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 800fc42:	c407      	stmia	r4!, {r0, r1, r2}
 800fc44:	8023      	strh	r3, [r4, #0]
						NeedWrite = true;
 800fc46:	4b3f      	ldr	r3, [pc, #252]	; (800fd44 <CheckErrors+0x1f0>)
 800fc48:	2201      	movs	r2, #1
 800fc4a:	701a      	strb	r2, [r3, #0]
						CheckDiscretsErrors();
 800fc4c:	4b3e      	ldr	r3, [pc, #248]	; (800fd48 <CheckErrors+0x1f4>)
 800fc4e:	4798      	blx	r3
						break;
 800fc50:	e060      	b.n	800fd14 <CheckErrors+0x1c0>
					}
				} else {
					switch (i) {
 800fc52:	687b      	ldr	r3, [r7, #4]
 800fc54:	2b04      	cmp	r3, #4
 800fc56:	d851      	bhi.n	800fcfc <CheckErrors+0x1a8>
 800fc58:	a201      	add	r2, pc, #4	; (adr r2, 800fc60 <CheckErrors+0x10c>)
 800fc5a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800fc5e:	bf00      	nop
 800fc60:	0800fc75 	.word	0x0800fc75
 800fc64:	0800fc8d 	.word	0x0800fc8d
 800fc68:	0800fcab 	.word	0x0800fcab
 800fc6c:	0800fcc3 	.word	0x0800fcc3
 800fc70:	0800fcdf 	.word	0x0800fcdf
					case 0:
						strcpy(message, " ");
 800fc74:	4a31      	ldr	r2, [pc, #196]	; (800fd3c <CheckErrors+0x1e8>)
 800fc76:	4b3a      	ldr	r3, [pc, #232]	; (800fd60 <CheckErrors+0x20c>)
 800fc78:	4614      	mov	r4, r2
 800fc7a:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 800fc7c:	c407      	stmia	r4!, {r0, r1, r2}
 800fc7e:	8023      	strh	r3, [r4, #0]
						NeedWrite = true;
 800fc80:	4b30      	ldr	r3, [pc, #192]	; (800fd44 <CheckErrors+0x1f0>)
 800fc82:	2201      	movs	r2, #1
 800fc84:	701a      	strb	r2, [r3, #0]
						CheckDiscretsErrors();
 800fc86:	4b30      	ldr	r3, [pc, #192]	; (800fd48 <CheckErrors+0x1f4>)
 800fc88:	4798      	blx	r3
						break;
 800fc8a:	e043      	b.n	800fd14 <CheckErrors+0x1c0>
					case 1:
						strcpy(message, " ..");
 800fc8c:	4a2b      	ldr	r2, [pc, #172]	; (800fd3c <CheckErrors+0x1e8>)
 800fc8e:	4b35      	ldr	r3, [pc, #212]	; (800fd64 <CheckErrors+0x210>)
 800fc90:	4614      	mov	r4, r2
 800fc92:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 800fc94:	c407      	stmia	r4!, {r0, r1, r2}
 800fc96:	8023      	strh	r3, [r4, #0]
 800fc98:	3402      	adds	r4, #2
 800fc9a:	0c1b      	lsrs	r3, r3, #16
 800fc9c:	7023      	strb	r3, [r4, #0]
						NeedWrite = true;
 800fc9e:	4b29      	ldr	r3, [pc, #164]	; (800fd44 <CheckErrors+0x1f0>)
 800fca0:	2201      	movs	r2, #1
 800fca2:	701a      	strb	r2, [r3, #0]
						CheckDiscretsErrors();
 800fca4:	4b28      	ldr	r3, [pc, #160]	; (800fd48 <CheckErrors+0x1f4>)
 800fca6:	4798      	blx	r3
						break;
 800fca8:	e034      	b.n	800fd14 <CheckErrors+0x1c0>
					case 2:
						strcpy(message, " ");
 800fcaa:	4a24      	ldr	r2, [pc, #144]	; (800fd3c <CheckErrors+0x1e8>)
 800fcac:	4b2e      	ldr	r3, [pc, #184]	; (800fd68 <CheckErrors+0x214>)
 800fcae:	4614      	mov	r4, r2
 800fcb0:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 800fcb2:	c407      	stmia	r4!, {r0, r1, r2}
 800fcb4:	8023      	strh	r3, [r4, #0]
						NeedWrite = true;
 800fcb6:	4b23      	ldr	r3, [pc, #140]	; (800fd44 <CheckErrors+0x1f0>)
 800fcb8:	2201      	movs	r2, #1
 800fcba:	701a      	strb	r2, [r3, #0]
						CheckDiscretsErrors();
 800fcbc:	4b22      	ldr	r3, [pc, #136]	; (800fd48 <CheckErrors+0x1f4>)
 800fcbe:	4798      	blx	r3
						break;
 800fcc0:	e028      	b.n	800fd14 <CheckErrors+0x1c0>
					case 3:
						strcpy(message, " .");
 800fcc2:	4b1e      	ldr	r3, [pc, #120]	; (800fd3c <CheckErrors+0x1e8>)
 800fcc4:	4a29      	ldr	r2, [pc, #164]	; (800fd6c <CheckErrors+0x218>)
 800fcc6:	ca07      	ldmia	r2, {r0, r1, r2}
 800fcc8:	c303      	stmia	r3!, {r0, r1}
 800fcca:	801a      	strh	r2, [r3, #0]
 800fccc:	3302      	adds	r3, #2
 800fcce:	0c12      	lsrs	r2, r2, #16
 800fcd0:	701a      	strb	r2, [r3, #0]
						NeedWrite = true;
 800fcd2:	4b1c      	ldr	r3, [pc, #112]	; (800fd44 <CheckErrors+0x1f0>)
 800fcd4:	2201      	movs	r2, #1
 800fcd6:	701a      	strb	r2, [r3, #0]
						CheckDiscretsErrors();
 800fcd8:	4b1b      	ldr	r3, [pc, #108]	; (800fd48 <CheckErrors+0x1f4>)
 800fcda:	4798      	blx	r3
						break;
 800fcdc:	e01a      	b.n	800fd14 <CheckErrors+0x1c0>
					case 4:
						strcpy(message, " .");
 800fcde:	4a17      	ldr	r2, [pc, #92]	; (800fd3c <CheckErrors+0x1e8>)
 800fce0:	4b23      	ldr	r3, [pc, #140]	; (800fd70 <CheckErrors+0x21c>)
 800fce2:	4614      	mov	r4, r2
 800fce4:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 800fce6:	c407      	stmia	r4!, {r0, r1, r2}
 800fce8:	8023      	strh	r3, [r4, #0]
 800fcea:	3402      	adds	r4, #2
 800fcec:	0c1b      	lsrs	r3, r3, #16
 800fcee:	7023      	strb	r3, [r4, #0]
						NeedWrite = true;
 800fcf0:	4b14      	ldr	r3, [pc, #80]	; (800fd44 <CheckErrors+0x1f0>)
 800fcf2:	2201      	movs	r2, #1
 800fcf4:	701a      	strb	r2, [r3, #0]
						CheckDiscretsErrors();
 800fcf6:	4b14      	ldr	r3, [pc, #80]	; (800fd48 <CheckErrors+0x1f4>)
 800fcf8:	4798      	blx	r3
						break;
 800fcfa:	e00b      	b.n	800fd14 <CheckErrors+0x1c0>
					default:
						strcpy(message, " ");
 800fcfc:	4b0f      	ldr	r3, [pc, #60]	; (800fd3c <CheckErrors+0x1e8>)
 800fcfe:	4a1d      	ldr	r2, [pc, #116]	; (800fd74 <CheckErrors+0x220>)
 800fd00:	ca07      	ldmia	r2, {r0, r1, r2}
 800fd02:	e883 0007 	stmia.w	r3, {r0, r1, r2}
						NeedWrite = true;
 800fd06:	4b0f      	ldr	r3, [pc, #60]	; (800fd44 <CheckErrors+0x1f0>)
 800fd08:	2201      	movs	r2, #1
 800fd0a:	701a      	strb	r2, [r3, #0]
						CheckDiscretsErrors();
 800fd0c:	4b0e      	ldr	r3, [pc, #56]	; (800fd48 <CheckErrors+0x1f4>)
 800fd0e:	4798      	blx	r3
						break;
 800fd10:	e000      	b.n	800fd14 <CheckErrors+0x1c0>
					}
				}
 800fd12:	bf00      	nop
		for (int i = 0; i < 8; i++) {
 800fd14:	687b      	ldr	r3, [r7, #4]
 800fd16:	3301      	adds	r3, #1
 800fd18:	607b      	str	r3, [r7, #4]
 800fd1a:	687b      	ldr	r3, [r7, #4]
 800fd1c:	2b07      	cmp	r3, #7
 800fd1e:	f77f af2c 	ble.w	800fb7a <CheckErrors+0x26>
			}
		}
		prevLogicFlags = RAM.LogicErrorFlags;
 800fd22:	4b04      	ldr	r3, [pc, #16]	; (800fd34 <CheckErrors+0x1e0>)
 800fd24:	7a1a      	ldrb	r2, [r3, #8]
 800fd26:	4b04      	ldr	r3, [pc, #16]	; (800fd38 <CheckErrors+0x1e4>)
 800fd28:	701a      	strb	r2, [r3, #0]
	}
}
 800fd2a:	bf00      	nop
 800fd2c:	370c      	adds	r7, #12
 800fd2e:	46bd      	mov	sp, r7
 800fd30:	bd90      	pop	{r4, r7, pc}
 800fd32:	bf00      	nop
 800fd34:	2000745c 	.word	0x2000745c
 800fd38:	20009420 	.word	0x20009420
 800fd3c:	20009458 	.word	0x20009458
 800fd40:	08015608 	.word	0x08015608
 800fd44:	20009454 	.word	0x20009454
 800fd48:	0800fd79 	.word	0x0800fd79
 800fd4c:	08015614 	.word	0x08015614
 800fd50:	08015624 	.word	0x08015624
 800fd54:	08015634 	.word	0x08015634
 800fd58:	08015640 	.word	0x08015640
 800fd5c:	08015650 	.word	0x08015650
 800fd60:	08015660 	.word	0x08015660
 800fd64:	08015670 	.word	0x08015670
 800fd68:	08015680 	.word	0x08015680
 800fd6c:	08015690 	.word	0x08015690
 800fd70:	0801569c 	.word	0x0801569c
 800fd74:	080156ac 	.word	0x080156ac

0800fd78 <CheckDiscretsErrors>:

void CheckDiscretsErrors() {
 800fd78:	b580      	push	{r7, lr}
 800fd7a:	b096      	sub	sp, #88	; 0x58
 800fd7c:	af00      	add	r7, sp, #0
	uint16 diffMask = 0;
 800fd7e:	2300      	movs	r3, #0
 800fd80:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e
	char buffer[64];
	char conv_buf[8];
	for (int it = 0; it < 4; it++)
 800fd84:	2300      	movs	r3, #0
 800fd86:	657b      	str	r3, [r7, #84]	; 0x54
 800fd88:	e0b8      	b.n	800fefc <CheckDiscretsErrors+0x184>
		if (prevErrDiscretLogic[it] != RAM.ErrorDiscretLogic[it]) {
 800fd8a:	4a67      	ldr	r2, [pc, #412]	; (800ff28 <CheckDiscretsErrors+0x1b0>)
 800fd8c:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800fd8e:	f832 2013 	ldrh.w	r2, [r2, r3, lsl #1]
 800fd92:	4966      	ldr	r1, [pc, #408]	; (800ff2c <CheckDiscretsErrors+0x1b4>)
 800fd94:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800fd96:	f503 7341 	add.w	r3, r3, #772	; 0x304
 800fd9a:	005b      	lsls	r3, r3, #1
 800fd9c:	440b      	add	r3, r1
 800fd9e:	885b      	ldrh	r3, [r3, #2]
 800fda0:	b29b      	uxth	r3, r3
 800fda2:	429a      	cmp	r2, r3
 800fda4:	f000 80a7 	beq.w	800fef6 <CheckDiscretsErrors+0x17e>
			diffMask = prevErrDiscretLogic[it] ^ RAM.ErrorDiscretLogic[it];
 800fda8:	4a5f      	ldr	r2, [pc, #380]	; (800ff28 <CheckDiscretsErrors+0x1b0>)
 800fdaa:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800fdac:	f832 2013 	ldrh.w	r2, [r2, r3, lsl #1]
 800fdb0:	495e      	ldr	r1, [pc, #376]	; (800ff2c <CheckDiscretsErrors+0x1b4>)
 800fdb2:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800fdb4:	f503 7341 	add.w	r3, r3, #772	; 0x304
 800fdb8:	005b      	lsls	r3, r3, #1
 800fdba:	440b      	add	r3, r1
 800fdbc:	885b      	ldrh	r3, [r3, #2]
 800fdbe:	b29b      	uxth	r3, r3
 800fdc0:	4053      	eors	r3, r2
 800fdc2:	f8a7 304e 	strh.w	r3, [r7, #78]	; 0x4e

			for (int i = 0; i < 11; i++) {
 800fdc6:	2300      	movs	r3, #0
 800fdc8:	653b      	str	r3, [r7, #80]	; 0x50
 800fdca:	e084      	b.n	800fed6 <CheckDiscretsErrors+0x15e>
				if ((diffMask >> i) & 0x0001 == 0x0001) {
 800fdcc:	f8b7 204e 	ldrh.w	r2, [r7, #78]	; 0x4e
 800fdd0:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800fdd2:	fa42 f303 	asr.w	r3, r2, r3
 800fdd6:	f003 0301 	and.w	r3, r3, #1
 800fdda:	2b00      	cmp	r3, #0
 800fddc:	d078      	beq.n	800fed0 <CheckDiscretsErrors+0x158>
					if ((RAM.ErrorDiscretLogic[it] >> i) & 0x0001 == 0x0001) {
 800fdde:	4a53      	ldr	r2, [pc, #332]	; (800ff2c <CheckDiscretsErrors+0x1b4>)
 800fde0:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800fde2:	f503 7341 	add.w	r3, r3, #772	; 0x304
 800fde6:	005b      	lsls	r3, r3, #1
 800fde8:	4413      	add	r3, r2
 800fdea:	885b      	ldrh	r3, [r3, #2]
 800fdec:	b29b      	uxth	r3, r3
 800fdee:	461a      	mov	r2, r3
 800fdf0:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800fdf2:	fa42 f303 	asr.w	r3, r2, r3
 800fdf6:	f003 0301 	and.w	r3, r3, #1
 800fdfa:	2b00      	cmp	r3, #0
 800fdfc:	d034      	beq.n	800fe68 <CheckDiscretsErrors+0xf0>
						strcpy(buffer, ":");
 800fdfe:	f107 030c 	add.w	r3, r7, #12
 800fe02:	4a4b      	ldr	r2, [pc, #300]	; (800ff30 <CheckDiscretsErrors+0x1b8>)
 800fe04:	6812      	ldr	r2, [r2, #0]
 800fe06:	4611      	mov	r1, r2
 800fe08:	8019      	strh	r1, [r3, #0]
 800fe0a:	3302      	adds	r3, #2
 800fe0c:	0c12      	lsrs	r2, r2, #16
 800fe0e:	701a      	strb	r2, [r3, #0]
						itoa1(i + 1, conv_buf);
 800fe10:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800fe12:	3301      	adds	r3, #1
 800fe14:	1d3a      	adds	r2, r7, #4
 800fe16:	4611      	mov	r1, r2
 800fe18:	4618      	mov	r0, r3
 800fe1a:	4b46      	ldr	r3, [pc, #280]	; (800ff34 <CheckDiscretsErrors+0x1bc>)
 800fe1c:	4798      	blx	r3
						strcat(buffer, conv_buf);
 800fe1e:	1d3a      	adds	r2, r7, #4
 800fe20:	f107 030c 	add.w	r3, r7, #12
 800fe24:	4611      	mov	r1, r2
 800fe26:	4618      	mov	r0, r3
 800fe28:	4b43      	ldr	r3, [pc, #268]	; (800ff38 <CheckDiscretsErrors+0x1c0>)
 800fe2a:	4798      	blx	r3
						strcat(buffer, "(0):");
 800fe2c:	f107 030c 	add.w	r3, r7, #12
 800fe30:	4618      	mov	r0, r3
 800fe32:	4b42      	ldr	r3, [pc, #264]	; (800ff3c <CheckDiscretsErrors+0x1c4>)
 800fe34:	4798      	blx	r3
 800fe36:	4603      	mov	r3, r0
 800fe38:	461a      	mov	r2, r3
 800fe3a:	f107 030c 	add.w	r3, r7, #12
 800fe3e:	4413      	add	r3, r2
 800fe40:	4a3f      	ldr	r2, [pc, #252]	; (800ff40 <CheckDiscretsErrors+0x1c8>)
 800fe42:	6810      	ldr	r0, [r2, #0]
 800fe44:	6018      	str	r0, [r3, #0]
 800fe46:	7912      	ldrb	r2, [r2, #4]
 800fe48:	711a      	strb	r2, [r3, #4]
						strcat(buffer, message);
 800fe4a:	f107 030c 	add.w	r3, r7, #12
 800fe4e:	493d      	ldr	r1, [pc, #244]	; (800ff44 <CheckDiscretsErrors+0x1cc>)
 800fe50:	4618      	mov	r0, r3
 800fe52:	4b39      	ldr	r3, [pc, #228]	; (800ff38 <CheckDiscretsErrors+0x1c0>)
 800fe54:	4798      	blx	r3
						JrnlWrite(buffer);
 800fe56:	f107 030c 	add.w	r3, r7, #12
 800fe5a:	4618      	mov	r0, r3
 800fe5c:	4b3a      	ldr	r3, [pc, #232]	; (800ff48 <CheckDiscretsErrors+0x1d0>)
 800fe5e:	4798      	blx	r3
						NeedWrite = false;
 800fe60:	4b3a      	ldr	r3, [pc, #232]	; (800ff4c <CheckDiscretsErrors+0x1d4>)
 800fe62:	2200      	movs	r2, #0
 800fe64:	701a      	strb	r2, [r3, #0]
 800fe66:	e033      	b.n	800fed0 <CheckDiscretsErrors+0x158>

					} else {
						strcpy(buffer, ":");
 800fe68:	f107 030c 	add.w	r3, r7, #12
 800fe6c:	4a30      	ldr	r2, [pc, #192]	; (800ff30 <CheckDiscretsErrors+0x1b8>)
 800fe6e:	6812      	ldr	r2, [r2, #0]
 800fe70:	4611      	mov	r1, r2
 800fe72:	8019      	strh	r1, [r3, #0]
 800fe74:	3302      	adds	r3, #2
 800fe76:	0c12      	lsrs	r2, r2, #16
 800fe78:	701a      	strb	r2, [r3, #0]
						itoa1(i + 1, conv_buf);
 800fe7a:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800fe7c:	3301      	adds	r3, #1
 800fe7e:	1d3a      	adds	r2, r7, #4
 800fe80:	4611      	mov	r1, r2
 800fe82:	4618      	mov	r0, r3
 800fe84:	4b2b      	ldr	r3, [pc, #172]	; (800ff34 <CheckDiscretsErrors+0x1bc>)
 800fe86:	4798      	blx	r3
						strcat(buffer, conv_buf);
 800fe88:	1d3a      	adds	r2, r7, #4
 800fe8a:	f107 030c 	add.w	r3, r7, #12
 800fe8e:	4611      	mov	r1, r2
 800fe90:	4618      	mov	r0, r3
 800fe92:	4b29      	ldr	r3, [pc, #164]	; (800ff38 <CheckDiscretsErrors+0x1c0>)
 800fe94:	4798      	blx	r3
						strcat(buffer, "(1):");
 800fe96:	f107 030c 	add.w	r3, r7, #12
 800fe9a:	4618      	mov	r0, r3
 800fe9c:	4b27      	ldr	r3, [pc, #156]	; (800ff3c <CheckDiscretsErrors+0x1c4>)
 800fe9e:	4798      	blx	r3
 800fea0:	4603      	mov	r3, r0
 800fea2:	461a      	mov	r2, r3
 800fea4:	f107 030c 	add.w	r3, r7, #12
 800fea8:	4413      	add	r3, r2
 800feaa:	4a29      	ldr	r2, [pc, #164]	; (800ff50 <CheckDiscretsErrors+0x1d8>)
 800feac:	6810      	ldr	r0, [r2, #0]
 800feae:	6018      	str	r0, [r3, #0]
 800feb0:	7912      	ldrb	r2, [r2, #4]
 800feb2:	711a      	strb	r2, [r3, #4]
						strcat(buffer, message);
 800feb4:	f107 030c 	add.w	r3, r7, #12
 800feb8:	4922      	ldr	r1, [pc, #136]	; (800ff44 <CheckDiscretsErrors+0x1cc>)
 800feba:	4618      	mov	r0, r3
 800febc:	4b1e      	ldr	r3, [pc, #120]	; (800ff38 <CheckDiscretsErrors+0x1c0>)
 800febe:	4798      	blx	r3
						JrnlWrite(buffer);
 800fec0:	f107 030c 	add.w	r3, r7, #12
 800fec4:	4618      	mov	r0, r3
 800fec6:	4b20      	ldr	r3, [pc, #128]	; (800ff48 <CheckDiscretsErrors+0x1d0>)
 800fec8:	4798      	blx	r3
						NeedWrite = false;
 800feca:	4b20      	ldr	r3, [pc, #128]	; (800ff4c <CheckDiscretsErrors+0x1d4>)
 800fecc:	2200      	movs	r2, #0
 800fece:	701a      	strb	r2, [r3, #0]
			for (int i = 0; i < 11; i++) {
 800fed0:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800fed2:	3301      	adds	r3, #1
 800fed4:	653b      	str	r3, [r7, #80]	; 0x50
 800fed6:	6d3b      	ldr	r3, [r7, #80]	; 0x50
 800fed8:	2b0a      	cmp	r3, #10
 800feda:	f77f af77 	ble.w	800fdcc <CheckDiscretsErrors+0x54>

				}

			}

			prevErrDiscretLogic[it] = RAM.ErrorDiscretLogic[it];
 800fede:	4a13      	ldr	r2, [pc, #76]	; (800ff2c <CheckDiscretsErrors+0x1b4>)
 800fee0:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800fee2:	f503 7341 	add.w	r3, r3, #772	; 0x304
 800fee6:	005b      	lsls	r3, r3, #1
 800fee8:	4413      	add	r3, r2
 800feea:	885b      	ldrh	r3, [r3, #2]
 800feec:	b299      	uxth	r1, r3
 800feee:	4a0e      	ldr	r2, [pc, #56]	; (800ff28 <CheckDiscretsErrors+0x1b0>)
 800fef0:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800fef2:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
	for (int it = 0; it < 4; it++)
 800fef6:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800fef8:	3301      	adds	r3, #1
 800fefa:	657b      	str	r3, [r7, #84]	; 0x54
 800fefc:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 800fefe:	2b03      	cmp	r3, #3
 800ff00:	f77f af43 	ble.w	800fd8a <CheckDiscretsErrors+0x12>
		}
	if (NeedWrite == true) {
 800ff04:	4b11      	ldr	r3, [pc, #68]	; (800ff4c <CheckDiscretsErrors+0x1d4>)
 800ff06:	781b      	ldrb	r3, [r3, #0]
 800ff08:	2b00      	cmp	r3, #0
 800ff0a:	d005      	beq.n	800ff18 <CheckDiscretsErrors+0x1a0>
		JrnlWrite(message);
 800ff0c:	480d      	ldr	r0, [pc, #52]	; (800ff44 <CheckDiscretsErrors+0x1cc>)
 800ff0e:	4b0e      	ldr	r3, [pc, #56]	; (800ff48 <CheckDiscretsErrors+0x1d0>)
 800ff10:	4798      	blx	r3
		NeedWrite = false;
 800ff12:	4b0e      	ldr	r3, [pc, #56]	; (800ff4c <CheckDiscretsErrors+0x1d4>)
 800ff14:	2200      	movs	r2, #0
 800ff16:	701a      	strb	r2, [r3, #0]
	}
	strcpy(message, "");
 800ff18:	4b0a      	ldr	r3, [pc, #40]	; (800ff44 <CheckDiscretsErrors+0x1cc>)
 800ff1a:	2200      	movs	r2, #0
 800ff1c:	701a      	strb	r2, [r3, #0]
}
 800ff1e:	bf00      	nop
 800ff20:	3758      	adds	r7, #88	; 0x58
 800ff22:	46bd      	mov	sp, r7
 800ff24:	bd80      	pop	{r7, pc}
 800ff26:	bf00      	nop
 800ff28:	20009424 	.word	0x20009424
 800ff2c:	2000745c 	.word	0x2000745c
 800ff30:	080156b8 	.word	0x080156b8
 800ff34:	0800e895 	.word	0x0800e895
 800ff38:	08014635 	.word	0x08014635
 800ff3c:	08014731 	.word	0x08014731
 800ff40:	080156bc 	.word	0x080156bc
 800ff44:	20009458 	.word	0x20009458
 800ff48:	0800edb5 	.word	0x0800edb5
 800ff4c:	20009454 	.word	0x20009454
 800ff50:	080156c4 	.word	0x080156c4

0800ff54 <CheckPowerOn>:

char minbuf[20];
char buffer[256];


void CheckPowerOn() {
 800ff54:	b580      	push	{r7, lr}
 800ff56:	b082      	sub	sp, #8
 800ff58:	af00      	add	r7, sp, #0
	FLASHMEM *pxConfig = (FLASHMEM*) DEVICE_FLASHMEM_LOCATION;
 800ff5a:	4b42      	ldr	r3, [pc, #264]	; (8010064 <CheckPowerOn+0x110>)
 800ff5c:	603b      	str	r3, [r7, #0]
	portENTER_CRITICAL();
 800ff5e:	4b42      	ldr	r3, [pc, #264]	; (8010068 <CheckPowerOn+0x114>)
 800ff60:	4798      	blx	r3
	{
		if (bPowerOn == false) {
 800ff62:	4b42      	ldr	r3, [pc, #264]	; (801006c <CheckPowerOn+0x118>)
 800ff64:	781b      	ldrb	r3, [r3, #0]
 800ff66:	f083 0301 	eor.w	r3, r3, #1
 800ff6a:	b2db      	uxtb	r3, r3
 800ff6c:	2b00      	cmp	r3, #0
 800ff6e:	d073      	beq.n	8010058 <CheckPowerOn+0x104>
			bPowerOn = true;
 800ff70:	4b3e      	ldr	r3, [pc, #248]	; (801006c <CheckPowerOn+0x118>)
 800ff72:	2201      	movs	r2, #1
 800ff74:	701a      	strb	r2, [r3, #0]
			if (RCC->CSR & RCC_CSR_IWDGRSTF) {
 800ff76:	4b3e      	ldr	r3, [pc, #248]	; (8010070 <CheckPowerOn+0x11c>)
 800ff78:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800ff7a:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
 800ff7e:	2b00      	cmp	r3, #0
 800ff80:	d023      	beq.n	800ffca <CheckPowerOn+0x76>
				JrnlWrite("  . ");
 800ff82:	483c      	ldr	r0, [pc, #240]	; (8010074 <CheckPowerOn+0x120>)
 800ff84:	4b3c      	ldr	r3, [pc, #240]	; (8010078 <CheckPowerOn+0x124>)
 800ff86:	4798      	blx	r3
				itoa1(T1, minbuf);
 800ff88:	4b3c      	ldr	r3, [pc, #240]	; (801007c <CheckPowerOn+0x128>)
 800ff8a:	881b      	ldrh	r3, [r3, #0]
 800ff8c:	493c      	ldr	r1, [pc, #240]	; (8010080 <CheckPowerOn+0x12c>)
 800ff8e:	4618      	mov	r0, r3
 800ff90:	4b3c      	ldr	r3, [pc, #240]	; (8010084 <CheckPowerOn+0x130>)
 800ff92:	4798      	blx	r3
				strcpy(buffer, " =");
 800ff94:	4b3c      	ldr	r3, [pc, #240]	; (8010088 <CheckPowerOn+0x134>)
 800ff96:	4a3d      	ldr	r2, [pc, #244]	; (801008c <CheckPowerOn+0x138>)
 800ff98:	ca07      	ldmia	r2, {r0, r1, r2}
 800ff9a:	e883 0007 	stmia.w	r3, {r0, r1, r2}
				strcat(buffer, minbuf);
 800ff9e:	4938      	ldr	r1, [pc, #224]	; (8010080 <CheckPowerOn+0x12c>)
 800ffa0:	4839      	ldr	r0, [pc, #228]	; (8010088 <CheckPowerOn+0x134>)
 800ffa2:	4b3b      	ldr	r3, [pc, #236]	; (8010090 <CheckPowerOn+0x13c>)
 800ffa4:	4798      	blx	r3
				JrnlWrite(buffer);
 800ffa6:	4838      	ldr	r0, [pc, #224]	; (8010088 <CheckPowerOn+0x134>)
 800ffa8:	4b33      	ldr	r3, [pc, #204]	; (8010078 <CheckPowerOn+0x124>)
 800ffaa:	4798      	blx	r3
				RAM.LocalCommand[0] = BKP_ReadBackupRegister(BKP_DR1);
 800ffac:	2004      	movs	r0, #4
 800ffae:	4b39      	ldr	r3, [pc, #228]	; (8010094 <CheckPowerOn+0x140>)
 800ffb0:	4798      	blx	r3
 800ffb2:	4603      	mov	r3, r0
 800ffb4:	461a      	mov	r2, r3
 800ffb6:	4b38      	ldr	r3, [pc, #224]	; (8010098 <CheckPowerOn+0x144>)
 800ffb8:	801a      	strh	r2, [r3, #0]
				RAM.LocalCommand[1] = BKP_ReadBackupRegister(BKP_DR2);
 800ffba:	2008      	movs	r0, #8
 800ffbc:	4b35      	ldr	r3, [pc, #212]	; (8010094 <CheckPowerOn+0x140>)
 800ffbe:	4798      	blx	r3
 800ffc0:	4603      	mov	r3, r0
 800ffc2:	461a      	mov	r2, r3
 800ffc4:	4b34      	ldr	r3, [pc, #208]	; (8010098 <CheckPowerOn+0x144>)
 800ffc6:	805a      	strh	r2, [r3, #2]
 800ffc8:	e005      	b.n	800ffd6 <CheckPowerOn+0x82>
			} else {
				//   -  
				JrnlWriteOff(" ");
 800ffca:	4834      	ldr	r0, [pc, #208]	; (801009c <CheckPowerOn+0x148>)
 800ffcc:	4b34      	ldr	r3, [pc, #208]	; (80100a0 <CheckPowerOn+0x14c>)
 800ffce:	4798      	blx	r3
				//   -  
				JrnlWrite(" ");
 800ffd0:	4834      	ldr	r0, [pc, #208]	; (80100a4 <CheckPowerOn+0x150>)
 800ffd2:	4b29      	ldr	r3, [pc, #164]	; (8010078 <CheckPowerOn+0x124>)
 800ffd4:	4798      	blx	r3
				//RAM.LocalCommand[1] = BKP_ReadBackupRegister(BKP_DR2);

			}

			//  
			for (int i = 0; i < 8; i++) {
 800ffd6:	2300      	movs	r3, #0
 800ffd8:	607b      	str	r3, [r7, #4]
 800ffda:	e03a      	b.n	8010052 <CheckPowerOn+0xfe>
				if (GetChannelBitDirect(i, RAM.OutputCommand) == 1) {
 800ffdc:	4932      	ldr	r1, [pc, #200]	; (80100a8 <CheckPowerOn+0x154>)
 800ffde:	6878      	ldr	r0, [r7, #4]
 800ffe0:	4b32      	ldr	r3, [pc, #200]	; (80100ac <CheckPowerOn+0x158>)
 800ffe2:	4798      	blx	r3
 800ffe4:	4603      	mov	r3, r0
 800ffe6:	2b01      	cmp	r3, #1
 800ffe8:	d10a      	bne.n	8010000 <CheckPowerOn+0xac>
					ChanelDirect[i] = true;
 800ffea:	4a31      	ldr	r2, [pc, #196]	; (80100b0 <CheckPowerOn+0x15c>)
 800ffec:	687b      	ldr	r3, [r7, #4]
 800ffee:	4413      	add	r3, r2
 800fff0:	2201      	movs	r2, #1
 800fff2:	701a      	strb	r2, [r3, #0]
					ChanelChangeDirect[i] = true;
 800fff4:	4a2f      	ldr	r2, [pc, #188]	; (80100b4 <CheckPowerOn+0x160>)
 800fff6:	687b      	ldr	r3, [r7, #4]
 800fff8:	4413      	add	r3, r2
 800fffa:	2201      	movs	r2, #1
 800fffc:	701a      	strb	r2, [r3, #0]
 800fffe:	e009      	b.n	8010014 <CheckPowerOn+0xc0>
				} else {

					ChanelDirect[i] = false;
 8010000:	4a2b      	ldr	r2, [pc, #172]	; (80100b0 <CheckPowerOn+0x15c>)
 8010002:	687b      	ldr	r3, [r7, #4]
 8010004:	4413      	add	r3, r2
 8010006:	2200      	movs	r2, #0
 8010008:	701a      	strb	r2, [r3, #0]
					ChanelChangeDirect[i] = false;
 801000a:	4a2a      	ldr	r2, [pc, #168]	; (80100b4 <CheckPowerOn+0x160>)
 801000c:	687b      	ldr	r3, [r7, #4]
 801000e:	4413      	add	r3, r2
 8010010:	2200      	movs	r2, #0
 8010012:	701a      	strb	r2, [r3, #0]
				}
				if (GetChannelBitRepare(i, RAM.OutputCommand) == 1) {
 8010014:	4924      	ldr	r1, [pc, #144]	; (80100a8 <CheckPowerOn+0x154>)
 8010016:	6878      	ldr	r0, [r7, #4]
 8010018:	4b27      	ldr	r3, [pc, #156]	; (80100b8 <CheckPowerOn+0x164>)
 801001a:	4798      	blx	r3
 801001c:	4603      	mov	r3, r0
 801001e:	2b01      	cmp	r3, #1
 8010020:	d10a      	bne.n	8010038 <CheckPowerOn+0xe4>
					ChanelRepare[i] = true;
 8010022:	4a26      	ldr	r2, [pc, #152]	; (80100bc <CheckPowerOn+0x168>)
 8010024:	687b      	ldr	r3, [r7, #4]
 8010026:	4413      	add	r3, r2
 8010028:	2201      	movs	r2, #1
 801002a:	701a      	strb	r2, [r3, #0]
					ChanelChangeRepare[i] = true;
 801002c:	4a24      	ldr	r2, [pc, #144]	; (80100c0 <CheckPowerOn+0x16c>)
 801002e:	687b      	ldr	r3, [r7, #4]
 8010030:	4413      	add	r3, r2
 8010032:	2201      	movs	r2, #1
 8010034:	701a      	strb	r2, [r3, #0]
 8010036:	e009      	b.n	801004c <CheckPowerOn+0xf8>
				} else {
					ChanelRepare[i] = false;
 8010038:	4a20      	ldr	r2, [pc, #128]	; (80100bc <CheckPowerOn+0x168>)
 801003a:	687b      	ldr	r3, [r7, #4]
 801003c:	4413      	add	r3, r2
 801003e:	2200      	movs	r2, #0
 8010040:	701a      	strb	r2, [r3, #0]
					ChanelChangeRepare[i] = false;
 8010042:	4a1f      	ldr	r2, [pc, #124]	; (80100c0 <CheckPowerOn+0x16c>)
 8010044:	687b      	ldr	r3, [r7, #4]
 8010046:	4413      	add	r3, r2
 8010048:	2200      	movs	r2, #0
 801004a:	701a      	strb	r2, [r3, #0]
			for (int i = 0; i < 8; i++) {
 801004c:	687b      	ldr	r3, [r7, #4]
 801004e:	3301      	adds	r3, #1
 8010050:	607b      	str	r3, [r7, #4]
 8010052:	687b      	ldr	r3, [r7, #4]
 8010054:	2b07      	cmp	r3, #7
 8010056:	ddc1      	ble.n	800ffdc <CheckPowerOn+0x88>
			}
			///
		}

	}
	portEXIT_CRITICAL();
 8010058:	4b1a      	ldr	r3, [pc, #104]	; (80100c4 <CheckPowerOn+0x170>)
 801005a:	4798      	blx	r3
}
 801005c:	bf00      	nop
 801005e:	3708      	adds	r7, #8
 8010060:	46bd      	mov	sp, r7
 8010062:	bd80      	pop	{r7, pc}
 8010064:	0802b000 	.word	0x0802b000
 8010068:	080025f9 	.word	0x080025f9
 801006c:	200093fe 	.word	0x200093fe
 8010070:	40021000 	.word	0x40021000
 8010074:	080156cc 	.word	0x080156cc
 8010078:	0800edb5 	.word	0x0800edb5
 801007c:	20007198 	.word	0x20007198
 8010080:	20009478 	.word	0x20009478
 8010084:	0800e895 	.word	0x0800e895
 8010088:	2000948c 	.word	0x2000948c
 801008c:	080156e4 	.word	0x080156e4
 8010090:	08014635 	.word	0x08014635
 8010094:	08003659 	.word	0x08003659
 8010098:	2000745c 	.word	0x2000745c
 801009c:	080156f0 	.word	0x080156f0
 80100a0:	0800efa5 	.word	0x0800efa5
 80100a4:	08015700 	.word	0x08015700
 80100a8:	20007460 	.word	0x20007460
 80100ac:	0800f36b 	.word	0x0800f36b
 80100b0:	20009400 	.word	0x20009400
 80100b4:	20009410 	.word	0x20009410
 80100b8:	0800f31d 	.word	0x0800f31d
 80100bc:	20009408 	.word	0x20009408
 80100c0:	20009418 	.word	0x20009418
 80100c4:	0800261d 	.word	0x0800261d

080100c8 <DoProgram>:

//--------------------------------------------------------------------------
void DoProgram() {
 80100c8:	b5b0      	push	{r4, r5, r7, lr}
 80100ca:	b0f0      	sub	sp, #448	; 0x1c0
 80100cc:	af00      	add	r7, sp, #0

	FLASHMEM *pxConfig = (FLASHMEM*) DEVICE_FLASHMEM_LOCATION;
 80100ce:	4bad      	ldr	r3, [pc, #692]	; (8010384 <DoProgram+0x2bc>)
 80100d0:	f8c7 3160 	str.w	r3, [r7, #352]	; 0x160
	DATATIME dtl, dt;
	bool reverseDay;
	char tmp_buf[8];

	if (RAM.reset != 0) {
 80100d4:	4bac      	ldr	r3, [pc, #688]	; (8010388 <DoProgram+0x2c0>)
 80100d6:	f8b3 3604 	ldrh.w	r3, [r3, #1540]	; 0x604
 80100da:	b29b      	uxth	r3, r3
 80100dc:	2b00      	cmp	r3, #0
 80100de:	d02d      	beq.n	801013c <DoProgram+0x74>
		if (RAM.reset == 1)
 80100e0:	4ba9      	ldr	r3, [pc, #676]	; (8010388 <DoProgram+0x2c0>)
 80100e2:	f8b3 3604 	ldrh.w	r3, [r3, #1540]	; 0x604
 80100e6:	b29b      	uxth	r3, r3
 80100e8:	2b01      	cmp	r3, #1
 80100ea:	d118      	bne.n	801011e <DoProgram+0x56>
		{
			Reset();
 80100ec:	4ba7      	ldr	r3, [pc, #668]	; (801038c <DoProgram+0x2c4>)
 80100ee:	4798      	blx	r3
			prevLogicFlags = 0;
 80100f0:	4ba7      	ldr	r3, [pc, #668]	; (8010390 <DoProgram+0x2c8>)
 80100f2:	2200      	movs	r2, #0
 80100f4:	701a      	strb	r2, [r3, #0]
			for (int i = 0; i < 4; i++)
 80100f6:	2300      	movs	r3, #0
 80100f8:	f8c7 31b8 	str.w	r3, [r7, #440]	; 0x1b8
 80100fc:	e00a      	b.n	8010114 <DoProgram+0x4c>
				{
				prevErrDiscretLogic[i] = 0;
 80100fe:	4aa5      	ldr	r2, [pc, #660]	; (8010394 <DoProgram+0x2cc>)
 8010100:	f8d7 31b8 	ldr.w	r3, [r7, #440]	; 0x1b8
 8010104:	2100      	movs	r1, #0
 8010106:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
			for (int i = 0; i < 4; i++)
 801010a:	f8d7 31b8 	ldr.w	r3, [r7, #440]	; 0x1b8
 801010e:	3301      	adds	r3, #1
 8010110:	f8c7 31b8 	str.w	r3, [r7, #440]	; 0x1b8
 8010114:	f8d7 31b8 	ldr.w	r3, [r7, #440]	; 0x1b8
 8010118:	2b03      	cmp	r3, #3
 801011a:	ddf0      	ble.n	80100fe <DoProgram+0x36>
 801011c:	e007      	b.n	801012e <DoProgram+0x66>
				}
			}
		else if (RAM.reset == 2)
 801011e:	4b9a      	ldr	r3, [pc, #616]	; (8010388 <DoProgram+0x2c0>)
 8010120:	f8b3 3604 	ldrh.w	r3, [r3, #1540]	; 0x604
 8010124:	b29b      	uxth	r3, r3
 8010126:	2b02      	cmp	r3, #2
 8010128:	d101      	bne.n	801012e <DoProgram+0x66>
			{
			JrnlClear();
 801012a:	4b9b      	ldr	r3, [pc, #620]	; (8010398 <DoProgram+0x2d0>)
 801012c:	4798      	blx	r3
			}
		RAM.reset = 0;
 801012e:	4b96      	ldr	r3, [pc, #600]	; (8010388 <DoProgram+0x2c0>)
 8010130:	2200      	movs	r2, #0
 8010132:	f883 2604 	strb.w	r2, [r3, #1540]	; 0x604
 8010136:	2200      	movs	r2, #0
 8010138:	f883 2605 	strb.w	r2, [r3, #1541]	; 0x605
		    if (jrnlLength == 0)
			{

			}*/

	BKP_WriteBackupRegister(BKP_DR7, 51);
 801013c:	2133      	movs	r1, #51	; 0x33
 801013e:	201c      	movs	r0, #28
 8010140:	4b96      	ldr	r3, [pc, #600]	; (801039c <DoProgram+0x2d4>)
 8010142:	4798      	blx	r3
	CheckPowerOn();
 8010144:	4b96      	ldr	r3, [pc, #600]	; (80103a0 <DoProgram+0x2d8>)
 8010146:	4798      	blx	r3

	uint16 u1 = 0;
 8010148:	2300      	movs	r3, #0
 801014a:	f8a7 315e 	strh.w	r3, [r7, #350]	; 0x15e
	int DelayForStopTime;

	if (pxConfig->devcfg.logica.StopTime == 0x01) {
 801014e:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 8010152:	f8b3 347c 	ldrh.w	r3, [r3, #1148]	; 0x47c
 8010156:	b29b      	uxth	r3, r3
 8010158:	2b01      	cmp	r3, #1
 801015a:	d128      	bne.n	80101ae <DoProgram+0xe6>
		vTaskDelay(2000);
 801015c:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 8010160:	4b90      	ldr	r3, [pc, #576]	; (80103a4 <DoProgram+0x2dc>)
 8010162:	4798      	blx	r3
		portENTER_CRITICAL();
 8010164:	4b90      	ldr	r3, [pc, #576]	; (80103a8 <DoProgram+0x2e0>)
 8010166:	4798      	blx	r3
		{
			uint16 u1 = 0;
 8010168:	f507 73e0 	add.w	r3, r7, #448	; 0x1c0
 801016c:	f5a3 73db 	sub.w	r3, r3, #438	; 0x1b6
 8010170:	2200      	movs	r2, #0
 8010172:	801a      	strh	r2, [r3, #0]
			for (int i = 0; i < 100000; i++) {
 8010174:	2300      	movs	r3, #0
 8010176:	f8c7 31b4 	str.w	r3, [r7, #436]	; 0x1b4
 801017a:	e004      	b.n	8010186 <DoProgram+0xbe>
 801017c:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 8010180:	3301      	adds	r3, #1
 8010182:	f8c7 31b4 	str.w	r3, [r7, #436]	; 0x1b4
 8010186:	f8d7 31b4 	ldr.w	r3, [r7, #436]	; 0x1b4
 801018a:	4a88      	ldr	r2, [pc, #544]	; (80103ac <DoProgram+0x2e4>)
 801018c:	4293      	cmp	r3, r2
 801018e:	ddf5      	ble.n	801017c <DoProgram+0xb4>
			}
			I2C_Time_BufferWrite(0xFF, 0x0E, 1);
 8010190:	2201      	movs	r2, #1
 8010192:	210e      	movs	r1, #14
 8010194:	20ff      	movs	r0, #255	; 0xff
 8010196:	4b86      	ldr	r3, [pc, #536]	; (80103b0 <DoProgram+0x2e8>)
 8010198:	4798      	blx	r3
			MemSetWords((uint16) (0x823E), &u1, 0x1);
 801019a:	f107 030a 	add.w	r3, r7, #10
 801019e:	2201      	movs	r2, #1
 80101a0:	4619      	mov	r1, r3
 80101a2:	f248 203e 	movw	r0, #33342	; 0x823e
 80101a6:	4b83      	ldr	r3, [pc, #524]	; (80103b4 <DoProgram+0x2ec>)
 80101a8:	4798      	blx	r3
		}
		portEXIT_CRITICAL();
 80101aa:	4b83      	ldr	r3, [pc, #524]	; (80103b8 <DoProgram+0x2f0>)
 80101ac:	4798      	blx	r3
	}
	BKP_WriteBackupRegister(BKP_DR7, 52);
 80101ae:	2134      	movs	r1, #52	; 0x34
 80101b0:	201c      	movs	r0, #28
 80101b2:	4b7a      	ldr	r3, [pc, #488]	; (801039c <DoProgram+0x2d4>)
 80101b4:	4798      	blx	r3
	if (pxConfig->devcfg.logica.SwitchTime * 1000 < atcGetCounter()) {
 80101b6:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 80101ba:	f8b3 3478 	ldrh.w	r3, [r3, #1144]	; 0x478
 80101be:	b29b      	uxth	r3, r3
 80101c0:	461a      	mov	r2, r3
 80101c2:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80101c6:	fb03 f402 	mul.w	r4, r3, r2
 80101ca:	4b7c      	ldr	r3, [pc, #496]	; (80103bc <DoProgram+0x2f4>)
 80101cc:	4798      	blx	r3
 80101ce:	4603      	mov	r3, r0
 80101d0:	429c      	cmp	r4, r3
 80101d2:	da6d      	bge.n	80102b0 <DoProgram+0x1e8>

		if (CountReset == 0) {
 80101d4:	4b7a      	ldr	r3, [pc, #488]	; (80103c0 <DoProgram+0x2f8>)
 80101d6:	881b      	ldrh	r3, [r3, #0]
 80101d8:	2b00      	cmp	r3, #0
 80101da:	d122      	bne.n	8010222 <DoProgram+0x15a>
			bool Direct = false;
 80101dc:	2300      	movs	r3, #0
 80101de:	f887 31b3 	strb.w	r3, [r7, #435]	; 0x1b3

			for (int i = 0; i < 8; i++) {
 80101e2:	2300      	movs	r3, #0
 80101e4:	f8c7 31ac 	str.w	r3, [r7, #428]	; 0x1ac
 80101e8:	e010      	b.n	801020c <DoProgram+0x144>
				if (GetChannelBitDirect(i, RAM.LocalCommand)) {
 80101ea:	4967      	ldr	r1, [pc, #412]	; (8010388 <DoProgram+0x2c0>)
 80101ec:	f8d7 01ac 	ldr.w	r0, [r7, #428]	; 0x1ac
 80101f0:	4b74      	ldr	r3, [pc, #464]	; (80103c4 <DoProgram+0x2fc>)
 80101f2:	4798      	blx	r3
 80101f4:	4603      	mov	r3, r0
 80101f6:	2b00      	cmp	r3, #0
 80101f8:	d003      	beq.n	8010202 <DoProgram+0x13a>
					Direct = true;
 80101fa:	2301      	movs	r3, #1
 80101fc:	f887 31b3 	strb.w	r3, [r7, #435]	; 0x1b3
					break;
 8010200:	e008      	b.n	8010214 <DoProgram+0x14c>
			for (int i = 0; i < 8; i++) {
 8010202:	f8d7 31ac 	ldr.w	r3, [r7, #428]	; 0x1ac
 8010206:	3301      	adds	r3, #1
 8010208:	f8c7 31ac 	str.w	r3, [r7, #428]	; 0x1ac
 801020c:	f8d7 31ac 	ldr.w	r3, [r7, #428]	; 0x1ac
 8010210:	2b07      	cmp	r3, #7
 8010212:	ddea      	ble.n	80101ea <DoProgram+0x122>
				}
			}
			if (Direct == true) {
 8010214:	f897 31b3 	ldrb.w	r3, [r7, #435]	; 0x1b3
 8010218:	2b00      	cmp	r3, #0
 801021a:	d002      	beq.n	8010222 <DoProgram+0x15a>
				JrnlWrite(".  ");
 801021c:	486a      	ldr	r0, [pc, #424]	; (80103c8 <DoProgram+0x300>)
 801021e:	4b6b      	ldr	r3, [pc, #428]	; (80103cc <DoProgram+0x304>)
 8010220:	4798      	blx	r3

			}
		}
		for (int i = 0; i < 8; i++) {
 8010222:	2300      	movs	r3, #0
 8010224:	f8c7 31a8 	str.w	r3, [r7, #424]	; 0x1a8
 8010228:	e011      	b.n	801024e <DoProgram+0x186>
			if (!block[i]) {
 801022a:	4a69      	ldr	r2, [pc, #420]	; (80103d0 <DoProgram+0x308>)
 801022c:	f8d7 31a8 	ldr.w	r3, [r7, #424]	; 0x1a8
 8010230:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8010234:	2b00      	cmp	r3, #0
 8010236:	d105      	bne.n	8010244 <DoProgram+0x17c>
				SetChannelBitDirect(i, RAM.LocalCommand, 0); //OutputCommand
 8010238:	2200      	movs	r2, #0
 801023a:	4953      	ldr	r1, [pc, #332]	; (8010388 <DoProgram+0x2c0>)
 801023c:	f8d7 01a8 	ldr.w	r0, [r7, #424]	; 0x1a8
 8010240:	4b64      	ldr	r3, [pc, #400]	; (80103d4 <DoProgram+0x30c>)
 8010242:	4798      	blx	r3
		for (int i = 0; i < 8; i++) {
 8010244:	f8d7 31a8 	ldr.w	r3, [r7, #424]	; 0x1a8
 8010248:	3301      	adds	r3, #1
 801024a:	f8c7 31a8 	str.w	r3, [r7, #424]	; 0x1a8
 801024e:	f8d7 31a8 	ldr.w	r3, [r7, #424]	; 0x1a8
 8010252:	2b07      	cmp	r3, #7
 8010254:	dde9      	ble.n	801022a <DoProgram+0x162>
			}
		}
		for (int i = 0; i < 8; i++) {
 8010256:	2300      	movs	r3, #0
 8010258:	f8c7 31a4 	str.w	r3, [r7, #420]	; 0x1a4
 801025c:	e024      	b.n	80102a8 <DoProgram+0x1e0>
			if (GetChannelBitDirect(i, RAM.LocalCommand) == 1) {
 801025e:	494a      	ldr	r1, [pc, #296]	; (8010388 <DoProgram+0x2c0>)
 8010260:	f8d7 01a4 	ldr.w	r0, [r7, #420]	; 0x1a4
 8010264:	4b57      	ldr	r3, [pc, #348]	; (80103c4 <DoProgram+0x2fc>)
 8010266:	4798      	blx	r3
 8010268:	4603      	mov	r3, r0
 801026a:	2b01      	cmp	r3, #1
 801026c:	d106      	bne.n	801027c <DoProgram+0x1b4>
				ChanelChangeDirect[i] = true;
 801026e:	4a5a      	ldr	r2, [pc, #360]	; (80103d8 <DoProgram+0x310>)
 8010270:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8010274:	4413      	add	r3, r2
 8010276:	2201      	movs	r2, #1
 8010278:	701a      	strb	r2, [r3, #0]
 801027a:	e005      	b.n	8010288 <DoProgram+0x1c0>
			} else {
				ChanelChangeDirect[i] = false;
 801027c:	4a56      	ldr	r2, [pc, #344]	; (80103d8 <DoProgram+0x310>)
 801027e:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8010282:	4413      	add	r3, r2
 8010284:	2200      	movs	r2, #0
 8010286:	701a      	strb	r2, [r3, #0]
			}
			ChanelDirect[i] = ChanelChangeDirect[i];
 8010288:	4a53      	ldr	r2, [pc, #332]	; (80103d8 <DoProgram+0x310>)
 801028a:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 801028e:	4413      	add	r3, r2
 8010290:	7819      	ldrb	r1, [r3, #0]
 8010292:	4a52      	ldr	r2, [pc, #328]	; (80103dc <DoProgram+0x314>)
 8010294:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 8010298:	4413      	add	r3, r2
 801029a:	460a      	mov	r2, r1
 801029c:	701a      	strb	r2, [r3, #0]
		for (int i = 0; i < 8; i++) {
 801029e:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 80102a2:	3301      	adds	r3, #1
 80102a4:	f8c7 31a4 	str.w	r3, [r7, #420]	; 0x1a4
 80102a8:	f8d7 31a4 	ldr.w	r3, [r7, #420]	; 0x1a4
 80102ac:	2b07      	cmp	r3, #7
 80102ae:	ddd6      	ble.n	801025e <DoProgram+0x196>
		}

	}
	BKP_WriteBackupRegister(BKP_DR7, 53);
 80102b0:	2135      	movs	r1, #53	; 0x35
 80102b2:	201c      	movs	r0, #28
 80102b4:	4b39      	ldr	r3, [pc, #228]	; (801039c <DoProgram+0x2d4>)
 80102b6:	4798      	blx	r3
	if (pxConfig->devcfg.logica.SwitchTime * 1000 < atcGetCounter()) {
 80102b8:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 80102bc:	f8b3 3478 	ldrh.w	r3, [r3, #1144]	; 0x478
 80102c0:	b29b      	uxth	r3, r3
 80102c2:	461a      	mov	r2, r3
 80102c4:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80102c8:	fb03 f402 	mul.w	r4, r3, r2
 80102cc:	4b3b      	ldr	r3, [pc, #236]	; (80103bc <DoProgram+0x2f4>)
 80102ce:	4798      	blx	r3
 80102d0:	4603      	mov	r3, r0
 80102d2:	429c      	cmp	r4, r3
 80102d4:	da34      	bge.n	8010340 <DoProgram+0x278>
		for (int i = 0; i < 8; i++) {
 80102d6:	2300      	movs	r3, #0
 80102d8:	f8c7 31a0 	str.w	r3, [r7, #416]	; 0x1a0
 80102dc:	e02a      	b.n	8010334 <DoProgram+0x26c>
			if (!block[i]) {
 80102de:	4a3c      	ldr	r2, [pc, #240]	; (80103d0 <DoProgram+0x308>)
 80102e0:	f8d7 31a0 	ldr.w	r3, [r7, #416]	; 0x1a0
 80102e4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 80102e8:	2b00      	cmp	r3, #0
 80102ea:	d11e      	bne.n	801032a <DoProgram+0x262>
				uint16 tmpGrNum = pxConfig->devcfg.logica.confCU[i].grafNum;
 80102ec:	f8d7 1160 	ldr.w	r1, [r7, #352]	; 0x160
 80102f0:	f8d7 21a0 	ldr.w	r2, [r7, #416]	; 0x1a0
 80102f4:	4613      	mov	r3, r2
 80102f6:	005b      	lsls	r3, r3, #1
 80102f8:	4413      	add	r3, r2
 80102fa:	009b      	lsls	r3, r3, #2
 80102fc:	440b      	add	r3, r1
 80102fe:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8010302:	781a      	ldrb	r2, [r3, #0]
 8010304:	785b      	ldrb	r3, [r3, #1]
 8010306:	021b      	lsls	r3, r3, #8
 8010308:	4313      	orrs	r3, r2
 801030a:	f8a7 315c 	strh.w	r3, [r7, #348]	; 0x15c
				if (tmpGrNum > 0 && tmpGrNum < 9) {
 801030e:	f8b7 315c 	ldrh.w	r3, [r7, #348]	; 0x15c
 8010312:	2b00      	cmp	r3, #0
 8010314:	d009      	beq.n	801032a <DoProgram+0x262>
 8010316:	f8b7 315c 	ldrh.w	r3, [r7, #348]	; 0x15c
 801031a:	2b08      	cmp	r3, #8
 801031c:	d805      	bhi.n	801032a <DoProgram+0x262>
					SetChannelBitDirect(i, RAM.LocalCommand, 0);
 801031e:	2200      	movs	r2, #0
 8010320:	4919      	ldr	r1, [pc, #100]	; (8010388 <DoProgram+0x2c0>)
 8010322:	f8d7 01a0 	ldr.w	r0, [r7, #416]	; 0x1a0
 8010326:	4b2b      	ldr	r3, [pc, #172]	; (80103d4 <DoProgram+0x30c>)
 8010328:	4798      	blx	r3
		for (int i = 0; i < 8; i++) {
 801032a:	f8d7 31a0 	ldr.w	r3, [r7, #416]	; 0x1a0
 801032e:	3301      	adds	r3, #1
 8010330:	f8c7 31a0 	str.w	r3, [r7, #416]	; 0x1a0
 8010334:	f8d7 31a0 	ldr.w	r3, [r7, #416]	; 0x1a0
 8010338:	2b07      	cmp	r3, #7
 801033a:	ddd0      	ble.n	80102de <DoProgram+0x216>
				}
			}
		}
		atcResetCounter();
 801033c:	4b28      	ldr	r3, [pc, #160]	; (80103e0 <DoProgram+0x318>)
 801033e:	4798      	blx	r3
	}

	rtcGetDataTime(&dt);
 8010340:	f507 7394 	add.w	r3, r7, #296	; 0x128
 8010344:	4618      	mov	r0, r3
 8010346:	4b27      	ldr	r3, [pc, #156]	; (80103e4 <DoProgram+0x31c>)
 8010348:	4798      	blx	r3
	rtcGetDataTime(&dtl);
 801034a:	f507 739c 	add.w	r3, r7, #312	; 0x138
 801034e:	4618      	mov	r0, r3
 8010350:	4b24      	ldr	r3, [pc, #144]	; (80103e4 <DoProgram+0x31c>)
 8010352:	4798      	blx	r3
	BKP_WriteBackupRegister(BKP_DR7, 54);
 8010354:	2136      	movs	r1, #54	; 0x36
 8010356:	201c      	movs	r0, #28
 8010358:	4b10      	ldr	r3, [pc, #64]	; (801039c <DoProgram+0x2d4>)
 801035a:	4798      	blx	r3
	if (CheckDiscretMask(pxConfig->devcfg.logica.MaskControl)) {
 801035c:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 8010360:	f503 638d 	add.w	r3, r3, #1128	; 0x468
 8010364:	4618      	mov	r0, r3
 8010366:	4b20      	ldr	r3, [pc, #128]	; (80103e8 <DoProgram+0x320>)
 8010368:	4798      	blx	r3
 801036a:	4603      	mov	r3, r0
 801036c:	2b00      	cmp	r3, #0
 801036e:	d03f      	beq.n	80103f0 <DoProgram+0x328>

		RAM.LogicErrorFlags &= ~(1 << 3);
 8010370:	4b05      	ldr	r3, [pc, #20]	; (8010388 <DoProgram+0x2c0>)
 8010372:	7a1b      	ldrb	r3, [r3, #8]
 8010374:	f023 0308 	bic.w	r3, r3, #8
 8010378:	b2da      	uxtb	r2, r3
 801037a:	4b03      	ldr	r3, [pc, #12]	; (8010388 <DoProgram+0x2c0>)
 801037c:	721a      	strb	r2, [r3, #8]
		CheckErrors();
 801037e:	4b1b      	ldr	r3, [pc, #108]	; (80103ec <DoProgram+0x324>)
 8010380:	4798      	blx	r3
 8010382:	e03e      	b.n	8010402 <DoProgram+0x33a>
 8010384:	0802b000 	.word	0x0802b000
 8010388:	2000745c 	.word	0x2000745c
 801038c:	0800f259 	.word	0x0800f259
 8010390:	20009420 	.word	0x20009420
 8010394:	20009424 	.word	0x20009424
 8010398:	0800ed11 	.word	0x0800ed11
 801039c:	08003621 	.word	0x08003621
 80103a0:	0800ff55 	.word	0x0800ff55
 80103a4:	08001529 	.word	0x08001529
 80103a8:	080025f9 	.word	0x080025f9
 80103ac:	0001869f 	.word	0x0001869f
 80103b0:	080060b5 	.word	0x080060b5
 80103b4:	08006ca1 	.word	0x08006ca1
 80103b8:	0800261d 	.word	0x0800261d
 80103bc:	080063e5 	.word	0x080063e5
 80103c0:	2000942c 	.word	0x2000942c
 80103c4:	0800f36b 	.word	0x0800f36b
 80103c8:	08015710 	.word	0x08015710
 80103cc:	0800edb5 	.word	0x0800edb5
 80103d0:	20009434 	.word	0x20009434
 80103d4:	0800f581 	.word	0x0800f581
 80103d8:	20009410 	.word	0x20009410
 80103dc:	20009400 	.word	0x20009400
 80103e0:	080063c1 	.word	0x080063c1
 80103e4:	0800548d 	.word	0x0800548d
 80103e8:	0800f7e9 	.word	0x0800f7e9
 80103ec:	0800fb55 	.word	0x0800fb55

	} else {

		RAM.LogicErrorFlags |= (1 << 3);
 80103f0:	4b71      	ldr	r3, [pc, #452]	; (80105b8 <DoProgram+0x4f0>)
 80103f2:	7a1b      	ldrb	r3, [r3, #8]
 80103f4:	f043 0308 	orr.w	r3, r3, #8
 80103f8:	b2da      	uxtb	r2, r3
 80103fa:	4b6f      	ldr	r3, [pc, #444]	; (80105b8 <DoProgram+0x4f0>)
 80103fc:	721a      	strb	r2, [r3, #8]
		CheckErrors();
 80103fe:	4b6f      	ldr	r3, [pc, #444]	; (80105bc <DoProgram+0x4f4>)
 8010400:	4798      	blx	r3

	}


	if (CheckDiscretMask(pxConfig->devcfg.logica.MaskPower)) {
 8010402:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 8010406:	f503 638e 	add.w	r3, r3, #1136	; 0x470
 801040a:	4618      	mov	r0, r3
 801040c:	4b6c      	ldr	r3, [pc, #432]	; (80105c0 <DoProgram+0x4f8>)
 801040e:	4798      	blx	r3
 8010410:	4603      	mov	r3, r0
 8010412:	2b00      	cmp	r3, #0
 8010414:	d009      	beq.n	801042a <DoProgram+0x362>

		RAM.LogicErrorFlags &= ~(1);
 8010416:	4b68      	ldr	r3, [pc, #416]	; (80105b8 <DoProgram+0x4f0>)
 8010418:	7a1b      	ldrb	r3, [r3, #8]
 801041a:	f023 0301 	bic.w	r3, r3, #1
 801041e:	b2da      	uxtb	r2, r3
 8010420:	4b65      	ldr	r3, [pc, #404]	; (80105b8 <DoProgram+0x4f0>)
 8010422:	721a      	strb	r2, [r3, #8]
		CheckErrors();
 8010424:	4b65      	ldr	r3, [pc, #404]	; (80105bc <DoProgram+0x4f4>)
 8010426:	4798      	blx	r3
 8010428:	e008      	b.n	801043c <DoProgram+0x374>

	} else {

		RAM.LogicErrorFlags |= (1);
 801042a:	4b63      	ldr	r3, [pc, #396]	; (80105b8 <DoProgram+0x4f0>)
 801042c:	7a1b      	ldrb	r3, [r3, #8]
 801042e:	f043 0301 	orr.w	r3, r3, #1
 8010432:	b2da      	uxtb	r2, r3
 8010434:	4b60      	ldr	r3, [pc, #384]	; (80105b8 <DoProgram+0x4f0>)
 8010436:	721a      	strb	r2, [r3, #8]
		CheckErrors();
 8010438:	4b60      	ldr	r3, [pc, #384]	; (80105bc <DoProgram+0x4f4>)
 801043a:	4798      	blx	r3

	}

	BKP_WriteBackupRegister(BKP_DR7, 55);
 801043c:	2137      	movs	r1, #55	; 0x37
 801043e:	201c      	movs	r0, #28
 8010440:	4b60      	ldr	r3, [pc, #384]	; (80105c4 <DoProgram+0x4fc>)
 8010442:	4798      	blx	r3
	for (int i = 0; i < 8; i++) {
 8010444:	2300      	movs	r3, #0
 8010446:	f8c7 319c 	str.w	r3, [r7, #412]	; 0x19c
 801044a:	e040      	b.n	80104ce <DoProgram+0x406>
		if (GetChannelBitRepare(i, RAM.CommonCommand) == 1) {
 801044c:	495e      	ldr	r1, [pc, #376]	; (80105c8 <DoProgram+0x500>)
 801044e:	f8d7 019c 	ldr.w	r0, [r7, #412]	; 0x19c
 8010452:	4b5e      	ldr	r3, [pc, #376]	; (80105cc <DoProgram+0x504>)
 8010454:	4798      	blx	r3
 8010456:	4603      	mov	r3, r0
 8010458:	2b01      	cmp	r3, #1
 801045a:	d133      	bne.n	80104c4 <DoProgram+0x3fc>
			if (GetChannelBitRepare(i, RAM.OutputCommand) == 1)
 801045c:	495c      	ldr	r1, [pc, #368]	; (80105d0 <DoProgram+0x508>)
 801045e:	f8d7 019c 	ldr.w	r0, [r7, #412]	; 0x19c
 8010462:	4b5a      	ldr	r3, [pc, #360]	; (80105cc <DoProgram+0x504>)
 8010464:	4798      	blx	r3
 8010466:	4603      	mov	r3, r0
 8010468:	2b01      	cmp	r3, #1
 801046a:	d02a      	beq.n	80104c2 <DoProgram+0x3fa>
				continue;
			SetChannelBitSignal(i, RAM.LocalCommand,GetChannelBitSignal(i, RAM.CommonCommand));
 801046c:	4956      	ldr	r1, [pc, #344]	; (80105c8 <DoProgram+0x500>)
 801046e:	f8d7 019c 	ldr.w	r0, [r7, #412]	; 0x19c
 8010472:	4b58      	ldr	r3, [pc, #352]	; (80105d4 <DoProgram+0x50c>)
 8010474:	4798      	blx	r3
 8010476:	4603      	mov	r3, r0
 8010478:	461a      	mov	r2, r3
 801047a:	494f      	ldr	r1, [pc, #316]	; (80105b8 <DoProgram+0x4f0>)
 801047c:	f8d7 019c 	ldr.w	r0, [r7, #412]	; 0x19c
 8010480:	4b55      	ldr	r3, [pc, #340]	; (80105d8 <DoProgram+0x510>)
 8010482:	4798      	blx	r3
			SetChannelBitDirect(i, RAM.LocalCommand,GetChannelBitDirect(i, RAM.CommonCommand));
 8010484:	4950      	ldr	r1, [pc, #320]	; (80105c8 <DoProgram+0x500>)
 8010486:	f8d7 019c 	ldr.w	r0, [r7, #412]	; 0x19c
 801048a:	4b54      	ldr	r3, [pc, #336]	; (80105dc <DoProgram+0x514>)
 801048c:	4798      	blx	r3
 801048e:	4603      	mov	r3, r0
 8010490:	461a      	mov	r2, r3
 8010492:	4949      	ldr	r1, [pc, #292]	; (80105b8 <DoProgram+0x4f0>)
 8010494:	f8d7 019c 	ldr.w	r0, [r7, #412]	; 0x19c
 8010498:	4b51      	ldr	r3, [pc, #324]	; (80105e0 <DoProgram+0x518>)
 801049a:	4798      	blx	r3
			SetChannelBitReserv(i, RAM.LocalCommand,GetChannelBitReserv(i, RAM.CommonCommand));
 801049c:	494a      	ldr	r1, [pc, #296]	; (80105c8 <DoProgram+0x500>)
 801049e:	f8d7 019c 	ldr.w	r0, [r7, #412]	; 0x19c
 80104a2:	4b50      	ldr	r3, [pc, #320]	; (80105e4 <DoProgram+0x51c>)
 80104a4:	4798      	blx	r3
 80104a6:	4603      	mov	r3, r0
 80104a8:	461a      	mov	r2, r3
 80104aa:	4943      	ldr	r1, [pc, #268]	; (80105b8 <DoProgram+0x4f0>)
 80104ac:	f8d7 019c 	ldr.w	r0, [r7, #412]	; 0x19c
 80104b0:	4b4d      	ldr	r3, [pc, #308]	; (80105e8 <DoProgram+0x520>)
 80104b2:	4798      	blx	r3
			SetChannelBitRepare(i, RAM.CommonCommand, 0); //insurance to make global command only once.
 80104b4:	2200      	movs	r2, #0
 80104b6:	4944      	ldr	r1, [pc, #272]	; (80105c8 <DoProgram+0x500>)
 80104b8:	f8d7 019c 	ldr.w	r0, [r7, #412]	; 0x19c
 80104bc:	4b4b      	ldr	r3, [pc, #300]	; (80105ec <DoProgram+0x524>)
 80104be:	4798      	blx	r3
 80104c0:	e000      	b.n	80104c4 <DoProgram+0x3fc>
				continue;
 80104c2:	bf00      	nop
	for (int i = 0; i < 8; i++) {
 80104c4:	f8d7 319c 	ldr.w	r3, [r7, #412]	; 0x19c
 80104c8:	3301      	adds	r3, #1
 80104ca:	f8c7 319c 	str.w	r3, [r7, #412]	; 0x19c
 80104ce:	f8d7 319c 	ldr.w	r3, [r7, #412]	; 0x19c
 80104d2:	2b07      	cmp	r3, #7
 80104d4:	ddba      	ble.n	801044c <DoProgram+0x384>
		}
	}
	BKP_WriteBackupRegister(BKP_DR7, 56);
 80104d6:	2138      	movs	r1, #56	; 0x38
 80104d8:	201c      	movs	r0, #28
 80104da:	4b3a      	ldr	r3, [pc, #232]	; (80105c4 <DoProgram+0x4fc>)
 80104dc:	4798      	blx	r3
	for (int i = 0; i < 8; i++) {
 80104de:	2300      	movs	r3, #0
 80104e0:	f8c7 3198 	str.w	r3, [r7, #408]	; 0x198
 80104e4:	e05b      	b.n	801059e <DoProgram+0x4d6>
		if (pxConfig->devcfg.logica.confCU[i].releNum == 0)
 80104e6:	f8d7 1160 	ldr.w	r1, [r7, #352]	; 0x160
 80104ea:	f8d7 2198 	ldr.w	r2, [r7, #408]	; 0x198
 80104ee:	4613      	mov	r3, r2
 80104f0:	005b      	lsls	r3, r3, #1
 80104f2:	4413      	add	r3, r2
 80104f4:	009b      	lsls	r3, r3, #2
 80104f6:	440b      	add	r3, r1
 80104f8:	f203 4302 	addw	r3, r3, #1026	; 0x402
 80104fc:	781b      	ldrb	r3, [r3, #0]
 80104fe:	2b00      	cmp	r3, #0
 8010500:	d047      	beq.n	8010592 <DoProgram+0x4ca>
			continue;

		SetChannelBitRepare(i, RAM.OutputCommand,GetChannelBitRepare(i, RAM.LocalCommand));
 8010502:	492d      	ldr	r1, [pc, #180]	; (80105b8 <DoProgram+0x4f0>)
 8010504:	f8d7 0198 	ldr.w	r0, [r7, #408]	; 0x198
 8010508:	4b30      	ldr	r3, [pc, #192]	; (80105cc <DoProgram+0x504>)
 801050a:	4798      	blx	r3
 801050c:	4603      	mov	r3, r0
 801050e:	461a      	mov	r2, r3
 8010510:	492f      	ldr	r1, [pc, #188]	; (80105d0 <DoProgram+0x508>)
 8010512:	f8d7 0198 	ldr.w	r0, [r7, #408]	; 0x198
 8010516:	4b35      	ldr	r3, [pc, #212]	; (80105ec <DoProgram+0x524>)
 8010518:	4798      	blx	r3
		SetChannelBitReserv(i, RAM.OutputCommand,GetChannelBitReserv(i, RAM.LocalCommand));
 801051a:	4927      	ldr	r1, [pc, #156]	; (80105b8 <DoProgram+0x4f0>)
 801051c:	f8d7 0198 	ldr.w	r0, [r7, #408]	; 0x198
 8010520:	4b30      	ldr	r3, [pc, #192]	; (80105e4 <DoProgram+0x51c>)
 8010522:	4798      	blx	r3
 8010524:	4603      	mov	r3, r0
 8010526:	461a      	mov	r2, r3
 8010528:	4929      	ldr	r1, [pc, #164]	; (80105d0 <DoProgram+0x508>)
 801052a:	f8d7 0198 	ldr.w	r0, [r7, #408]	; 0x198
 801052e:	4b2e      	ldr	r3, [pc, #184]	; (80105e8 <DoProgram+0x520>)
 8010530:	4798      	blx	r3

		if (GetChannelBitDirect(i, RAM.LocalCommand) == 1) {
 8010532:	4921      	ldr	r1, [pc, #132]	; (80105b8 <DoProgram+0x4f0>)
 8010534:	f8d7 0198 	ldr.w	r0, [r7, #408]	; 0x198
 8010538:	4b28      	ldr	r3, [pc, #160]	; (80105dc <DoProgram+0x514>)
 801053a:	4798      	blx	r3
 801053c:	4603      	mov	r3, r0
 801053e:	2b01      	cmp	r3, #1
 8010540:	d112      	bne.n	8010568 <DoProgram+0x4a0>
			SetChannelBitDirect(i, RAM.OutputCommand, 1);
 8010542:	2201      	movs	r2, #1
 8010544:	4922      	ldr	r1, [pc, #136]	; (80105d0 <DoProgram+0x508>)
 8010546:	f8d7 0198 	ldr.w	r0, [r7, #408]	; 0x198
 801054a:	4b25      	ldr	r3, [pc, #148]	; (80105e0 <DoProgram+0x518>)
 801054c:	4798      	blx	r3

			SetChannelBitSignal(i, RAM.OutputCommand,
 801054e:	491a      	ldr	r1, [pc, #104]	; (80105b8 <DoProgram+0x4f0>)
 8010550:	f8d7 0198 	ldr.w	r0, [r7, #408]	; 0x198
 8010554:	4b1f      	ldr	r3, [pc, #124]	; (80105d4 <DoProgram+0x50c>)
 8010556:	4798      	blx	r3
 8010558:	4603      	mov	r3, r0
 801055a:	461a      	mov	r2, r3
 801055c:	491c      	ldr	r1, [pc, #112]	; (80105d0 <DoProgram+0x508>)
 801055e:	f8d7 0198 	ldr.w	r0, [r7, #408]	; 0x198
 8010562:	4b1d      	ldr	r3, [pc, #116]	; (80105d8 <DoProgram+0x510>)
 8010564:	4798      	blx	r3
 8010566:	e015      	b.n	8010594 <DoProgram+0x4cc>
					GetChannelBitSignal(i, RAM.LocalCommand));

		} else {
			SetChannelBitDirect(i, RAM.OutputCommand, 0);
 8010568:	2200      	movs	r2, #0
 801056a:	4919      	ldr	r1, [pc, #100]	; (80105d0 <DoProgram+0x508>)
 801056c:	f8d7 0198 	ldr.w	r0, [r7, #408]	; 0x198
 8010570:	4b1b      	ldr	r3, [pc, #108]	; (80105e0 <DoProgram+0x518>)
 8010572:	4798      	blx	r3
			if (GetChannelBitRepare(i, RAM.LocalCommand) == 1) {
 8010574:	4910      	ldr	r1, [pc, #64]	; (80105b8 <DoProgram+0x4f0>)
 8010576:	f8d7 0198 	ldr.w	r0, [r7, #408]	; 0x198
 801057a:	4b14      	ldr	r3, [pc, #80]	; (80105cc <DoProgram+0x504>)
 801057c:	4798      	blx	r3
 801057e:	4603      	mov	r3, r0
 8010580:	2b01      	cmp	r3, #1
 8010582:	d107      	bne.n	8010594 <DoProgram+0x4cc>
				SetChannelBitSignal(i, RAM.OutputCommand, 0);
 8010584:	2200      	movs	r2, #0
 8010586:	4912      	ldr	r1, [pc, #72]	; (80105d0 <DoProgram+0x508>)
 8010588:	f8d7 0198 	ldr.w	r0, [r7, #408]	; 0x198
 801058c:	4b12      	ldr	r3, [pc, #72]	; (80105d8 <DoProgram+0x510>)
 801058e:	4798      	blx	r3
 8010590:	e000      	b.n	8010594 <DoProgram+0x4cc>
			continue;
 8010592:	bf00      	nop
	for (int i = 0; i < 8; i++) {
 8010594:	f8d7 3198 	ldr.w	r3, [r7, #408]	; 0x198
 8010598:	3301      	adds	r3, #1
 801059a:	f8c7 3198 	str.w	r3, [r7, #408]	; 0x198
 801059e:	f8d7 3198 	ldr.w	r3, [r7, #408]	; 0x198
 80105a2:	2b07      	cmp	r3, #7
 80105a4:	dd9f      	ble.n	80104e6 <DoProgram+0x41e>
			}

		}

	}
	BKP_WriteBackupRegister(BKP_DR7, 57);
 80105a6:	2139      	movs	r1, #57	; 0x39
 80105a8:	201c      	movs	r0, #28
 80105aa:	4b06      	ldr	r3, [pc, #24]	; (80105c4 <DoProgram+0x4fc>)
 80105ac:	4798      	blx	r3
	//grafs check
	for (int i = 0; i < 8; i++) {
 80105ae:	2300      	movs	r3, #0
 80105b0:	f8c7 3194 	str.w	r3, [r7, #404]	; 0x194
 80105b4:	e3ca      	b.n	8010d4c <DoProgram+0xc84>
 80105b6:	bf00      	nop
 80105b8:	2000745c 	.word	0x2000745c
 80105bc:	0800fb55 	.word	0x0800fb55
 80105c0:	0800f7e9 	.word	0x0800f7e9
 80105c4:	08003621 	.word	0x08003621
 80105c8:	20007858 	.word	0x20007858
 80105cc:	0800f31d 	.word	0x0800f31d
 80105d0:	20007460 	.word	0x20007460
 80105d4:	0800f2d1 	.word	0x0800f2d1
 80105d8:	0800f407 	.word	0x0800f407
 80105dc:	0800f36b 	.word	0x0800f36b
 80105e0:	0800f581 	.word	0x0800f581
 80105e4:	0800f3b9 	.word	0x0800f3b9
 80105e8:	0800f633 	.word	0x0800f633
 80105ec:	0800f4b5 	.word	0x0800f4b5
		uint16 tmpGrNum = pxConfig->devcfg.logica.confCU[i].grafNum;
 80105f0:	f8d7 1160 	ldr.w	r1, [r7, #352]	; 0x160
 80105f4:	f8d7 2194 	ldr.w	r2, [r7, #404]	; 0x194
 80105f8:	4613      	mov	r3, r2
 80105fa:	005b      	lsls	r3, r3, #1
 80105fc:	4413      	add	r3, r2
 80105fe:	009b      	lsls	r3, r3, #2
 8010600:	440b      	add	r3, r1
 8010602:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8010606:	781a      	ldrb	r2, [r3, #0]
 8010608:	785b      	ldrb	r3, [r3, #1]
 801060a:	021b      	lsls	r3, r3, #8
 801060c:	4313      	orrs	r3, r2
 801060e:	f8a7 3192 	strh.w	r3, [r7, #402]	; 0x192

		if (GetChannelBitRepare(i, RAM.OutputCommand)) {
 8010612:	49d7      	ldr	r1, [pc, #860]	; (8010970 <DoProgram+0x8a8>)
 8010614:	f8d7 0194 	ldr.w	r0, [r7, #404]	; 0x194
 8010618:	4bd6      	ldr	r3, [pc, #856]	; (8010974 <DoProgram+0x8ac>)
 801061a:	4798      	blx	r3
 801061c:	4603      	mov	r3, r0
 801061e:	2b00      	cmp	r3, #0
 8010620:	f040 838c 	bne.w	8010d3c <DoProgram+0xc74>

			continue;
		}

		if (GetChannelBitDirect(i, RAM.OutputCommand)) {
 8010624:	49d2      	ldr	r1, [pc, #840]	; (8010970 <DoProgram+0x8a8>)
 8010626:	f8d7 0194 	ldr.w	r0, [r7, #404]	; 0x194
 801062a:	4bd3      	ldr	r3, [pc, #844]	; (8010978 <DoProgram+0x8b0>)
 801062c:	4798      	blx	r3
 801062e:	4603      	mov	r3, r0
 8010630:	2b00      	cmp	r3, #0
 8010632:	f040 8385 	bne.w	8010d40 <DoProgram+0xc78>
			continue;
		}

		if (tmpGrNum > 0 && tmpGrNum < 5) {
 8010636:	f8b7 3192 	ldrh.w	r3, [r7, #402]	; 0x192
 801063a:	2b00      	cmp	r3, #0
 801063c:	f000 8112 	beq.w	8010864 <DoProgram+0x79c>
 8010640:	f8b7 3192 	ldrh.w	r3, [r7, #402]	; 0x192
 8010644:	2b04      	cmp	r3, #4
 8010646:	f200 810d 	bhi.w	8010864 <DoProgram+0x79c>
			tmpGrNum--;
 801064a:	f8b7 3192 	ldrh.w	r3, [r7, #402]	; 0x192
 801064e:	3b01      	subs	r3, #1
 8010650:	f8a7 3192 	strh.w	r3, [r7, #402]	; 0x192
			reverseDay = false;
 8010654:	2300      	movs	r3, #0
 8010656:	f887 31bf 	strb.w	r3, [r7, #447]	; 0x1bf
			uint8 tmp = 0;
 801065a:	2300      	movs	r3, #0
 801065c:	f887 315a 	strb.w	r3, [r7, #346]	; 0x15a
			uint8 startHour =
					pxConfig->devconst.Graph[tmpGrNum].Shedule[dt.Month - 1][dt.Data
							- 1].StartHour;
 8010660:	f8b7 2192 	ldrh.w	r2, [r7, #402]	; 0x192
					pxConfig->devconst.Graph[tmpGrNum].Shedule[dt.Month - 1][dt.Data
 8010664:	f8b7 312a 	ldrh.w	r3, [r7, #298]	; 0x12a
 8010668:	3b01      	subs	r3, #1
 801066a:	f8b7 112c 	ldrh.w	r1, [r7, #300]	; 0x12c
							- 1].StartHour;
 801066e:	1e48      	subs	r0, r1, #1
			uint8 startHour =
 8010670:	f8d7 1160 	ldr.w	r1, [r7, #352]	; 0x160
 8010674:	015c      	lsls	r4, r3, #5
 8010676:	4613      	mov	r3, r2
 8010678:	005b      	lsls	r3, r3, #1
 801067a:	4413      	add	r3, r2
 801067c:	01db      	lsls	r3, r3, #7
 801067e:	4413      	add	r3, r2
 8010680:	4423      	add	r3, r4
 8010682:	4403      	add	r3, r0
 8010684:	f503 7320 	add.w	r3, r3, #640	; 0x280
 8010688:	009b      	lsls	r3, r3, #2
 801068a:	440b      	add	r3, r1
 801068c:	785b      	ldrb	r3, [r3, #1]
 801068e:	f887 3191 	strb.w	r3, [r7, #401]	; 0x191
			uint8 startMin = pxConfig->devconst.Graph[tmpGrNum].Shedule[dt.Month
					- 1][dt.Data - 1].StartMin;
 8010692:	f8b7 2192 	ldrh.w	r2, [r7, #402]	; 0x192
			uint8 startMin = pxConfig->devconst.Graph[tmpGrNum].Shedule[dt.Month
 8010696:	f8b7 312a 	ldrh.w	r3, [r7, #298]	; 0x12a
					- 1][dt.Data - 1].StartMin;
 801069a:	3b01      	subs	r3, #1
 801069c:	f8b7 112c 	ldrh.w	r1, [r7, #300]	; 0x12c
 80106a0:	1e48      	subs	r0, r1, #1
			uint8 startMin = pxConfig->devconst.Graph[tmpGrNum].Shedule[dt.Month
 80106a2:	f8d7 1160 	ldr.w	r1, [r7, #352]	; 0x160
 80106a6:	015c      	lsls	r4, r3, #5
 80106a8:	4613      	mov	r3, r2
 80106aa:	005b      	lsls	r3, r3, #1
 80106ac:	4413      	add	r3, r2
 80106ae:	01db      	lsls	r3, r3, #7
 80106b0:	4413      	add	r3, r2
 80106b2:	4423      	add	r3, r4
 80106b4:	4403      	add	r3, r0
 80106b6:	f503 7320 	add.w	r3, r3, #640	; 0x280
 80106ba:	f811 3023 	ldrb.w	r3, [r1, r3, lsl #2]
 80106be:	f887 3190 	strb.w	r3, [r7, #400]	; 0x190
			uint8 finishHour =
					pxConfig->devconst.Graph[tmpGrNum].Shedule[dt.Month - 1][dt.Data
							- 1].FinishHour;
 80106c2:	f8b7 2192 	ldrh.w	r2, [r7, #402]	; 0x192
					pxConfig->devconst.Graph[tmpGrNum].Shedule[dt.Month - 1][dt.Data
 80106c6:	f8b7 312a 	ldrh.w	r3, [r7, #298]	; 0x12a
 80106ca:	3b01      	subs	r3, #1
 80106cc:	f8b7 112c 	ldrh.w	r1, [r7, #300]	; 0x12c
							- 1].FinishHour;
 80106d0:	1e48      	subs	r0, r1, #1
			uint8 finishHour =
 80106d2:	f8d7 1160 	ldr.w	r1, [r7, #352]	; 0x160
 80106d6:	015c      	lsls	r4, r3, #5
 80106d8:	4613      	mov	r3, r2
 80106da:	005b      	lsls	r3, r3, #1
 80106dc:	4413      	add	r3, r2
 80106de:	01db      	lsls	r3, r3, #7
 80106e0:	4413      	add	r3, r2
 80106e2:	4423      	add	r3, r4
 80106e4:	4403      	add	r3, r0
 80106e6:	f503 7320 	add.w	r3, r3, #640	; 0x280
 80106ea:	009b      	lsls	r3, r3, #2
 80106ec:	440b      	add	r3, r1
 80106ee:	78db      	ldrb	r3, [r3, #3]
 80106f0:	f887 318f 	strb.w	r3, [r7, #399]	; 0x18f
			uint8 finishMin =
					pxConfig->devconst.Graph[tmpGrNum].Shedule[dt.Month - 1][dt.Data
							- 1].FinishMin;
 80106f4:	f8b7 2192 	ldrh.w	r2, [r7, #402]	; 0x192
					pxConfig->devconst.Graph[tmpGrNum].Shedule[dt.Month - 1][dt.Data
 80106f8:	f8b7 312a 	ldrh.w	r3, [r7, #298]	; 0x12a
 80106fc:	3b01      	subs	r3, #1
 80106fe:	f8b7 112c 	ldrh.w	r1, [r7, #300]	; 0x12c
							- 1].FinishMin;
 8010702:	1e48      	subs	r0, r1, #1
			uint8 finishMin =
 8010704:	f8d7 1160 	ldr.w	r1, [r7, #352]	; 0x160
 8010708:	015c      	lsls	r4, r3, #5
 801070a:	4613      	mov	r3, r2
 801070c:	005b      	lsls	r3, r3, #1
 801070e:	4413      	add	r3, r2
 8010710:	01db      	lsls	r3, r3, #7
 8010712:	4413      	add	r3, r2
 8010714:	4423      	add	r3, r4
 8010716:	4403      	add	r3, r0
 8010718:	f503 7320 	add.w	r3, r3, #640	; 0x280
 801071c:	009b      	lsls	r3, r3, #2
 801071e:	440b      	add	r3, r1
 8010720:	789b      	ldrb	r3, [r3, #2]
 8010722:	f887 318e 	strb.w	r3, [r7, #398]	; 0x18e
			if (startHour * 60 + startMin > finishHour * 60 + finishMin) {
 8010726:	f897 2191 	ldrb.w	r2, [r7, #401]	; 0x191
 801072a:	4613      	mov	r3, r2
 801072c:	011b      	lsls	r3, r3, #4
 801072e:	1a9b      	subs	r3, r3, r2
 8010730:	009b      	lsls	r3, r3, #2
 8010732:	461a      	mov	r2, r3
 8010734:	f897 3190 	ldrb.w	r3, [r7, #400]	; 0x190
 8010738:	18d1      	adds	r1, r2, r3
 801073a:	f897 218f 	ldrb.w	r2, [r7, #399]	; 0x18f
 801073e:	4613      	mov	r3, r2
 8010740:	011b      	lsls	r3, r3, #4
 8010742:	1a9b      	subs	r3, r3, r2
 8010744:	009b      	lsls	r3, r3, #2
 8010746:	461a      	mov	r2, r3
 8010748:	f897 318e 	ldrb.w	r3, [r7, #398]	; 0x18e
 801074c:	4413      	add	r3, r2
 801074e:	4299      	cmp	r1, r3
 8010750:	dd1a      	ble.n	8010788 <DoProgram+0x6c0>
				reverseDay = true;
 8010752:	2301      	movs	r3, #1
 8010754:	f887 31bf 	strb.w	r3, [r7, #447]	; 0x1bf
				tmp = startHour;
 8010758:	f897 3191 	ldrb.w	r3, [r7, #401]	; 0x191
 801075c:	f887 315a 	strb.w	r3, [r7, #346]	; 0x15a
				startHour = finishHour;
 8010760:	f897 318f 	ldrb.w	r3, [r7, #399]	; 0x18f
 8010764:	f887 3191 	strb.w	r3, [r7, #401]	; 0x191
				finishHour = tmp;
 8010768:	f897 315a 	ldrb.w	r3, [r7, #346]	; 0x15a
 801076c:	f887 318f 	strb.w	r3, [r7, #399]	; 0x18f

				tmp = startMin;
 8010770:	f897 3190 	ldrb.w	r3, [r7, #400]	; 0x190
 8010774:	f887 315a 	strb.w	r3, [r7, #346]	; 0x15a
				startMin = finishMin;
 8010778:	f897 318e 	ldrb.w	r3, [r7, #398]	; 0x18e
 801077c:	f887 3190 	strb.w	r3, [r7, #400]	; 0x190
				finishMin = tmp;
 8010780:	f897 315a 	ldrb.w	r3, [r7, #346]	; 0x15a
 8010784:	f887 318e 	strb.w	r3, [r7, #398]	; 0x18e
			}
			//-------------- graph 1-3 without economy-------------------
			if(!((finishHour==startHour)&(finishMin==startMin)))
 8010788:	f897 218f 	ldrb.w	r2, [r7, #399]	; 0x18f
 801078c:	f897 3191 	ldrb.w	r3, [r7, #401]	; 0x191
 8010790:	429a      	cmp	r2, r3
 8010792:	bf14      	ite	ne
 8010794:	2301      	movne	r3, #1
 8010796:	2300      	moveq	r3, #0
 8010798:	b2da      	uxtb	r2, r3
 801079a:	f897 118e 	ldrb.w	r1, [r7, #398]	; 0x18e
 801079e:	f897 3190 	ldrb.w	r3, [r7, #400]	; 0x190
 80107a2:	4299      	cmp	r1, r3
 80107a4:	bf14      	ite	ne
 80107a6:	2301      	movne	r3, #1
 80107a8:	2300      	moveq	r3, #0
 80107aa:	b2db      	uxtb	r3, r3
 80107ac:	4313      	orrs	r3, r2
 80107ae:	b2db      	uxtb	r3, r3
 80107b0:	2b00      	cmp	r3, #0
 80107b2:	d057      	beq.n	8010864 <DoProgram+0x79c>
			{
			if ((startHour * 60 + startMin <= (dt.Hour * 60 + dt.Min))
 80107b4:	f897 2191 	ldrb.w	r2, [r7, #401]	; 0x191
 80107b8:	4613      	mov	r3, r2
 80107ba:	011b      	lsls	r3, r3, #4
 80107bc:	1a9b      	subs	r3, r3, r2
 80107be:	009b      	lsls	r3, r3, #2
 80107c0:	461a      	mov	r2, r3
 80107c2:	f897 3190 	ldrb.w	r3, [r7, #400]	; 0x190
 80107c6:	441a      	add	r2, r3
 80107c8:	f8b7 3130 	ldrh.w	r3, [r7, #304]	; 0x130
 80107cc:	4619      	mov	r1, r3
 80107ce:	460b      	mov	r3, r1
 80107d0:	011b      	lsls	r3, r3, #4
 80107d2:	1a5b      	subs	r3, r3, r1
 80107d4:	009b      	lsls	r3, r3, #2
 80107d6:	4619      	mov	r1, r3
 80107d8:	f8b7 3132 	ldrh.w	r3, [r7, #306]	; 0x132
 80107dc:	440b      	add	r3, r1
 80107de:	429a      	cmp	r2, r3
 80107e0:	dc2b      	bgt.n	801083a <DoProgram+0x772>
					&& (finishHour * 60 + finishMin > (dt.Hour * 60 + dt.Min))) {
 80107e2:	f897 218f 	ldrb.w	r2, [r7, #399]	; 0x18f
 80107e6:	4613      	mov	r3, r2
 80107e8:	011b      	lsls	r3, r3, #4
 80107ea:	1a9b      	subs	r3, r3, r2
 80107ec:	009b      	lsls	r3, r3, #2
 80107ee:	461a      	mov	r2, r3
 80107f0:	f897 318e 	ldrb.w	r3, [r7, #398]	; 0x18e
 80107f4:	441a      	add	r2, r3
 80107f6:	f8b7 3130 	ldrh.w	r3, [r7, #304]	; 0x130
 80107fa:	4619      	mov	r1, r3
 80107fc:	460b      	mov	r3, r1
 80107fe:	011b      	lsls	r3, r3, #4
 8010800:	1a5b      	subs	r3, r3, r1
 8010802:	009b      	lsls	r3, r3, #2
 8010804:	4619      	mov	r1, r3
 8010806:	f8b7 3132 	ldrh.w	r3, [r7, #306]	; 0x132
 801080a:	440b      	add	r3, r1
 801080c:	429a      	cmp	r2, r3
 801080e:	dd14      	ble.n	801083a <DoProgram+0x772>
				if (!reverseDay)
 8010810:	f897 31bf 	ldrb.w	r3, [r7, #447]	; 0x1bf
 8010814:	f083 0301 	eor.w	r3, r3, #1
 8010818:	b2db      	uxtb	r3, r3
 801081a:	2b00      	cmp	r3, #0
 801081c:	d006      	beq.n	801082c <DoProgram+0x764>
					SetChannelBitSignal(i, RAM.OutputCommand, 0);
 801081e:	2200      	movs	r2, #0
 8010820:	4953      	ldr	r1, [pc, #332]	; (8010970 <DoProgram+0x8a8>)
 8010822:	f8d7 0194 	ldr.w	r0, [r7, #404]	; 0x194
 8010826:	4b55      	ldr	r3, [pc, #340]	; (801097c <DoProgram+0x8b4>)
 8010828:	4798      	blx	r3
				else
					SetChannelBitSignal(i, RAM.OutputCommand, 1);
				continue;
 801082a:	e28a      	b.n	8010d42 <DoProgram+0xc7a>
					SetChannelBitSignal(i, RAM.OutputCommand, 1);
 801082c:	2201      	movs	r2, #1
 801082e:	4950      	ldr	r1, [pc, #320]	; (8010970 <DoProgram+0x8a8>)
 8010830:	f8d7 0194 	ldr.w	r0, [r7, #404]	; 0x194
 8010834:	4b51      	ldr	r3, [pc, #324]	; (801097c <DoProgram+0x8b4>)
 8010836:	4798      	blx	r3
				continue;
 8010838:	e283      	b.n	8010d42 <DoProgram+0xc7a>
			} else {
				if (!reverseDay)
 801083a:	f897 31bf 	ldrb.w	r3, [r7, #447]	; 0x1bf
 801083e:	f083 0301 	eor.w	r3, r3, #1
 8010842:	b2db      	uxtb	r3, r3
 8010844:	2b00      	cmp	r3, #0
 8010846:	d006      	beq.n	8010856 <DoProgram+0x78e>
					SetChannelBitSignal(i, RAM.OutputCommand, 1);
 8010848:	2201      	movs	r2, #1
 801084a:	4949      	ldr	r1, [pc, #292]	; (8010970 <DoProgram+0x8a8>)
 801084c:	f8d7 0194 	ldr.w	r0, [r7, #404]	; 0x194
 8010850:	4b4a      	ldr	r3, [pc, #296]	; (801097c <DoProgram+0x8b4>)
 8010852:	4798      	blx	r3
				else
					SetChannelBitSignal(i, RAM.OutputCommand, 0);
				continue;
 8010854:	e275      	b.n	8010d42 <DoProgram+0xc7a>
					SetChannelBitSignal(i, RAM.OutputCommand, 0);
 8010856:	2200      	movs	r2, #0
 8010858:	4945      	ldr	r1, [pc, #276]	; (8010970 <DoProgram+0x8a8>)
 801085a:	f8d7 0194 	ldr.w	r0, [r7, #404]	; 0x194
 801085e:	4b47      	ldr	r3, [pc, #284]	; (801097c <DoProgram+0x8b4>)
 8010860:	4798      	blx	r3
				continue;
 8010862:	e26e      	b.n	8010d42 <DoProgram+0xc7a>
			}
			}
		}
		BKP_WriteBackupRegister(BKP_DR7, 58);
 8010864:	213a      	movs	r1, #58	; 0x3a
 8010866:	201c      	movs	r0, #28
 8010868:	4b45      	ldr	r3, [pc, #276]	; (8010980 <DoProgram+0x8b8>)
 801086a:	4798      	blx	r3
		if (tmpGrNum == 5) {
 801086c:	f8b7 3192 	ldrh.w	r3, [r7, #402]	; 0x192
 8010870:	2b05      	cmp	r3, #5
 8010872:	f040 808e 	bne.w	8010992 <DoProgram+0x8ca>
			tmpGrNum--;
 8010876:	f8b7 3192 	ldrh.w	r3, [r7, #402]	; 0x192
 801087a:	3b01      	subs	r3, #1
 801087c:	f8a7 3192 	strh.w	r3, [r7, #402]	; 0x192

			uint8 startMonth = pxConfig->devconst.Schedule4.StartMonth;
 8010880:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 8010884:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8010888:	f893 3c0d 	ldrb.w	r3, [r3, #3085]	; 0xc0d
 801088c:	f887 314f 	strb.w	r3, [r7, #335]	; 0x14f
			uint8 startDate = pxConfig->devconst.Schedule4.StartDay;
 8010890:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 8010894:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8010898:	f893 3c0c 	ldrb.w	r3, [r3, #3084]	; 0xc0c
 801089c:	f887 314e 	strb.w	r3, [r7, #334]	; 0x14e
			uint8 finishMonth = pxConfig->devconst.Schedule4.FinishMonth;
 80108a0:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 80108a4:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 80108a8:	f893 3c0f 	ldrb.w	r3, [r3, #3087]	; 0xc0f
 80108ac:	f887 314d 	strb.w	r3, [r7, #333]	; 0x14d
			uint8 finishDate = pxConfig->devconst.Schedule4.FinishDay;
 80108b0:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 80108b4:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 80108b8:	f893 3c0e 	ldrb.w	r3, [r3, #3086]	; 0xc0e
 80108bc:	f887 314c 	strb.w	r3, [r7, #332]	; 0x14c

			uint8 FnMonth =
 80108c0:	f897 214d 	ldrb.w	r2, [r7, #333]	; 0x14d
 80108c4:	f897 314f 	ldrb.w	r3, [r7, #335]	; 0x14f
 80108c8:	429a      	cmp	r2, r3
 80108ca:	d804      	bhi.n	80108d6 <DoProgram+0x80e>
 80108cc:	f897 314d 	ldrb.w	r3, [r7, #333]	; 0x14d
 80108d0:	330c      	adds	r3, #12
 80108d2:	b2db      	uxtb	r3, r3
 80108d4:	e001      	b.n	80108da <DoProgram+0x812>
 80108d6:	f897 314d 	ldrb.w	r3, [r7, #333]	; 0x14d
 80108da:	f887 314b 	strb.w	r3, [r7, #331]	; 0x14b
					(finishMonth > startMonth) ?
							finishMonth : (finishMonth + 12);
			uint8 CurMonth =
					(dt.Month * 31 + dt.Data >= startMonth * 31 + startDate) ?
 80108de:	f8b7 312a 	ldrh.w	r3, [r7, #298]	; 0x12a
 80108e2:	461a      	mov	r2, r3
 80108e4:	4613      	mov	r3, r2
 80108e6:	015b      	lsls	r3, r3, #5
 80108e8:	1a9b      	subs	r3, r3, r2
 80108ea:	f8b7 212c 	ldrh.w	r2, [r7, #300]	; 0x12c
 80108ee:	1899      	adds	r1, r3, r2
 80108f0:	f897 214f 	ldrb.w	r2, [r7, #335]	; 0x14f
 80108f4:	4613      	mov	r3, r2
 80108f6:	015b      	lsls	r3, r3, #5
 80108f8:	1a9a      	subs	r2, r3, r2
 80108fa:	f897 314e 	ldrb.w	r3, [r7, #334]	; 0x14e
 80108fe:	4413      	add	r3, r2
			uint8 CurMonth =
 8010900:	4299      	cmp	r1, r3
 8010902:	db03      	blt.n	801090c <DoProgram+0x844>
							dt.Month : (dt.Month + 12);
 8010904:	f8b7 312a 	ldrh.w	r3, [r7, #298]	; 0x12a
			uint8 CurMonth =
 8010908:	b2db      	uxtb	r3, r3
 801090a:	e004      	b.n	8010916 <DoProgram+0x84e>
							dt.Month : (dt.Month + 12);
 801090c:	f8b7 312a 	ldrh.w	r3, [r7, #298]	; 0x12a
 8010910:	b2db      	uxtb	r3, r3
			uint8 CurMonth =
 8010912:	330c      	adds	r3, #12
 8010914:	b2db      	uxtb	r3, r3
 8010916:	f887 314a 	strb.w	r3, [r7, #330]	; 0x14a
			//-------------- graph 4 heating-------------------
			if ((startMonth * 31 + startDate <= CurMonth * 31 + dt.Data)
 801091a:	f897 214f 	ldrb.w	r2, [r7, #335]	; 0x14f
 801091e:	4613      	mov	r3, r2
 8010920:	015b      	lsls	r3, r3, #5
 8010922:	1a9a      	subs	r2, r3, r2
 8010924:	f897 314e 	ldrb.w	r3, [r7, #334]	; 0x14e
 8010928:	18d1      	adds	r1, r2, r3
 801092a:	f897 214a 	ldrb.w	r2, [r7, #330]	; 0x14a
 801092e:	4613      	mov	r3, r2
 8010930:	015b      	lsls	r3, r3, #5
 8010932:	1a9b      	subs	r3, r3, r2
 8010934:	f8b7 212c 	ldrh.w	r2, [r7, #300]	; 0x12c
 8010938:	4413      	add	r3, r2
 801093a:	4299      	cmp	r1, r3
 801093c:	dc22      	bgt.n	8010984 <DoProgram+0x8bc>
					&& (FnMonth * 31 + finishDate > CurMonth * 31 + dt.Data)) {
 801093e:	f897 214b 	ldrb.w	r2, [r7, #331]	; 0x14b
 8010942:	4613      	mov	r3, r2
 8010944:	015b      	lsls	r3, r3, #5
 8010946:	1a9a      	subs	r2, r3, r2
 8010948:	f897 314c 	ldrb.w	r3, [r7, #332]	; 0x14c
 801094c:	18d1      	adds	r1, r2, r3
 801094e:	f897 214a 	ldrb.w	r2, [r7, #330]	; 0x14a
 8010952:	4613      	mov	r3, r2
 8010954:	015b      	lsls	r3, r3, #5
 8010956:	1a9b      	subs	r3, r3, r2
 8010958:	f8b7 212c 	ldrh.w	r2, [r7, #300]	; 0x12c
 801095c:	4413      	add	r3, r2
 801095e:	4299      	cmp	r1, r3
 8010960:	dd10      	ble.n	8010984 <DoProgram+0x8bc>
				SetChannelBitSignal(i, RAM.OutputCommand, 1);
 8010962:	2201      	movs	r2, #1
 8010964:	4902      	ldr	r1, [pc, #8]	; (8010970 <DoProgram+0x8a8>)
 8010966:	f8d7 0194 	ldr.w	r0, [r7, #404]	; 0x194
 801096a:	4b04      	ldr	r3, [pc, #16]	; (801097c <DoProgram+0x8b4>)
 801096c:	4798      	blx	r3
				continue;
 801096e:	e1e8      	b.n	8010d42 <DoProgram+0xc7a>
 8010970:	20007460 	.word	0x20007460
 8010974:	0800f31d 	.word	0x0800f31d
 8010978:	0800f36b 	.word	0x0800f36b
 801097c:	0800f407 	.word	0x0800f407
 8010980:	08003621 	.word	0x08003621
			} else {
				SetChannelBitSignal(i, RAM.OutputCommand, 0);
 8010984:	2200      	movs	r2, #0
 8010986:	49e4      	ldr	r1, [pc, #912]	; (8010d18 <DoProgram+0xc50>)
 8010988:	f8d7 0194 	ldr.w	r0, [r7, #404]	; 0x194
 801098c:	4be3      	ldr	r3, [pc, #908]	; (8010d1c <DoProgram+0xc54>)
 801098e:	4798      	blx	r3
				continue;
 8010990:	e1d7      	b.n	8010d42 <DoProgram+0xc7a>
			}
		}
		if (tmpGrNum < 9 && tmpGrNum > 5) {
 8010992:	f8b7 3192 	ldrh.w	r3, [r7, #402]	; 0x192
 8010996:	2b08      	cmp	r3, #8
 8010998:	f200 81d3 	bhi.w	8010d42 <DoProgram+0xc7a>
 801099c:	f8b7 3192 	ldrh.w	r3, [r7, #402]	; 0x192
 80109a0:	2b05      	cmp	r3, #5
 80109a2:	f240 81ce 	bls.w	8010d42 <DoProgram+0xc7a>
			tmpGrNum -= 6;
 80109a6:	f8b7 3192 	ldrh.w	r3, [r7, #402]	; 0x192
 80109aa:	3b06      	subs	r3, #6
 80109ac:	f8a7 3192 	strh.w	r3, [r7, #402]	; 0x192
			uint8 startHour =
					pxConfig->devconst.Graph[tmpGrNum].Shedule[dt.Month - 1][dt.Data
							- 1].StartHour;
 80109b0:	f8b7 2192 	ldrh.w	r2, [r7, #402]	; 0x192
					pxConfig->devconst.Graph[tmpGrNum].Shedule[dt.Month - 1][dt.Data
 80109b4:	f8b7 312a 	ldrh.w	r3, [r7, #298]	; 0x12a
 80109b8:	3b01      	subs	r3, #1
 80109ba:	f8b7 112c 	ldrh.w	r1, [r7, #300]	; 0x12c
							- 1].StartHour;
 80109be:	1e48      	subs	r0, r1, #1
			uint8 startHour =
 80109c0:	f8d7 1160 	ldr.w	r1, [r7, #352]	; 0x160
 80109c4:	015c      	lsls	r4, r3, #5
 80109c6:	4613      	mov	r3, r2
 80109c8:	005b      	lsls	r3, r3, #1
 80109ca:	4413      	add	r3, r2
 80109cc:	01db      	lsls	r3, r3, #7
 80109ce:	4413      	add	r3, r2
 80109d0:	4423      	add	r3, r4
 80109d2:	4403      	add	r3, r0
 80109d4:	f503 7320 	add.w	r3, r3, #640	; 0x280
 80109d8:	009b      	lsls	r3, r3, #2
 80109da:	440b      	add	r3, r1
 80109dc:	785b      	ldrb	r3, [r3, #1]
 80109de:	f887 3159 	strb.w	r3, [r7, #345]	; 0x159
			uint8 startMin = pxConfig->devconst.Graph[tmpGrNum].Shedule[dt.Month
					- 1][dt.Data - 1].StartMin;
 80109e2:	f8b7 2192 	ldrh.w	r2, [r7, #402]	; 0x192
			uint8 startMin = pxConfig->devconst.Graph[tmpGrNum].Shedule[dt.Month
 80109e6:	f8b7 312a 	ldrh.w	r3, [r7, #298]	; 0x12a
					- 1][dt.Data - 1].StartMin;
 80109ea:	3b01      	subs	r3, #1
 80109ec:	f8b7 112c 	ldrh.w	r1, [r7, #300]	; 0x12c
 80109f0:	1e48      	subs	r0, r1, #1
			uint8 startMin = pxConfig->devconst.Graph[tmpGrNum].Shedule[dt.Month
 80109f2:	f8d7 1160 	ldr.w	r1, [r7, #352]	; 0x160
 80109f6:	015c      	lsls	r4, r3, #5
 80109f8:	4613      	mov	r3, r2
 80109fa:	005b      	lsls	r3, r3, #1
 80109fc:	4413      	add	r3, r2
 80109fe:	01db      	lsls	r3, r3, #7
 8010a00:	4413      	add	r3, r2
 8010a02:	4423      	add	r3, r4
 8010a04:	4403      	add	r3, r0
 8010a06:	f503 7320 	add.w	r3, r3, #640	; 0x280
 8010a0a:	f811 3023 	ldrb.w	r3, [r1, r3, lsl #2]
 8010a0e:	f887 3158 	strb.w	r3, [r7, #344]	; 0x158
			uint8 finishHour =
					pxConfig->devconst.Graph[tmpGrNum].Shedule[dt.Month - 1][dt.Data
							- 1].FinishHour;
 8010a12:	f8b7 2192 	ldrh.w	r2, [r7, #402]	; 0x192
					pxConfig->devconst.Graph[tmpGrNum].Shedule[dt.Month - 1][dt.Data
 8010a16:	f8b7 312a 	ldrh.w	r3, [r7, #298]	; 0x12a
 8010a1a:	3b01      	subs	r3, #1
 8010a1c:	f8b7 112c 	ldrh.w	r1, [r7, #300]	; 0x12c
							- 1].FinishHour;
 8010a20:	1e48      	subs	r0, r1, #1
			uint8 finishHour =
 8010a22:	f8d7 1160 	ldr.w	r1, [r7, #352]	; 0x160
 8010a26:	015c      	lsls	r4, r3, #5
 8010a28:	4613      	mov	r3, r2
 8010a2a:	005b      	lsls	r3, r3, #1
 8010a2c:	4413      	add	r3, r2
 8010a2e:	01db      	lsls	r3, r3, #7
 8010a30:	4413      	add	r3, r2
 8010a32:	4423      	add	r3, r4
 8010a34:	4403      	add	r3, r0
 8010a36:	f503 7320 	add.w	r3, r3, #640	; 0x280
 8010a3a:	009b      	lsls	r3, r3, #2
 8010a3c:	440b      	add	r3, r1
 8010a3e:	78db      	ldrb	r3, [r3, #3]
 8010a40:	f887 3157 	strb.w	r3, [r7, #343]	; 0x157
			uint8 finishMin =
					pxConfig->devconst.Graph[tmpGrNum].Shedule[dt.Month - 1][dt.Data
							- 1].FinishMin;
 8010a44:	f8b7 2192 	ldrh.w	r2, [r7, #402]	; 0x192
					pxConfig->devconst.Graph[tmpGrNum].Shedule[dt.Month - 1][dt.Data
 8010a48:	f8b7 312a 	ldrh.w	r3, [r7, #298]	; 0x12a
 8010a4c:	3b01      	subs	r3, #1
 8010a4e:	f8b7 112c 	ldrh.w	r1, [r7, #300]	; 0x12c
							- 1].FinishMin;
 8010a52:	1e48      	subs	r0, r1, #1
			uint8 finishMin =
 8010a54:	f8d7 1160 	ldr.w	r1, [r7, #352]	; 0x160
 8010a58:	015c      	lsls	r4, r3, #5
 8010a5a:	4613      	mov	r3, r2
 8010a5c:	005b      	lsls	r3, r3, #1
 8010a5e:	4413      	add	r3, r2
 8010a60:	01db      	lsls	r3, r3, #7
 8010a62:	4413      	add	r3, r2
 8010a64:	4423      	add	r3, r4
 8010a66:	4403      	add	r3, r0
 8010a68:	f503 7320 	add.w	r3, r3, #640	; 0x280
 8010a6c:	009b      	lsls	r3, r3, #2
 8010a6e:	440b      	add	r3, r1
 8010a70:	789b      	ldrb	r3, [r3, #2]
 8010a72:	f887 3156 	strb.w	r3, [r7, #342]	; 0x156
			//-------------- graphs 1-3 with economy-------------------
			if(!((finishHour==startHour)&(finishMin==startMin)))
 8010a76:	f897 2157 	ldrb.w	r2, [r7, #343]	; 0x157
 8010a7a:	f897 3159 	ldrb.w	r3, [r7, #345]	; 0x159
 8010a7e:	429a      	cmp	r2, r3
 8010a80:	bf14      	ite	ne
 8010a82:	2301      	movne	r3, #1
 8010a84:	2300      	moveq	r3, #0
 8010a86:	b2da      	uxtb	r2, r3
 8010a88:	f897 1156 	ldrb.w	r1, [r7, #342]	; 0x156
 8010a8c:	f897 3158 	ldrb.w	r3, [r7, #344]	; 0x158
 8010a90:	4299      	cmp	r1, r3
 8010a92:	bf14      	ite	ne
 8010a94:	2301      	movne	r3, #1
 8010a96:	2300      	moveq	r3, #0
 8010a98:	b2db      	uxtb	r3, r3
 8010a9a:	4313      	orrs	r3, r2
 8010a9c:	b2db      	uxtb	r3, r3
 8010a9e:	2b00      	cmp	r3, #0
 8010aa0:	f000 814f 	beq.w	8010d42 <DoProgram+0xc7a>
            {
			if (startHour * 60 + startMin <= dt.Hour * 60 + dt.Min
 8010aa4:	f897 2159 	ldrb.w	r2, [r7, #345]	; 0x159
 8010aa8:	4613      	mov	r3, r2
 8010aaa:	011b      	lsls	r3, r3, #4
 8010aac:	1a9b      	subs	r3, r3, r2
 8010aae:	009b      	lsls	r3, r3, #2
 8010ab0:	461a      	mov	r2, r3
 8010ab2:	f897 3158 	ldrb.w	r3, [r7, #344]	; 0x158
 8010ab6:	441a      	add	r2, r3
 8010ab8:	f8b7 3130 	ldrh.w	r3, [r7, #304]	; 0x130
 8010abc:	4619      	mov	r1, r3
 8010abe:	460b      	mov	r3, r1
 8010ac0:	011b      	lsls	r3, r3, #4
 8010ac2:	1a5b      	subs	r3, r3, r1
 8010ac4:	009b      	lsls	r3, r3, #2
 8010ac6:	4619      	mov	r1, r3
 8010ac8:	f8b7 3132 	ldrh.w	r3, [r7, #306]	; 0x132
 8010acc:	440b      	add	r3, r1
 8010ace:	429a      	cmp	r2, r3
 8010ad0:	dc1d      	bgt.n	8010b0e <DoProgram+0xa46>
					&& finishHour * 60 + finishMin > dt.Hour * 60 + dt.Min) {
 8010ad2:	f897 2157 	ldrb.w	r2, [r7, #343]	; 0x157
 8010ad6:	4613      	mov	r3, r2
 8010ad8:	011b      	lsls	r3, r3, #4
 8010ada:	1a9b      	subs	r3, r3, r2
 8010adc:	009b      	lsls	r3, r3, #2
 8010ade:	461a      	mov	r2, r3
 8010ae0:	f897 3156 	ldrb.w	r3, [r7, #342]	; 0x156
 8010ae4:	441a      	add	r2, r3
 8010ae6:	f8b7 3130 	ldrh.w	r3, [r7, #304]	; 0x130
 8010aea:	4619      	mov	r1, r3
 8010aec:	460b      	mov	r3, r1
 8010aee:	011b      	lsls	r3, r3, #4
 8010af0:	1a5b      	subs	r3, r3, r1
 8010af2:	009b      	lsls	r3, r3, #2
 8010af4:	4619      	mov	r1, r3
 8010af6:	f8b7 3132 	ldrh.w	r3, [r7, #306]	; 0x132
 8010afa:	440b      	add	r3, r1
 8010afc:	429a      	cmp	r2, r3
 8010afe:	dd06      	ble.n	8010b0e <DoProgram+0xa46>
				SetChannelBitSignal(i, RAM.OutputCommand, 0);
 8010b00:	2200      	movs	r2, #0
 8010b02:	4985      	ldr	r1, [pc, #532]	; (8010d18 <DoProgram+0xc50>)
 8010b04:	f8d7 0194 	ldr.w	r0, [r7, #404]	; 0x194
 8010b08:	4b84      	ldr	r3, [pc, #528]	; (8010d1c <DoProgram+0xc54>)
 8010b0a:	4798      	blx	r3
				continue;
 8010b0c:	e119      	b.n	8010d42 <DoProgram+0xc7a>
			} else {
				//date economy
				if ((pxConfig->devconst.Graph[tmpGrNum].EconomyDate.StartMonth
 8010b0e:	f8b7 3192 	ldrh.w	r3, [r7, #402]	; 0x192
 8010b12:	f8d7 2160 	ldr.w	r2, [r7, #352]	; 0x160
 8010b16:	f240 6104 	movw	r1, #1540	; 0x604
 8010b1a:	fb01 f303 	mul.w	r3, r1, r3
 8010b1e:	4413      	add	r3, r2
 8010b20:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8010b24:	3301      	adds	r3, #1
 8010b26:	781b      	ldrb	r3, [r3, #0]
 8010b28:	461a      	mov	r2, r3
						* 31
 8010b2a:	4613      	mov	r3, r2
 8010b2c:	015b      	lsls	r3, r3, #5
 8010b2e:	1a9b      	subs	r3, r3, r2
						+ pxConfig->devconst.Graph[tmpGrNum].EconomyDate.StartDay
 8010b30:	f8b7 2192 	ldrh.w	r2, [r7, #402]	; 0x192
 8010b34:	f8d7 1160 	ldr.w	r1, [r7, #352]	; 0x160
 8010b38:	f240 6004 	movw	r0, #1540	; 0x604
 8010b3c:	fb00 f202 	mul.w	r2, r0, r2
 8010b40:	440a      	add	r2, r1
 8010b42:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
 8010b46:	7812      	ldrb	r2, [r2, #0]
 8010b48:	441a      	add	r2, r3
						<= dtl.Month * 31 + dtl.Data)
 8010b4a:	f8b7 313a 	ldrh.w	r3, [r7, #314]	; 0x13a
 8010b4e:	4619      	mov	r1, r3
 8010b50:	460b      	mov	r3, r1
 8010b52:	015b      	lsls	r3, r3, #5
 8010b54:	1a5b      	subs	r3, r3, r1
 8010b56:	f8b7 113c 	ldrh.w	r1, [r7, #316]	; 0x13c
 8010b5a:	440b      	add	r3, r1
				if ((pxConfig->devconst.Graph[tmpGrNum].EconomyDate.StartMonth
 8010b5c:	429a      	cmp	r2, r3
 8010b5e:	f300 80e6 	bgt.w	8010d2e <DoProgram+0xc66>
						&& (pxConfig->devconst.Graph[tmpGrNum].EconomyDate.FinishMonth
 8010b62:	f8b7 3192 	ldrh.w	r3, [r7, #402]	; 0x192
 8010b66:	f8d7 2160 	ldr.w	r2, [r7, #352]	; 0x160
 8010b6a:	f240 6104 	movw	r1, #1540	; 0x604
 8010b6e:	fb01 f303 	mul.w	r3, r1, r3
 8010b72:	4413      	add	r3, r2
 8010b74:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8010b78:	3303      	adds	r3, #3
 8010b7a:	781b      	ldrb	r3, [r3, #0]
 8010b7c:	461a      	mov	r2, r3
								* 31
 8010b7e:	4613      	mov	r3, r2
 8010b80:	015b      	lsls	r3, r3, #5
 8010b82:	1a9a      	subs	r2, r3, r2
								+ pxConfig->devconst.Graph[tmpGrNum].EconomyDate.FinishDay
 8010b84:	f8b7 3192 	ldrh.w	r3, [r7, #402]	; 0x192
 8010b88:	f8d7 1160 	ldr.w	r1, [r7, #352]	; 0x160
 8010b8c:	f240 6004 	movw	r0, #1540	; 0x604
 8010b90:	fb00 f303 	mul.w	r3, r0, r3
 8010b94:	440b      	add	r3, r1
 8010b96:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
 8010b9a:	3302      	adds	r3, #2
 8010b9c:	781b      	ldrb	r3, [r3, #0]
 8010b9e:	441a      	add	r2, r3
								>= dtl.Month * 31 + dtl.Data)) {
 8010ba0:	f8b7 313a 	ldrh.w	r3, [r7, #314]	; 0x13a
 8010ba4:	4619      	mov	r1, r3
 8010ba6:	460b      	mov	r3, r1
 8010ba8:	015b      	lsls	r3, r3, #5
 8010baa:	1a5b      	subs	r3, r3, r1
 8010bac:	f8b7 113c 	ldrh.w	r1, [r7, #316]	; 0x13c
 8010bb0:	440b      	add	r3, r1
						&& (pxConfig->devconst.Graph[tmpGrNum].EconomyDate.FinishMonth
 8010bb2:	429a      	cmp	r2, r3
 8010bb4:	f2c0 80bb 	blt.w	8010d2e <DoProgram+0xc66>
					//time economy
					uint8 startHourEk =
							pxConfig->devconst.Graph[tmpGrNum].Shedule[dtl.Month
									- 1][31].StartHour;
 8010bb8:	f8b7 3192 	ldrh.w	r3, [r7, #402]	; 0x192
							pxConfig->devconst.Graph[tmpGrNum].Shedule[dtl.Month
 8010bbc:	f8b7 213a 	ldrh.w	r2, [r7, #314]	; 0x13a
									- 1][31].StartHour;
 8010bc0:	1e51      	subs	r1, r2, #1
					uint8 startHourEk =
 8010bc2:	f8d7 2160 	ldr.w	r2, [r7, #352]	; 0x160
 8010bc6:	01c9      	lsls	r1, r1, #7
 8010bc8:	f240 6004 	movw	r0, #1540	; 0x604
 8010bcc:	fb00 f303 	mul.w	r3, r0, r3
 8010bd0:	440b      	add	r3, r1
 8010bd2:	4413      	add	r3, r2
 8010bd4:	f603 237d 	addw	r3, r3, #2685	; 0xa7d
 8010bd8:	781b      	ldrb	r3, [r3, #0]
 8010bda:	f887 3155 	strb.w	r3, [r7, #341]	; 0x155
					uint8 startMinEk =
							pxConfig->devconst.Graph[tmpGrNum].Shedule[dtl.Month
									- 1][31].StartMin;
 8010bde:	f8b7 3192 	ldrh.w	r3, [r7, #402]	; 0x192
							pxConfig->devconst.Graph[tmpGrNum].Shedule[dtl.Month
 8010be2:	f8b7 213a 	ldrh.w	r2, [r7, #314]	; 0x13a
									- 1][31].StartMin;
 8010be6:	1e51      	subs	r1, r2, #1
					uint8 startMinEk =
 8010be8:	f8d7 2160 	ldr.w	r2, [r7, #352]	; 0x160
 8010bec:	01c9      	lsls	r1, r1, #7
 8010bee:	f240 6004 	movw	r0, #1540	; 0x604
 8010bf2:	fb00 f303 	mul.w	r3, r0, r3
 8010bf6:	440b      	add	r3, r1
 8010bf8:	4413      	add	r3, r2
 8010bfa:	f603 237c 	addw	r3, r3, #2684	; 0xa7c
 8010bfe:	781b      	ldrb	r3, [r3, #0]
 8010c00:	f887 3154 	strb.w	r3, [r7, #340]	; 0x154
					uint8 finishHourEk =
							pxConfig->devconst.Graph[tmpGrNum].Shedule[dtl.Month
									- 1][31].FinishHour;
 8010c04:	f8b7 3192 	ldrh.w	r3, [r7, #402]	; 0x192
							pxConfig->devconst.Graph[tmpGrNum].Shedule[dtl.Month
 8010c08:	f8b7 213a 	ldrh.w	r2, [r7, #314]	; 0x13a
									- 1][31].FinishHour;
 8010c0c:	1e51      	subs	r1, r2, #1
					uint8 finishHourEk =
 8010c0e:	f8d7 2160 	ldr.w	r2, [r7, #352]	; 0x160
 8010c12:	01c9      	lsls	r1, r1, #7
 8010c14:	f240 6004 	movw	r0, #1540	; 0x604
 8010c18:	fb00 f303 	mul.w	r3, r0, r3
 8010c1c:	440b      	add	r3, r1
 8010c1e:	4413      	add	r3, r2
 8010c20:	f603 237f 	addw	r3, r3, #2687	; 0xa7f
 8010c24:	781b      	ldrb	r3, [r3, #0]
 8010c26:	f887 3153 	strb.w	r3, [r7, #339]	; 0x153
					uint8 finishMinEk =
							pxConfig->devconst.Graph[tmpGrNum].Shedule[dtl.Month
									- 1][31].FinishMin;
 8010c2a:	f8b7 3192 	ldrh.w	r3, [r7, #402]	; 0x192
							pxConfig->devconst.Graph[tmpGrNum].Shedule[dtl.Month
 8010c2e:	f8b7 213a 	ldrh.w	r2, [r7, #314]	; 0x13a
									- 1][31].FinishMin;
 8010c32:	1e51      	subs	r1, r2, #1
					uint8 finishMinEk =
 8010c34:	f8d7 2160 	ldr.w	r2, [r7, #352]	; 0x160
 8010c38:	01c9      	lsls	r1, r1, #7
 8010c3a:	f240 6004 	movw	r0, #1540	; 0x604
 8010c3e:	fb00 f303 	mul.w	r3, r0, r3
 8010c42:	440b      	add	r3, r1
 8010c44:	4413      	add	r3, r2
 8010c46:	f603 237e 	addw	r3, r3, #2686	; 0xa7e
 8010c4a:	781b      	ldrb	r3, [r3, #0]
 8010c4c:	f887 3152 	strb.w	r3, [r7, #338]	; 0x152
					uint8 FnEKHour =
 8010c50:	f897 2153 	ldrb.w	r2, [r7, #339]	; 0x153
 8010c54:	f897 3155 	ldrb.w	r3, [r7, #341]	; 0x155
 8010c58:	429a      	cmp	r2, r3
 8010c5a:	d804      	bhi.n	8010c66 <DoProgram+0xb9e>
 8010c5c:	f897 3153 	ldrb.w	r3, [r7, #339]	; 0x153
 8010c60:	3318      	adds	r3, #24
 8010c62:	b2db      	uxtb	r3, r3
 8010c64:	e001      	b.n	8010c6a <DoProgram+0xba2>
 8010c66:	f897 3153 	ldrb.w	r3, [r7, #339]	; 0x153
 8010c6a:	f887 3151 	strb.w	r3, [r7, #337]	; 0x151
							(finishHourEk > startHourEk) ?
									finishHourEk : (finishHourEk + 24);
					uint8 CurHour =
							(dtl.Hour * 60 + dtl.Min
 8010c6e:	f8b7 3140 	ldrh.w	r3, [r7, #320]	; 0x140
 8010c72:	461a      	mov	r2, r3
 8010c74:	4613      	mov	r3, r2
 8010c76:	011b      	lsls	r3, r3, #4
 8010c78:	1a9b      	subs	r3, r3, r2
 8010c7a:	009b      	lsls	r3, r3, #2
 8010c7c:	461a      	mov	r2, r3
 8010c7e:	f8b7 3142 	ldrh.w	r3, [r7, #322]	; 0x142
 8010c82:	18d1      	adds	r1, r2, r3
									>= startHourEk * 60 + startMinEk) ?
 8010c84:	f897 2155 	ldrb.w	r2, [r7, #341]	; 0x155
 8010c88:	4613      	mov	r3, r2
 8010c8a:	011b      	lsls	r3, r3, #4
 8010c8c:	1a9b      	subs	r3, r3, r2
 8010c8e:	009b      	lsls	r3, r3, #2
 8010c90:	461a      	mov	r2, r3
 8010c92:	f897 3154 	ldrb.w	r3, [r7, #340]	; 0x154
 8010c96:	4413      	add	r3, r2
					uint8 CurHour =
 8010c98:	4299      	cmp	r1, r3
 8010c9a:	db03      	blt.n	8010ca4 <DoProgram+0xbdc>
									dtl.Hour : (dtl.Hour + 24);
 8010c9c:	f8b7 3140 	ldrh.w	r3, [r7, #320]	; 0x140
					uint8 CurHour =
 8010ca0:	b2db      	uxtb	r3, r3
 8010ca2:	e004      	b.n	8010cae <DoProgram+0xbe6>
									dtl.Hour : (dtl.Hour + 24);
 8010ca4:	f8b7 3140 	ldrh.w	r3, [r7, #320]	; 0x140
 8010ca8:	b2db      	uxtb	r3, r3
					uint8 CurHour =
 8010caa:	3318      	adds	r3, #24
 8010cac:	b2db      	uxtb	r3, r3
 8010cae:	f887 3150 	strb.w	r3, [r7, #336]	; 0x150

					if ((startHourEk * 60 + startMinEk <= CurHour * 60 + dtl.Min)
 8010cb2:	f897 2155 	ldrb.w	r2, [r7, #341]	; 0x155
 8010cb6:	4613      	mov	r3, r2
 8010cb8:	011b      	lsls	r3, r3, #4
 8010cba:	1a9b      	subs	r3, r3, r2
 8010cbc:	009b      	lsls	r3, r3, #2
 8010cbe:	461a      	mov	r2, r3
 8010cc0:	f897 3154 	ldrb.w	r3, [r7, #340]	; 0x154
 8010cc4:	18d1      	adds	r1, r2, r3
 8010cc6:	f897 2150 	ldrb.w	r2, [r7, #336]	; 0x150
 8010cca:	4613      	mov	r3, r2
 8010ccc:	011b      	lsls	r3, r3, #4
 8010cce:	1a9b      	subs	r3, r3, r2
 8010cd0:	009b      	lsls	r3, r3, #2
 8010cd2:	461a      	mov	r2, r3
 8010cd4:	f8b7 3142 	ldrh.w	r3, [r7, #322]	; 0x142
 8010cd8:	4413      	add	r3, r2
 8010cda:	4299      	cmp	r1, r3
 8010cdc:	dc20      	bgt.n	8010d20 <DoProgram+0xc58>
							&& (FnEKHour * 60 + finishMinEk
 8010cde:	f897 2151 	ldrb.w	r2, [r7, #337]	; 0x151
 8010ce2:	4613      	mov	r3, r2
 8010ce4:	011b      	lsls	r3, r3, #4
 8010ce6:	1a9b      	subs	r3, r3, r2
 8010ce8:	009b      	lsls	r3, r3, #2
 8010cea:	461a      	mov	r2, r3
 8010cec:	f897 3152 	ldrb.w	r3, [r7, #338]	; 0x152
 8010cf0:	18d1      	adds	r1, r2, r3
									> CurHour * 60 + dtl.Min)) {
 8010cf2:	f897 2150 	ldrb.w	r2, [r7, #336]	; 0x150
 8010cf6:	4613      	mov	r3, r2
 8010cf8:	011b      	lsls	r3, r3, #4
 8010cfa:	1a9b      	subs	r3, r3, r2
 8010cfc:	009b      	lsls	r3, r3, #2
 8010cfe:	461a      	mov	r2, r3
 8010d00:	f8b7 3142 	ldrh.w	r3, [r7, #322]	; 0x142
 8010d04:	4413      	add	r3, r2
							&& (FnEKHour * 60 + finishMinEk
 8010d06:	4299      	cmp	r1, r3
 8010d08:	dd0a      	ble.n	8010d20 <DoProgram+0xc58>
						SetChannelBitSignal(i, RAM.OutputCommand, 1);
 8010d0a:	2201      	movs	r2, #1
 8010d0c:	4902      	ldr	r1, [pc, #8]	; (8010d18 <DoProgram+0xc50>)
 8010d0e:	f8d7 0194 	ldr.w	r0, [r7, #404]	; 0x194
 8010d12:	4b02      	ldr	r3, [pc, #8]	; (8010d1c <DoProgram+0xc54>)
 8010d14:	4798      	blx	r3
						continue;
 8010d16:	e014      	b.n	8010d42 <DoProgram+0xc7a>
 8010d18:	20007460 	.word	0x20007460
 8010d1c:	0800f407 	.word	0x0800f407
					} else {
						SetChannelBitSignal(i, RAM.OutputCommand, 0);
 8010d20:	2200      	movs	r2, #0
 8010d22:	49ae      	ldr	r1, [pc, #696]	; (8010fdc <DoProgram+0xf14>)
 8010d24:	f8d7 0194 	ldr.w	r0, [r7, #404]	; 0x194
 8010d28:	4bad      	ldr	r3, [pc, #692]	; (8010fe0 <DoProgram+0xf18>)
 8010d2a:	4798      	blx	r3
						continue;
 8010d2c:	e009      	b.n	8010d42 <DoProgram+0xc7a>
					}
				} else {
					SetChannelBitSignal(i, RAM.OutputCommand, 1);
 8010d2e:	2201      	movs	r2, #1
 8010d30:	49aa      	ldr	r1, [pc, #680]	; (8010fdc <DoProgram+0xf14>)
 8010d32:	f8d7 0194 	ldr.w	r0, [r7, #404]	; 0x194
 8010d36:	4baa      	ldr	r3, [pc, #680]	; (8010fe0 <DoProgram+0xf18>)
 8010d38:	4798      	blx	r3
					continue;
 8010d3a:	e002      	b.n	8010d42 <DoProgram+0xc7a>
			continue;
 8010d3c:	bf00      	nop
 8010d3e:	e000      	b.n	8010d42 <DoProgram+0xc7a>
			continue;
 8010d40:	bf00      	nop
	for (int i = 0; i < 8; i++) {
 8010d42:	f8d7 3194 	ldr.w	r3, [r7, #404]	; 0x194
 8010d46:	3301      	adds	r3, #1
 8010d48:	f8c7 3194 	str.w	r3, [r7, #404]	; 0x194
 8010d4c:	f8d7 3194 	ldr.w	r3, [r7, #404]	; 0x194
 8010d50:	2b07      	cmp	r3, #7
 8010d52:	f77f ac4d 	ble.w	80105f0 <DoProgram+0x528>
			/////
			}
		}

	}
	BKP_WriteBackupRegister(BKP_DR7, 59);
 8010d56:	213b      	movs	r1, #59	; 0x3b
 8010d58:	201c      	movs	r0, #28
 8010d5a:	4ba2      	ldr	r3, [pc, #648]	; (8010fe4 <DoProgram+0xf1c>)
 8010d5c:	4798      	blx	r3
	//error and condition module for iFIX
	for (int i = 0; i < 4; i++) {
 8010d5e:	2300      	movs	r3, #0
 8010d60:	f8c7 3188 	str.w	r3, [r7, #392]	; 0x188
 8010d64:	e028      	b.n	8010db8 <DoProgram+0xcf0>
		RAM.ErrorAndConditionModule[i * 2] = RAM.ErrorDiscretLogic[i];
 8010d66:	f8d7 3188 	ldr.w	r3, [r7, #392]	; 0x188
 8010d6a:	005a      	lsls	r2, r3, #1
 8010d6c:	499e      	ldr	r1, [pc, #632]	; (8010fe8 <DoProgram+0xf20>)
 8010d6e:	f8d7 3188 	ldr.w	r3, [r7, #392]	; 0x188
 8010d72:	f503 7341 	add.w	r3, r3, #772	; 0x304
 8010d76:	005b      	lsls	r3, r3, #1
 8010d78:	440b      	add	r3, r1
 8010d7a:	885b      	ldrh	r3, [r3, #2]
 8010d7c:	b298      	uxth	r0, r3
 8010d7e:	499a      	ldr	r1, [pc, #616]	; (8010fe8 <DoProgram+0xf20>)
 8010d80:	1d13      	adds	r3, r2, #4
 8010d82:	005b      	lsls	r3, r3, #1
 8010d84:	440b      	add	r3, r1
 8010d86:	4602      	mov	r2, r0
 8010d88:	805a      	strh	r2, [r3, #2]
		RAM.ErrorAndConditionModule[i * 2 + 1] = RAM.diskrets[i];
 8010d8a:	f8d7 3188 	ldr.w	r3, [r7, #392]	; 0x188
 8010d8e:	005b      	lsls	r3, r3, #1
 8010d90:	3301      	adds	r3, #1
 8010d92:	4995      	ldr	r1, [pc, #596]	; (8010fe8 <DoProgram+0xf20>)
 8010d94:	f8d7 2188 	ldr.w	r2, [r7, #392]	; 0x188
 8010d98:	f502 7200 	add.w	r2, r2, #512	; 0x200
 8010d9c:	f831 2012 	ldrh.w	r2, [r1, r2, lsl #1]
 8010da0:	b291      	uxth	r1, r2
 8010da2:	4a91      	ldr	r2, [pc, #580]	; (8010fe8 <DoProgram+0xf20>)
 8010da4:	3304      	adds	r3, #4
 8010da6:	005b      	lsls	r3, r3, #1
 8010da8:	4413      	add	r3, r2
 8010daa:	460a      	mov	r2, r1
 8010dac:	805a      	strh	r2, [r3, #2]
	for (int i = 0; i < 4; i++) {
 8010dae:	f8d7 3188 	ldr.w	r3, [r7, #392]	; 0x188
 8010db2:	3301      	adds	r3, #1
 8010db4:	f8c7 3188 	str.w	r3, [r7, #392]	; 0x188
 8010db8:	f8d7 3188 	ldr.w	r3, [r7, #392]	; 0x188
 8010dbc:	2b03      	cmp	r3, #3
 8010dbe:	ddd2      	ble.n	8010d66 <DoProgram+0xc9e>
	}

	// 
	CheckCUSignal();
 8010dc0:	4b8a      	ldr	r3, [pc, #552]	; (8010fec <DoProgram+0xf24>)
 8010dc2:	4798      	blx	r3

	// send signals to rele
	uint8 tempReleMaskCounter = 0;
 8010dc4:	2300      	movs	r3, #0
 8010dc6:	f887 3187 	strb.w	r3, [r7, #391]	; 0x187
	BKP_WriteBackupRegister(BKP_DR7, 60);
 8010dca:	213c      	movs	r1, #60	; 0x3c
 8010dcc:	201c      	movs	r0, #28
 8010dce:	4b85      	ldr	r3, [pc, #532]	; (8010fe4 <DoProgram+0xf1c>)
 8010dd0:	4798      	blx	r3
	for (int i = 0; i < 8; i++) {
 8010dd2:	2300      	movs	r3, #0
 8010dd4:	f8c7 3180 	str.w	r3, [r7, #384]	; 0x180
 8010dd8:	e03b      	b.n	8010e52 <DoProgram+0xd8a>
		if (pxConfig->devcfg.logica.confCU[i].releNum == 0)
 8010dda:	f8d7 1160 	ldr.w	r1, [r7, #352]	; 0x160
 8010dde:	f8d7 2180 	ldr.w	r2, [r7, #384]	; 0x180
 8010de2:	4613      	mov	r3, r2
 8010de4:	005b      	lsls	r3, r3, #1
 8010de6:	4413      	add	r3, r2
 8010de8:	009b      	lsls	r3, r3, #2
 8010dea:	440b      	add	r3, r1
 8010dec:	f203 4302 	addw	r3, r3, #1026	; 0x402
 8010df0:	781b      	ldrb	r3, [r3, #0]
 8010df2:	2b00      	cmp	r3, #0
 8010df4:	d027      	beq.n	8010e46 <DoProgram+0xd7e>
			continue;
		uint8 TempReleInd = pxConfig->devcfg.logica.confCU[i].releNum - 1;
 8010df6:	f8d7 1160 	ldr.w	r1, [r7, #352]	; 0x160
 8010dfa:	f8d7 2180 	ldr.w	r2, [r7, #384]	; 0x180
 8010dfe:	4613      	mov	r3, r2
 8010e00:	005b      	lsls	r3, r3, #1
 8010e02:	4413      	add	r3, r2
 8010e04:	009b      	lsls	r3, r3, #2
 8010e06:	440b      	add	r3, r1
 8010e08:	f203 4302 	addw	r3, r3, #1026	; 0x402
 8010e0c:	781b      	ldrb	r3, [r3, #0]
 8010e0e:	3b01      	subs	r3, #1
 8010e10:	f887 315b 	strb.w	r3, [r7, #347]	; 0x15b
		SetRelayToRam(TempReleInd, GetChannelBitSignal(i, RAM.OutputCommand));
 8010e14:	f897 415b 	ldrb.w	r4, [r7, #347]	; 0x15b
 8010e18:	4970      	ldr	r1, [pc, #448]	; (8010fdc <DoProgram+0xf14>)
 8010e1a:	f8d7 0180 	ldr.w	r0, [r7, #384]	; 0x180
 8010e1e:	4b74      	ldr	r3, [pc, #464]	; (8010ff0 <DoProgram+0xf28>)
 8010e20:	4798      	blx	r3
 8010e22:	4603      	mov	r3, r0
 8010e24:	4619      	mov	r1, r3
 8010e26:	4620      	mov	r0, r4
 8010e28:	4b72      	ldr	r3, [pc, #456]	; (8010ff4 <DoProgram+0xf2c>)
 8010e2a:	4798      	blx	r3

		tempReleMaskCounter |= (1 << TempReleInd);
 8010e2c:	f897 315b 	ldrb.w	r3, [r7, #347]	; 0x15b
 8010e30:	2201      	movs	r2, #1
 8010e32:	fa02 f303 	lsl.w	r3, r2, r3
 8010e36:	b25a      	sxtb	r2, r3
 8010e38:	f997 3187 	ldrsb.w	r3, [r7, #391]	; 0x187
 8010e3c:	4313      	orrs	r3, r2
 8010e3e:	b25b      	sxtb	r3, r3
 8010e40:	f887 3187 	strb.w	r3, [r7, #391]	; 0x187
 8010e44:	e000      	b.n	8010e48 <DoProgram+0xd80>
			continue;
 8010e46:	bf00      	nop
	for (int i = 0; i < 8; i++) {
 8010e48:	f8d7 3180 	ldr.w	r3, [r7, #384]	; 0x180
 8010e4c:	3301      	adds	r3, #1
 8010e4e:	f8c7 3180 	str.w	r3, [r7, #384]	; 0x180
 8010e52:	f8d7 3180 	ldr.w	r3, [r7, #384]	; 0x180
 8010e56:	2b07      	cmp	r3, #7
 8010e58:	ddbf      	ble.n	8010dda <DoProgram+0xd12>
	}
	//switch off unused relays
	for (int i = 0; i < 8; i++) {
 8010e5a:	2300      	movs	r3, #0
 8010e5c:	f8c7 317c 	str.w	r3, [r7, #380]	; 0x17c
 8010e60:	e013      	b.n	8010e8a <DoProgram+0xdc2>
		if ((tempReleMaskCounter & (1 << i)) == 0) {
 8010e62:	f897 2187 	ldrb.w	r2, [r7, #391]	; 0x187
 8010e66:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 8010e6a:	fa42 f303 	asr.w	r3, r2, r3
 8010e6e:	f003 0301 	and.w	r3, r3, #1
 8010e72:	2b00      	cmp	r3, #0
 8010e74:	d104      	bne.n	8010e80 <DoProgram+0xdb8>
			SetRelayToRam(i, 0);
 8010e76:	2100      	movs	r1, #0
 8010e78:	f8d7 017c 	ldr.w	r0, [r7, #380]	; 0x17c
 8010e7c:	4b5d      	ldr	r3, [pc, #372]	; (8010ff4 <DoProgram+0xf2c>)
 8010e7e:	4798      	blx	r3
	for (int i = 0; i < 8; i++) {
 8010e80:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 8010e84:	3301      	adds	r3, #1
 8010e86:	f8c7 317c 	str.w	r3, [r7, #380]	; 0x17c
 8010e8a:	f8d7 317c 	ldr.w	r3, [r7, #380]	; 0x17c
 8010e8e:	2b07      	cmp	r3, #7
 8010e90:	dde7      	ble.n	8010e62 <DoProgram+0xd9a>
		}
	}

	vTaskDelay(20);
 8010e92:	2014      	movs	r0, #20
 8010e94:	4b58      	ldr	r3, [pc, #352]	; (8010ff8 <DoProgram+0xf30>)
 8010e96:	4798      	blx	r3
	BKP_WriteBackupRegister(BKP_DR7, 61);
 8010e98:	213d      	movs	r1, #61	; 0x3d
 8010e9a:	201c      	movs	r0, #28
 8010e9c:	4b51      	ldr	r3, [pc, #324]	; (8010fe4 <DoProgram+0xf1c>)
 8010e9e:	4798      	blx	r3
	//Get Channel Condition CU
	for (int i = 0; i < 8; i++) {
 8010ea0:	2300      	movs	r3, #0
 8010ea2:	f8c7 3178 	str.w	r3, [r7, #376]	; 0x178
 8010ea6:	e042      	b.n	8010f2e <DoProgram+0xe66>

		if (pxConfig->devcfg.logica.confCU[i].discNum == 0)
 8010ea8:	f8d7 1160 	ldr.w	r1, [r7, #352]	; 0x160
 8010eac:	f8d7 2178 	ldr.w	r2, [r7, #376]	; 0x178
 8010eb0:	4613      	mov	r3, r2
 8010eb2:	005b      	lsls	r3, r3, #1
 8010eb4:	4413      	add	r3, r2
 8010eb6:	009b      	lsls	r3, r3, #2
 8010eb8:	440b      	add	r3, r1
 8010eba:	f203 4303 	addw	r3, r3, #1027	; 0x403
 8010ebe:	781b      	ldrb	r3, [r3, #0]
 8010ec0:	2b00      	cmp	r3, #0
 8010ec2:	d02e      	beq.n	8010f22 <DoProgram+0xe5a>
			continue;
		if (GetDiskretFromRam(pxConfig->devcfg.logica.confCU[i].discNum - 1)
 8010ec4:	f8d7 1160 	ldr.w	r1, [r7, #352]	; 0x160
 8010ec8:	f8d7 2178 	ldr.w	r2, [r7, #376]	; 0x178
 8010ecc:	4613      	mov	r3, r2
 8010ece:	005b      	lsls	r3, r3, #1
 8010ed0:	4413      	add	r3, r2
 8010ed2:	009b      	lsls	r3, r3, #2
 8010ed4:	440b      	add	r3, r1
 8010ed6:	f203 4303 	addw	r3, r3, #1027	; 0x403
 8010eda:	781b      	ldrb	r3, [r3, #0]
 8010edc:	3b01      	subs	r3, #1
 8010ede:	4618      	mov	r0, r3
 8010ee0:	4b46      	ldr	r3, [pc, #280]	; (8010ffc <DoProgram+0xf34>)
 8010ee2:	4798      	blx	r3
 8010ee4:	4603      	mov	r3, r0
 8010ee6:	2b00      	cmp	r3, #0
 8010ee8:	d10e      	bne.n	8010f08 <DoProgram+0xe40>
				== 0) {
			RAM.ChannelCondition &= (uint8) (~(1 << i));
 8010eea:	4b3f      	ldr	r3, [pc, #252]	; (8010fe8 <DoProgram+0xf20>)
 8010eec:	7a5a      	ldrb	r2, [r3, #9]
 8010eee:	2101      	movs	r1, #1
 8010ef0:	f8d7 3178 	ldr.w	r3, [r7, #376]	; 0x178
 8010ef4:	fa01 f303 	lsl.w	r3, r1, r3
 8010ef8:	b2db      	uxtb	r3, r3
 8010efa:	43db      	mvns	r3, r3
 8010efc:	b2db      	uxtb	r3, r3
 8010efe:	4013      	ands	r3, r2
 8010f00:	b2da      	uxtb	r2, r3
 8010f02:	4b39      	ldr	r3, [pc, #228]	; (8010fe8 <DoProgram+0xf20>)
 8010f04:	725a      	strb	r2, [r3, #9]
 8010f06:	e00d      	b.n	8010f24 <DoProgram+0xe5c>
		} else {
			RAM.ChannelCondition |= (uint8) (1 << i);
 8010f08:	4b37      	ldr	r3, [pc, #220]	; (8010fe8 <DoProgram+0xf20>)
 8010f0a:	7a5a      	ldrb	r2, [r3, #9]
 8010f0c:	2101      	movs	r1, #1
 8010f0e:	f8d7 3178 	ldr.w	r3, [r7, #376]	; 0x178
 8010f12:	fa01 f303 	lsl.w	r3, r1, r3
 8010f16:	b2db      	uxtb	r3, r3
 8010f18:	4313      	orrs	r3, r2
 8010f1a:	b2da      	uxtb	r2, r3
 8010f1c:	4b32      	ldr	r3, [pc, #200]	; (8010fe8 <DoProgram+0xf20>)
 8010f1e:	725a      	strb	r2, [r3, #9]
 8010f20:	e000      	b.n	8010f24 <DoProgram+0xe5c>
			continue;
 8010f22:	bf00      	nop
	for (int i = 0; i < 8; i++) {
 8010f24:	f8d7 3178 	ldr.w	r3, [r7, #376]	; 0x178
 8010f28:	3301      	adds	r3, #1
 8010f2a:	f8c7 3178 	str.w	r3, [r7, #376]	; 0x178
 8010f2e:	f8d7 3178 	ldr.w	r3, [r7, #376]	; 0x178
 8010f32:	2b07      	cmp	r3, #7
 8010f34:	ddb8      	ble.n	8010ea8 <DoProgram+0xde0>
		}
	}
	BKP_WriteBackupRegister(BKP_DR7, 62);
 8010f36:	213e      	movs	r1, #62	; 0x3e
 8010f38:	201c      	movs	r0, #28
 8010f3a:	4b2a      	ldr	r3, [pc, #168]	; (8010fe4 <DoProgram+0xf1c>)
 8010f3c:	4798      	blx	r3
	//Check Channel
	for (int i = 0; i < 8; i++) {
 8010f3e:	2300      	movs	r3, #0
 8010f40:	f8c7 3174 	str.w	r3, [r7, #372]	; 0x174
 8010f44:	e074      	b.n	8011030 <DoProgram+0xf68>

		if (pxConfig->devcfg.logica.confCU[i].discNum == 0) {
 8010f46:	f8d7 1160 	ldr.w	r1, [r7, #352]	; 0x160
 8010f4a:	f8d7 2174 	ldr.w	r2, [r7, #372]	; 0x174
 8010f4e:	4613      	mov	r3, r2
 8010f50:	005b      	lsls	r3, r3, #1
 8010f52:	4413      	add	r3, r2
 8010f54:	009b      	lsls	r3, r3, #2
 8010f56:	440b      	add	r3, r1
 8010f58:	f203 4303 	addw	r3, r3, #1027	; 0x403
 8010f5c:	781b      	ldrb	r3, [r3, #0]
 8010f5e:	2b00      	cmp	r3, #0
 8010f60:	d113      	bne.n	8010f8a <DoProgram+0xec2>
			RAM.ErrorChannel &= ~(1 << i);
 8010f62:	4b21      	ldr	r3, [pc, #132]	; (8010fe8 <DoProgram+0xf20>)
 8010f64:	f8b3 3608 	ldrh.w	r3, [r3, #1544]	; 0x608
 8010f68:	b29b      	uxth	r3, r3
 8010f6a:	b21a      	sxth	r2, r3
 8010f6c:	2101      	movs	r1, #1
 8010f6e:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 8010f72:	fa01 f303 	lsl.w	r3, r1, r3
 8010f76:	b21b      	sxth	r3, r3
 8010f78:	43db      	mvns	r3, r3
 8010f7a:	b21b      	sxth	r3, r3
 8010f7c:	4013      	ands	r3, r2
 8010f7e:	b21b      	sxth	r3, r3
 8010f80:	b29a      	uxth	r2, r3
 8010f82:	4b19      	ldr	r3, [pc, #100]	; (8010fe8 <DoProgram+0xf20>)
 8010f84:	f8a3 2608 	strh.w	r2, [r3, #1544]	; 0x608
			continue;
 8010f88:	e04d      	b.n	8011026 <DoProgram+0xf5e>
		}
		if (((RAM.ChannelCondition) & (1 << i)) >> i
 8010f8a:	4b17      	ldr	r3, [pc, #92]	; (8010fe8 <DoProgram+0xf20>)
 8010f8c:	7a5b      	ldrb	r3, [r3, #9]
 8010f8e:	4619      	mov	r1, r3
 8010f90:	2201      	movs	r2, #1
 8010f92:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 8010f96:	fa02 f303 	lsl.w	r3, r2, r3
 8010f9a:	ea01 0203 	and.w	r2, r1, r3
 8010f9e:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 8010fa2:	fa42 f403 	asr.w	r4, r2, r3
				!= GetChannelBitSignal(i, RAM.OutputCommand)) {
 8010fa6:	490d      	ldr	r1, [pc, #52]	; (8010fdc <DoProgram+0xf14>)
 8010fa8:	f8d7 0174 	ldr.w	r0, [r7, #372]	; 0x174
 8010fac:	4b10      	ldr	r3, [pc, #64]	; (8010ff0 <DoProgram+0xf28>)
 8010fae:	4798      	blx	r3
 8010fb0:	4603      	mov	r3, r0
		if (((RAM.ChannelCondition) & (1 << i)) >> i
 8010fb2:	429c      	cmp	r4, r3
 8010fb4:	d024      	beq.n	8011000 <DoProgram+0xf38>
			RAM.ErrorChannel |= (1 << i);
 8010fb6:	4b0c      	ldr	r3, [pc, #48]	; (8010fe8 <DoProgram+0xf20>)
 8010fb8:	f8b3 3608 	ldrh.w	r3, [r3, #1544]	; 0x608
 8010fbc:	b29b      	uxth	r3, r3
 8010fbe:	b21a      	sxth	r2, r3
 8010fc0:	2101      	movs	r1, #1
 8010fc2:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 8010fc6:	fa01 f303 	lsl.w	r3, r1, r3
 8010fca:	b21b      	sxth	r3, r3
 8010fcc:	4313      	orrs	r3, r2
 8010fce:	b21b      	sxth	r3, r3
 8010fd0:	b29a      	uxth	r2, r3
 8010fd2:	4b05      	ldr	r3, [pc, #20]	; (8010fe8 <DoProgram+0xf20>)
 8010fd4:	f8a3 2608 	strh.w	r2, [r3, #1544]	; 0x608
 8010fd8:	e025      	b.n	8011026 <DoProgram+0xf5e>
 8010fda:	bf00      	nop
 8010fdc:	20007460 	.word	0x20007460
 8010fe0:	0800f407 	.word	0x0800f407
 8010fe4:	08003621 	.word	0x08003621
 8010fe8:	2000745c 	.word	0x2000745c
 8010fec:	0800fa19 	.word	0x0800fa19
 8010ff0:	0800f2d1 	.word	0x0800f2d1
 8010ff4:	0800f73d 	.word	0x0800f73d
 8010ff8:	08001529 	.word	0x08001529
 8010ffc:	0800f6e5 	.word	0x0800f6e5
		} else {
			RAM.ErrorChannel &= ~(1 << i);
 8011000:	4b9d      	ldr	r3, [pc, #628]	; (8011278 <DoProgram+0x11b0>)
 8011002:	f8b3 3608 	ldrh.w	r3, [r3, #1544]	; 0x608
 8011006:	b29b      	uxth	r3, r3
 8011008:	b21a      	sxth	r2, r3
 801100a:	2101      	movs	r1, #1
 801100c:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 8011010:	fa01 f303 	lsl.w	r3, r1, r3
 8011014:	b21b      	sxth	r3, r3
 8011016:	43db      	mvns	r3, r3
 8011018:	b21b      	sxth	r3, r3
 801101a:	4013      	ands	r3, r2
 801101c:	b21b      	sxth	r3, r3
 801101e:	b29a      	uxth	r2, r3
 8011020:	4b95      	ldr	r3, [pc, #596]	; (8011278 <DoProgram+0x11b0>)
 8011022:	f8a3 2608 	strh.w	r2, [r3, #1544]	; 0x608
	for (int i = 0; i < 8; i++) {
 8011026:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 801102a:	3301      	adds	r3, #1
 801102c:	f8c7 3174 	str.w	r3, [r7, #372]	; 0x174
 8011030:	f8d7 3174 	ldr.w	r3, [r7, #372]	; 0x174
 8011034:	2b07      	cmp	r3, #7
 8011036:	dd86      	ble.n	8010f46 <DoProgram+0xe7e>
		}
	}

	if (RAM.ErrorChannel != 0) {
 8011038:	4b8f      	ldr	r3, [pc, #572]	; (8011278 <DoProgram+0x11b0>)
 801103a:	f8b3 3608 	ldrh.w	r3, [r3, #1544]	; 0x608
 801103e:	b29b      	uxth	r3, r3
 8011040:	2b00      	cmp	r3, #0
 8011042:	d009      	beq.n	8011058 <DoProgram+0xf90>
		RAM.LogicErrorFlags |= (1 << 1);
 8011044:	4b8c      	ldr	r3, [pc, #560]	; (8011278 <DoProgram+0x11b0>)
 8011046:	7a1b      	ldrb	r3, [r3, #8]
 8011048:	f043 0302 	orr.w	r3, r3, #2
 801104c:	b2da      	uxtb	r2, r3
 801104e:	4b8a      	ldr	r3, [pc, #552]	; (8011278 <DoProgram+0x11b0>)
 8011050:	721a      	strb	r2, [r3, #8]
		CheckErrors();
 8011052:	4b8a      	ldr	r3, [pc, #552]	; (801127c <DoProgram+0x11b4>)
 8011054:	4798      	blx	r3
 8011056:	e008      	b.n	801106a <DoProgram+0xfa2>

	} else {
		RAM.LogicErrorFlags &= ~(1 << 1);
 8011058:	4b87      	ldr	r3, [pc, #540]	; (8011278 <DoProgram+0x11b0>)
 801105a:	7a1b      	ldrb	r3, [r3, #8]
 801105c:	f023 0302 	bic.w	r3, r3, #2
 8011060:	b2da      	uxtb	r2, r3
 8011062:	4b85      	ldr	r3, [pc, #532]	; (8011278 <DoProgram+0x11b0>)
 8011064:	721a      	strb	r2, [r3, #8]
		CheckErrors();
 8011066:	4b85      	ldr	r3, [pc, #532]	; (801127c <DoProgram+0x11b4>)
 8011068:	4798      	blx	r3

	}


	BKP_WriteBackupRegister(BKP_DR7, 63);
 801106a:	213f      	movs	r1, #63	; 0x3f
 801106c:	201c      	movs	r0, #28
 801106e:	4b84      	ldr	r3, [pc, #528]	; (8011280 <DoProgram+0x11b8>)
 8011070:	4798      	blx	r3
	//Check Fuse on Channels
	for (int i = 0; i < 8; i++) {
 8011072:	2300      	movs	r3, #0
 8011074:	f8c7 3170 	str.w	r3, [r7, #368]	; 0x170
 8011078:	e0a8      	b.n	80111cc <DoProgram+0x1104>
		if (pxConfig->devcfg.logica.confCU[i].releNum == 0)
 801107a:	f8d7 1160 	ldr.w	r1, [r7, #352]	; 0x160
 801107e:	f8d7 2170 	ldr.w	r2, [r7, #368]	; 0x170
 8011082:	4613      	mov	r3, r2
 8011084:	005b      	lsls	r3, r3, #1
 8011086:	4413      	add	r3, r2
 8011088:	009b      	lsls	r3, r3, #2
 801108a:	440b      	add	r3, r1
 801108c:	f203 4302 	addw	r3, r3, #1026	; 0x402
 8011090:	781b      	ldrb	r3, [r3, #0]
 8011092:	2b00      	cmp	r3, #0
 8011094:	f000 8092 	beq.w	80111bc <DoProgram+0x10f4>
			continue;
		if (pxConfig->devcfg.logica.confCU[i].discNum == 0)
 8011098:	f8d7 1160 	ldr.w	r1, [r7, #352]	; 0x160
 801109c:	f8d7 2170 	ldr.w	r2, [r7, #368]	; 0x170
 80110a0:	4613      	mov	r3, r2
 80110a2:	005b      	lsls	r3, r3, #1
 80110a4:	4413      	add	r3, r2
 80110a6:	009b      	lsls	r3, r3, #2
 80110a8:	440b      	add	r3, r1
 80110aa:	f203 4303 	addw	r3, r3, #1027	; 0x403
 80110ae:	781b      	ldrb	r3, [r3, #0]
 80110b0:	2b00      	cmp	r3, #0
 80110b2:	f000 8085 	beq.w	80111c0 <DoProgram+0x10f8>
			continue;
		if (GetDiskretFromRam(pxConfig->devcfg.logica.confCU[i].discNum - 1)) {
 80110b6:	f8d7 1160 	ldr.w	r1, [r7, #352]	; 0x160
 80110ba:	f8d7 2170 	ldr.w	r2, [r7, #368]	; 0x170
 80110be:	4613      	mov	r3, r2
 80110c0:	005b      	lsls	r3, r3, #1
 80110c2:	4413      	add	r3, r2
 80110c4:	009b      	lsls	r3, r3, #2
 80110c6:	440b      	add	r3, r1
 80110c8:	f203 4303 	addw	r3, r3, #1027	; 0x403
 80110cc:	781b      	ldrb	r3, [r3, #0]
 80110ce:	3b01      	subs	r3, #1
 80110d0:	4618      	mov	r0, r3
 80110d2:	4b6c      	ldr	r3, [pc, #432]	; (8011284 <DoProgram+0x11bc>)
 80110d4:	4798      	blx	r3
 80110d6:	4603      	mov	r3, r0
 80110d8:	2b00      	cmp	r3, #0
 80110da:	d037      	beq.n	801114c <DoProgram+0x1084>
			if (CheckDiscretMask(pxConfig->devcfg.logica.confCU[i].Mask)) {
 80110dc:	f8d7 2170 	ldr.w	r2, [r7, #368]	; 0x170
 80110e0:	4613      	mov	r3, r2
 80110e2:	005b      	lsls	r3, r3, #1
 80110e4:	4413      	add	r3, r2
 80110e6:	009b      	lsls	r3, r3, #2
 80110e8:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 80110ec:	f8d7 2160 	ldr.w	r2, [r7, #352]	; 0x160
 80110f0:	4413      	add	r3, r2
 80110f2:	3304      	adds	r3, #4
 80110f4:	4618      	mov	r0, r3
 80110f6:	4b64      	ldr	r3, [pc, #400]	; (8011288 <DoProgram+0x11c0>)
 80110f8:	4798      	blx	r3
 80110fa:	4603      	mov	r3, r0
 80110fc:	2b00      	cmp	r3, #0
 80110fe:	d013      	beq.n	8011128 <DoProgram+0x1060>
				RAM.ErrorFuseChannel &= ~(1 << i);
 8011100:	4b5d      	ldr	r3, [pc, #372]	; (8011278 <DoProgram+0x11b0>)
 8011102:	f8b3 3606 	ldrh.w	r3, [r3, #1542]	; 0x606
 8011106:	b29b      	uxth	r3, r3
 8011108:	b21a      	sxth	r2, r3
 801110a:	2101      	movs	r1, #1
 801110c:	f8d7 3170 	ldr.w	r3, [r7, #368]	; 0x170
 8011110:	fa01 f303 	lsl.w	r3, r1, r3
 8011114:	b21b      	sxth	r3, r3
 8011116:	43db      	mvns	r3, r3
 8011118:	b21b      	sxth	r3, r3
 801111a:	4013      	ands	r3, r2
 801111c:	b21b      	sxth	r3, r3
 801111e:	b29a      	uxth	r2, r3
 8011120:	4b55      	ldr	r3, [pc, #340]	; (8011278 <DoProgram+0x11b0>)
 8011122:	f8a3 2606 	strh.w	r2, [r3, #1542]	; 0x606
 8011126:	e04c      	b.n	80111c2 <DoProgram+0x10fa>
			} else {
				RAM.ErrorFuseChannel |= (1 << i);
 8011128:	4b53      	ldr	r3, [pc, #332]	; (8011278 <DoProgram+0x11b0>)
 801112a:	f8b3 3606 	ldrh.w	r3, [r3, #1542]	; 0x606
 801112e:	b29b      	uxth	r3, r3
 8011130:	b21a      	sxth	r2, r3
 8011132:	2101      	movs	r1, #1
 8011134:	f8d7 3170 	ldr.w	r3, [r7, #368]	; 0x170
 8011138:	fa01 f303 	lsl.w	r3, r1, r3
 801113c:	b21b      	sxth	r3, r3
 801113e:	4313      	orrs	r3, r2
 8011140:	b21b      	sxth	r3, r3
 8011142:	b29a      	uxth	r2, r3
 8011144:	4b4c      	ldr	r3, [pc, #304]	; (8011278 <DoProgram+0x11b0>)
 8011146:	f8a3 2606 	strh.w	r2, [r3, #1542]	; 0x606
 801114a:	e03a      	b.n	80111c2 <DoProgram+0x10fa>
			}
		} else {
			if (CheckDiscretMaskNegative(
					pxConfig->devcfg.logica.confCU[i].Mask)) {
 801114c:	f8d7 2170 	ldr.w	r2, [r7, #368]	; 0x170
 8011150:	4613      	mov	r3, r2
 8011152:	005b      	lsls	r3, r3, #1
 8011154:	4413      	add	r3, r2
 8011156:	009b      	lsls	r3, r3, #2
 8011158:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 801115c:	f8d7 2160 	ldr.w	r2, [r7, #352]	; 0x160
 8011160:	4413      	add	r3, r2
 8011162:	3304      	adds	r3, #4
			if (CheckDiscretMaskNegative(
 8011164:	4618      	mov	r0, r3
 8011166:	4b49      	ldr	r3, [pc, #292]	; (801128c <DoProgram+0x11c4>)
 8011168:	4798      	blx	r3
 801116a:	4603      	mov	r3, r0
 801116c:	2b00      	cmp	r3, #0
 801116e:	d013      	beq.n	8011198 <DoProgram+0x10d0>
				RAM.ErrorFuseChannel &= ~(1 << i);
 8011170:	4b41      	ldr	r3, [pc, #260]	; (8011278 <DoProgram+0x11b0>)
 8011172:	f8b3 3606 	ldrh.w	r3, [r3, #1542]	; 0x606
 8011176:	b29b      	uxth	r3, r3
 8011178:	b21a      	sxth	r2, r3
 801117a:	2101      	movs	r1, #1
 801117c:	f8d7 3170 	ldr.w	r3, [r7, #368]	; 0x170
 8011180:	fa01 f303 	lsl.w	r3, r1, r3
 8011184:	b21b      	sxth	r3, r3
 8011186:	43db      	mvns	r3, r3
 8011188:	b21b      	sxth	r3, r3
 801118a:	4013      	ands	r3, r2
 801118c:	b21b      	sxth	r3, r3
 801118e:	b29a      	uxth	r2, r3
 8011190:	4b39      	ldr	r3, [pc, #228]	; (8011278 <DoProgram+0x11b0>)
 8011192:	f8a3 2606 	strh.w	r2, [r3, #1542]	; 0x606
 8011196:	e014      	b.n	80111c2 <DoProgram+0x10fa>
			} else {
				RAM.ErrorFuseChannel |= (1 << i);
 8011198:	4b37      	ldr	r3, [pc, #220]	; (8011278 <DoProgram+0x11b0>)
 801119a:	f8b3 3606 	ldrh.w	r3, [r3, #1542]	; 0x606
 801119e:	b29b      	uxth	r3, r3
 80111a0:	b21a      	sxth	r2, r3
 80111a2:	2101      	movs	r1, #1
 80111a4:	f8d7 3170 	ldr.w	r3, [r7, #368]	; 0x170
 80111a8:	fa01 f303 	lsl.w	r3, r1, r3
 80111ac:	b21b      	sxth	r3, r3
 80111ae:	4313      	orrs	r3, r2
 80111b0:	b21b      	sxth	r3, r3
 80111b2:	b29a      	uxth	r2, r3
 80111b4:	4b30      	ldr	r3, [pc, #192]	; (8011278 <DoProgram+0x11b0>)
 80111b6:	f8a3 2606 	strh.w	r2, [r3, #1542]	; 0x606
 80111ba:	e002      	b.n	80111c2 <DoProgram+0x10fa>
			continue;
 80111bc:	bf00      	nop
 80111be:	e000      	b.n	80111c2 <DoProgram+0x10fa>
			continue;
 80111c0:	bf00      	nop
	for (int i = 0; i < 8; i++) {
 80111c2:	f8d7 3170 	ldr.w	r3, [r7, #368]	; 0x170
 80111c6:	3301      	adds	r3, #1
 80111c8:	f8c7 3170 	str.w	r3, [r7, #368]	; 0x170
 80111cc:	f8d7 3170 	ldr.w	r3, [r7, #368]	; 0x170
 80111d0:	2b07      	cmp	r3, #7
 80111d2:	f77f af52 	ble.w	801107a <DoProgram+0xfb2>
			}
		}
	}
	BKP_WriteBackupRegister(BKP_DR7, 64);
 80111d6:	2140      	movs	r1, #64	; 0x40
 80111d8:	201c      	movs	r0, #28
 80111da:	4b29      	ldr	r3, [pc, #164]	; (8011280 <DoProgram+0x11b8>)
 80111dc:	4798      	blx	r3
	if (RAM.ErrorFuseChannel != 0) {
 80111de:	4b26      	ldr	r3, [pc, #152]	; (8011278 <DoProgram+0x11b0>)
 80111e0:	f8b3 3606 	ldrh.w	r3, [r3, #1542]	; 0x606
 80111e4:	b29b      	uxth	r3, r3
 80111e6:	2b00      	cmp	r3, #0
 80111e8:	d009      	beq.n	80111fe <DoProgram+0x1136>
		RAM.LogicErrorFlags |= (1 << 4);
 80111ea:	4b23      	ldr	r3, [pc, #140]	; (8011278 <DoProgram+0x11b0>)
 80111ec:	7a1b      	ldrb	r3, [r3, #8]
 80111ee:	f043 0310 	orr.w	r3, r3, #16
 80111f2:	b2da      	uxtb	r2, r3
 80111f4:	4b20      	ldr	r3, [pc, #128]	; (8011278 <DoProgram+0x11b0>)
 80111f6:	721a      	strb	r2, [r3, #8]
		CheckErrors();
 80111f8:	4b20      	ldr	r3, [pc, #128]	; (801127c <DoProgram+0x11b4>)
 80111fa:	4798      	blx	r3
 80111fc:	e008      	b.n	8011210 <DoProgram+0x1148>

	} else {
		RAM.LogicErrorFlags &= ~(1 << 4);
 80111fe:	4b1e      	ldr	r3, [pc, #120]	; (8011278 <DoProgram+0x11b0>)
 8011200:	7a1b      	ldrb	r3, [r3, #8]
 8011202:	f023 0310 	bic.w	r3, r3, #16
 8011206:	b2da      	uxtb	r2, r3
 8011208:	4b1b      	ldr	r3, [pc, #108]	; (8011278 <DoProgram+0x11b0>)
 801120a:	721a      	strb	r2, [r3, #8]
		CheckErrors();
 801120c:	4b1b      	ldr	r3, [pc, #108]	; (801127c <DoProgram+0x11b4>)
 801120e:	4798      	blx	r3

	}


	//check Security
	if (CheckDiscretMask(pxConfig->devcfg.logica.MaskSecurity)) {
 8011210:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 8011214:	f503 638c 	add.w	r3, r3, #1120	; 0x460
 8011218:	4618      	mov	r0, r3
 801121a:	4b1b      	ldr	r3, [pc, #108]	; (8011288 <DoProgram+0x11c0>)
 801121c:	4798      	blx	r3
 801121e:	4603      	mov	r3, r0
 8011220:	2b00      	cmp	r3, #0
 8011222:	d009      	beq.n	8011238 <DoProgram+0x1170>
		RAM.LogicErrorFlags &= ~(1 << 2);
 8011224:	4b14      	ldr	r3, [pc, #80]	; (8011278 <DoProgram+0x11b0>)
 8011226:	7a1b      	ldrb	r3, [r3, #8]
 8011228:	f023 0304 	bic.w	r3, r3, #4
 801122c:	b2da      	uxtb	r2, r3
 801122e:	4b12      	ldr	r3, [pc, #72]	; (8011278 <DoProgram+0x11b0>)
 8011230:	721a      	strb	r2, [r3, #8]
		CheckErrors();
 8011232:	4b12      	ldr	r3, [pc, #72]	; (801127c <DoProgram+0x11b4>)
 8011234:	4798      	blx	r3
 8011236:	e008      	b.n	801124a <DoProgram+0x1182>

	} else {
		RAM.LogicErrorFlags |= (1 << 2);
 8011238:	4b0f      	ldr	r3, [pc, #60]	; (8011278 <DoProgram+0x11b0>)
 801123a:	7a1b      	ldrb	r3, [r3, #8]
 801123c:	f043 0304 	orr.w	r3, r3, #4
 8011240:	b2da      	uxtb	r2, r3
 8011242:	4b0d      	ldr	r3, [pc, #52]	; (8011278 <DoProgram+0x11b0>)
 8011244:	721a      	strb	r2, [r3, #8]
		CheckErrors();
 8011246:	4b0d      	ldr	r3, [pc, #52]	; (801127c <DoProgram+0x11b4>)
 8011248:	4798      	blx	r3

	}


	BKP_WriteBackupRegister(BKP_DR7, 65);
 801124a:	2141      	movs	r1, #65	; 0x41
 801124c:	201c      	movs	r0, #28
 801124e:	4b0c      	ldr	r3, [pc, #48]	; (8011280 <DoProgram+0x11b8>)
 8011250:	4798      	blx	r3
	if ((pxConfig->devcfg.logica.SwitchTime) == 0xFFFF) {
 8011252:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 8011256:	f8b3 3478 	ldrh.w	r3, [r3, #1144]	; 0x478
 801125a:	b29b      	uxth	r3, r3
 801125c:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8011260:	4293      	cmp	r3, r2
 8011262:	d12d      	bne.n	80112c0 <DoProgram+0x11f8>
		uint16 u1 = 0;
 8011264:	f507 73e0 	add.w	r3, r7, #448	; 0x1c0
 8011268:	f5a3 73dc 	sub.w	r3, r3, #440	; 0x1b8
 801126c:	2200      	movs	r2, #0
 801126e:	801a      	strh	r2, [r3, #0]
		for (int i = 0; i < 64; i++) {
 8011270:	2300      	movs	r3, #0
 8011272:	f8c7 316c 	str.w	r3, [r7, #364]	; 0x16c
 8011276:	e01f      	b.n	80112b8 <DoProgram+0x11f0>
 8011278:	2000745c 	.word	0x2000745c
 801127c:	0800fb55 	.word	0x0800fb55
 8011280:	08003621 	.word	0x08003621
 8011284:	0800f6e5 	.word	0x0800f6e5
 8011288:	0800f7e9 	.word	0x0800f7e9
 801128c:	0800f915 	.word	0x0800f915
			MemSetWords((uint16) (0x8200 + i), &u1, 0x1);
 8011290:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 8011294:	b29b      	uxth	r3, r3
 8011296:	f5a3 43fc 	sub.w	r3, r3, #32256	; 0x7e00
 801129a:	b29b      	uxth	r3, r3
 801129c:	f107 0108 	add.w	r1, r7, #8
 80112a0:	2201      	movs	r2, #1
 80112a2:	4618      	mov	r0, r3
 80112a4:	4b38      	ldr	r3, [pc, #224]	; (8011388 <DoProgram+0x12c0>)
 80112a6:	4798      	blx	r3
			vTaskDelay(1);
 80112a8:	2001      	movs	r0, #1
 80112aa:	4b38      	ldr	r3, [pc, #224]	; (801138c <DoProgram+0x12c4>)
 80112ac:	4798      	blx	r3
		for (int i = 0; i < 64; i++) {
 80112ae:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 80112b2:	3301      	adds	r3, #1
 80112b4:	f8c7 316c 	str.w	r3, [r7, #364]	; 0x16c
 80112b8:	f8d7 316c 	ldr.w	r3, [r7, #364]	; 0x16c
 80112bc:	2b3f      	cmp	r3, #63	; 0x3f
 80112be:	dde7      	ble.n	8011290 <DoProgram+0x11c8>
		}

	}

	if (pxConfig->devcfg.logica.SwitchTime > 1800
 80112c0:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 80112c4:	f8b3 3478 	ldrh.w	r3, [r3, #1144]	; 0x478
 80112c8:	b29b      	uxth	r3, r3
 80112ca:	f5b3 6fe1 	cmp.w	r3, #1800	; 0x708
 80112ce:	d806      	bhi.n	80112de <DoProgram+0x1216>
			|| pxConfig->devcfg.logica.SwitchTime == 0) {
 80112d0:	f8d7 3160 	ldr.w	r3, [r7, #352]	; 0x160
 80112d4:	f8b3 3478 	ldrh.w	r3, [r3, #1144]	; 0x478
 80112d8:	b29b      	uxth	r3, r3
 80112da:	2b00      	cmp	r3, #0
 80112dc:	d111      	bne.n	8011302 <DoProgram+0x123a>
		uint16 u1 = 300;
 80112de:	f507 73e0 	add.w	r3, r7, #448	; 0x1c0
 80112e2:	f5a3 73dd 	sub.w	r3, r3, #442	; 0x1ba
 80112e6:	f44f 7296 	mov.w	r2, #300	; 0x12c
 80112ea:	801a      	strh	r2, [r3, #0]
		portENTER_CRITICAL();
 80112ec:	4b28      	ldr	r3, [pc, #160]	; (8011390 <DoProgram+0x12c8>)
 80112ee:	4798      	blx	r3
		{
			MemSetWords((uint16) (0x823C), &u1, 0x1);
 80112f0:	1dbb      	adds	r3, r7, #6
 80112f2:	2201      	movs	r2, #1
 80112f4:	4619      	mov	r1, r3
 80112f6:	f248 203c 	movw	r0, #33340	; 0x823c
 80112fa:	4b23      	ldr	r3, [pc, #140]	; (8011388 <DoProgram+0x12c0>)
 80112fc:	4798      	blx	r3
		}
		portEXIT_CRITICAL();
 80112fe:	4b25      	ldr	r3, [pc, #148]	; (8011394 <DoProgram+0x12cc>)
 8011300:	4798      	blx	r3
	}

	SetCRC(&RAM.LogicErrorFlags, 18);
 8011302:	2112      	movs	r1, #18
 8011304:	4824      	ldr	r0, [pc, #144]	; (8011398 <DoProgram+0x12d0>)
 8011306:	4b25      	ldr	r3, [pc, #148]	; (801139c <DoProgram+0x12d4>)
 8011308:	4798      	blx	r3

	BKP_WriteBackupRegister(BKP_DR7, 66);
 801130a:	2142      	movs	r1, #66	; 0x42
 801130c:	201c      	movs	r0, #28
 801130e:	4b24      	ldr	r3, [pc, #144]	; (80113a0 <DoProgram+0x12d8>)
 8011310:	4798      	blx	r3
	//      ,   
	for (int i = 0; i < 8; i++) {
 8011312:	2300      	movs	r3, #0
 8011314:	f8c7 3168 	str.w	r3, [r7, #360]	; 0x168
 8011318:	e02e      	b.n	8011378 <DoProgram+0x12b0>
		if (GetChannelBitDirect(i, RAM.OutputCommand) == 1) {
 801131a:	4922      	ldr	r1, [pc, #136]	; (80113a4 <DoProgram+0x12dc>)
 801131c:	f8d7 0168 	ldr.w	r0, [r7, #360]	; 0x168
 8011320:	4b21      	ldr	r3, [pc, #132]	; (80113a8 <DoProgram+0x12e0>)
 8011322:	4798      	blx	r3
 8011324:	4603      	mov	r3, r0
 8011326:	2b01      	cmp	r3, #1
 8011328:	d106      	bne.n	8011338 <DoProgram+0x1270>
			ChanelChangeDirect[i] = true;
 801132a:	4a20      	ldr	r2, [pc, #128]	; (80113ac <DoProgram+0x12e4>)
 801132c:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 8011330:	4413      	add	r3, r2
 8011332:	2201      	movs	r2, #1
 8011334:	701a      	strb	r2, [r3, #0]
 8011336:	e005      	b.n	8011344 <DoProgram+0x127c>
		} else {
			ChanelChangeDirect[i] = false;
 8011338:	4a1c      	ldr	r2, [pc, #112]	; (80113ac <DoProgram+0x12e4>)
 801133a:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 801133e:	4413      	add	r3, r2
 8011340:	2200      	movs	r2, #0
 8011342:	701a      	strb	r2, [r3, #0]
		}
		if (GetChannelBitRepare(i, RAM.OutputCommand) == 1) {
 8011344:	4917      	ldr	r1, [pc, #92]	; (80113a4 <DoProgram+0x12dc>)
 8011346:	f8d7 0168 	ldr.w	r0, [r7, #360]	; 0x168
 801134a:	4b19      	ldr	r3, [pc, #100]	; (80113b0 <DoProgram+0x12e8>)
 801134c:	4798      	blx	r3
 801134e:	4603      	mov	r3, r0
 8011350:	2b01      	cmp	r3, #1
 8011352:	d106      	bne.n	8011362 <DoProgram+0x129a>
			ChanelChangeRepare[i] = true;
 8011354:	4a17      	ldr	r2, [pc, #92]	; (80113b4 <DoProgram+0x12ec>)
 8011356:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 801135a:	4413      	add	r3, r2
 801135c:	2201      	movs	r2, #1
 801135e:	701a      	strb	r2, [r3, #0]
 8011360:	e005      	b.n	801136e <DoProgram+0x12a6>
		} else {
			ChanelChangeRepare[i] = false;
 8011362:	4a14      	ldr	r2, [pc, #80]	; (80113b4 <DoProgram+0x12ec>)
 8011364:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 8011368:	4413      	add	r3, r2
 801136a:	2200      	movs	r2, #0
 801136c:	701a      	strb	r2, [r3, #0]
	for (int i = 0; i < 8; i++) {
 801136e:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 8011372:	3301      	adds	r3, #1
 8011374:	f8c7 3168 	str.w	r3, [r7, #360]	; 0x168
 8011378:	f8d7 3168 	ldr.w	r3, [r7, #360]	; 0x168
 801137c:	2b07      	cmp	r3, #7
 801137e:	ddcc      	ble.n	801131a <DoProgram+0x1252>
		}
	}
	char minbuf[20];
	char buffer[256];
	for (int i = 0; i < 8; i++) {
 8011380:	2300      	movs	r3, #0
 8011382:	f8c7 3164 	str.w	r3, [r7, #356]	; 0x164
 8011386:	e121      	b.n	80115cc <DoProgram+0x1504>
 8011388:	08006ca1 	.word	0x08006ca1
 801138c:	08001529 	.word	0x08001529
 8011390:	080025f9 	.word	0x080025f9
 8011394:	0800261d 	.word	0x0800261d
 8011398:	20007464 	.word	0x20007464
 801139c:	08006d9d 	.word	0x08006d9d
 80113a0:	08003621 	.word	0x08003621
 80113a4:	20007460 	.word	0x20007460
 80113a8:	0800f36b 	.word	0x0800f36b
 80113ac:	20009410 	.word	0x20009410
 80113b0:	0800f31d 	.word	0x0800f31d
 80113b4:	20009418 	.word	0x20009418
		if ((ChanelChangeDirect[i] == true) && (ChanelDirect[i] == false)) {
 80113b8:	4a8a      	ldr	r2, [pc, #552]	; (80115e4 <DoProgram+0x151c>)
 80113ba:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 80113be:	4413      	add	r3, r2
 80113c0:	781b      	ldrb	r3, [r3, #0]
 80113c2:	2b00      	cmp	r3, #0
 80113c4:	d036      	beq.n	8011434 <DoProgram+0x136c>
 80113c6:	4a88      	ldr	r2, [pc, #544]	; (80115e8 <DoProgram+0x1520>)
 80113c8:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 80113cc:	4413      	add	r3, r2
 80113ce:	781b      	ldrb	r3, [r3, #0]
 80113d0:	f083 0301 	eor.w	r3, r3, #1
 80113d4:	b2db      	uxtb	r3, r3
 80113d6:	2b00      	cmp	r3, #0
 80113d8:	d02c      	beq.n	8011434 <DoProgram+0x136c>
			itoa1(i + 1, minbuf);
 80113da:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 80113de:	3301      	adds	r3, #1
 80113e0:	f507 7286 	add.w	r2, r7, #268	; 0x10c
 80113e4:	4611      	mov	r1, r2
 80113e6:	4618      	mov	r0, r3
 80113e8:	4b80      	ldr	r3, [pc, #512]	; (80115ec <DoProgram+0x1524>)
 80113ea:	4798      	blx	r3
			manualwork=1;
 80113ec:	4b80      	ldr	r3, [pc, #512]	; (80115f0 <DoProgram+0x1528>)
 80113ee:	2201      	movs	r2, #1
 80113f0:	601a      	str	r2, [r3, #0]
			strcpy(buffer, " .:");
 80113f2:	f107 030c 	add.w	r3, r7, #12
 80113f6:	4a7f      	ldr	r2, [pc, #508]	; (80115f4 <DoProgram+0x152c>)
 80113f8:	461c      	mov	r4, r3
 80113fa:	4615      	mov	r5, r2
 80113fc:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80113fe:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8011400:	682b      	ldr	r3, [r5, #0]
 8011402:	7023      	strb	r3, [r4, #0]
			strcat(buffer, minbuf);
 8011404:	f507 7286 	add.w	r2, r7, #268	; 0x10c
 8011408:	f107 030c 	add.w	r3, r7, #12
 801140c:	4611      	mov	r1, r2
 801140e:	4618      	mov	r0, r3
 8011410:	4b79      	ldr	r3, [pc, #484]	; (80115f8 <DoProgram+0x1530>)
 8011412:	4798      	blx	r3
			JrnlWrite(buffer);
 8011414:	f107 030c 	add.w	r3, r7, #12
 8011418:	4618      	mov	r0, r3
 801141a:	4b78      	ldr	r3, [pc, #480]	; (80115fc <DoProgram+0x1534>)
 801141c:	4798      	blx	r3
			ChanelDirect[i] = ChanelChangeDirect[i];
 801141e:	4a71      	ldr	r2, [pc, #452]	; (80115e4 <DoProgram+0x151c>)
 8011420:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 8011424:	4413      	add	r3, r2
 8011426:	7819      	ldrb	r1, [r3, #0]
 8011428:	4a6f      	ldr	r2, [pc, #444]	; (80115e8 <DoProgram+0x1520>)
 801142a:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 801142e:	4413      	add	r3, r2
 8011430:	460a      	mov	r2, r1
 8011432:	701a      	strb	r2, [r3, #0]

		}
		if ((ChanelChangeDirect[i] == false) && (ChanelDirect[i] == true)) {
 8011434:	4a6b      	ldr	r2, [pc, #428]	; (80115e4 <DoProgram+0x151c>)
 8011436:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 801143a:	4413      	add	r3, r2
 801143c:	781b      	ldrb	r3, [r3, #0]
 801143e:	f083 0301 	eor.w	r3, r3, #1
 8011442:	b2db      	uxtb	r3, r3
 8011444:	2b00      	cmp	r3, #0
 8011446:	d035      	beq.n	80114b4 <DoProgram+0x13ec>
 8011448:	4a67      	ldr	r2, [pc, #412]	; (80115e8 <DoProgram+0x1520>)
 801144a:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 801144e:	4413      	add	r3, r2
 8011450:	781b      	ldrb	r3, [r3, #0]
 8011452:	2b00      	cmp	r3, #0
 8011454:	d02e      	beq.n	80114b4 <DoProgram+0x13ec>
			itoa1(i + 1, minbuf);
 8011456:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 801145a:	3301      	adds	r3, #1
 801145c:	f507 7286 	add.w	r2, r7, #268	; 0x10c
 8011460:	4611      	mov	r1, r2
 8011462:	4618      	mov	r0, r3
 8011464:	4b61      	ldr	r3, [pc, #388]	; (80115ec <DoProgram+0x1524>)
 8011466:	4798      	blx	r3
			manualwork=0;
 8011468:	4b61      	ldr	r3, [pc, #388]	; (80115f0 <DoProgram+0x1528>)
 801146a:	2200      	movs	r2, #0
 801146c:	601a      	str	r2, [r3, #0]
			strcpy(buffer, " .:");
 801146e:	f107 030c 	add.w	r3, r7, #12
 8011472:	4a63      	ldr	r2, [pc, #396]	; (8011600 <DoProgram+0x1538>)
 8011474:	461c      	mov	r4, r3
 8011476:	4613      	mov	r3, r2
 8011478:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 801147a:	c407      	stmia	r4!, {r0, r1, r2}
 801147c:	8023      	strh	r3, [r4, #0]
 801147e:	3402      	adds	r4, #2
 8011480:	0c1b      	lsrs	r3, r3, #16
 8011482:	7023      	strb	r3, [r4, #0]
			strcat(buffer, minbuf);
 8011484:	f507 7286 	add.w	r2, r7, #268	; 0x10c
 8011488:	f107 030c 	add.w	r3, r7, #12
 801148c:	4611      	mov	r1, r2
 801148e:	4618      	mov	r0, r3
 8011490:	4b59      	ldr	r3, [pc, #356]	; (80115f8 <DoProgram+0x1530>)
 8011492:	4798      	blx	r3
			JrnlWrite(buffer);
 8011494:	f107 030c 	add.w	r3, r7, #12
 8011498:	4618      	mov	r0, r3
 801149a:	4b58      	ldr	r3, [pc, #352]	; (80115fc <DoProgram+0x1534>)
 801149c:	4798      	blx	r3
			ChanelDirect[i] = ChanelChangeDirect[i];
 801149e:	4a51      	ldr	r2, [pc, #324]	; (80115e4 <DoProgram+0x151c>)
 80114a0:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 80114a4:	4413      	add	r3, r2
 80114a6:	7819      	ldrb	r1, [r3, #0]
 80114a8:	4a4f      	ldr	r2, [pc, #316]	; (80115e8 <DoProgram+0x1520>)
 80114aa:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 80114ae:	4413      	add	r3, r2
 80114b0:	460a      	mov	r2, r1
 80114b2:	701a      	strb	r2, [r3, #0]

		}
		if ((ChanelChangeRepare[i] == true) && (ChanelRepare[i] == false)) {
 80114b4:	4a53      	ldr	r2, [pc, #332]	; (8011604 <DoProgram+0x153c>)
 80114b6:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 80114ba:	4413      	add	r3, r2
 80114bc:	781b      	ldrb	r3, [r3, #0]
 80114be:	2b00      	cmp	r3, #0
 80114c0:	d033      	beq.n	801152a <DoProgram+0x1462>
 80114c2:	4a51      	ldr	r2, [pc, #324]	; (8011608 <DoProgram+0x1540>)
 80114c4:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 80114c8:	4413      	add	r3, r2
 80114ca:	781b      	ldrb	r3, [r3, #0]
 80114cc:	f083 0301 	eor.w	r3, r3, #1
 80114d0:	b2db      	uxtb	r3, r3
 80114d2:	2b00      	cmp	r3, #0
 80114d4:	d029      	beq.n	801152a <DoProgram+0x1462>
			itoa1(i + 1, minbuf);
 80114d6:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 80114da:	3301      	adds	r3, #1
 80114dc:	f507 7286 	add.w	r2, r7, #268	; 0x10c
 80114e0:	4611      	mov	r1, r2
 80114e2:	4618      	mov	r0, r3
 80114e4:	4b41      	ldr	r3, [pc, #260]	; (80115ec <DoProgram+0x1524>)
 80114e6:	4798      	blx	r3
			strcpy(buffer, ". . .:");
 80114e8:	f107 030c 	add.w	r3, r7, #12
 80114ec:	4a47      	ldr	r2, [pc, #284]	; (801160c <DoProgram+0x1544>)
 80114ee:	461c      	mov	r4, r3
 80114f0:	4615      	mov	r5, r2
 80114f2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80114f4:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80114f6:	682b      	ldr	r3, [r5, #0]
 80114f8:	6023      	str	r3, [r4, #0]
			strcat(buffer, minbuf);
 80114fa:	f507 7286 	add.w	r2, r7, #268	; 0x10c
 80114fe:	f107 030c 	add.w	r3, r7, #12
 8011502:	4611      	mov	r1, r2
 8011504:	4618      	mov	r0, r3
 8011506:	4b3c      	ldr	r3, [pc, #240]	; (80115f8 <DoProgram+0x1530>)
 8011508:	4798      	blx	r3
			JrnlWrite(buffer);
 801150a:	f107 030c 	add.w	r3, r7, #12
 801150e:	4618      	mov	r0, r3
 8011510:	4b3a      	ldr	r3, [pc, #232]	; (80115fc <DoProgram+0x1534>)
 8011512:	4798      	blx	r3
			ChanelRepare[i] = ChanelChangeRepare[i];
 8011514:	4a3b      	ldr	r2, [pc, #236]	; (8011604 <DoProgram+0x153c>)
 8011516:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 801151a:	4413      	add	r3, r2
 801151c:	7819      	ldrb	r1, [r3, #0]
 801151e:	4a3a      	ldr	r2, [pc, #232]	; (8011608 <DoProgram+0x1540>)
 8011520:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 8011524:	4413      	add	r3, r2
 8011526:	460a      	mov	r2, r1
 8011528:	701a      	strb	r2, [r3, #0]

		}

		if ((ChanelChangeRepare[i] == false) && (ChanelRepare[i] == true)) {
 801152a:	4a36      	ldr	r2, [pc, #216]	; (8011604 <DoProgram+0x153c>)
 801152c:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 8011530:	4413      	add	r3, r2
 8011532:	781b      	ldrb	r3, [r3, #0]
 8011534:	f083 0301 	eor.w	r3, r3, #1
 8011538:	b2db      	uxtb	r3, r3
 801153a:	2b00      	cmp	r3, #0
 801153c:	d033      	beq.n	80115a6 <DoProgram+0x14de>
 801153e:	4a32      	ldr	r2, [pc, #200]	; (8011608 <DoProgram+0x1540>)
 8011540:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 8011544:	4413      	add	r3, r2
 8011546:	781b      	ldrb	r3, [r3, #0]
 8011548:	2b00      	cmp	r3, #0
 801154a:	d02c      	beq.n	80115a6 <DoProgram+0x14de>
			itoa1(i + 1, minbuf);
 801154c:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 8011550:	3301      	adds	r3, #1
 8011552:	f507 7286 	add.w	r2, r7, #268	; 0x10c
 8011556:	4611      	mov	r1, r2
 8011558:	4618      	mov	r0, r3
 801155a:	4b24      	ldr	r3, [pc, #144]	; (80115ec <DoProgram+0x1524>)
 801155c:	4798      	blx	r3
			strcpy(buffer, ". . .:");
 801155e:	f107 030c 	add.w	r3, r7, #12
 8011562:	4a2b      	ldr	r2, [pc, #172]	; (8011610 <DoProgram+0x1548>)
 8011564:	461c      	mov	r4, r3
 8011566:	4615      	mov	r5, r2
 8011568:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 801156a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 801156c:	e895 0003 	ldmia.w	r5, {r0, r1}
 8011570:	6020      	str	r0, [r4, #0]
 8011572:	3404      	adds	r4, #4
 8011574:	7021      	strb	r1, [r4, #0]
			strcat(buffer, minbuf);
 8011576:	f507 7286 	add.w	r2, r7, #268	; 0x10c
 801157a:	f107 030c 	add.w	r3, r7, #12
 801157e:	4611      	mov	r1, r2
 8011580:	4618      	mov	r0, r3
 8011582:	4b1d      	ldr	r3, [pc, #116]	; (80115f8 <DoProgram+0x1530>)
 8011584:	4798      	blx	r3
			JrnlWrite(buffer);
 8011586:	f107 030c 	add.w	r3, r7, #12
 801158a:	4618      	mov	r0, r3
 801158c:	4b1b      	ldr	r3, [pc, #108]	; (80115fc <DoProgram+0x1534>)
 801158e:	4798      	blx	r3
			ChanelRepare[i] = ChanelChangeRepare[i];
 8011590:	4a1c      	ldr	r2, [pc, #112]	; (8011604 <DoProgram+0x153c>)
 8011592:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 8011596:	4413      	add	r3, r2
 8011598:	7819      	ldrb	r1, [r3, #0]
 801159a:	4a1b      	ldr	r2, [pc, #108]	; (8011608 <DoProgram+0x1540>)
 801159c:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 80115a0:	4413      	add	r3, r2
 80115a2:	460a      	mov	r2, r1
 80115a4:	701a      	strb	r2, [r3, #0]

		}

		BKP_WriteBackupRegister(BKP_DR1, RAM.LocalCommand[0]);
 80115a6:	4b1b      	ldr	r3, [pc, #108]	; (8011614 <DoProgram+0x154c>)
 80115a8:	881b      	ldrh	r3, [r3, #0]
 80115aa:	b29b      	uxth	r3, r3
 80115ac:	4619      	mov	r1, r3
 80115ae:	2004      	movs	r0, #4
 80115b0:	4b19      	ldr	r3, [pc, #100]	; (8011618 <DoProgram+0x1550>)
 80115b2:	4798      	blx	r3
		BKP_WriteBackupRegister(BKP_DR2, RAM.LocalCommand[1]);
 80115b4:	4b17      	ldr	r3, [pc, #92]	; (8011614 <DoProgram+0x154c>)
 80115b6:	885b      	ldrh	r3, [r3, #2]
 80115b8:	b29b      	uxth	r3, r3
 80115ba:	4619      	mov	r1, r3
 80115bc:	2008      	movs	r0, #8
 80115be:	4b16      	ldr	r3, [pc, #88]	; (8011618 <DoProgram+0x1550>)
 80115c0:	4798      	blx	r3
	for (int i = 0; i < 8; i++) {
 80115c2:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 80115c6:	3301      	adds	r3, #1
 80115c8:	f8c7 3164 	str.w	r3, [r7, #356]	; 0x164
 80115cc:	f8d7 3164 	ldr.w	r3, [r7, #356]	; 0x164
 80115d0:	2b07      	cmp	r3, #7
 80115d2:	f77f aef1 	ble.w	80113b8 <DoProgram+0x12f0>
	}

}
 80115d6:	bf00      	nop
 80115d8:	bf00      	nop
 80115da:	f507 77e0 	add.w	r7, r7, #448	; 0x1c0
 80115de:	46bd      	mov	sp, r7
 80115e0:	bdb0      	pop	{r4, r5, r7, pc}
 80115e2:	bf00      	nop
 80115e4:	20009410 	.word	0x20009410
 80115e8:	20009400 	.word	0x20009400
 80115ec:	0800e895 	.word	0x0800e895
 80115f0:	20009430 	.word	0x20009430
 80115f4:	08015724 	.word	0x08015724
 80115f8:	08014635 	.word	0x08014635
 80115fc:	0800edb5 	.word	0x0800edb5
 8011600:	08015738 	.word	0x08015738
 8011604:	20009418 	.word	0x20009418
 8011608:	20009408 	.word	0x20009408
 801160c:	08015748 	.word	0x08015748
 8011610:	0801575c 	.word	0x0801575c
 8011614:	2000745c 	.word	0x2000745c
 8011618:	08003621 	.word	0x08003621

0801161c <I2C_Configuration>:
 * Description    : I2C Configuration
 * Input          : None
 * Output         : None
 * Return         : None
 *******************************************************************************/
void I2C_Configuration(void) {
 801161c:	b580      	push	{r7, lr}
 801161e:	b084      	sub	sp, #16
 8011620:	af00      	add	r7, sp, #0

	RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C1, ENABLE);
 8011622:	2101      	movs	r1, #1
 8011624:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 8011628:	4b12      	ldr	r3, [pc, #72]	; (8011674 <I2C_Configuration+0x58>)
 801162a:	4798      	blx	r3

	/* GPIO Periph clock enable */
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
 801162c:	2101      	movs	r1, #1
 801162e:	2008      	movs	r0, #8
 8011630:	4b11      	ldr	r3, [pc, #68]	; (8011678 <I2C_Configuration+0x5c>)
 8011632:	4798      	blx	r3

	I2C_InitTypeDef I2C_InitStructure;

	/* I2C configuration */
	I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
 8011634:	2300      	movs	r3, #0
 8011636:	80bb      	strh	r3, [r7, #4]
	I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
 8011638:	f64b 73ff 	movw	r3, #49151	; 0xbfff
 801163c:	80fb      	strh	r3, [r7, #6]
	I2C_InitStructure.I2C_OwnAddress1 = I2C1_SLAVE_ADDRESS7;
 801163e:	23a2      	movs	r3, #162	; 0xa2
 8011640:	813b      	strh	r3, [r7, #8]
	I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
 8011642:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8011646:	817b      	strh	r3, [r7, #10]
	I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
 8011648:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 801164c:	81bb      	strh	r3, [r7, #12]
	I2C_InitStructure.I2C_ClockSpeed = I2C_Speed;
 801164e:	4b0b      	ldr	r3, [pc, #44]	; (801167c <I2C_Configuration+0x60>)
 8011650:	603b      	str	r3, [r7, #0]

	/* I2C Peripheral Enable */
	I2C_Cmd(I2C1, ENABLE);
 8011652:	2101      	movs	r1, #1
 8011654:	480a      	ldr	r0, [pc, #40]	; (8011680 <I2C_Configuration+0x64>)
 8011656:	4b0b      	ldr	r3, [pc, #44]	; (8011684 <I2C_Configuration+0x68>)
 8011658:	4798      	blx	r3
	/* Apply I2C configuration after enabling it */
	I2C_Init(I2C1, &I2C_InitStructure);
 801165a:	463b      	mov	r3, r7
 801165c:	4619      	mov	r1, r3
 801165e:	4808      	ldr	r0, [pc, #32]	; (8011680 <I2C_Configuration+0x64>)
 8011660:	4b09      	ldr	r3, [pc, #36]	; (8011688 <I2C_Configuration+0x6c>)
 8011662:	4798      	blx	r3
	I2C_AcknowledgeConfig(I2C1, ENABLE);
 8011664:	2101      	movs	r1, #1
 8011666:	4806      	ldr	r0, [pc, #24]	; (8011680 <I2C_Configuration+0x64>)
 8011668:	4b08      	ldr	r3, [pc, #32]	; (801168c <I2C_Configuration+0x70>)
 801166a:	4798      	blx	r3
}
 801166c:	bf00      	nop
 801166e:	3710      	adds	r7, #16
 8011670:	46bd      	mov	sp, r7
 8011672:	bd80      	pop	{r7, pc}
 8011674:	080034f9 	.word	0x080034f9
 8011678:	080034bd 	.word	0x080034bd
 801167c:	000186a0 	.word	0x000186a0
 8011680:	40005400 	.word	0x40005400
 8011684:	08003da5 	.word	0x08003da5
 8011688:	08003c1d 	.word	0x08003c1d
 801168c:	08003e5f 	.word	0x08003e5f

08011690 <I2C_EE_BufferWrite>:
 *                  - WriteAddr : EEPROM's internal address to write to.
 *                  - NumByteToWrite : number of bytes to write to the EEPROM.
 * Output         : None
 * Return         : None
 *******************************************************************************/
bool I2C_EE_BufferWrite(u8 *pBuffer, u16 WriteAddr, u16 NumByteToWrite) {
 8011690:	b580      	push	{r7, lr}
 8011692:	b084      	sub	sp, #16
 8011694:	af00      	add	r7, sp, #0
 8011696:	6078      	str	r0, [r7, #4]
 8011698:	460b      	mov	r3, r1
 801169a:	807b      	strh	r3, [r7, #2]
 801169c:	4613      	mov	r3, r2
 801169e:	803b      	strh	r3, [r7, #0]
	BKP_WriteBackupRegister(BKP_DR7, 21);
 80116a0:	2115      	movs	r1, #21
 80116a2:	201c      	movs	r0, #28
 80116a4:	4b4d      	ldr	r3, [pc, #308]	; (80117dc <I2C_EE_BufferWrite+0x14c>)
 80116a6:	4798      	blx	r3
	u8 NumOfPage = 0, NumOfSingle = 0, Addr = 0, count = 0;
 80116a8:	2300      	movs	r3, #0
 80116aa:	73fb      	strb	r3, [r7, #15]
 80116ac:	2300      	movs	r3, #0
 80116ae:	73bb      	strb	r3, [r7, #14]
 80116b0:	2300      	movs	r3, #0
 80116b2:	737b      	strb	r3, [r7, #13]
 80116b4:	2300      	movs	r3, #0
 80116b6:	733b      	strb	r3, [r7, #12]

	Addr = WriteAddr % I2C_PageSize;
 80116b8:	887b      	ldrh	r3, [r7, #2]
 80116ba:	b2db      	uxtb	r3, r3
 80116bc:	f003 031f 	and.w	r3, r3, #31
 80116c0:	737b      	strb	r3, [r7, #13]
	count = I2C_PageSize - Addr;
 80116c2:	7b7b      	ldrb	r3, [r7, #13]
 80116c4:	f1c3 0320 	rsb	r3, r3, #32
 80116c8:	733b      	strb	r3, [r7, #12]
	NumOfPage = NumByteToWrite / I2C_PageSize;
 80116ca:	883b      	ldrh	r3, [r7, #0]
 80116cc:	095b      	lsrs	r3, r3, #5
 80116ce:	b29b      	uxth	r3, r3
 80116d0:	73fb      	strb	r3, [r7, #15]
	NumOfSingle = NumByteToWrite % I2C_PageSize;
 80116d2:	883b      	ldrh	r3, [r7, #0]
 80116d4:	b2db      	uxtb	r3, r3
 80116d6:	f003 031f 	and.w	r3, r3, #31
 80116da:	73bb      	strb	r3, [r7, #14]

	/* If WriteAddr is I2C_PageSize aligned  */
	if (Addr == 0) {
 80116dc:	7b7b      	ldrb	r3, [r7, #13]
 80116de:	2b00      	cmp	r3, #0
 80116e0:	d12a      	bne.n	8011738 <I2C_EE_BufferWrite+0xa8>
		/* If NumByteToWrite  I2C_PageSize */
		if (NumOfPage == 0) {
 80116e2:	7bfb      	ldrb	r3, [r7, #15]
 80116e4:	2b00      	cmp	r3, #0
 80116e6:	d116      	bne.n	8011716 <I2C_EE_BufferWrite+0x86>
			I2C_EE_PageWrite(pBuffer, WriteAddr, NumOfSingle);
 80116e8:	7bba      	ldrb	r2, [r7, #14]
 80116ea:	887b      	ldrh	r3, [r7, #2]
 80116ec:	4619      	mov	r1, r3
 80116ee:	6878      	ldr	r0, [r7, #4]
 80116f0:	4b3b      	ldr	r3, [pc, #236]	; (80117e0 <I2C_EE_BufferWrite+0x150>)
 80116f2:	4798      	blx	r3
			I2C_EE_WaitEepromStandbyState();
 80116f4:	4b3b      	ldr	r3, [pc, #236]	; (80117e4 <I2C_EE_BufferWrite+0x154>)
 80116f6:	4798      	blx	r3
 80116f8:	e06b      	b.n	80117d2 <I2C_EE_BufferWrite+0x142>
		}
		/* If NumByteToWrite > I2C_PageSize */
		else {
			while (NumOfPage--) {
				I2C_EE_PageWrite(pBuffer, WriteAddr, I2C_PageSize);
 80116fa:	887b      	ldrh	r3, [r7, #2]
 80116fc:	2220      	movs	r2, #32
 80116fe:	4619      	mov	r1, r3
 8011700:	6878      	ldr	r0, [r7, #4]
 8011702:	4b37      	ldr	r3, [pc, #220]	; (80117e0 <I2C_EE_BufferWrite+0x150>)
 8011704:	4798      	blx	r3
				I2C_EE_WaitEepromStandbyState();
 8011706:	4b37      	ldr	r3, [pc, #220]	; (80117e4 <I2C_EE_BufferWrite+0x154>)
 8011708:	4798      	blx	r3
				WriteAddr += I2C_PageSize;
 801170a:	887b      	ldrh	r3, [r7, #2]
 801170c:	3320      	adds	r3, #32
 801170e:	807b      	strh	r3, [r7, #2]
				pBuffer += I2C_PageSize;
 8011710:	687b      	ldr	r3, [r7, #4]
 8011712:	3320      	adds	r3, #32
 8011714:	607b      	str	r3, [r7, #4]
			while (NumOfPage--) {
 8011716:	7bfb      	ldrb	r3, [r7, #15]
 8011718:	1e5a      	subs	r2, r3, #1
 801171a:	73fa      	strb	r2, [r7, #15]
 801171c:	2b00      	cmp	r3, #0
 801171e:	d1ec      	bne.n	80116fa <I2C_EE_BufferWrite+0x6a>
			}

			if (NumOfSingle != 0) {
 8011720:	7bbb      	ldrb	r3, [r7, #14]
 8011722:	2b00      	cmp	r3, #0
 8011724:	d055      	beq.n	80117d2 <I2C_EE_BufferWrite+0x142>
				I2C_EE_PageWrite(pBuffer, WriteAddr, NumOfSingle);
 8011726:	7bba      	ldrb	r2, [r7, #14]
 8011728:	887b      	ldrh	r3, [r7, #2]
 801172a:	4619      	mov	r1, r3
 801172c:	6878      	ldr	r0, [r7, #4]
 801172e:	4b2c      	ldr	r3, [pc, #176]	; (80117e0 <I2C_EE_BufferWrite+0x150>)
 8011730:	4798      	blx	r3
				I2C_EE_WaitEepromStandbyState();
 8011732:	4b2c      	ldr	r3, [pc, #176]	; (80117e4 <I2C_EE_BufferWrite+0x154>)
 8011734:	4798      	blx	r3
 8011736:	e04c      	b.n	80117d2 <I2C_EE_BufferWrite+0x142>
		}
	}
	/* If WriteAddr is not I2C_PageSize aligned  */
	else {
		/* If NumByteToWrite  I2C_PageSize */
		if (NumOfPage == 0) {
 8011738:	7bfb      	ldrb	r3, [r7, #15]
 801173a:	2b00      	cmp	r3, #0
 801173c:	d108      	bne.n	8011750 <I2C_EE_BufferWrite+0xc0>
			I2C_EE_PageWrite(pBuffer, WriteAddr, NumOfSingle);
 801173e:	7bba      	ldrb	r2, [r7, #14]
 8011740:	887b      	ldrh	r3, [r7, #2]
 8011742:	4619      	mov	r1, r3
 8011744:	6878      	ldr	r0, [r7, #4]
 8011746:	4b26      	ldr	r3, [pc, #152]	; (80117e0 <I2C_EE_BufferWrite+0x150>)
 8011748:	4798      	blx	r3
			I2C_EE_WaitEepromStandbyState();
 801174a:	4b26      	ldr	r3, [pc, #152]	; (80117e4 <I2C_EE_BufferWrite+0x154>)
 801174c:	4798      	blx	r3
 801174e:	e040      	b.n	80117d2 <I2C_EE_BufferWrite+0x142>
		}
		/* If NumByteToWrite > I2C_PageSize */
		else {
			NumByteToWrite -= count;
 8011750:	7b3b      	ldrb	r3, [r7, #12]
 8011752:	b29b      	uxth	r3, r3
 8011754:	883a      	ldrh	r2, [r7, #0]
 8011756:	1ad3      	subs	r3, r2, r3
 8011758:	803b      	strh	r3, [r7, #0]
			NumOfPage = NumByteToWrite / I2C_PageSize;
 801175a:	883b      	ldrh	r3, [r7, #0]
 801175c:	095b      	lsrs	r3, r3, #5
 801175e:	b29b      	uxth	r3, r3
 8011760:	73fb      	strb	r3, [r7, #15]
			NumOfSingle = NumByteToWrite % I2C_PageSize;
 8011762:	883b      	ldrh	r3, [r7, #0]
 8011764:	b2db      	uxtb	r3, r3
 8011766:	f003 031f 	and.w	r3, r3, #31
 801176a:	73bb      	strb	r3, [r7, #14]

			if (count != 0) {
 801176c:	7b3b      	ldrb	r3, [r7, #12]
 801176e:	2b00      	cmp	r3, #0
 8011770:	d01f      	beq.n	80117b2 <I2C_EE_BufferWrite+0x122>
				I2C_EE_PageWrite(pBuffer, WriteAddr, count);
 8011772:	7b3a      	ldrb	r2, [r7, #12]
 8011774:	887b      	ldrh	r3, [r7, #2]
 8011776:	4619      	mov	r1, r3
 8011778:	6878      	ldr	r0, [r7, #4]
 801177a:	4b19      	ldr	r3, [pc, #100]	; (80117e0 <I2C_EE_BufferWrite+0x150>)
 801177c:	4798      	blx	r3
				I2C_EE_WaitEepromStandbyState();
 801177e:	4b19      	ldr	r3, [pc, #100]	; (80117e4 <I2C_EE_BufferWrite+0x154>)
 8011780:	4798      	blx	r3
				WriteAddr += count;
 8011782:	7b3b      	ldrb	r3, [r7, #12]
 8011784:	b29a      	uxth	r2, r3
 8011786:	887b      	ldrh	r3, [r7, #2]
 8011788:	4413      	add	r3, r2
 801178a:	807b      	strh	r3, [r7, #2]
				pBuffer += count;
 801178c:	7b3b      	ldrb	r3, [r7, #12]
 801178e:	687a      	ldr	r2, [r7, #4]
 8011790:	4413      	add	r3, r2
 8011792:	607b      	str	r3, [r7, #4]
			}

			while (NumOfPage--) {
 8011794:	e00d      	b.n	80117b2 <I2C_EE_BufferWrite+0x122>
				I2C_EE_PageWrite(pBuffer, WriteAddr, I2C_PageSize);
 8011796:	887b      	ldrh	r3, [r7, #2]
 8011798:	2220      	movs	r2, #32
 801179a:	4619      	mov	r1, r3
 801179c:	6878      	ldr	r0, [r7, #4]
 801179e:	4b10      	ldr	r3, [pc, #64]	; (80117e0 <I2C_EE_BufferWrite+0x150>)
 80117a0:	4798      	blx	r3
				I2C_EE_WaitEepromStandbyState();
 80117a2:	4b10      	ldr	r3, [pc, #64]	; (80117e4 <I2C_EE_BufferWrite+0x154>)
 80117a4:	4798      	blx	r3
				WriteAddr += I2C_PageSize;
 80117a6:	887b      	ldrh	r3, [r7, #2]
 80117a8:	3320      	adds	r3, #32
 80117aa:	807b      	strh	r3, [r7, #2]
				pBuffer += I2C_PageSize;
 80117ac:	687b      	ldr	r3, [r7, #4]
 80117ae:	3320      	adds	r3, #32
 80117b0:	607b      	str	r3, [r7, #4]
			while (NumOfPage--) {
 80117b2:	7bfb      	ldrb	r3, [r7, #15]
 80117b4:	1e5a      	subs	r2, r3, #1
 80117b6:	73fa      	strb	r2, [r7, #15]
 80117b8:	2b00      	cmp	r3, #0
 80117ba:	d1ec      	bne.n	8011796 <I2C_EE_BufferWrite+0x106>
			}
			if (NumOfSingle != 0) {
 80117bc:	7bbb      	ldrb	r3, [r7, #14]
 80117be:	2b00      	cmp	r3, #0
 80117c0:	d007      	beq.n	80117d2 <I2C_EE_BufferWrite+0x142>
				I2C_EE_PageWrite(pBuffer, WriteAddr, NumOfSingle);
 80117c2:	7bba      	ldrb	r2, [r7, #14]
 80117c4:	887b      	ldrh	r3, [r7, #2]
 80117c6:	4619      	mov	r1, r3
 80117c8:	6878      	ldr	r0, [r7, #4]
 80117ca:	4b05      	ldr	r3, [pc, #20]	; (80117e0 <I2C_EE_BufferWrite+0x150>)
 80117cc:	4798      	blx	r3
				I2C_EE_WaitEepromStandbyState();
 80117ce:	4b05      	ldr	r3, [pc, #20]	; (80117e4 <I2C_EE_BufferWrite+0x154>)
 80117d0:	4798      	blx	r3
			}
		}
	}
	return true;
 80117d2:	2301      	movs	r3, #1
}
 80117d4:	4618      	mov	r0, r3
 80117d6:	3710      	adds	r7, #16
 80117d8:	46bd      	mov	sp, r7
 80117da:	bd80      	pop	{r7, pc}
 80117dc:	08003621 	.word	0x08003621
 80117e0:	080117e9 	.word	0x080117e9
 80117e4:	08011f41 	.word	0x08011f41

080117e8 <I2C_EE_PageWrite>:
 *                  - WriteAddr : EEPROM's internal address to write to.
 *                  - NumByteToWrite : number of bytes to write to the EEPROM.
 * Output         : None
 * Return         : None
 *******************************************************************************/
bool I2C_EE_PageWrite(u8 *pBuffer, u16 WriteAddr, u8 NumByteToWrite) {
 80117e8:	b580      	push	{r7, lr}
 80117ea:	b084      	sub	sp, #16
 80117ec:	af00      	add	r7, sp, #0
 80117ee:	6078      	str	r0, [r7, #4]
 80117f0:	460b      	mov	r3, r1
 80117f2:	807b      	strh	r3, [r7, #2]
 80117f4:	4613      	mov	r3, r2
 80117f6:	707b      	strb	r3, [r7, #1]
	if (initMK == 1) {
 80117f8:	4b8c      	ldr	r3, [pc, #560]	; (8011a2c <I2C_EE_PageWrite+0x244>)
 80117fa:	681b      	ldr	r3, [r3, #0]
 80117fc:	2b01      	cmp	r3, #1
 80117fe:	f040 8094 	bne.w	801192a <I2C_EE_PageWrite+0x142>
		int counter = RETRY_NUMBER;
 8011802:	f640 33b8 	movw	r3, #3000	; 0xbb8
 8011806:	60fb      	str	r3, [r7, #12]
		/* While the bus is busy */
		while (I2C_GetFlagStatus(I2C1, I2C_FLAG_BUSY)) {
 8011808:	e008      	b.n	801181c <I2C_EE_PageWrite+0x34>
			if (counter-- <= 0)
 801180a:	68fb      	ldr	r3, [r7, #12]
 801180c:	1e5a      	subs	r2, r3, #1
 801180e:	60fa      	str	r2, [r7, #12]
 8011810:	2b00      	cmp	r3, #0
 8011812:	dc03      	bgt.n	801181c <I2C_EE_PageWrite+0x34>
				return I2C_EE_Relaunch();
 8011814:	4b86      	ldr	r3, [pc, #536]	; (8011a30 <I2C_EE_PageWrite+0x248>)
 8011816:	4798      	blx	r3
 8011818:	4603      	mov	r3, r0
 801181a:	e14a      	b.n	8011ab2 <I2C_EE_PageWrite+0x2ca>
		while (I2C_GetFlagStatus(I2C1, I2C_FLAG_BUSY)) {
 801181c:	f44f 3100 	mov.w	r1, #131072	; 0x20000
 8011820:	4884      	ldr	r0, [pc, #528]	; (8011a34 <I2C_EE_PageWrite+0x24c>)
 8011822:	4b85      	ldr	r3, [pc, #532]	; (8011a38 <I2C_EE_PageWrite+0x250>)
 8011824:	4798      	blx	r3
 8011826:	4603      	mov	r3, r0
 8011828:	2b00      	cmp	r3, #0
 801182a:	d1ee      	bne.n	801180a <I2C_EE_PageWrite+0x22>
		}

		/* Send START condition */
		I2C_GenerateSTART(I2C1, ENABLE);
 801182c:	2101      	movs	r1, #1
 801182e:	4881      	ldr	r0, [pc, #516]	; (8011a34 <I2C_EE_PageWrite+0x24c>)
 8011830:	4b82      	ldr	r3, [pc, #520]	; (8011a3c <I2C_EE_PageWrite+0x254>)
 8011832:	4798      	blx	r3

		/* Test on EV5 and clear it */
		counter = RETRY_NUMBER;
 8011834:	f640 33b8 	movw	r3, #3000	; 0xbb8
 8011838:	60fb      	str	r3, [r7, #12]
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT)) {
 801183a:	e008      	b.n	801184e <I2C_EE_PageWrite+0x66>
			if (counter-- <= 0)
 801183c:	68fb      	ldr	r3, [r7, #12]
 801183e:	1e5a      	subs	r2, r3, #1
 8011840:	60fa      	str	r2, [r7, #12]
 8011842:	2b00      	cmp	r3, #0
 8011844:	dc03      	bgt.n	801184e <I2C_EE_PageWrite+0x66>
				return I2C_EE_Relaunch();
 8011846:	4b7a      	ldr	r3, [pc, #488]	; (8011a30 <I2C_EE_PageWrite+0x248>)
 8011848:	4798      	blx	r3
 801184a:	4603      	mov	r3, r0
 801184c:	e131      	b.n	8011ab2 <I2C_EE_PageWrite+0x2ca>
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT)) {
 801184e:	497c      	ldr	r1, [pc, #496]	; (8011a40 <I2C_EE_PageWrite+0x258>)
 8011850:	4878      	ldr	r0, [pc, #480]	; (8011a34 <I2C_EE_PageWrite+0x24c>)
 8011852:	4b7c      	ldr	r3, [pc, #496]	; (8011a44 <I2C_EE_PageWrite+0x25c>)
 8011854:	4798      	blx	r3
 8011856:	4603      	mov	r3, r0
 8011858:	2b00      	cmp	r3, #0
 801185a:	d0ef      	beq.n	801183c <I2C_EE_PageWrite+0x54>
		}

		/* Send EEPROM address for write */
		I2C_Send7bitAddress(I2C1, EEPROM_ADDRESS, I2C_Direction_Transmitter);
 801185c:	4b7a      	ldr	r3, [pc, #488]	; (8011a48 <I2C_EE_PageWrite+0x260>)
 801185e:	881b      	ldrh	r3, [r3, #0]
 8011860:	b2db      	uxtb	r3, r3
 8011862:	2200      	movs	r2, #0
 8011864:	4619      	mov	r1, r3
 8011866:	4873      	ldr	r0, [pc, #460]	; (8011a34 <I2C_EE_PageWrite+0x24c>)
 8011868:	4b78      	ldr	r3, [pc, #480]	; (8011a4c <I2C_EE_PageWrite+0x264>)
 801186a:	4798      	blx	r3

		/* Read I2C1 SR1 register*/
		// SR2_Tmp = I2C_ReadRegister(I2C1, I2C_Register_SR1);
		//  I2C_ClearFlag(I2C1, I2C_FLAG_ADDR);
		/* Send the EEPROM's internal address to write to */
		I2C_SendData(I2C1, (WriteAddr >> 8) & 0xFF);
 801186c:	887b      	ldrh	r3, [r7, #2]
 801186e:	0a1b      	lsrs	r3, r3, #8
 8011870:	b29b      	uxth	r3, r3
 8011872:	b2db      	uxtb	r3, r3
 8011874:	4619      	mov	r1, r3
 8011876:	486f      	ldr	r0, [pc, #444]	; (8011a34 <I2C_EE_PageWrite+0x24c>)
 8011878:	4b75      	ldr	r3, [pc, #468]	; (8011a50 <I2C_EE_PageWrite+0x268>)
 801187a:	4798      	blx	r3

		counter = RETRY_NUMBER;
 801187c:	f640 33b8 	movw	r3, #3000	; 0xbb8
 8011880:	60fb      	str	r3, [r7, #12]
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED)) {
 8011882:	e008      	b.n	8011896 <I2C_EE_PageWrite+0xae>
			if (counter-- <= 0)
 8011884:	68fb      	ldr	r3, [r7, #12]
 8011886:	1e5a      	subs	r2, r3, #1
 8011888:	60fa      	str	r2, [r7, #12]
 801188a:	2b00      	cmp	r3, #0
 801188c:	dc03      	bgt.n	8011896 <I2C_EE_PageWrite+0xae>
				return I2C_EE_Relaunch();
 801188e:	4b68      	ldr	r3, [pc, #416]	; (8011a30 <I2C_EE_PageWrite+0x248>)
 8011890:	4798      	blx	r3
 8011892:	4603      	mov	r3, r0
 8011894:	e10d      	b.n	8011ab2 <I2C_EE_PageWrite+0x2ca>
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED)) {
 8011896:	496f      	ldr	r1, [pc, #444]	; (8011a54 <I2C_EE_PageWrite+0x26c>)
 8011898:	4866      	ldr	r0, [pc, #408]	; (8011a34 <I2C_EE_PageWrite+0x24c>)
 801189a:	4b6a      	ldr	r3, [pc, #424]	; (8011a44 <I2C_EE_PageWrite+0x25c>)
 801189c:	4798      	blx	r3
 801189e:	4603      	mov	r3, r0
 80118a0:	2b00      	cmp	r3, #0
 80118a2:	d0ef      	beq.n	8011884 <I2C_EE_PageWrite+0x9c>
		}

		I2C_SendData(I2C1, WriteAddr & 0xFF);
 80118a4:	887b      	ldrh	r3, [r7, #2]
 80118a6:	b2db      	uxtb	r3, r3
 80118a8:	4619      	mov	r1, r3
 80118aa:	4862      	ldr	r0, [pc, #392]	; (8011a34 <I2C_EE_PageWrite+0x24c>)
 80118ac:	4b68      	ldr	r3, [pc, #416]	; (8011a50 <I2C_EE_PageWrite+0x268>)
 80118ae:	4798      	blx	r3

		/* Test on EV8 and clear it */
		counter = RETRY_NUMBER;
 80118b0:	f640 33b8 	movw	r3, #3000	; 0xbb8
 80118b4:	60fb      	str	r3, [r7, #12]

		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED))
 80118b6:	e008      	b.n	80118ca <I2C_EE_PageWrite+0xe2>

		{
			if (counter-- <= 0)
 80118b8:	68fb      	ldr	r3, [r7, #12]
 80118ba:	1e5a      	subs	r2, r3, #1
 80118bc:	60fa      	str	r2, [r7, #12]
 80118be:	2b00      	cmp	r3, #0
 80118c0:	dc03      	bgt.n	80118ca <I2C_EE_PageWrite+0xe2>
				return I2C_EE_Relaunch();
 80118c2:	4b5b      	ldr	r3, [pc, #364]	; (8011a30 <I2C_EE_PageWrite+0x248>)
 80118c4:	4798      	blx	r3
 80118c6:	4603      	mov	r3, r0
 80118c8:	e0f3      	b.n	8011ab2 <I2C_EE_PageWrite+0x2ca>
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED))
 80118ca:	4962      	ldr	r1, [pc, #392]	; (8011a54 <I2C_EE_PageWrite+0x26c>)
 80118cc:	4859      	ldr	r0, [pc, #356]	; (8011a34 <I2C_EE_PageWrite+0x24c>)
 80118ce:	4b5d      	ldr	r3, [pc, #372]	; (8011a44 <I2C_EE_PageWrite+0x25c>)
 80118d0:	4798      	blx	r3
 80118d2:	4603      	mov	r3, r0
 80118d4:	2b00      	cmp	r3, #0
 80118d6:	d0ef      	beq.n	80118b8 <I2C_EE_PageWrite+0xd0>
		}

		/* While there is data to be written */
		while (NumByteToWrite--) {
 80118d8:	e01c      	b.n	8011914 <I2C_EE_PageWrite+0x12c>
			/* Send the current byte */
			I2C_SendData(I2C1, *pBuffer);
 80118da:	687b      	ldr	r3, [r7, #4]
 80118dc:	781b      	ldrb	r3, [r3, #0]
 80118de:	4619      	mov	r1, r3
 80118e0:	4854      	ldr	r0, [pc, #336]	; (8011a34 <I2C_EE_PageWrite+0x24c>)
 80118e2:	4b5b      	ldr	r3, [pc, #364]	; (8011a50 <I2C_EE_PageWrite+0x268>)
 80118e4:	4798      	blx	r3

			/* Point to the next byte to be written */
			pBuffer++;
 80118e6:	687b      	ldr	r3, [r7, #4]
 80118e8:	3301      	adds	r3, #1
 80118ea:	607b      	str	r3, [r7, #4]
			counter = RETRY_NUMBER;
 80118ec:	f640 33b8 	movw	r3, #3000	; 0xbb8
 80118f0:	60fb      	str	r3, [r7, #12]
			while (!I2C_GetFlagStatus(I2C1, I2C_FLAG_TXE))
 80118f2:	bf00      	nop
 80118f4:	4958      	ldr	r1, [pc, #352]	; (8011a58 <I2C_EE_PageWrite+0x270>)
 80118f6:	484f      	ldr	r0, [pc, #316]	; (8011a34 <I2C_EE_PageWrite+0x24c>)
 80118f8:	4b4f      	ldr	r3, [pc, #316]	; (8011a38 <I2C_EE_PageWrite+0x250>)
 80118fa:	4798      	blx	r3
 80118fc:	4603      	mov	r3, r0
 80118fe:	2b00      	cmp	r3, #0
 8011900:	d0f8      	beq.n	80118f4 <I2C_EE_PageWrite+0x10c>
				;
			{
				if (counter-- <= 0)
 8011902:	68fb      	ldr	r3, [r7, #12]
 8011904:	1e5a      	subs	r2, r3, #1
 8011906:	60fa      	str	r2, [r7, #12]
 8011908:	2b00      	cmp	r3, #0
 801190a:	dc03      	bgt.n	8011914 <I2C_EE_PageWrite+0x12c>
					return I2C_EE_Relaunch();
 801190c:	4b48      	ldr	r3, [pc, #288]	; (8011a30 <I2C_EE_PageWrite+0x248>)
 801190e:	4798      	blx	r3
 8011910:	4603      	mov	r3, r0
 8011912:	e0ce      	b.n	8011ab2 <I2C_EE_PageWrite+0x2ca>
		while (NumByteToWrite--) {
 8011914:	787b      	ldrb	r3, [r7, #1]
 8011916:	1e5a      	subs	r2, r3, #1
 8011918:	707a      	strb	r2, [r7, #1]
 801191a:	2b00      	cmp	r3, #0
 801191c:	d1dd      	bne.n	80118da <I2C_EE_PageWrite+0xf2>
			/* Test on EV8 and clear it */

		}

		/* Send STOP condition */
		I2C_GenerateSTOP(I2C1, ENABLE);
 801191e:	2101      	movs	r1, #1
 8011920:	4844      	ldr	r0, [pc, #272]	; (8011a34 <I2C_EE_PageWrite+0x24c>)
 8011922:	4b4e      	ldr	r3, [pc, #312]	; (8011a5c <I2C_EE_PageWrite+0x274>)
 8011924:	4798      	blx	r3
		return true;
 8011926:	2301      	movs	r3, #1
 8011928:	e0c3      	b.n	8011ab2 <I2C_EE_PageWrite+0x2ca>
	} else {
		int counter = RETRY_NUMBER;
 801192a:	f640 33b8 	movw	r3, #3000	; 0xbb8
 801192e:	60bb      	str	r3, [r7, #8]
		/* While the bus is busy */
		while (I2C_GetFlagStatus(I2C1, I2C_FLAG_BUSY)) {
 8011930:	e008      	b.n	8011944 <I2C_EE_PageWrite+0x15c>
			if (counter-- <= 0)
 8011932:	68bb      	ldr	r3, [r7, #8]
 8011934:	1e5a      	subs	r2, r3, #1
 8011936:	60ba      	str	r2, [r7, #8]
 8011938:	2b00      	cmp	r3, #0
 801193a:	dc03      	bgt.n	8011944 <I2C_EE_PageWrite+0x15c>
				return I2C_EE_Relaunch();
 801193c:	4b3c      	ldr	r3, [pc, #240]	; (8011a30 <I2C_EE_PageWrite+0x248>)
 801193e:	4798      	blx	r3
 8011940:	4603      	mov	r3, r0
 8011942:	e0b6      	b.n	8011ab2 <I2C_EE_PageWrite+0x2ca>
		while (I2C_GetFlagStatus(I2C1, I2C_FLAG_BUSY)) {
 8011944:	f44f 3100 	mov.w	r1, #131072	; 0x20000
 8011948:	483a      	ldr	r0, [pc, #232]	; (8011a34 <I2C_EE_PageWrite+0x24c>)
 801194a:	4b3b      	ldr	r3, [pc, #236]	; (8011a38 <I2C_EE_PageWrite+0x250>)
 801194c:	4798      	blx	r3
 801194e:	4603      	mov	r3, r0
 8011950:	2b00      	cmp	r3, #0
 8011952:	d1ee      	bne.n	8011932 <I2C_EE_PageWrite+0x14a>
		}

		/* Send START condition */
		I2C_GenerateSTART(I2C1, ENABLE);
 8011954:	2101      	movs	r1, #1
 8011956:	4837      	ldr	r0, [pc, #220]	; (8011a34 <I2C_EE_PageWrite+0x24c>)
 8011958:	4b38      	ldr	r3, [pc, #224]	; (8011a3c <I2C_EE_PageWrite+0x254>)
 801195a:	4798      	blx	r3

		/* Test on EV5 and clear it */
		counter = RETRY_NUMBER;
 801195c:	f640 33b8 	movw	r3, #3000	; 0xbb8
 8011960:	60bb      	str	r3, [r7, #8]
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT)) {
 8011962:	e008      	b.n	8011976 <I2C_EE_PageWrite+0x18e>
			if (counter-- <= 0)
 8011964:	68bb      	ldr	r3, [r7, #8]
 8011966:	1e5a      	subs	r2, r3, #1
 8011968:	60ba      	str	r2, [r7, #8]
 801196a:	2b00      	cmp	r3, #0
 801196c:	dc03      	bgt.n	8011976 <I2C_EE_PageWrite+0x18e>
				return I2C_EE_Relaunch();
 801196e:	4b30      	ldr	r3, [pc, #192]	; (8011a30 <I2C_EE_PageWrite+0x248>)
 8011970:	4798      	blx	r3
 8011972:	4603      	mov	r3, r0
 8011974:	e09d      	b.n	8011ab2 <I2C_EE_PageWrite+0x2ca>
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT)) {
 8011976:	4932      	ldr	r1, [pc, #200]	; (8011a40 <I2C_EE_PageWrite+0x258>)
 8011978:	482e      	ldr	r0, [pc, #184]	; (8011a34 <I2C_EE_PageWrite+0x24c>)
 801197a:	4b32      	ldr	r3, [pc, #200]	; (8011a44 <I2C_EE_PageWrite+0x25c>)
 801197c:	4798      	blx	r3
 801197e:	4603      	mov	r3, r0
 8011980:	2b00      	cmp	r3, #0
 8011982:	d0ef      	beq.n	8011964 <I2C_EE_PageWrite+0x17c>
		}

		/* Send EEPROM address for write */
		I2C_Send7bitAddress(I2C1, EEPROM_ADDRESS, I2C_Direction_Transmitter);
 8011984:	4b30      	ldr	r3, [pc, #192]	; (8011a48 <I2C_EE_PageWrite+0x260>)
 8011986:	881b      	ldrh	r3, [r3, #0]
 8011988:	b2db      	uxtb	r3, r3
 801198a:	2200      	movs	r2, #0
 801198c:	4619      	mov	r1, r3
 801198e:	4829      	ldr	r0, [pc, #164]	; (8011a34 <I2C_EE_PageWrite+0x24c>)
 8011990:	4b2e      	ldr	r3, [pc, #184]	; (8011a4c <I2C_EE_PageWrite+0x264>)
 8011992:	4798      	blx	r3

		/* Test on EV6 and clear it */
		counter = RETRY_NUMBER;
 8011994:	f640 33b8 	movw	r3, #3000	; 0xbb8
 8011998:	60bb      	str	r3, [r7, #8]
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED)) {
 801199a:	e008      	b.n	80119ae <I2C_EE_PageWrite+0x1c6>
			if (counter-- <= 0)
 801199c:	68bb      	ldr	r3, [r7, #8]
 801199e:	1e5a      	subs	r2, r3, #1
 80119a0:	60ba      	str	r2, [r7, #8]
 80119a2:	2b00      	cmp	r3, #0
 80119a4:	dc03      	bgt.n	80119ae <I2C_EE_PageWrite+0x1c6>
				return I2C_EE_Relaunch();
 80119a6:	4b22      	ldr	r3, [pc, #136]	; (8011a30 <I2C_EE_PageWrite+0x248>)
 80119a8:	4798      	blx	r3
 80119aa:	4603      	mov	r3, r0
 80119ac:	e081      	b.n	8011ab2 <I2C_EE_PageWrite+0x2ca>
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED)) {
 80119ae:	492c      	ldr	r1, [pc, #176]	; (8011a60 <I2C_EE_PageWrite+0x278>)
 80119b0:	4820      	ldr	r0, [pc, #128]	; (8011a34 <I2C_EE_PageWrite+0x24c>)
 80119b2:	4b24      	ldr	r3, [pc, #144]	; (8011a44 <I2C_EE_PageWrite+0x25c>)
 80119b4:	4798      	blx	r3
 80119b6:	4603      	mov	r3, r0
 80119b8:	2b00      	cmp	r3, #0
 80119ba:	d0ef      	beq.n	801199c <I2C_EE_PageWrite+0x1b4>
		}

		/* Send the EEPROM's internal address to write to */
		I2C_SendData(I2C1, (WriteAddr >> 8) & 0xFF);
 80119bc:	887b      	ldrh	r3, [r7, #2]
 80119be:	0a1b      	lsrs	r3, r3, #8
 80119c0:	b29b      	uxth	r3, r3
 80119c2:	b2db      	uxtb	r3, r3
 80119c4:	4619      	mov	r1, r3
 80119c6:	481b      	ldr	r0, [pc, #108]	; (8011a34 <I2C_EE_PageWrite+0x24c>)
 80119c8:	4b21      	ldr	r3, [pc, #132]	; (8011a50 <I2C_EE_PageWrite+0x268>)
 80119ca:	4798      	blx	r3
		counter = RETRY_NUMBER;
 80119cc:	f640 33b8 	movw	r3, #3000	; 0xbb8
 80119d0:	60bb      	str	r3, [r7, #8]
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED)) {
 80119d2:	e008      	b.n	80119e6 <I2C_EE_PageWrite+0x1fe>
			if (counter-- <= 0)
 80119d4:	68bb      	ldr	r3, [r7, #8]
 80119d6:	1e5a      	subs	r2, r3, #1
 80119d8:	60ba      	str	r2, [r7, #8]
 80119da:	2b00      	cmp	r3, #0
 80119dc:	dc03      	bgt.n	80119e6 <I2C_EE_PageWrite+0x1fe>
				return I2C_EE_Relaunch();
 80119de:	4b14      	ldr	r3, [pc, #80]	; (8011a30 <I2C_EE_PageWrite+0x248>)
 80119e0:	4798      	blx	r3
 80119e2:	4603      	mov	r3, r0
 80119e4:	e065      	b.n	8011ab2 <I2C_EE_PageWrite+0x2ca>
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED)) {
 80119e6:	491b      	ldr	r1, [pc, #108]	; (8011a54 <I2C_EE_PageWrite+0x26c>)
 80119e8:	4812      	ldr	r0, [pc, #72]	; (8011a34 <I2C_EE_PageWrite+0x24c>)
 80119ea:	4b16      	ldr	r3, [pc, #88]	; (8011a44 <I2C_EE_PageWrite+0x25c>)
 80119ec:	4798      	blx	r3
 80119ee:	4603      	mov	r3, r0
 80119f0:	2b00      	cmp	r3, #0
 80119f2:	d0ef      	beq.n	80119d4 <I2C_EE_PageWrite+0x1ec>
		}

		I2C_SendData(I2C1, WriteAddr & 0xFF);
 80119f4:	887b      	ldrh	r3, [r7, #2]
 80119f6:	b2db      	uxtb	r3, r3
 80119f8:	4619      	mov	r1, r3
 80119fa:	480e      	ldr	r0, [pc, #56]	; (8011a34 <I2C_EE_PageWrite+0x24c>)
 80119fc:	4b14      	ldr	r3, [pc, #80]	; (8011a50 <I2C_EE_PageWrite+0x268>)
 80119fe:	4798      	blx	r3

		/* Test on EV8 and clear it */
		counter = RETRY_NUMBER;
 8011a00:	f640 33b8 	movw	r3, #3000	; 0xbb8
 8011a04:	60bb      	str	r3, [r7, #8]
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED)) {
 8011a06:	e008      	b.n	8011a1a <I2C_EE_PageWrite+0x232>
			if (counter-- <= 0)
 8011a08:	68bb      	ldr	r3, [r7, #8]
 8011a0a:	1e5a      	subs	r2, r3, #1
 8011a0c:	60ba      	str	r2, [r7, #8]
 8011a0e:	2b00      	cmp	r3, #0
 8011a10:	dc03      	bgt.n	8011a1a <I2C_EE_PageWrite+0x232>
				return I2C_EE_Relaunch();
 8011a12:	4b07      	ldr	r3, [pc, #28]	; (8011a30 <I2C_EE_PageWrite+0x248>)
 8011a14:	4798      	blx	r3
 8011a16:	4603      	mov	r3, r0
 8011a18:	e04b      	b.n	8011ab2 <I2C_EE_PageWrite+0x2ca>
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED)) {
 8011a1a:	490e      	ldr	r1, [pc, #56]	; (8011a54 <I2C_EE_PageWrite+0x26c>)
 8011a1c:	4805      	ldr	r0, [pc, #20]	; (8011a34 <I2C_EE_PageWrite+0x24c>)
 8011a1e:	4b09      	ldr	r3, [pc, #36]	; (8011a44 <I2C_EE_PageWrite+0x25c>)
 8011a20:	4798      	blx	r3
 8011a22:	4603      	mov	r3, r0
 8011a24:	2b00      	cmp	r3, #0
 8011a26:	d0ef      	beq.n	8011a08 <I2C_EE_PageWrite+0x220>
		}

		/* While there is data to be written */
		while (NumByteToWrite--) {
 8011a28:	e039      	b.n	8011a9e <I2C_EE_PageWrite+0x2b6>
 8011a2a:	bf00      	nop
 8011a2c:	20007194 	.word	0x20007194
 8011a30:	080120b1 	.word	0x080120b1
 8011a34:	40005400 	.word	0x40005400
 8011a38:	0800401d 	.word	0x0800401d
 8011a3c:	08003de3 	.word	0x08003de3
 8011a40:	00030001 	.word	0x00030001
 8011a44:	08003fc3 	.word	0x08003fc3
 8011a48:	2000958c 	.word	0x2000958c
 8011a4c:	08003f1b 	.word	0x08003f1b
 8011a50:	08003ee3 	.word	0x08003ee3
 8011a54:	00070084 	.word	0x00070084
 8011a58:	10000080 	.word	0x10000080
 8011a5c:	08003e21 	.word	0x08003e21
 8011a60:	00070082 	.word	0x00070082
			/* Send the current byte */
			I2C_SendData(I2C1, *pBuffer);
 8011a64:	687b      	ldr	r3, [r7, #4]
 8011a66:	781b      	ldrb	r3, [r3, #0]
 8011a68:	4619      	mov	r1, r3
 8011a6a:	4814      	ldr	r0, [pc, #80]	; (8011abc <I2C_EE_PageWrite+0x2d4>)
 8011a6c:	4b14      	ldr	r3, [pc, #80]	; (8011ac0 <I2C_EE_PageWrite+0x2d8>)
 8011a6e:	4798      	blx	r3

			/* Point to the next byte to be written */
			pBuffer++;
 8011a70:	687b      	ldr	r3, [r7, #4]
 8011a72:	3301      	adds	r3, #1
 8011a74:	607b      	str	r3, [r7, #4]

			/* Test on EV8 and clear it */
			counter = RETRY_NUMBER;
 8011a76:	f640 33b8 	movw	r3, #3000	; 0xbb8
 8011a7a:	60bb      	str	r3, [r7, #8]
			while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED)) {
 8011a7c:	e008      	b.n	8011a90 <I2C_EE_PageWrite+0x2a8>
				if (counter-- <= 0)
 8011a7e:	68bb      	ldr	r3, [r7, #8]
 8011a80:	1e5a      	subs	r2, r3, #1
 8011a82:	60ba      	str	r2, [r7, #8]
 8011a84:	2b00      	cmp	r3, #0
 8011a86:	dc03      	bgt.n	8011a90 <I2C_EE_PageWrite+0x2a8>
					return I2C_EE_Relaunch();
 8011a88:	4b0e      	ldr	r3, [pc, #56]	; (8011ac4 <I2C_EE_PageWrite+0x2dc>)
 8011a8a:	4798      	blx	r3
 8011a8c:	4603      	mov	r3, r0
 8011a8e:	e010      	b.n	8011ab2 <I2C_EE_PageWrite+0x2ca>
			while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED)) {
 8011a90:	490d      	ldr	r1, [pc, #52]	; (8011ac8 <I2C_EE_PageWrite+0x2e0>)
 8011a92:	480a      	ldr	r0, [pc, #40]	; (8011abc <I2C_EE_PageWrite+0x2d4>)
 8011a94:	4b0d      	ldr	r3, [pc, #52]	; (8011acc <I2C_EE_PageWrite+0x2e4>)
 8011a96:	4798      	blx	r3
 8011a98:	4603      	mov	r3, r0
 8011a9a:	2b00      	cmp	r3, #0
 8011a9c:	d0ef      	beq.n	8011a7e <I2C_EE_PageWrite+0x296>
		while (NumByteToWrite--) {
 8011a9e:	787b      	ldrb	r3, [r7, #1]
 8011aa0:	1e5a      	subs	r2, r3, #1
 8011aa2:	707a      	strb	r2, [r7, #1]
 8011aa4:	2b00      	cmp	r3, #0
 8011aa6:	d1dd      	bne.n	8011a64 <I2C_EE_PageWrite+0x27c>
			}
		}

		/* Send STOP condition */
		I2C_GenerateSTOP(I2C1, ENABLE);
 8011aa8:	2101      	movs	r1, #1
 8011aaa:	4804      	ldr	r0, [pc, #16]	; (8011abc <I2C_EE_PageWrite+0x2d4>)
 8011aac:	4b08      	ldr	r3, [pc, #32]	; (8011ad0 <I2C_EE_PageWrite+0x2e8>)
 8011aae:	4798      	blx	r3
		return true;
 8011ab0:	2301      	movs	r3, #1
	}
}
 8011ab2:	4618      	mov	r0, r3
 8011ab4:	3710      	adds	r7, #16
 8011ab6:	46bd      	mov	sp, r7
 8011ab8:	bd80      	pop	{r7, pc}
 8011aba:	bf00      	nop
 8011abc:	40005400 	.word	0x40005400
 8011ac0:	08003ee3 	.word	0x08003ee3
 8011ac4:	080120b1 	.word	0x080120b1
 8011ac8:	00070084 	.word	0x00070084
 8011acc:	08003fc3 	.word	0x08003fc3
 8011ad0:	08003e21 	.word	0x08003e21

08011ad4 <I2C_EE_BufferRead>:
 *                  - ReadAddr : EEPROM's internal address to read from.
 *                  - NumByteToRead : number of bytes to read from the EEPROM.
 * Output         : None
 * Return         : None
 *******************************************************************************/
bool I2C_EE_BufferRead(u8 *pBuffer, u16 ReadAddr, u16 NumByteToRead) {
 8011ad4:	b580      	push	{r7, lr}
 8011ad6:	b086      	sub	sp, #24
 8011ad8:	af00      	add	r7, sp, #0
 8011ada:	6078      	str	r0, [r7, #4]
 8011adc:	460b      	mov	r3, r1
 8011ade:	807b      	strh	r3, [r7, #2]
 8011ae0:	4613      	mov	r3, r2
 8011ae2:	803b      	strh	r3, [r7, #0]
	if (initMK == 1) {
 8011ae4:	4b8e      	ldr	r3, [pc, #568]	; (8011d20 <I2C_EE_BufferRead+0x24c>)
 8011ae6:	681b      	ldr	r3, [r3, #0]
 8011ae8:	2b01      	cmp	r3, #1
 8011aea:	f040 80f2 	bne.w	8011cd2 <I2C_EE_BufferRead+0x1fe>
		int counter = RETRY_NUMBER;
 8011aee:	f640 33b8 	movw	r3, #3000	; 0xbb8
 8011af2:	617b      	str	r3, [r7, #20]
		vu16 SR2_Tmp;
		/* While the bus is busy */

		while (I2C_GetFlagStatus(I2C1, I2C_FLAG_BUSY)) {
 8011af4:	e008      	b.n	8011b08 <I2C_EE_BufferRead+0x34>
			if (counter-- <= 0)
 8011af6:	697b      	ldr	r3, [r7, #20]
 8011af8:	1e5a      	subs	r2, r3, #1
 8011afa:	617a      	str	r2, [r7, #20]
 8011afc:	2b00      	cmp	r3, #0
 8011afe:	dc03      	bgt.n	8011b08 <I2C_EE_BufferRead+0x34>
				return I2C_EE_Relaunch();
 8011b00:	4b88      	ldr	r3, [pc, #544]	; (8011d24 <I2C_EE_BufferRead+0x250>)
 8011b02:	4798      	blx	r3
 8011b04:	4603      	mov	r3, r0
 8011b06:	e1f6      	b.n	8011ef6 <I2C_EE_BufferRead+0x422>
		while (I2C_GetFlagStatus(I2C1, I2C_FLAG_BUSY)) {
 8011b08:	f44f 3100 	mov.w	r1, #131072	; 0x20000
 8011b0c:	4886      	ldr	r0, [pc, #536]	; (8011d28 <I2C_EE_BufferRead+0x254>)
 8011b0e:	4b87      	ldr	r3, [pc, #540]	; (8011d2c <I2C_EE_BufferRead+0x258>)
 8011b10:	4798      	blx	r3
 8011b12:	4603      	mov	r3, r0
 8011b14:	2b00      	cmp	r3, #0
 8011b16:	d1ee      	bne.n	8011af6 <I2C_EE_BufferRead+0x22>
		}

		/* Send START condition */
		I2C_GenerateSTART(I2C1, ENABLE);
 8011b18:	2101      	movs	r1, #1
 8011b1a:	4883      	ldr	r0, [pc, #524]	; (8011d28 <I2C_EE_BufferRead+0x254>)
 8011b1c:	4b84      	ldr	r3, [pc, #528]	; (8011d30 <I2C_EE_BufferRead+0x25c>)
 8011b1e:	4798      	blx	r3

		/* Test on EV5 and clear it */
		counter = RETRY_NUMBER;
 8011b20:	f640 33b8 	movw	r3, #3000	; 0xbb8
 8011b24:	617b      	str	r3, [r7, #20]
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT)) {
 8011b26:	e008      	b.n	8011b3a <I2C_EE_BufferRead+0x66>
			if (counter-- <= 0)
 8011b28:	697b      	ldr	r3, [r7, #20]
 8011b2a:	1e5a      	subs	r2, r3, #1
 8011b2c:	617a      	str	r2, [r7, #20]
 8011b2e:	2b00      	cmp	r3, #0
 8011b30:	dc03      	bgt.n	8011b3a <I2C_EE_BufferRead+0x66>
				return I2C_EE_Relaunch();
 8011b32:	4b7c      	ldr	r3, [pc, #496]	; (8011d24 <I2C_EE_BufferRead+0x250>)
 8011b34:	4798      	blx	r3
 8011b36:	4603      	mov	r3, r0
 8011b38:	e1dd      	b.n	8011ef6 <I2C_EE_BufferRead+0x422>
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT)) {
 8011b3a:	497e      	ldr	r1, [pc, #504]	; (8011d34 <I2C_EE_BufferRead+0x260>)
 8011b3c:	487a      	ldr	r0, [pc, #488]	; (8011d28 <I2C_EE_BufferRead+0x254>)
 8011b3e:	4b7e      	ldr	r3, [pc, #504]	; (8011d38 <I2C_EE_BufferRead+0x264>)
 8011b40:	4798      	blx	r3
 8011b42:	4603      	mov	r3, r0
 8011b44:	2b00      	cmp	r3, #0
 8011b46:	d0ef      	beq.n	8011b28 <I2C_EE_BufferRead+0x54>
		}

		/* Send EEPROM address for write */
		I2C_Send7bitAddress(I2C1, EEPROM_ADDRESS, I2C_Direction_Transmitter);
 8011b48:	4b7c      	ldr	r3, [pc, #496]	; (8011d3c <I2C_EE_BufferRead+0x268>)
 8011b4a:	881b      	ldrh	r3, [r3, #0]
 8011b4c:	b2db      	uxtb	r3, r3
 8011b4e:	2200      	movs	r2, #0
 8011b50:	4619      	mov	r1, r3
 8011b52:	4875      	ldr	r0, [pc, #468]	; (8011d28 <I2C_EE_BufferRead+0x254>)
 8011b54:	4b7a      	ldr	r3, [pc, #488]	; (8011d40 <I2C_EE_BufferRead+0x26c>)
 8011b56:	4798      	blx	r3

		/* Test on EV6 and clear it */

		counter = RETRY_NUMBER;
 8011b58:	f640 33b8 	movw	r3, #3000	; 0xbb8
 8011b5c:	617b      	str	r3, [r7, #20]
		while (!I2C_GetFlagStatus(I2C1, I2C_FLAG_ADDR)) {
 8011b5e:	e008      	b.n	8011b72 <I2C_EE_BufferRead+0x9e>
			if (counter-- <= 0)
 8011b60:	697b      	ldr	r3, [r7, #20]
 8011b62:	1e5a      	subs	r2, r3, #1
 8011b64:	617a      	str	r2, [r7, #20]
 8011b66:	2b00      	cmp	r3, #0
 8011b68:	dc03      	bgt.n	8011b72 <I2C_EE_BufferRead+0x9e>
				return I2C_EE_Relaunch();
 8011b6a:	4b6e      	ldr	r3, [pc, #440]	; (8011d24 <I2C_EE_BufferRead+0x250>)
 8011b6c:	4798      	blx	r3
 8011b6e:	4603      	mov	r3, r0
 8011b70:	e1c1      	b.n	8011ef6 <I2C_EE_BufferRead+0x422>
		while (!I2C_GetFlagStatus(I2C1, I2C_FLAG_ADDR)) {
 8011b72:	4974      	ldr	r1, [pc, #464]	; (8011d44 <I2C_EE_BufferRead+0x270>)
 8011b74:	486c      	ldr	r0, [pc, #432]	; (8011d28 <I2C_EE_BufferRead+0x254>)
 8011b76:	4b6d      	ldr	r3, [pc, #436]	; (8011d2c <I2C_EE_BufferRead+0x258>)
 8011b78:	4798      	blx	r3
 8011b7a:	4603      	mov	r3, r0
 8011b7c:	2b00      	cmp	r3, #0
 8011b7e:	d0ef      	beq.n	8011b60 <I2C_EE_BufferRead+0x8c>
		}

		/* Read I2C1 SR1 register*/
		SR2_Tmp = I2C_ReadRegister(I2C1, I2C_Register_SR1);
 8011b80:	2114      	movs	r1, #20
 8011b82:	4869      	ldr	r0, [pc, #420]	; (8011d28 <I2C_EE_BufferRead+0x254>)
 8011b84:	4b70      	ldr	r3, [pc, #448]	; (8011d48 <I2C_EE_BufferRead+0x274>)
 8011b86:	4798      	blx	r3
 8011b88:	4603      	mov	r3, r0
 8011b8a:	81fb      	strh	r3, [r7, #14]

		//

		/* Clear EV6 by setting again the PE bit */
		I2C_Cmd(I2C1, ENABLE);
 8011b8c:	2101      	movs	r1, #1
 8011b8e:	4866      	ldr	r0, [pc, #408]	; (8011d28 <I2C_EE_BufferRead+0x254>)
 8011b90:	4b6e      	ldr	r3, [pc, #440]	; (8011d4c <I2C_EE_BufferRead+0x278>)
 8011b92:	4798      	blx	r3

		/* Send the EEPROM's internal address to write to */
		I2C_SendData(I2C1, (ReadAddr >> 8) & 0xFF);
 8011b94:	887b      	ldrh	r3, [r7, #2]
 8011b96:	0a1b      	lsrs	r3, r3, #8
 8011b98:	b29b      	uxth	r3, r3
 8011b9a:	b2db      	uxtb	r3, r3
 8011b9c:	4619      	mov	r1, r3
 8011b9e:	4862      	ldr	r0, [pc, #392]	; (8011d28 <I2C_EE_BufferRead+0x254>)
 8011ba0:	4b6b      	ldr	r3, [pc, #428]	; (8011d50 <I2C_EE_BufferRead+0x27c>)
 8011ba2:	4798      	blx	r3

		counter = RETRY_NUMBER;
 8011ba4:	f640 33b8 	movw	r3, #3000	; 0xbb8
 8011ba8:	617b      	str	r3, [r7, #20]
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED)) {
 8011baa:	e008      	b.n	8011bbe <I2C_EE_BufferRead+0xea>
			if (counter-- <= 0)
 8011bac:	697b      	ldr	r3, [r7, #20]
 8011bae:	1e5a      	subs	r2, r3, #1
 8011bb0:	617a      	str	r2, [r7, #20]
 8011bb2:	2b00      	cmp	r3, #0
 8011bb4:	dc03      	bgt.n	8011bbe <I2C_EE_BufferRead+0xea>
				return I2C_EE_Relaunch();
 8011bb6:	4b5b      	ldr	r3, [pc, #364]	; (8011d24 <I2C_EE_BufferRead+0x250>)
 8011bb8:	4798      	blx	r3
 8011bba:	4603      	mov	r3, r0
 8011bbc:	e19b      	b.n	8011ef6 <I2C_EE_BufferRead+0x422>
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED)) {
 8011bbe:	4965      	ldr	r1, [pc, #404]	; (8011d54 <I2C_EE_BufferRead+0x280>)
 8011bc0:	4859      	ldr	r0, [pc, #356]	; (8011d28 <I2C_EE_BufferRead+0x254>)
 8011bc2:	4b5d      	ldr	r3, [pc, #372]	; (8011d38 <I2C_EE_BufferRead+0x264>)
 8011bc4:	4798      	blx	r3
 8011bc6:	4603      	mov	r3, r0
 8011bc8:	2b00      	cmp	r3, #0
 8011bca:	d0ef      	beq.n	8011bac <I2C_EE_BufferRead+0xd8>
		}

		I2C_SendData(I2C1, ReadAddr & 0xFF);
 8011bcc:	887b      	ldrh	r3, [r7, #2]
 8011bce:	b2db      	uxtb	r3, r3
 8011bd0:	4619      	mov	r1, r3
 8011bd2:	4855      	ldr	r0, [pc, #340]	; (8011d28 <I2C_EE_BufferRead+0x254>)
 8011bd4:	4b5e      	ldr	r3, [pc, #376]	; (8011d50 <I2C_EE_BufferRead+0x27c>)
 8011bd6:	4798      	blx	r3

		/* Test on EV8 and clear it */
		counter = RETRY_NUMBER;
 8011bd8:	f640 33b8 	movw	r3, #3000	; 0xbb8
 8011bdc:	617b      	str	r3, [r7, #20]
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED)) {
 8011bde:	e008      	b.n	8011bf2 <I2C_EE_BufferRead+0x11e>
			if (counter-- <= 0)
 8011be0:	697b      	ldr	r3, [r7, #20]
 8011be2:	1e5a      	subs	r2, r3, #1
 8011be4:	617a      	str	r2, [r7, #20]
 8011be6:	2b00      	cmp	r3, #0
 8011be8:	dc03      	bgt.n	8011bf2 <I2C_EE_BufferRead+0x11e>
				return I2C_EE_Relaunch();
 8011bea:	4b4e      	ldr	r3, [pc, #312]	; (8011d24 <I2C_EE_BufferRead+0x250>)
 8011bec:	4798      	blx	r3
 8011bee:	4603      	mov	r3, r0
 8011bf0:	e181      	b.n	8011ef6 <I2C_EE_BufferRead+0x422>
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED)) {
 8011bf2:	4958      	ldr	r1, [pc, #352]	; (8011d54 <I2C_EE_BufferRead+0x280>)
 8011bf4:	484c      	ldr	r0, [pc, #304]	; (8011d28 <I2C_EE_BufferRead+0x254>)
 8011bf6:	4b50      	ldr	r3, [pc, #320]	; (8011d38 <I2C_EE_BufferRead+0x264>)
 8011bf8:	4798      	blx	r3
 8011bfa:	4603      	mov	r3, r0
 8011bfc:	2b00      	cmp	r3, #0
 8011bfe:	d0ef      	beq.n	8011be0 <I2C_EE_BufferRead+0x10c>
		}

		/* Send STRAT condition a second time */
		I2C_GenerateSTART(I2C1, ENABLE);
 8011c00:	2101      	movs	r1, #1
 8011c02:	4849      	ldr	r0, [pc, #292]	; (8011d28 <I2C_EE_BufferRead+0x254>)
 8011c04:	4b4a      	ldr	r3, [pc, #296]	; (8011d30 <I2C_EE_BufferRead+0x25c>)
 8011c06:	4798      	blx	r3

		/* Test on EV5 and clear it */
		counter = RETRY_NUMBER;
 8011c08:	f640 33b8 	movw	r3, #3000	; 0xbb8
 8011c0c:	617b      	str	r3, [r7, #20]
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT)) {
 8011c0e:	e008      	b.n	8011c22 <I2C_EE_BufferRead+0x14e>
			if (counter-- <= 0)
 8011c10:	697b      	ldr	r3, [r7, #20]
 8011c12:	1e5a      	subs	r2, r3, #1
 8011c14:	617a      	str	r2, [r7, #20]
 8011c16:	2b00      	cmp	r3, #0
 8011c18:	dc03      	bgt.n	8011c22 <I2C_EE_BufferRead+0x14e>
				return I2C_EE_Relaunch();
 8011c1a:	4b42      	ldr	r3, [pc, #264]	; (8011d24 <I2C_EE_BufferRead+0x250>)
 8011c1c:	4798      	blx	r3
 8011c1e:	4603      	mov	r3, r0
 8011c20:	e169      	b.n	8011ef6 <I2C_EE_BufferRead+0x422>
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT)) {
 8011c22:	4944      	ldr	r1, [pc, #272]	; (8011d34 <I2C_EE_BufferRead+0x260>)
 8011c24:	4840      	ldr	r0, [pc, #256]	; (8011d28 <I2C_EE_BufferRead+0x254>)
 8011c26:	4b44      	ldr	r3, [pc, #272]	; (8011d38 <I2C_EE_BufferRead+0x264>)
 8011c28:	4798      	blx	r3
 8011c2a:	4603      	mov	r3, r0
 8011c2c:	2b00      	cmp	r3, #0
 8011c2e:	d0ef      	beq.n	8011c10 <I2C_EE_BufferRead+0x13c>
		}

		/* Send EEPROM address for read */
		I2C_Send7bitAddress(I2C1, EEPROM_ADDRESS, I2C_Direction_Receiver);
 8011c30:	4b42      	ldr	r3, [pc, #264]	; (8011d3c <I2C_EE_BufferRead+0x268>)
 8011c32:	881b      	ldrh	r3, [r3, #0]
 8011c34:	b2db      	uxtb	r3, r3
 8011c36:	2201      	movs	r2, #1
 8011c38:	4619      	mov	r1, r3
 8011c3a:	483b      	ldr	r0, [pc, #236]	; (8011d28 <I2C_EE_BufferRead+0x254>)
 8011c3c:	4b40      	ldr	r3, [pc, #256]	; (8011d40 <I2C_EE_BufferRead+0x26c>)
 8011c3e:	4798      	blx	r3

		/* Test on EV6 and clear it */
		counter = RETRY_NUMBER;
 8011c40:	f640 33b8 	movw	r3, #3000	; 0xbb8
 8011c44:	617b      	str	r3, [r7, #20]
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED)) {
 8011c46:	e008      	b.n	8011c5a <I2C_EE_BufferRead+0x186>
			if (counter-- <= 0)
 8011c48:	697b      	ldr	r3, [r7, #20]
 8011c4a:	1e5a      	subs	r2, r3, #1
 8011c4c:	617a      	str	r2, [r7, #20]
 8011c4e:	2b00      	cmp	r3, #0
 8011c50:	dc03      	bgt.n	8011c5a <I2C_EE_BufferRead+0x186>
				return I2C_EE_Relaunch();
 8011c52:	4b34      	ldr	r3, [pc, #208]	; (8011d24 <I2C_EE_BufferRead+0x250>)
 8011c54:	4798      	blx	r3
 8011c56:	4603      	mov	r3, r0
 8011c58:	e14d      	b.n	8011ef6 <I2C_EE_BufferRead+0x422>
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED)) {
 8011c5a:	493f      	ldr	r1, [pc, #252]	; (8011d58 <I2C_EE_BufferRead+0x284>)
 8011c5c:	4832      	ldr	r0, [pc, #200]	; (8011d28 <I2C_EE_BufferRead+0x254>)
 8011c5e:	4b36      	ldr	r3, [pc, #216]	; (8011d38 <I2C_EE_BufferRead+0x264>)
 8011c60:	4798      	blx	r3
 8011c62:	4603      	mov	r3, r0
 8011c64:	2b00      	cmp	r3, #0
 8011c66:	d0ef      	beq.n	8011c48 <I2C_EE_BufferRead+0x174>
		}

		/* While there is data to be read */
		counter = RETRY_NUMBER;
 8011c68:	f640 33b8 	movw	r3, #3000	; 0xbb8
 8011c6c:	617b      	str	r3, [r7, #20]

		while (NumByteToRead) {
 8011c6e:	e027      	b.n	8011cc0 <I2C_EE_BufferRead+0x1ec>
			if (NumByteToRead == 1) {
 8011c70:	883b      	ldrh	r3, [r7, #0]
 8011c72:	2b01      	cmp	r3, #1
 8011c74:	d107      	bne.n	8011c86 <I2C_EE_BufferRead+0x1b2>
				/* Disable Acknowledgement */
				I2C_AcknowledgeConfig(I2C1, DISABLE);
 8011c76:	2100      	movs	r1, #0
 8011c78:	482b      	ldr	r0, [pc, #172]	; (8011d28 <I2C_EE_BufferRead+0x254>)
 8011c7a:	4b38      	ldr	r3, [pc, #224]	; (8011d5c <I2C_EE_BufferRead+0x288>)
 8011c7c:	4798      	blx	r3

				/* Send STOP Condition */
				I2C_GenerateSTOP(I2C1, ENABLE);
 8011c7e:	2101      	movs	r1, #1
 8011c80:	4829      	ldr	r0, [pc, #164]	; (8011d28 <I2C_EE_BufferRead+0x254>)
 8011c82:	4b37      	ldr	r3, [pc, #220]	; (8011d60 <I2C_EE_BufferRead+0x28c>)
 8011c84:	4798      	blx	r3
			}

			/* Test on EV7 and clear it */
			if (I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_RECEIVED)) {
 8011c86:	4937      	ldr	r1, [pc, #220]	; (8011d64 <I2C_EE_BufferRead+0x290>)
 8011c88:	4827      	ldr	r0, [pc, #156]	; (8011d28 <I2C_EE_BufferRead+0x254>)
 8011c8a:	4b2b      	ldr	r3, [pc, #172]	; (8011d38 <I2C_EE_BufferRead+0x264>)
 8011c8c:	4798      	blx	r3
 8011c8e:	4603      	mov	r3, r0
 8011c90:	2b00      	cmp	r3, #0
 8011c92:	d00c      	beq.n	8011cae <I2C_EE_BufferRead+0x1da>
				/* Read a byte from the EEPROM */
				*pBuffer = I2C_ReceiveData(I2C1);
 8011c94:	4824      	ldr	r0, [pc, #144]	; (8011d28 <I2C_EE_BufferRead+0x254>)
 8011c96:	4b34      	ldr	r3, [pc, #208]	; (8011d68 <I2C_EE_BufferRead+0x294>)
 8011c98:	4798      	blx	r3
 8011c9a:	4603      	mov	r3, r0
 8011c9c:	461a      	mov	r2, r3
 8011c9e:	687b      	ldr	r3, [r7, #4]
 8011ca0:	701a      	strb	r2, [r3, #0]

				/* Point to the next location where the byte read will be saved */
				pBuffer++;
 8011ca2:	687b      	ldr	r3, [r7, #4]
 8011ca4:	3301      	adds	r3, #1
 8011ca6:	607b      	str	r3, [r7, #4]

				/* Decrement the read bytes counter */
				NumByteToRead--;
 8011ca8:	883b      	ldrh	r3, [r7, #0]
 8011caa:	3b01      	subs	r3, #1
 8011cac:	803b      	strh	r3, [r7, #0]

			}

			if (counter-- <= 0)
 8011cae:	697b      	ldr	r3, [r7, #20]
 8011cb0:	1e5a      	subs	r2, r3, #1
 8011cb2:	617a      	str	r2, [r7, #20]
 8011cb4:	2b00      	cmp	r3, #0
 8011cb6:	dc03      	bgt.n	8011cc0 <I2C_EE_BufferRead+0x1ec>
				return I2C_EE_Relaunch();
 8011cb8:	4b1a      	ldr	r3, [pc, #104]	; (8011d24 <I2C_EE_BufferRead+0x250>)
 8011cba:	4798      	blx	r3
 8011cbc:	4603      	mov	r3, r0
 8011cbe:	e11a      	b.n	8011ef6 <I2C_EE_BufferRead+0x422>
		while (NumByteToRead) {
 8011cc0:	883b      	ldrh	r3, [r7, #0]
 8011cc2:	2b00      	cmp	r3, #0
 8011cc4:	d1d4      	bne.n	8011c70 <I2C_EE_BufferRead+0x19c>
		}

		/* Enable Acknowledgement to be ready for another reception */
		I2C_AcknowledgeConfig(I2C1, ENABLE);
 8011cc6:	2101      	movs	r1, #1
 8011cc8:	4817      	ldr	r0, [pc, #92]	; (8011d28 <I2C_EE_BufferRead+0x254>)
 8011cca:	4b24      	ldr	r3, [pc, #144]	; (8011d5c <I2C_EE_BufferRead+0x288>)
 8011ccc:	4798      	blx	r3
		return true;
 8011cce:	2301      	movs	r3, #1
 8011cd0:	e111      	b.n	8011ef6 <I2C_EE_BufferRead+0x422>
	} else {
		int counter = RETRY_NUMBER;
 8011cd2:	f640 33b8 	movw	r3, #3000	; 0xbb8
 8011cd6:	613b      	str	r3, [r7, #16]
		/* While the bus is busy */

		while (I2C_GetFlagStatus(I2C1, I2C_FLAG_BUSY)) {
 8011cd8:	e008      	b.n	8011cec <I2C_EE_BufferRead+0x218>
			if (counter-- <= 0)
 8011cda:	693b      	ldr	r3, [r7, #16]
 8011cdc:	1e5a      	subs	r2, r3, #1
 8011cde:	613a      	str	r2, [r7, #16]
 8011ce0:	2b00      	cmp	r3, #0
 8011ce2:	dc03      	bgt.n	8011cec <I2C_EE_BufferRead+0x218>
				return I2C_EE_Relaunch();
 8011ce4:	4b0f      	ldr	r3, [pc, #60]	; (8011d24 <I2C_EE_BufferRead+0x250>)
 8011ce6:	4798      	blx	r3
 8011ce8:	4603      	mov	r3, r0
 8011cea:	e104      	b.n	8011ef6 <I2C_EE_BufferRead+0x422>
		while (I2C_GetFlagStatus(I2C1, I2C_FLAG_BUSY)) {
 8011cec:	f44f 3100 	mov.w	r1, #131072	; 0x20000
 8011cf0:	480d      	ldr	r0, [pc, #52]	; (8011d28 <I2C_EE_BufferRead+0x254>)
 8011cf2:	4b0e      	ldr	r3, [pc, #56]	; (8011d2c <I2C_EE_BufferRead+0x258>)
 8011cf4:	4798      	blx	r3
 8011cf6:	4603      	mov	r3, r0
 8011cf8:	2b00      	cmp	r3, #0
 8011cfa:	d1ee      	bne.n	8011cda <I2C_EE_BufferRead+0x206>
		}

		/* Send START condition */
		I2C_GenerateSTART(I2C1, ENABLE);
 8011cfc:	2101      	movs	r1, #1
 8011cfe:	480a      	ldr	r0, [pc, #40]	; (8011d28 <I2C_EE_BufferRead+0x254>)
 8011d00:	4b0b      	ldr	r3, [pc, #44]	; (8011d30 <I2C_EE_BufferRead+0x25c>)
 8011d02:	4798      	blx	r3

		/* Test on EV5 and clear it */
		counter = RETRY_NUMBER;
 8011d04:	f640 33b8 	movw	r3, #3000	; 0xbb8
 8011d08:	613b      	str	r3, [r7, #16]
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT)) {
 8011d0a:	e02f      	b.n	8011d6c <I2C_EE_BufferRead+0x298>
			if (counter-- <= 0)
 8011d0c:	693b      	ldr	r3, [r7, #16]
 8011d0e:	1e5a      	subs	r2, r3, #1
 8011d10:	613a      	str	r2, [r7, #16]
 8011d12:	2b00      	cmp	r3, #0
 8011d14:	dc2a      	bgt.n	8011d6c <I2C_EE_BufferRead+0x298>
				return I2C_EE_Relaunch();
 8011d16:	4b03      	ldr	r3, [pc, #12]	; (8011d24 <I2C_EE_BufferRead+0x250>)
 8011d18:	4798      	blx	r3
 8011d1a:	4603      	mov	r3, r0
 8011d1c:	e0eb      	b.n	8011ef6 <I2C_EE_BufferRead+0x422>
 8011d1e:	bf00      	nop
 8011d20:	20007194 	.word	0x20007194
 8011d24:	080120b1 	.word	0x080120b1
 8011d28:	40005400 	.word	0x40005400
 8011d2c:	0800401d 	.word	0x0800401d
 8011d30:	08003de3 	.word	0x08003de3
 8011d34:	00030001 	.word	0x00030001
 8011d38:	08003fc3 	.word	0x08003fc3
 8011d3c:	2000958c 	.word	0x2000958c
 8011d40:	08003f1b 	.word	0x08003f1b
 8011d44:	10000002 	.word	0x10000002
 8011d48:	08003f55 	.word	0x08003f55
 8011d4c:	08003da5 	.word	0x08003da5
 8011d50:	08003ee3 	.word	0x08003ee3
 8011d54:	00070084 	.word	0x00070084
 8011d58:	00030002 	.word	0x00030002
 8011d5c:	08003e5f 	.word	0x08003e5f
 8011d60:	08003e21 	.word	0x08003e21
 8011d64:	00030040 	.word	0x00030040
 8011d68:	08003f01 	.word	0x08003f01
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT)) {
 8011d6c:	4964      	ldr	r1, [pc, #400]	; (8011f00 <I2C_EE_BufferRead+0x42c>)
 8011d6e:	4865      	ldr	r0, [pc, #404]	; (8011f04 <I2C_EE_BufferRead+0x430>)
 8011d70:	4b65      	ldr	r3, [pc, #404]	; (8011f08 <I2C_EE_BufferRead+0x434>)
 8011d72:	4798      	blx	r3
 8011d74:	4603      	mov	r3, r0
 8011d76:	2b00      	cmp	r3, #0
 8011d78:	d0c8      	beq.n	8011d0c <I2C_EE_BufferRead+0x238>
		}

		/* Send EEPROM address for write */
		I2C_Send7bitAddress(I2C1, EEPROM_ADDRESS, I2C_Direction_Transmitter);
 8011d7a:	4b64      	ldr	r3, [pc, #400]	; (8011f0c <I2C_EE_BufferRead+0x438>)
 8011d7c:	881b      	ldrh	r3, [r3, #0]
 8011d7e:	b2db      	uxtb	r3, r3
 8011d80:	2200      	movs	r2, #0
 8011d82:	4619      	mov	r1, r3
 8011d84:	485f      	ldr	r0, [pc, #380]	; (8011f04 <I2C_EE_BufferRead+0x430>)
 8011d86:	4b62      	ldr	r3, [pc, #392]	; (8011f10 <I2C_EE_BufferRead+0x43c>)
 8011d88:	4798      	blx	r3

		/* Test on EV6 and clear it */
		counter = RETRY_NUMBER;
 8011d8a:	f640 33b8 	movw	r3, #3000	; 0xbb8
 8011d8e:	613b      	str	r3, [r7, #16]
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED)) {
 8011d90:	e008      	b.n	8011da4 <I2C_EE_BufferRead+0x2d0>
			if (counter-- <= 0)
 8011d92:	693b      	ldr	r3, [r7, #16]
 8011d94:	1e5a      	subs	r2, r3, #1
 8011d96:	613a      	str	r2, [r7, #16]
 8011d98:	2b00      	cmp	r3, #0
 8011d9a:	dc03      	bgt.n	8011da4 <I2C_EE_BufferRead+0x2d0>
				return I2C_EE_Relaunch();
 8011d9c:	4b5d      	ldr	r3, [pc, #372]	; (8011f14 <I2C_EE_BufferRead+0x440>)
 8011d9e:	4798      	blx	r3
 8011da0:	4603      	mov	r3, r0
 8011da2:	e0a8      	b.n	8011ef6 <I2C_EE_BufferRead+0x422>
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED)) {
 8011da4:	495c      	ldr	r1, [pc, #368]	; (8011f18 <I2C_EE_BufferRead+0x444>)
 8011da6:	4857      	ldr	r0, [pc, #348]	; (8011f04 <I2C_EE_BufferRead+0x430>)
 8011da8:	4b57      	ldr	r3, [pc, #348]	; (8011f08 <I2C_EE_BufferRead+0x434>)
 8011daa:	4798      	blx	r3
 8011dac:	4603      	mov	r3, r0
 8011dae:	2b00      	cmp	r3, #0
 8011db0:	d0ef      	beq.n	8011d92 <I2C_EE_BufferRead+0x2be>
		}

		/* Clear EV6 by setting again the PE bit */
		I2C_Cmd(I2C1, ENABLE);
 8011db2:	2101      	movs	r1, #1
 8011db4:	4853      	ldr	r0, [pc, #332]	; (8011f04 <I2C_EE_BufferRead+0x430>)
 8011db6:	4b59      	ldr	r3, [pc, #356]	; (8011f1c <I2C_EE_BufferRead+0x448>)
 8011db8:	4798      	blx	r3

		/* Send the EEPROM's internal address to write to */
		I2C_SendData(I2C1, (ReadAddr >> 8) & 0xFF);
 8011dba:	887b      	ldrh	r3, [r7, #2]
 8011dbc:	0a1b      	lsrs	r3, r3, #8
 8011dbe:	b29b      	uxth	r3, r3
 8011dc0:	b2db      	uxtb	r3, r3
 8011dc2:	4619      	mov	r1, r3
 8011dc4:	484f      	ldr	r0, [pc, #316]	; (8011f04 <I2C_EE_BufferRead+0x430>)
 8011dc6:	4b56      	ldr	r3, [pc, #344]	; (8011f20 <I2C_EE_BufferRead+0x44c>)
 8011dc8:	4798      	blx	r3
		counter = RETRY_NUMBER;
 8011dca:	f640 33b8 	movw	r3, #3000	; 0xbb8
 8011dce:	613b      	str	r3, [r7, #16]
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED)) {
 8011dd0:	e008      	b.n	8011de4 <I2C_EE_BufferRead+0x310>
			if (counter-- <= 0)
 8011dd2:	693b      	ldr	r3, [r7, #16]
 8011dd4:	1e5a      	subs	r2, r3, #1
 8011dd6:	613a      	str	r2, [r7, #16]
 8011dd8:	2b00      	cmp	r3, #0
 8011dda:	dc03      	bgt.n	8011de4 <I2C_EE_BufferRead+0x310>
				return I2C_EE_Relaunch();
 8011ddc:	4b4d      	ldr	r3, [pc, #308]	; (8011f14 <I2C_EE_BufferRead+0x440>)
 8011dde:	4798      	blx	r3
 8011de0:	4603      	mov	r3, r0
 8011de2:	e088      	b.n	8011ef6 <I2C_EE_BufferRead+0x422>
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED)) {
 8011de4:	494f      	ldr	r1, [pc, #316]	; (8011f24 <I2C_EE_BufferRead+0x450>)
 8011de6:	4847      	ldr	r0, [pc, #284]	; (8011f04 <I2C_EE_BufferRead+0x430>)
 8011de8:	4b47      	ldr	r3, [pc, #284]	; (8011f08 <I2C_EE_BufferRead+0x434>)
 8011dea:	4798      	blx	r3
 8011dec:	4603      	mov	r3, r0
 8011dee:	2b00      	cmp	r3, #0
 8011df0:	d0ef      	beq.n	8011dd2 <I2C_EE_BufferRead+0x2fe>
		}

		I2C_SendData(I2C1, ReadAddr & 0xFF);
 8011df2:	887b      	ldrh	r3, [r7, #2]
 8011df4:	b2db      	uxtb	r3, r3
 8011df6:	4619      	mov	r1, r3
 8011df8:	4842      	ldr	r0, [pc, #264]	; (8011f04 <I2C_EE_BufferRead+0x430>)
 8011dfa:	4b49      	ldr	r3, [pc, #292]	; (8011f20 <I2C_EE_BufferRead+0x44c>)
 8011dfc:	4798      	blx	r3

		/* Test on EV8 and clear it */
		counter = RETRY_NUMBER;
 8011dfe:	f640 33b8 	movw	r3, #3000	; 0xbb8
 8011e02:	613b      	str	r3, [r7, #16]
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED)) {
 8011e04:	e008      	b.n	8011e18 <I2C_EE_BufferRead+0x344>
			if (counter-- <= 0)
 8011e06:	693b      	ldr	r3, [r7, #16]
 8011e08:	1e5a      	subs	r2, r3, #1
 8011e0a:	613a      	str	r2, [r7, #16]
 8011e0c:	2b00      	cmp	r3, #0
 8011e0e:	dc03      	bgt.n	8011e18 <I2C_EE_BufferRead+0x344>
				return I2C_EE_Relaunch();
 8011e10:	4b40      	ldr	r3, [pc, #256]	; (8011f14 <I2C_EE_BufferRead+0x440>)
 8011e12:	4798      	blx	r3
 8011e14:	4603      	mov	r3, r0
 8011e16:	e06e      	b.n	8011ef6 <I2C_EE_BufferRead+0x422>
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_TRANSMITTED)) {
 8011e18:	4942      	ldr	r1, [pc, #264]	; (8011f24 <I2C_EE_BufferRead+0x450>)
 8011e1a:	483a      	ldr	r0, [pc, #232]	; (8011f04 <I2C_EE_BufferRead+0x430>)
 8011e1c:	4b3a      	ldr	r3, [pc, #232]	; (8011f08 <I2C_EE_BufferRead+0x434>)
 8011e1e:	4798      	blx	r3
 8011e20:	4603      	mov	r3, r0
 8011e22:	2b00      	cmp	r3, #0
 8011e24:	d0ef      	beq.n	8011e06 <I2C_EE_BufferRead+0x332>
		}

		/* Send STRAT condition a second time */
		I2C_GenerateSTART(I2C1, ENABLE);
 8011e26:	2101      	movs	r1, #1
 8011e28:	4836      	ldr	r0, [pc, #216]	; (8011f04 <I2C_EE_BufferRead+0x430>)
 8011e2a:	4b3f      	ldr	r3, [pc, #252]	; (8011f28 <I2C_EE_BufferRead+0x454>)
 8011e2c:	4798      	blx	r3

		/* Test on EV5 and clear it */
		counter = RETRY_NUMBER;
 8011e2e:	f640 33b8 	movw	r3, #3000	; 0xbb8
 8011e32:	613b      	str	r3, [r7, #16]
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT)) {
 8011e34:	e008      	b.n	8011e48 <I2C_EE_BufferRead+0x374>
			if (counter-- <= 0)
 8011e36:	693b      	ldr	r3, [r7, #16]
 8011e38:	1e5a      	subs	r2, r3, #1
 8011e3a:	613a      	str	r2, [r7, #16]
 8011e3c:	2b00      	cmp	r3, #0
 8011e3e:	dc03      	bgt.n	8011e48 <I2C_EE_BufferRead+0x374>
				return I2C_EE_Relaunch();
 8011e40:	4b34      	ldr	r3, [pc, #208]	; (8011f14 <I2C_EE_BufferRead+0x440>)
 8011e42:	4798      	blx	r3
 8011e44:	4603      	mov	r3, r0
 8011e46:	e056      	b.n	8011ef6 <I2C_EE_BufferRead+0x422>
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT)) {
 8011e48:	492d      	ldr	r1, [pc, #180]	; (8011f00 <I2C_EE_BufferRead+0x42c>)
 8011e4a:	482e      	ldr	r0, [pc, #184]	; (8011f04 <I2C_EE_BufferRead+0x430>)
 8011e4c:	4b2e      	ldr	r3, [pc, #184]	; (8011f08 <I2C_EE_BufferRead+0x434>)
 8011e4e:	4798      	blx	r3
 8011e50:	4603      	mov	r3, r0
 8011e52:	2b00      	cmp	r3, #0
 8011e54:	d0ef      	beq.n	8011e36 <I2C_EE_BufferRead+0x362>
		}

		/* Send EEPROM address for read */
		I2C_Send7bitAddress(I2C1, EEPROM_ADDRESS, I2C_Direction_Receiver);
 8011e56:	4b2d      	ldr	r3, [pc, #180]	; (8011f0c <I2C_EE_BufferRead+0x438>)
 8011e58:	881b      	ldrh	r3, [r3, #0]
 8011e5a:	b2db      	uxtb	r3, r3
 8011e5c:	2201      	movs	r2, #1
 8011e5e:	4619      	mov	r1, r3
 8011e60:	4828      	ldr	r0, [pc, #160]	; (8011f04 <I2C_EE_BufferRead+0x430>)
 8011e62:	4b2b      	ldr	r3, [pc, #172]	; (8011f10 <I2C_EE_BufferRead+0x43c>)
 8011e64:	4798      	blx	r3

		/* Test on EV6 and clear it */
		counter = RETRY_NUMBER;
 8011e66:	f640 33b8 	movw	r3, #3000	; 0xbb8
 8011e6a:	613b      	str	r3, [r7, #16]
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED)) {
 8011e6c:	e008      	b.n	8011e80 <I2C_EE_BufferRead+0x3ac>
			if (counter-- <= 0)
 8011e6e:	693b      	ldr	r3, [r7, #16]
 8011e70:	1e5a      	subs	r2, r3, #1
 8011e72:	613a      	str	r2, [r7, #16]
 8011e74:	2b00      	cmp	r3, #0
 8011e76:	dc03      	bgt.n	8011e80 <I2C_EE_BufferRead+0x3ac>
				return I2C_EE_Relaunch();
 8011e78:	4b26      	ldr	r3, [pc, #152]	; (8011f14 <I2C_EE_BufferRead+0x440>)
 8011e7a:	4798      	blx	r3
 8011e7c:	4603      	mov	r3, r0
 8011e7e:	e03a      	b.n	8011ef6 <I2C_EE_BufferRead+0x422>
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED)) {
 8011e80:	492a      	ldr	r1, [pc, #168]	; (8011f2c <I2C_EE_BufferRead+0x458>)
 8011e82:	4820      	ldr	r0, [pc, #128]	; (8011f04 <I2C_EE_BufferRead+0x430>)
 8011e84:	4b20      	ldr	r3, [pc, #128]	; (8011f08 <I2C_EE_BufferRead+0x434>)
 8011e86:	4798      	blx	r3
 8011e88:	4603      	mov	r3, r0
 8011e8a:	2b00      	cmp	r3, #0
 8011e8c:	d0ef      	beq.n	8011e6e <I2C_EE_BufferRead+0x39a>
		}

		/* While there is data to be read */
		counter = RETRY_NUMBER;
 8011e8e:	f640 33b8 	movw	r3, #3000	; 0xbb8
 8011e92:	613b      	str	r3, [r7, #16]

		while (NumByteToRead) {
 8011e94:	e027      	b.n	8011ee6 <I2C_EE_BufferRead+0x412>
			if (NumByteToRead == 1) {
 8011e96:	883b      	ldrh	r3, [r7, #0]
 8011e98:	2b01      	cmp	r3, #1
 8011e9a:	d107      	bne.n	8011eac <I2C_EE_BufferRead+0x3d8>
				/* Disable Acknowledgement */
				I2C_AcknowledgeConfig(I2C1, DISABLE);
 8011e9c:	2100      	movs	r1, #0
 8011e9e:	4819      	ldr	r0, [pc, #100]	; (8011f04 <I2C_EE_BufferRead+0x430>)
 8011ea0:	4b23      	ldr	r3, [pc, #140]	; (8011f30 <I2C_EE_BufferRead+0x45c>)
 8011ea2:	4798      	blx	r3

				/* Send STOP Condition */
				I2C_GenerateSTOP(I2C1, ENABLE);
 8011ea4:	2101      	movs	r1, #1
 8011ea6:	4817      	ldr	r0, [pc, #92]	; (8011f04 <I2C_EE_BufferRead+0x430>)
 8011ea8:	4b22      	ldr	r3, [pc, #136]	; (8011f34 <I2C_EE_BufferRead+0x460>)
 8011eaa:	4798      	blx	r3
			}

			/* Test on EV7 and clear it */
			if (I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_BYTE_RECEIVED)) {
 8011eac:	4922      	ldr	r1, [pc, #136]	; (8011f38 <I2C_EE_BufferRead+0x464>)
 8011eae:	4815      	ldr	r0, [pc, #84]	; (8011f04 <I2C_EE_BufferRead+0x430>)
 8011eb0:	4b15      	ldr	r3, [pc, #84]	; (8011f08 <I2C_EE_BufferRead+0x434>)
 8011eb2:	4798      	blx	r3
 8011eb4:	4603      	mov	r3, r0
 8011eb6:	2b00      	cmp	r3, #0
 8011eb8:	d00c      	beq.n	8011ed4 <I2C_EE_BufferRead+0x400>
				/* Read a byte from the EEPROM */
				*pBuffer = I2C_ReceiveData(I2C1);
 8011eba:	4812      	ldr	r0, [pc, #72]	; (8011f04 <I2C_EE_BufferRead+0x430>)
 8011ebc:	4b1f      	ldr	r3, [pc, #124]	; (8011f3c <I2C_EE_BufferRead+0x468>)
 8011ebe:	4798      	blx	r3
 8011ec0:	4603      	mov	r3, r0
 8011ec2:	461a      	mov	r2, r3
 8011ec4:	687b      	ldr	r3, [r7, #4]
 8011ec6:	701a      	strb	r2, [r3, #0]

				/* Point to the next location where the byte read will be saved */
				pBuffer++;
 8011ec8:	687b      	ldr	r3, [r7, #4]
 8011eca:	3301      	adds	r3, #1
 8011ecc:	607b      	str	r3, [r7, #4]

				/* Decrement the read bytes counter */
				NumByteToRead--;
 8011ece:	883b      	ldrh	r3, [r7, #0]
 8011ed0:	3b01      	subs	r3, #1
 8011ed2:	803b      	strh	r3, [r7, #0]

			}

			if (counter-- <= 0)
 8011ed4:	693b      	ldr	r3, [r7, #16]
 8011ed6:	1e5a      	subs	r2, r3, #1
 8011ed8:	613a      	str	r2, [r7, #16]
 8011eda:	2b00      	cmp	r3, #0
 8011edc:	dc03      	bgt.n	8011ee6 <I2C_EE_BufferRead+0x412>
				return I2C_EE_Relaunch();
 8011ede:	4b0d      	ldr	r3, [pc, #52]	; (8011f14 <I2C_EE_BufferRead+0x440>)
 8011ee0:	4798      	blx	r3
 8011ee2:	4603      	mov	r3, r0
 8011ee4:	e007      	b.n	8011ef6 <I2C_EE_BufferRead+0x422>
		while (NumByteToRead) {
 8011ee6:	883b      	ldrh	r3, [r7, #0]
 8011ee8:	2b00      	cmp	r3, #0
 8011eea:	d1d4      	bne.n	8011e96 <I2C_EE_BufferRead+0x3c2>
		}

		/* Enable Acknowledgement to be ready for another reception */
		I2C_AcknowledgeConfig(I2C1, ENABLE);
 8011eec:	2101      	movs	r1, #1
 8011eee:	4805      	ldr	r0, [pc, #20]	; (8011f04 <I2C_EE_BufferRead+0x430>)
 8011ef0:	4b0f      	ldr	r3, [pc, #60]	; (8011f30 <I2C_EE_BufferRead+0x45c>)
 8011ef2:	4798      	blx	r3
		return true;
 8011ef4:	2301      	movs	r3, #1

	}

}
 8011ef6:	4618      	mov	r0, r3
 8011ef8:	3718      	adds	r7, #24
 8011efa:	46bd      	mov	sp, r7
 8011efc:	bd80      	pop	{r7, pc}
 8011efe:	bf00      	nop
 8011f00:	00030001 	.word	0x00030001
 8011f04:	40005400 	.word	0x40005400
 8011f08:	08003fc3 	.word	0x08003fc3
 8011f0c:	2000958c 	.word	0x2000958c
 8011f10:	08003f1b 	.word	0x08003f1b
 8011f14:	080120b1 	.word	0x080120b1
 8011f18:	00070082 	.word	0x00070082
 8011f1c:	08003da5 	.word	0x08003da5
 8011f20:	08003ee3 	.word	0x08003ee3
 8011f24:	00070084 	.word	0x00070084
 8011f28:	08003de3 	.word	0x08003de3
 8011f2c:	00030002 	.word	0x00030002
 8011f30:	08003e5f 	.word	0x08003e5f
 8011f34:	08003e21 	.word	0x08003e21
 8011f38:	00030040 	.word	0x00030040
 8011f3c:	08003f01 	.word	0x08003f01

08011f40 <I2C_EE_WaitEepromStandbyState>:
 * Description    : Wait for EEPROM Standby state
 * Input          : None
 * Output         : None
 * Return         : None
 *******************************************************************************/
bool I2C_EE_WaitEepromStandbyState(void) {
 8011f40:	b580      	push	{r7, lr}
 8011f42:	b084      	sub	sp, #16
 8011f44:	af00      	add	r7, sp, #0

	if (initMK == 1) {
 8011f46:	4b4b      	ldr	r3, [pc, #300]	; (8012074 <I2C_EE_WaitEepromStandbyState+0x134>)
 8011f48:	681b      	ldr	r3, [r3, #0]
 8011f4a:	2b01      	cmp	r3, #1
 8011f4c:	d15b      	bne.n	8012006 <I2C_EE_WaitEepromStandbyState+0xc6>
		vu16 SR1_Tmp = 0;
 8011f4e:	2300      	movs	r3, #0
 8011f50:	80fb      	strh	r3, [r7, #6]
		int counter = RETRY_NUMBER;
 8011f52:	f640 33b8 	movw	r3, #3000	; 0xbb8
 8011f56:	60fb      	str	r3, [r7, #12]
		//SR1_Tmp = I2C_ReadRegister(I2C1, I2C_Register_SR1);
		/* Send EEPROM address for write */
		// I2C_Send7bitAddress(I2C1, EEPROM_ADDRESS, I2C_Direction_Transmitter);
		// if(counter-- <= 0) return I2C_EE_Relaunch();
		//}while(!(I2C_ReadRegister(I2C1, I2C_Register_SR1) & 0x0002));
		while (I2C_GetFlagStatus(I2C1, I2C_FLAG_BUSY)) {
 8011f58:	e008      	b.n	8011f6c <I2C_EE_WaitEepromStandbyState+0x2c>
			if (counter-- <= 0)
 8011f5a:	68fb      	ldr	r3, [r7, #12]
 8011f5c:	1e5a      	subs	r2, r3, #1
 8011f5e:	60fa      	str	r2, [r7, #12]
 8011f60:	2b00      	cmp	r3, #0
 8011f62:	dc03      	bgt.n	8011f6c <I2C_EE_WaitEepromStandbyState+0x2c>
				return I2C_EE_Relaunch();
 8011f64:	4b44      	ldr	r3, [pc, #272]	; (8012078 <I2C_EE_WaitEepromStandbyState+0x138>)
 8011f66:	4798      	blx	r3
 8011f68:	4603      	mov	r3, r0
 8011f6a:	e07e      	b.n	801206a <I2C_EE_WaitEepromStandbyState+0x12a>
		while (I2C_GetFlagStatus(I2C1, I2C_FLAG_BUSY)) {
 8011f6c:	f44f 3100 	mov.w	r1, #131072	; 0x20000
 8011f70:	4842      	ldr	r0, [pc, #264]	; (801207c <I2C_EE_WaitEepromStandbyState+0x13c>)
 8011f72:	4b43      	ldr	r3, [pc, #268]	; (8012080 <I2C_EE_WaitEepromStandbyState+0x140>)
 8011f74:	4798      	blx	r3
 8011f76:	4603      	mov	r3, r0
 8011f78:	2b00      	cmp	r3, #0
 8011f7a:	d1ee      	bne.n	8011f5a <I2C_EE_WaitEepromStandbyState+0x1a>
		}
		/* Send START condition*/
		I2C_GenerateSTART(I2C1, ENABLE);
 8011f7c:	2101      	movs	r1, #1
 8011f7e:	483f      	ldr	r0, [pc, #252]	; (801207c <I2C_EE_WaitEepromStandbyState+0x13c>)
 8011f80:	4b40      	ldr	r3, [pc, #256]	; (8012084 <I2C_EE_WaitEepromStandbyState+0x144>)
 8011f82:	4798      	blx	r3
		/* Read I2C1 SR1 register*/
		SR1_Tmp = I2C_ReadRegister(I2C1, I2C_Register_SR1);
 8011f84:	2114      	movs	r1, #20
 8011f86:	483d      	ldr	r0, [pc, #244]	; (801207c <I2C_EE_WaitEepromStandbyState+0x13c>)
 8011f88:	4b3f      	ldr	r3, [pc, #252]	; (8012088 <I2C_EE_WaitEepromStandbyState+0x148>)
 8011f8a:	4798      	blx	r3
 8011f8c:	4603      	mov	r3, r0
 8011f8e:	80fb      	strh	r3, [r7, #6]

		I2C_ClearFlag(I2C1, I2C_FLAG_ADDR);
 8011f90:	493e      	ldr	r1, [pc, #248]	; (801208c <I2C_EE_WaitEepromStandbyState+0x14c>)
 8011f92:	483a      	ldr	r0, [pc, #232]	; (801207c <I2C_EE_WaitEepromStandbyState+0x13c>)
 8011f94:	4b3e      	ldr	r3, [pc, #248]	; (8012090 <I2C_EE_WaitEepromStandbyState+0x150>)
 8011f96:	4798      	blx	r3

		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT)) {
 8011f98:	e008      	b.n	8011fac <I2C_EE_WaitEepromStandbyState+0x6c>
			if (counter-- <= 0)
 8011f9a:	68fb      	ldr	r3, [r7, #12]
 8011f9c:	1e5a      	subs	r2, r3, #1
 8011f9e:	60fa      	str	r2, [r7, #12]
 8011fa0:	2b00      	cmp	r3, #0
 8011fa2:	dc03      	bgt.n	8011fac <I2C_EE_WaitEepromStandbyState+0x6c>
				return I2C_EE_Relaunch();
 8011fa4:	4b34      	ldr	r3, [pc, #208]	; (8012078 <I2C_EE_WaitEepromStandbyState+0x138>)
 8011fa6:	4798      	blx	r3
 8011fa8:	4603      	mov	r3, r0
 8011faa:	e05e      	b.n	801206a <I2C_EE_WaitEepromStandbyState+0x12a>
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT)) {
 8011fac:	4939      	ldr	r1, [pc, #228]	; (8012094 <I2C_EE_WaitEepromStandbyState+0x154>)
 8011fae:	4833      	ldr	r0, [pc, #204]	; (801207c <I2C_EE_WaitEepromStandbyState+0x13c>)
 8011fb0:	4b39      	ldr	r3, [pc, #228]	; (8012098 <I2C_EE_WaitEepromStandbyState+0x158>)
 8011fb2:	4798      	blx	r3
 8011fb4:	4603      	mov	r3, r0
 8011fb6:	2b00      	cmp	r3, #0
 8011fb8:	d0ef      	beq.n	8011f9a <I2C_EE_WaitEepromStandbyState+0x5a>
		}
		/* Send EEPROM address for write*/
		I2C_Send7bitAddress(I2C1, EEPROM_ADDRESS, I2C_Direction_Transmitter);
 8011fba:	4b38      	ldr	r3, [pc, #224]	; (801209c <I2C_EE_WaitEepromStandbyState+0x15c>)
 8011fbc:	881b      	ldrh	r3, [r3, #0]
 8011fbe:	b2db      	uxtb	r3, r3
 8011fc0:	2200      	movs	r2, #0
 8011fc2:	4619      	mov	r1, r3
 8011fc4:	482d      	ldr	r0, [pc, #180]	; (801207c <I2C_EE_WaitEepromStandbyState+0x13c>)
 8011fc6:	4b36      	ldr	r3, [pc, #216]	; (80120a0 <I2C_EE_WaitEepromStandbyState+0x160>)
 8011fc8:	4798      	blx	r3
		/*{
		 int i = 0xfff;
		 while(i --);
		 }*/
		counter = RETRY_NUMBER;
 8011fca:	f640 33b8 	movw	r3, #3000	; 0xbb8
 8011fce:	60fb      	str	r3, [r7, #12]

		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED)) {
 8011fd0:	e008      	b.n	8011fe4 <I2C_EE_WaitEepromStandbyState+0xa4>
			if (counter-- <= 0)
 8011fd2:	68fb      	ldr	r3, [r7, #12]
 8011fd4:	1e5a      	subs	r2, r3, #1
 8011fd6:	60fa      	str	r2, [r7, #12]
 8011fd8:	2b00      	cmp	r3, #0
 8011fda:	dc03      	bgt.n	8011fe4 <I2C_EE_WaitEepromStandbyState+0xa4>
				return I2C_EE_Relaunch();
 8011fdc:	4b26      	ldr	r3, [pc, #152]	; (8012078 <I2C_EE_WaitEepromStandbyState+0x138>)
 8011fde:	4798      	blx	r3
 8011fe0:	4603      	mov	r3, r0
 8011fe2:	e042      	b.n	801206a <I2C_EE_WaitEepromStandbyState+0x12a>
		while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED)) {
 8011fe4:	492f      	ldr	r1, [pc, #188]	; (80120a4 <I2C_EE_WaitEepromStandbyState+0x164>)
 8011fe6:	4825      	ldr	r0, [pc, #148]	; (801207c <I2C_EE_WaitEepromStandbyState+0x13c>)
 8011fe8:	4b2b      	ldr	r3, [pc, #172]	; (8012098 <I2C_EE_WaitEepromStandbyState+0x158>)
 8011fea:	4798      	blx	r3
 8011fec:	4603      	mov	r3, r0
 8011fee:	2b00      	cmp	r3, #0
 8011ff0:	d0ef      	beq.n	8011fd2 <I2C_EE_WaitEepromStandbyState+0x92>
		}

		/* Clear AF flag */
		I2C_ClearFlag(I2C1, I2C_FLAG_AF);
 8011ff2:	492d      	ldr	r1, [pc, #180]	; (80120a8 <I2C_EE_WaitEepromStandbyState+0x168>)
 8011ff4:	4821      	ldr	r0, [pc, #132]	; (801207c <I2C_EE_WaitEepromStandbyState+0x13c>)
 8011ff6:	4b26      	ldr	r3, [pc, #152]	; (8012090 <I2C_EE_WaitEepromStandbyState+0x150>)
 8011ff8:	4798      	blx	r3

		/* STOP condition */
		I2C_GenerateSTOP(I2C1, ENABLE);
 8011ffa:	2101      	movs	r1, #1
 8011ffc:	481f      	ldr	r0, [pc, #124]	; (801207c <I2C_EE_WaitEepromStandbyState+0x13c>)
 8011ffe:	4b2b      	ldr	r3, [pc, #172]	; (80120ac <I2C_EE_WaitEepromStandbyState+0x16c>)
 8012000:	4798      	blx	r3
		return true;
 8012002:	2301      	movs	r3, #1
 8012004:	e031      	b.n	801206a <I2C_EE_WaitEepromStandbyState+0x12a>
	} else {
		vu16 SR1_Tmp = 0;
 8012006:	2300      	movs	r3, #0
 8012008:	80bb      	strh	r3, [r7, #4]
		int counter = RETRY_NUMBER;
 801200a:	f640 33b8 	movw	r3, #3000	; 0xbb8
 801200e:	60bb      	str	r3, [r7, #8]
		do {
			/* Send START condition */
			I2C_GenerateSTART(I2C1, ENABLE);
 8012010:	2101      	movs	r1, #1
 8012012:	481a      	ldr	r0, [pc, #104]	; (801207c <I2C_EE_WaitEepromStandbyState+0x13c>)
 8012014:	4b1b      	ldr	r3, [pc, #108]	; (8012084 <I2C_EE_WaitEepromStandbyState+0x144>)
 8012016:	4798      	blx	r3
			/* Read I2C1 SR1 register */
			SR1_Tmp = I2C_ReadRegister(I2C1, I2C_Register_SR1);
 8012018:	2114      	movs	r1, #20
 801201a:	4818      	ldr	r0, [pc, #96]	; (801207c <I2C_EE_WaitEepromStandbyState+0x13c>)
 801201c:	4b1a      	ldr	r3, [pc, #104]	; (8012088 <I2C_EE_WaitEepromStandbyState+0x148>)
 801201e:	4798      	blx	r3
 8012020:	4603      	mov	r3, r0
 8012022:	80bb      	strh	r3, [r7, #4]
			/* Send EEPROM address for write */
			I2C_Send7bitAddress(I2C1, EEPROM_ADDRESS,
 8012024:	4b1d      	ldr	r3, [pc, #116]	; (801209c <I2C_EE_WaitEepromStandbyState+0x15c>)
 8012026:	881b      	ldrh	r3, [r3, #0]
 8012028:	b2db      	uxtb	r3, r3
 801202a:	2200      	movs	r2, #0
 801202c:	4619      	mov	r1, r3
 801202e:	4813      	ldr	r0, [pc, #76]	; (801207c <I2C_EE_WaitEepromStandbyState+0x13c>)
 8012030:	4b1b      	ldr	r3, [pc, #108]	; (80120a0 <I2C_EE_WaitEepromStandbyState+0x160>)
 8012032:	4798      	blx	r3
					I2C_Direction_Transmitter);
			if (counter-- <= 0)
 8012034:	68bb      	ldr	r3, [r7, #8]
 8012036:	1e5a      	subs	r2, r3, #1
 8012038:	60ba      	str	r2, [r7, #8]
 801203a:	2b00      	cmp	r3, #0
 801203c:	dc03      	bgt.n	8012046 <I2C_EE_WaitEepromStandbyState+0x106>
				return I2C_EE_Relaunch();
 801203e:	4b0e      	ldr	r3, [pc, #56]	; (8012078 <I2C_EE_WaitEepromStandbyState+0x138>)
 8012040:	4798      	blx	r3
 8012042:	4603      	mov	r3, r0
 8012044:	e011      	b.n	801206a <I2C_EE_WaitEepromStandbyState+0x12a>
		} while (!(I2C_ReadRegister(I2C1, I2C_Register_SR1) & 0x0002));
 8012046:	2114      	movs	r1, #20
 8012048:	480c      	ldr	r0, [pc, #48]	; (801207c <I2C_EE_WaitEepromStandbyState+0x13c>)
 801204a:	4b0f      	ldr	r3, [pc, #60]	; (8012088 <I2C_EE_WaitEepromStandbyState+0x148>)
 801204c:	4798      	blx	r3
 801204e:	4603      	mov	r3, r0
 8012050:	f003 0302 	and.w	r3, r3, #2
 8012054:	2b00      	cmp	r3, #0
 8012056:	d0db      	beq.n	8012010 <I2C_EE_WaitEepromStandbyState+0xd0>

		/* Clear AF flag */
		I2C_ClearFlag(I2C1, I2C_FLAG_AF);
 8012058:	4913      	ldr	r1, [pc, #76]	; (80120a8 <I2C_EE_WaitEepromStandbyState+0x168>)
 801205a:	4808      	ldr	r0, [pc, #32]	; (801207c <I2C_EE_WaitEepromStandbyState+0x13c>)
 801205c:	4b0c      	ldr	r3, [pc, #48]	; (8012090 <I2C_EE_WaitEepromStandbyState+0x150>)
 801205e:	4798      	blx	r3

		/* STOP condition */
		I2C_GenerateSTOP(I2C1, ENABLE);
 8012060:	2101      	movs	r1, #1
 8012062:	4806      	ldr	r0, [pc, #24]	; (801207c <I2C_EE_WaitEepromStandbyState+0x13c>)
 8012064:	4b11      	ldr	r3, [pc, #68]	; (80120ac <I2C_EE_WaitEepromStandbyState+0x16c>)
 8012066:	4798      	blx	r3
		return true;
 8012068:	2301      	movs	r3, #1
	}

}
 801206a:	4618      	mov	r0, r3
 801206c:	3710      	adds	r7, #16
 801206e:	46bd      	mov	sp, r7
 8012070:	bd80      	pop	{r7, pc}
 8012072:	bf00      	nop
 8012074:	20007194 	.word	0x20007194
 8012078:	080120b1 	.word	0x080120b1
 801207c:	40005400 	.word	0x40005400
 8012080:	0800401d 	.word	0x0800401d
 8012084:	08003de3 	.word	0x08003de3
 8012088:	08003f55 	.word	0x08003f55
 801208c:	10000002 	.word	0x10000002
 8012090:	08004081 	.word	0x08004081
 8012094:	00030001 	.word	0x00030001
 8012098:	08003fc3 	.word	0x08003fc3
 801209c:	2000958c 	.word	0x2000958c
 80120a0:	08003f1b 	.word	0x08003f1b
 80120a4:	00070082 	.word	0x00070082
 80120a8:	10000400 	.word	0x10000400
 80120ac:	08003e21 	.word	0x08003e21

080120b0 <I2C_EE_Relaunch>:

bool I2C_EE_Relaunch(void) {
 80120b0:	b580      	push	{r7, lr}
 80120b2:	b082      	sub	sp, #8
 80120b4:	af00      	add	r7, sp, #0
	if (initMK == 1) {
 80120b6:	4b3b      	ldr	r3, [pc, #236]	; (80121a4 <I2C_EE_Relaunch+0xf4>)
 80120b8:	681b      	ldr	r3, [r3, #0]
 80120ba:	2b01      	cmp	r3, #1
 80120bc:	d110      	bne.n	80120e0 <I2C_EE_Relaunch+0x30>
		I2C_ClearFlag(I2C1, I2C_FLAG_AF);
 80120be:	493a      	ldr	r1, [pc, #232]	; (80121a8 <I2C_EE_Relaunch+0xf8>)
 80120c0:	483a      	ldr	r0, [pc, #232]	; (80121ac <I2C_EE_Relaunch+0xfc>)
 80120c2:	4b3b      	ldr	r3, [pc, #236]	; (80121b0 <I2C_EE_Relaunch+0x100>)
 80120c4:	4798      	blx	r3

		if (I2C_GetFlagStatus(I2C1, I2C_FLAG_BUSY)) {
 80120c6:	f44f 3100 	mov.w	r1, #131072	; 0x20000
 80120ca:	4838      	ldr	r0, [pc, #224]	; (80121ac <I2C_EE_Relaunch+0xfc>)
 80120cc:	4b39      	ldr	r3, [pc, #228]	; (80121b4 <I2C_EE_Relaunch+0x104>)
 80120ce:	4798      	blx	r3
 80120d0:	4603      	mov	r3, r0
 80120d2:	2b00      	cmp	r3, #0
 80120d4:	d062      	beq.n	801219c <I2C_EE_Relaunch+0xec>

			I2C_GenerateSTOP(I2C1, ENABLE);
 80120d6:	2101      	movs	r1, #1
 80120d8:	4834      	ldr	r0, [pc, #208]	; (80121ac <I2C_EE_Relaunch+0xfc>)
 80120da:	4b37      	ldr	r3, [pc, #220]	; (80121b8 <I2C_EE_Relaunch+0x108>)
 80120dc:	4798      	blx	r3
 80120de:	e05d      	b.n	801219c <I2C_EE_Relaunch+0xec>
			//vTaskDelay(100);
		}
	} else {

		I2C_Cmd(I2C1, DISABLE);
 80120e0:	2100      	movs	r1, #0
 80120e2:	4832      	ldr	r0, [pc, #200]	; (80121ac <I2C_EE_Relaunch+0xfc>)
 80120e4:	4b35      	ldr	r3, [pc, #212]	; (80121bc <I2C_EE_Relaunch+0x10c>)
 80120e6:	4798      	blx	r3
		GPIO_InitTypeDef GPIO_InitStructure;

		// reconfigure IIC pins to push pull
		GPIO_StructInit(&GPIO_InitStructure);
 80120e8:	463b      	mov	r3, r7
 80120ea:	4618      	mov	r0, r3
 80120ec:	4b34      	ldr	r3, [pc, #208]	; (80121c0 <I2C_EE_Relaunch+0x110>)
 80120ee:	4798      	blx	r3
		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 80120f0:	2303      	movs	r3, #3
 80120f2:	70bb      	strb	r3, [r7, #2]
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
 80120f4:	2310      	movs	r3, #16
 80120f6:	70fb      	strb	r3, [r7, #3]

		GPIO_InitStructure.GPIO_Pin = MIOS32_IIC0_SCL_PIN;
 80120f8:	f44f 7380 	mov.w	r3, #256	; 0x100
 80120fc:	803b      	strh	r3, [r7, #0]
		GPIO_Init(MIOS32_IIC0_SCL_PORT, &GPIO_InitStructure);
 80120fe:	463b      	mov	r3, r7
 8012100:	4619      	mov	r1, r3
 8012102:	4830      	ldr	r0, [pc, #192]	; (80121c4 <I2C_EE_Relaunch+0x114>)
 8012104:	4b30      	ldr	r3, [pc, #192]	; (80121c8 <I2C_EE_Relaunch+0x118>)
 8012106:	4798      	blx	r3
		GPIO_InitStructure.GPIO_Pin = MIOS32_IIC0_SDA_PIN;
 8012108:	f44f 7300 	mov.w	r3, #512	; 0x200
 801210c:	803b      	strh	r3, [r7, #0]
		GPIO_Init(MIOS32_IIC0_SDA_PORT, &GPIO_InitStructure);
 801210e:	463b      	mov	r3, r7
 8012110:	4619      	mov	r1, r3
 8012112:	482c      	ldr	r0, [pc, #176]	; (80121c4 <I2C_EE_Relaunch+0x114>)
 8012114:	4b2c      	ldr	r3, [pc, #176]	; (80121c8 <I2C_EE_Relaunch+0x118>)
 8012116:	4798      	blx	r3

		u32 i;
		//vTaskDelay(20);
		for (i = 0; i < 16; i++) {
 8012118:	2300      	movs	r3, #0
 801211a:	607b      	str	r3, [r7, #4]
 801211c:	e016      	b.n	801214c <I2C_EE_Relaunch+0x9c>
			/*Reset the SDA Pin*/
			GPIO_ResetBits(GPIOB, MIOS32_IIC0_SDA_PIN);
 801211e:	f44f 7100 	mov.w	r1, #512	; 0x200
 8012122:	4828      	ldr	r0, [pc, #160]	; (80121c4 <I2C_EE_Relaunch+0x114>)
 8012124:	4b29      	ldr	r3, [pc, #164]	; (80121cc <I2C_EE_Relaunch+0x11c>)
 8012126:	4798      	blx	r3
			// vTaskDelay(20);
			/*Reset the SCL Pin*/
			GPIO_ResetBits(GPIOB, MIOS32_IIC0_SCL_PIN);
 8012128:	f44f 7180 	mov.w	r1, #256	; 0x100
 801212c:	4825      	ldr	r0, [pc, #148]	; (80121c4 <I2C_EE_Relaunch+0x114>)
 801212e:	4b27      	ldr	r3, [pc, #156]	; (80121cc <I2C_EE_Relaunch+0x11c>)
 8012130:	4798      	blx	r3
			// vTaskDelay(20);
			/*Set the SCL Pin*/
			GPIO_SetBits(GPIOB, MIOS32_IIC0_SCL_PIN);
 8012132:	f44f 7180 	mov.w	r1, #256	; 0x100
 8012136:	4823      	ldr	r0, [pc, #140]	; (80121c4 <I2C_EE_Relaunch+0x114>)
 8012138:	4b25      	ldr	r3, [pc, #148]	; (80121d0 <I2C_EE_Relaunch+0x120>)
 801213a:	4798      	blx	r3
			// vTaskDelay(20);
			/*Set the SDA Pin*/
			GPIO_SetBits(GPIOB, MIOS32_IIC0_SDA_PIN);
 801213c:	f44f 7100 	mov.w	r1, #512	; 0x200
 8012140:	4820      	ldr	r0, [pc, #128]	; (80121c4 <I2C_EE_Relaunch+0x114>)
 8012142:	4b23      	ldr	r3, [pc, #140]	; (80121d0 <I2C_EE_Relaunch+0x120>)
 8012144:	4798      	blx	r3
		for (i = 0; i < 16; i++) {
 8012146:	687b      	ldr	r3, [r7, #4]
 8012148:	3301      	adds	r3, #1
 801214a:	607b      	str	r3, [r7, #4]
 801214c:	687b      	ldr	r3, [r7, #4]
 801214e:	2b0f      	cmp	r3, #15
 8012150:	d9e5      	bls.n	801211e <I2C_EE_Relaunch+0x6e>
			// vTaskDelay(20);
		}

		GPIO_StructInit(&GPIO_InitStructure);
 8012152:	463b      	mov	r3, r7
 8012154:	4618      	mov	r0, r3
 8012156:	4b1a      	ldr	r3, [pc, #104]	; (80121c0 <I2C_EE_Relaunch+0x110>)
 8012158:	4798      	blx	r3
		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz;
 801215a:	2301      	movs	r3, #1
 801215c:	70bb      	strb	r3, [r7, #2]
		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;
 801215e:	231c      	movs	r3, #28
 8012160:	70fb      	strb	r3, [r7, #3]

		GPIO_InitStructure.GPIO_Pin = MIOS32_IIC0_SCL_PIN;
 8012162:	f44f 7380 	mov.w	r3, #256	; 0x100
 8012166:	803b      	strh	r3, [r7, #0]
		GPIO_Init(MIOS32_IIC0_SCL_PORT, &GPIO_InitStructure);
 8012168:	463b      	mov	r3, r7
 801216a:	4619      	mov	r1, r3
 801216c:	4815      	ldr	r0, [pc, #84]	; (80121c4 <I2C_EE_Relaunch+0x114>)
 801216e:	4b16      	ldr	r3, [pc, #88]	; (80121c8 <I2C_EE_Relaunch+0x118>)
 8012170:	4798      	blx	r3
		GPIO_InitStructure.GPIO_Pin = MIOS32_IIC0_SDA_PIN;
 8012172:	f44f 7300 	mov.w	r3, #512	; 0x200
 8012176:	803b      	strh	r3, [r7, #0]
		GPIO_Init(MIOS32_IIC0_SDA_PORT, &GPIO_InitStructure);
 8012178:	463b      	mov	r3, r7
 801217a:	4619      	mov	r1, r3
 801217c:	4811      	ldr	r0, [pc, #68]	; (80121c4 <I2C_EE_Relaunch+0x114>)
 801217e:	4b12      	ldr	r3, [pc, #72]	; (80121c8 <I2C_EE_Relaunch+0x118>)
 8012180:	4798      	blx	r3

		I2C_Cmd(I2C1, ENABLE);
 8012182:	2101      	movs	r1, #1
 8012184:	4809      	ldr	r0, [pc, #36]	; (80121ac <I2C_EE_Relaunch+0xfc>)
 8012186:	4b0d      	ldr	r3, [pc, #52]	; (80121bc <I2C_EE_Relaunch+0x10c>)
 8012188:	4798      	blx	r3

		I2C_AcknowledgeConfig(I2C1, ENABLE);
 801218a:	2101      	movs	r1, #1
 801218c:	4807      	ldr	r0, [pc, #28]	; (80121ac <I2C_EE_Relaunch+0xfc>)
 801218e:	4b11      	ldr	r3, [pc, #68]	; (80121d4 <I2C_EE_Relaunch+0x124>)
 8012190:	4798      	blx	r3
		vTaskDelay(100);
 8012192:	2064      	movs	r0, #100	; 0x64
 8012194:	4b10      	ldr	r3, [pc, #64]	; (80121d8 <I2C_EE_Relaunch+0x128>)
 8012196:	4798      	blx	r3

		return false;
 8012198:	2300      	movs	r3, #0
 801219a:	e7ff      	b.n	801219c <I2C_EE_Relaunch+0xec>
	}

}
 801219c:	4618      	mov	r0, r3
 801219e:	3708      	adds	r7, #8
 80121a0:	46bd      	mov	sp, r7
 80121a2:	bd80      	pop	{r7, pc}
 80121a4:	20007194 	.word	0x20007194
 80121a8:	10000400 	.word	0x10000400
 80121ac:	40005400 	.word	0x40005400
 80121b0:	08004081 	.word	0x08004081
 80121b4:	0800401d 	.word	0x0800401d
 80121b8:	08003e21 	.word	0x08003e21
 80121bc:	08003da5 	.word	0x08003da5
 80121c0:	08002f15 	.word	0x08002f15
 80121c4:	40010c00 	.word	0x40010c00
 80121c8:	08002d9d 	.word	0x08002d9d
 80121cc:	08002f89 	.word	0x08002f89
 80121d0:	08002f6d 	.word	0x08002f6d
 80121d4:	08003e5f 	.word	0x08003e5f
 80121d8:	08001529 	.word	0x08001529

080121dc <EV_IRQHandler>:

/////////////////////////////////////////////////////////////////////////////
// Internal function for handling IIC event interrupts
/////////////////////////////////////////////////////////////////////////////
static void EV_IRQHandler(iic_rec_t *iicx)
{
 80121dc:	b590      	push	{r4, r7, lr}
 80121de:	b085      	sub	sp, #20
 80121e0:	af00      	add	r7, sp, #0
 80121e2:	6078      	str	r0, [r7, #4]
  u8 b;

  // Read SR1 and SR2 at the beginning (if not done so, flags may get lost)
  u32 event = I2C_GetLastEvent(iicx->base);
 80121e4:	687b      	ldr	r3, [r7, #4]
 80121e6:	681b      	ldr	r3, [r3, #0]
 80121e8:	4618      	mov	r0, r3
 80121ea:	4b90      	ldr	r3, [pc, #576]	; (801242c <EV_IRQHandler+0x250>)
 80121ec:	4798      	blx	r3
 80121ee:	60f8      	str	r0, [r7, #12]
  // RxNE set, will be cleared by reading/writing DR
  // note: also BTF will be reset after a read of SR1 (TxE flag) followed by either read/write DR
  // or a START or STOP condition generated
  // failsave: really requested a receive transfer? If not, continue to check TXE flag, if not set,
  // we'll end up in the unexpected event handler.
  if( event & I2C_FLAG_RXNE && iicx->rx_buffer_ptr != null ){
 80121f0:	68fa      	ldr	r2, [r7, #12]
 80121f2:	4b8f      	ldr	r3, [pc, #572]	; (8012430 <EV_IRQHandler+0x254>)
 80121f4:	4013      	ands	r3, r2
 80121f6:	2b00      	cmp	r3, #0
 80121f8:	d061      	beq.n	80122be <EV_IRQHandler+0xe2>
 80121fa:	687b      	ldr	r3, [r7, #4]
 80121fc:	68db      	ldr	r3, [r3, #12]
 80121fe:	2b00      	cmp	r3, #0
 8012200:	d05d      	beq.n	80122be <EV_IRQHandler+0xe2>
    // get received data
    b = I2C_ReceiveData(iicx->base);
 8012202:	687b      	ldr	r3, [r7, #4]
 8012204:	681b      	ldr	r3, [r3, #0]
 8012206:	4618      	mov	r0, r3
 8012208:	4b8a      	ldr	r3, [pc, #552]	; (8012434 <EV_IRQHandler+0x258>)
 801220a:	4798      	blx	r3
 801220c:	4603      	mov	r3, r0
 801220e:	72fb      	strb	r3, [r7, #11]

    // failsave: still place in buffer?
    if( iicx->buffer_ix < iicx->buffer_len )
 8012210:	687b      	ldr	r3, [r7, #4]
 8012212:	8a5b      	ldrh	r3, [r3, #18]
 8012214:	b29a      	uxth	r2, r3
 8012216:	687b      	ldr	r3, [r7, #4]
 8012218:	8a1b      	ldrh	r3, [r3, #16]
 801221a:	b29b      	uxth	r3, r3
 801221c:	429a      	cmp	r2, r3
 801221e:	d20b      	bcs.n	8012238 <EV_IRQHandler+0x5c>
      iicx->rx_buffer_ptr[iicx->buffer_ix++] = b;
 8012220:	687b      	ldr	r3, [r7, #4]
 8012222:	68da      	ldr	r2, [r3, #12]
 8012224:	687b      	ldr	r3, [r7, #4]
 8012226:	8a5b      	ldrh	r3, [r3, #18]
 8012228:	b29b      	uxth	r3, r3
 801222a:	1c59      	adds	r1, r3, #1
 801222c:	b288      	uxth	r0, r1
 801222e:	6879      	ldr	r1, [r7, #4]
 8012230:	8248      	strh	r0, [r1, #18]
 8012232:	4413      	add	r3, r2
 8012234:	7afa      	ldrb	r2, [r7, #11]
 8012236:	701a      	strb	r2, [r3, #0]

    // last byte received, disable interrupts and return.
    if( iicx->transfer_state.STOP_REQUESTED ) {
 8012238:	687b      	ldr	r3, [r7, #4]
 801223a:	695b      	ldr	r3, [r3, #20]
 801223c:	f3c3 0340 	ubfx	r3, r3, #1, #1
 8012240:	b2db      	uxtb	r3, r3
 8012242:	2b00      	cmp	r3, #0
 8012244:	d00d      	beq.n	8012262 <EV_IRQHandler+0x86>
      // transfer finished
      iicx->transfer_state.BUSY = 0;
 8012246:	687a      	ldr	r2, [r7, #4]
 8012248:	7d13      	ldrb	r3, [r2, #20]
 801224a:	f36f 0300 	bfc	r3, #0, #1
 801224e:	7513      	strb	r3, [r2, #20]
      // disable all interrupts
      I2C_ITConfig(iicx->base, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR, DISABLE);
 8012250:	687b      	ldr	r3, [r7, #4]
 8012252:	681b      	ldr	r3, [r3, #0]
 8012254:	2200      	movs	r2, #0
 8012256:	f44f 61e0 	mov.w	r1, #1792	; 0x700
 801225a:	4618      	mov	r0, r3
 801225c:	4b76      	ldr	r3, [pc, #472]	; (8012438 <EV_IRQHandler+0x25c>)
 801225e:	4798      	blx	r3
      return;
 8012260:	e127      	b.n	80124b2 <EV_IRQHandler+0x2d6>
    }

    // request NAK and stop condition before receiving last data
    if( (iicx->buffer_ix >= iicx->buffer_len-1) || (iicx->transfer_state.ABORT_IF_FIRST_BYTE_0 && iicx->buffer_ix == 1 && b == 0x00) ) {
 8012262:	687b      	ldr	r3, [r7, #4]
 8012264:	8a5b      	ldrh	r3, [r3, #18]
 8012266:	b29b      	uxth	r3, r3
 8012268:	461a      	mov	r2, r3
 801226a:	687b      	ldr	r3, [r7, #4]
 801226c:	8a1b      	ldrh	r3, [r3, #16]
 801226e:	b29b      	uxth	r3, r3
 8012270:	3b01      	subs	r3, #1
 8012272:	429a      	cmp	r2, r3
 8012274:	da11      	bge.n	801229a <EV_IRQHandler+0xbe>
 8012276:	687b      	ldr	r3, [r7, #4]
 8012278:	695b      	ldr	r3, [r3, #20]
 801227a:	f3c3 0380 	ubfx	r3, r3, #2, #1
 801227e:	b2db      	uxtb	r3, r3
 8012280:	2b00      	cmp	r3, #0
 8012282:	f000 8113 	beq.w	80124ac <EV_IRQHandler+0x2d0>
 8012286:	687b      	ldr	r3, [r7, #4]
 8012288:	8a5b      	ldrh	r3, [r3, #18]
 801228a:	b29b      	uxth	r3, r3
 801228c:	2b01      	cmp	r3, #1
 801228e:	f040 810d 	bne.w	80124ac <EV_IRQHandler+0x2d0>
 8012292:	7afb      	ldrb	r3, [r7, #11]
 8012294:	2b00      	cmp	r3, #0
 8012296:	f040 8109 	bne.w	80124ac <EV_IRQHandler+0x2d0>
      // request NAK
      I2C_AcknowledgeConfig(iicx->base, DISABLE);
 801229a:	687b      	ldr	r3, [r7, #4]
 801229c:	681b      	ldr	r3, [r3, #0]
 801229e:	2100      	movs	r1, #0
 80122a0:	4618      	mov	r0, r3
 80122a2:	4b66      	ldr	r3, [pc, #408]	; (801243c <EV_IRQHandler+0x260>)
 80122a4:	4798      	blx	r3
      // request stop condition
      I2C_GenerateSTOP(iicx->base, ENABLE);
 80122a6:	687b      	ldr	r3, [r7, #4]
 80122a8:	681b      	ldr	r3, [r3, #0]
 80122aa:	2101      	movs	r1, #1
 80122ac:	4618      	mov	r0, r3
 80122ae:	4b64      	ldr	r3, [pc, #400]	; (8012440 <EV_IRQHandler+0x264>)
 80122b0:	4798      	blx	r3
      iicx->transfer_state.STOP_REQUESTED = 1;
 80122b2:	687a      	ldr	r2, [r7, #4]
 80122b4:	7d13      	ldrb	r3, [r2, #20]
 80122b6:	f043 0302 	orr.w	r3, r3, #2
 80122ba:	7513      	strb	r3, [r2, #20]
    }
    return;
 80122bc:	e0f6      	b.n	80124ac <EV_IRQHandler+0x2d0>
  }

  // ADDR set, TRA flag not set (indicates transmitter/receiver mode).
  // ADDR will be cleared by a read of SR1 followed by a read of SR2 (done by I2C_GetLastEvent)
  // If transmitter mode is selected (TRA set), we go on, TXE will be catched to send the first byte
  if( (event & I2C_FLAG_ADDR) && !(event & I2C_FLAG_TRA) ){
 80122be:	68fa      	ldr	r2, [r7, #12]
 80122c0:	4b60      	ldr	r3, [pc, #384]	; (8012444 <EV_IRQHandler+0x268>)
 80122c2:	4013      	ands	r3, r2
 80122c4:	2b00      	cmp	r3, #0
 80122c6:	d01c      	beq.n	8012302 <EV_IRQHandler+0x126>
 80122c8:	68fb      	ldr	r3, [r7, #12]
 80122ca:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 80122ce:	2b00      	cmp	r3, #0
 80122d0:	d117      	bne.n	8012302 <EV_IRQHandler+0x126>
    // address sent (receiver mode), receiving first byte - check if we already have to request NAK/Stop
    if( iicx->buffer_len == 1 ) {
 80122d2:	687b      	ldr	r3, [r7, #4]
 80122d4:	8a1b      	ldrh	r3, [r3, #16]
 80122d6:	b29b      	uxth	r3, r3
 80122d8:	2b01      	cmp	r3, #1
 80122da:	f040 80e9 	bne.w	80124b0 <EV_IRQHandler+0x2d4>
      // request NAK
      I2C_AcknowledgeConfig(iicx->base, DISABLE);
 80122de:	687b      	ldr	r3, [r7, #4]
 80122e0:	681b      	ldr	r3, [r3, #0]
 80122e2:	2100      	movs	r1, #0
 80122e4:	4618      	mov	r0, r3
 80122e6:	4b55      	ldr	r3, [pc, #340]	; (801243c <EV_IRQHandler+0x260>)
 80122e8:	4798      	blx	r3
      // request stop condition
      I2C_GenerateSTOP(iicx->base, ENABLE);
 80122ea:	687b      	ldr	r3, [r7, #4]
 80122ec:	681b      	ldr	r3, [r3, #0]
 80122ee:	2101      	movs	r1, #1
 80122f0:	4618      	mov	r0, r3
 80122f2:	4b53      	ldr	r3, [pc, #332]	; (8012440 <EV_IRQHandler+0x264>)
 80122f4:	4798      	blx	r3
      iicx->transfer_state.STOP_REQUESTED = 1;
 80122f6:	687a      	ldr	r2, [r7, #4]
 80122f8:	7d13      	ldrb	r3, [r2, #20]
 80122fa:	f043 0302 	orr.w	r3, r3, #2
 80122fe:	7513      	strb	r3, [r2, #20]
    }
    return;
 8012300:	e0d6      	b.n	80124b0 <EV_IRQHandler+0x2d4>

  // TxE set, will be cleared by writing DR, or after START or STOP was generated
  // This handling also applies for BTF, as TXE will alway be set if BTF is.
  // note: also BTF will be reset after a read of SR1 (TxE flag) followed by either read/write DR
  // or a START or STOP condition generated
  if( event & I2C_FLAG_TXE ){
 8012302:	68fa      	ldr	r2, [r7, #12]
 8012304:	4b50      	ldr	r3, [pc, #320]	; (8012448 <EV_IRQHandler+0x26c>)
 8012306:	4013      	ands	r3, r2
 8012308:	2b00      	cmp	r3, #0
 801230a:	d068      	beq.n	80123de <EV_IRQHandler+0x202>

    // last byte already sent, disable interrupts and return.
    if( iicx->transfer_state.STOP_REQUESTED ) {
 801230c:	687b      	ldr	r3, [r7, #4]
 801230e:	695b      	ldr	r3, [r3, #20]
 8012310:	f3c3 0340 	ubfx	r3, r3, #1, #1
 8012314:	b2db      	uxtb	r3, r3
 8012316:	2b00      	cmp	r3, #0
 8012318:	d00d      	beq.n	8012336 <EV_IRQHandler+0x15a>
      // transfer finished
      iicx->transfer_state.BUSY = 0;
 801231a:	687a      	ldr	r2, [r7, #4]
 801231c:	7d13      	ldrb	r3, [r2, #20]
 801231e:	f36f 0300 	bfc	r3, #0, #1
 8012322:	7513      	strb	r3, [r2, #20]
      // disable all interrupts
      I2C_ITConfig(iicx->base, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR, DISABLE);
 8012324:	687b      	ldr	r3, [r7, #4]
 8012326:	681b      	ldr	r3, [r3, #0]
 8012328:	2200      	movs	r2, #0
 801232a:	f44f 61e0 	mov.w	r1, #1792	; 0x700
 801232e:	4618      	mov	r0, r3
 8012330:	4b41      	ldr	r3, [pc, #260]	; (8012438 <EV_IRQHandler+0x25c>)
 8012332:	4798      	blx	r3
      return;
 8012334:	e0bd      	b.n	80124b2 <EV_IRQHandler+0x2d6>
    }

    if( iicx->buffer_ix < iicx->buffer_len ) {
 8012336:	687b      	ldr	r3, [r7, #4]
 8012338:	8a5b      	ldrh	r3, [r3, #18]
 801233a:	b29a      	uxth	r2, r3
 801233c:	687b      	ldr	r3, [r7, #4]
 801233e:	8a1b      	ldrh	r3, [r3, #16]
 8012340:	b29b      	uxth	r3, r3
 8012342:	429a      	cmp	r2, r3
 8012344:	d216      	bcs.n	8012374 <EV_IRQHandler+0x198>
      // checking tx_buffer_ptr for NULL is a failsafe measure.
      I2C_SendData(iicx->base, (iicx->tx_buffer_ptr == null) ? 0 : iicx->tx_buffer_ptr[iicx->buffer_ix++]);
 8012346:	687b      	ldr	r3, [r7, #4]
 8012348:	6818      	ldr	r0, [r3, #0]
 801234a:	687b      	ldr	r3, [r7, #4]
 801234c:	689b      	ldr	r3, [r3, #8]
 801234e:	2b00      	cmp	r3, #0
 8012350:	d00b      	beq.n	801236a <EV_IRQHandler+0x18e>
 8012352:	687b      	ldr	r3, [r7, #4]
 8012354:	689a      	ldr	r2, [r3, #8]
 8012356:	687b      	ldr	r3, [r7, #4]
 8012358:	8a5b      	ldrh	r3, [r3, #18]
 801235a:	b29b      	uxth	r3, r3
 801235c:	1c59      	adds	r1, r3, #1
 801235e:	b28c      	uxth	r4, r1
 8012360:	6879      	ldr	r1, [r7, #4]
 8012362:	824c      	strh	r4, [r1, #18]
 8012364:	4413      	add	r3, r2
 8012366:	781b      	ldrb	r3, [r3, #0]
 8012368:	e000      	b.n	801236c <EV_IRQHandler+0x190>
 801236a:	2300      	movs	r3, #0
 801236c:	4619      	mov	r1, r3
 801236e:	4b37      	ldr	r3, [pc, #220]	; (801244c <EV_IRQHandler+0x270>)
 8012370:	4798      	blx	r3
      return;
 8012372:	e09e      	b.n	80124b2 <EV_IRQHandler+0x2d6>
    }

    // peripheral is transfering last byte, request stop condition /
    // on write-without-stop transfer-type, request start condition instead
    if( !iicx->transfer_state.WRITE_WITHOUT_STOP )
 8012374:	687b      	ldr	r3, [r7, #4]
 8012376:	695b      	ldr	r3, [r3, #20]
 8012378:	f3c3 03c0 	ubfx	r3, r3, #3, #1
 801237c:	b2db      	uxtb	r3, r3
 801237e:	2b00      	cmp	r3, #0
 8012380:	d106      	bne.n	8012390 <EV_IRQHandler+0x1b4>
      I2C_GenerateSTOP(iicx->base, ENABLE);
 8012382:	687b      	ldr	r3, [r7, #4]
 8012384:	681b      	ldr	r3, [r3, #0]
 8012386:	2101      	movs	r1, #1
 8012388:	4618      	mov	r0, r3
 801238a:	4b2d      	ldr	r3, [pc, #180]	; (8012440 <EV_IRQHandler+0x264>)
 801238c:	4798      	blx	r3
 801238e:	e005      	b.n	801239c <EV_IRQHandler+0x1c0>
    else
      I2C_GenerateSTART(iicx->base, ENABLE);
 8012390:	687b      	ldr	r3, [r7, #4]
 8012392:	681b      	ldr	r3, [r3, #0]
 8012394:	2101      	movs	r1, #1
 8012396:	4618      	mov	r0, r3
 8012398:	4b2d      	ldr	r3, [pc, #180]	; (8012450 <EV_IRQHandler+0x274>)
 801239a:	4798      	blx	r3
    iicx->transfer_state.STOP_REQUESTED = 1;
 801239c:	687a      	ldr	r2, [r7, #4]
 801239e:	7d13      	ldrb	r3, [r2, #20]
 80123a0:	f043 0302 	orr.w	r3, r3, #2
 80123a4:	7513      	strb	r3, [r2, #20]

    if( iicx->buffer_len == 0 ) {
 80123a6:	687b      	ldr	r3, [r7, #4]
 80123a8:	8a1b      	ldrh	r3, [r3, #16]
 80123aa:	b29b      	uxth	r3, r3
 80123ac:	2b00      	cmp	r3, #0
 80123ae:	d10d      	bne.n	80123cc <EV_IRQHandler+0x1f0>
      // transfer finished
      iicx->transfer_state.BUSY = 0;
 80123b0:	687a      	ldr	r2, [r7, #4]
 80123b2:	7d13      	ldrb	r3, [r2, #20]
 80123b4:	f36f 0300 	bfc	r3, #0, #1
 80123b8:	7513      	strb	r3, [r2, #20]
      // disable all interrupts
      I2C_ITConfig(iicx->base, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR, DISABLE);
 80123ba:	687b      	ldr	r3, [r7, #4]
 80123bc:	681b      	ldr	r3, [r3, #0]
 80123be:	2200      	movs	r2, #0
 80123c0:	f44f 61e0 	mov.w	r1, #1792	; 0x700
 80123c4:	4618      	mov	r0, r3
 80123c6:	4b1c      	ldr	r3, [pc, #112]	; (8012438 <EV_IRQHandler+0x25c>)
 80123c8:	4798      	blx	r3
      // Disable the I2C_IT_BUF interrupt after sending the last buffer data
      // (last EV8) to not allow a new interrupt just with TxE - only BTF will generate it
      // if this is not done, BUSY will be cleared before the transfer is finished
      I2C_ITConfig(iicx->base, I2C_IT_BUF, DISABLE);
    }
  return;
 80123ca:	e072      	b.n	80124b2 <EV_IRQHandler+0x2d6>
      I2C_ITConfig(iicx->base, I2C_IT_BUF, DISABLE);
 80123cc:	687b      	ldr	r3, [r7, #4]
 80123ce:	681b      	ldr	r3, [r3, #0]
 80123d0:	2200      	movs	r2, #0
 80123d2:	f44f 6180 	mov.w	r1, #1024	; 0x400
 80123d6:	4618      	mov	r0, r3
 80123d8:	4b17      	ldr	r3, [pc, #92]	; (8012438 <EV_IRQHandler+0x25c>)
 80123da:	4798      	blx	r3
  return;
 80123dc:	e069      	b.n	80124b2 <EV_IRQHandler+0x2d6>
  }

  // SB set, cleared by reading SR1 (done by I2C_GetLastEvent) followed by writing DR register
  if( event & I2C_FLAG_SB ){
 80123de:	68fa      	ldr	r2, [r7, #12]
 80123e0:	4b1c      	ldr	r3, [pc, #112]	; (8012454 <EV_IRQHandler+0x278>)
 80123e2:	4013      	ands	r3, r2
 80123e4:	2b00      	cmp	r3, #0
 80123e6:	d039      	beq.n	801245c <EV_IRQHandler+0x280>
    // don't send address if stop was requested (WRITE_WITHOUT_STOP - mode, start condition was sent)
    // we have to wait for the application to start the next transfer
    if( iicx->transfer_state.STOP_REQUESTED ) {
 80123e8:	687b      	ldr	r3, [r7, #4]
 80123ea:	695b      	ldr	r3, [r3, #20]
 80123ec:	f3c3 0340 	ubfx	r3, r3, #1, #1
 80123f0:	b2db      	uxtb	r3, r3
 80123f2:	2b00      	cmp	r3, #0
 80123f4:	d00d      	beq.n	8012412 <EV_IRQHandler+0x236>
      // transfer finished
      iicx->transfer_state.BUSY = 0;
 80123f6:	687a      	ldr	r2, [r7, #4]
 80123f8:	7d13      	ldrb	r3, [r2, #20]
 80123fa:	f36f 0300 	bfc	r3, #0, #1
 80123fe:	7513      	strb	r3, [r2, #20]
      // disable all interrupts
      I2C_ITConfig(iicx->base, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR, DISABLE);
 8012400:	687b      	ldr	r3, [r7, #4]
 8012402:	681b      	ldr	r3, [r3, #0]
 8012404:	2200      	movs	r2, #0
 8012406:	f44f 61e0 	mov.w	r1, #1792	; 0x700
 801240a:	4618      	mov	r0, r3
 801240c:	4b0a      	ldr	r3, [pc, #40]	; (8012438 <EV_IRQHandler+0x25c>)
 801240e:	4798      	blx	r3
      return;
 8012410:	e04f      	b.n	80124b2 <EV_IRQHandler+0x2d6>
    }
    // send IIC address
    I2C_Send7bitAddress(iicx->base, iicx->iic_address,
 8012412:	687b      	ldr	r3, [r7, #4]
 8012414:	6818      	ldr	r0, [r3, #0]
 8012416:	687b      	ldr	r3, [r7, #4]
 8012418:	7919      	ldrb	r1, [r3, #4]
      (iicx->iic_address & 1)
 801241a:	687b      	ldr	r3, [r7, #4]
 801241c:	791b      	ldrb	r3, [r3, #4]
    I2C_Send7bitAddress(iicx->base, iicx->iic_address,
 801241e:	f003 0301 	and.w	r3, r3, #1
 8012422:	b2db      	uxtb	r3, r3
 8012424:	461a      	mov	r2, r3
 8012426:	4b0c      	ldr	r3, [pc, #48]	; (8012458 <EV_IRQHandler+0x27c>)
 8012428:	4798      	blx	r3
      ? I2C_Direction_Receiver
      : I2C_Direction_Transmitter);
    return;
 801242a:	e042      	b.n	80124b2 <EV_IRQHandler+0x2d6>
 801242c:	08003f81 	.word	0x08003f81
 8012430:	10000040 	.word	0x10000040
 8012434:	08003f01 	.word	0x08003f01
 8012438:	08003e9d 	.word	0x08003e9d
 801243c:	08003e5f 	.word	0x08003e5f
 8012440:	08003e21 	.word	0x08003e21
 8012444:	10000002 	.word	0x10000002
 8012448:	10000080 	.word	0x10000080
 801244c:	08003ee3 	.word	0x08003ee3
 8012450:	08003de3 	.word	0x08003de3
 8012454:	10000001 	.word	0x10000001
 8012458:	08003f1b 	.word	0x08003f1b
  }

  // this code is only reached if something got wrong, e.g. interrupt handler is called too late,
  // the device reset itself (while testing, it was always event 0x00000000). we have to stop the transfer,
  // else read/write of corrupt data may be the result.
  I2C_ITConfig(iicx->base, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR, DISABLE);
 801245c:	687b      	ldr	r3, [r7, #4]
 801245e:	681b      	ldr	r3, [r3, #0]
 8012460:	2200      	movs	r2, #0
 8012462:	f44f 61e0 	mov.w	r1, #1792	; 0x700
 8012466:	4618      	mov	r0, r3
 8012468:	4b13      	ldr	r3, [pc, #76]	; (80124b8 <EV_IRQHandler+0x2dc>)
 801246a:	4798      	blx	r3
  // notify error
  MIOS32_IIC_unexpected_event = event;
 801246c:	4a13      	ldr	r2, [pc, #76]	; (80124bc <EV_IRQHandler+0x2e0>)
 801246e:	68fb      	ldr	r3, [r7, #12]
 8012470:	6013      	str	r3, [r2, #0]
  iicx->transfer_error = MIOS32_IIC_ERROR_UNEXPECTED_EVENT;
 8012472:	687b      	ldr	r3, [r7, #4]
 8012474:	f06f 0207 	mvn.w	r2, #7
 8012478:	619a      	str	r2, [r3, #24]
  iicx->transfer_state.BUSY = 0;
 801247a:	687a      	ldr	r2, [r7, #4]
 801247c:	7d13      	ldrb	r3, [r2, #20]
 801247e:	f36f 0300 	bfc	r3, #0, #1
 8012482:	7513      	strb	r3, [r2, #20]
  // do dummy read to send NAK + STOP condition
  I2C_AcknowledgeConfig(iicx->base, DISABLE);
 8012484:	687b      	ldr	r3, [r7, #4]
 8012486:	681b      	ldr	r3, [r3, #0]
 8012488:	2100      	movs	r1, #0
 801248a:	4618      	mov	r0, r3
 801248c:	4b0c      	ldr	r3, [pc, #48]	; (80124c0 <EV_IRQHandler+0x2e4>)
 801248e:	4798      	blx	r3
  b = I2C_ReceiveData(iicx->base);
 8012490:	687b      	ldr	r3, [r7, #4]
 8012492:	681b      	ldr	r3, [r3, #0]
 8012494:	4618      	mov	r0, r3
 8012496:	4b0b      	ldr	r3, [pc, #44]	; (80124c4 <EV_IRQHandler+0x2e8>)
 8012498:	4798      	blx	r3
 801249a:	4603      	mov	r3, r0
 801249c:	72fb      	strb	r3, [r7, #11]
  I2C_GenerateSTOP(iicx->base, ENABLE);
 801249e:	687b      	ldr	r3, [r7, #4]
 80124a0:	681b      	ldr	r3, [r3, #0]
 80124a2:	2101      	movs	r1, #1
 80124a4:	4618      	mov	r0, r3
 80124a6:	4b08      	ldr	r3, [pc, #32]	; (80124c8 <EV_IRQHandler+0x2ec>)
 80124a8:	4798      	blx	r3
 80124aa:	e002      	b.n	80124b2 <EV_IRQHandler+0x2d6>
    return;
 80124ac:	bf00      	nop
 80124ae:	e000      	b.n	80124b2 <EV_IRQHandler+0x2d6>
    return;
 80124b0:	bf00      	nop
  }
 80124b2:	3714      	adds	r7, #20
 80124b4:	46bd      	mov	sp, r7
 80124b6:	bd90      	pop	{r4, r7, pc}
 80124b8:	08003e9d 	.word	0x08003e9d
 80124bc:	20009590 	.word	0x20009590
 80124c0:	08003e5f 	.word	0x08003e5f
 80124c4:	08003f01 	.word	0x08003f01
 80124c8:	08003e21 	.word	0x08003e21

080124cc <ER_IRQHandler>:

/////////////////////////////////////////////////////////////////////////////
// Internal function for handling IIC error interrupts
/////////////////////////////////////////////////////////////////////////////
static void ER_IRQHandler(iic_rec_t *iicx)
{
 80124cc:	b580      	push	{r7, lr}
 80124ce:	b084      	sub	sp, #16
 80124d0:	af00      	add	r7, sp, #0
 80124d2:	6078      	str	r0, [r7, #4]
  // Read SR1 and SR2 at the beginning (if not done so, flags may get lost)
  u32 event = I2C_GetLastEvent(iicx->base);
 80124d4:	687b      	ldr	r3, [r7, #4]
 80124d6:	681b      	ldr	r3, [r3, #0]
 80124d8:	4618      	mov	r0, r3
 80124da:	4b24      	ldr	r3, [pc, #144]	; (801256c <ER_IRQHandler+0xa0>)
 80124dc:	4798      	blx	r3
 80124de:	60f8      	str	r0, [r7, #12]
  // note that only one error number is available
  // the order of these checks defines the priority

  // bus error (start/stop condition during read
  // unlikely, should only be relevant for slave mode?)
  if( event & I2C_FLAG_BERR  ) {
 80124e0:	68fa      	ldr	r2, [r7, #12]
 80124e2:	4b23      	ldr	r3, [pc, #140]	; (8012570 <ER_IRQHandler+0xa4>)
 80124e4:	4013      	ands	r3, r2
 80124e6:	2b00      	cmp	r3, #0
 80124e8:	d00a      	beq.n	8012500 <ER_IRQHandler+0x34>
    I2C_ClearITPendingBit(iicx->base, I2C_IT_BERR);
 80124ea:	687b      	ldr	r3, [r7, #4]
 80124ec:	681b      	ldr	r3, [r3, #0]
 80124ee:	f04f 2101 	mov.w	r1, #16777472	; 0x1000100
 80124f2:	4618      	mov	r0, r3
 80124f4:	4b1f      	ldr	r3, [pc, #124]	; (8012574 <ER_IRQHandler+0xa8>)
 80124f6:	4798      	blx	r3
    iicx->transfer_error = MIOS32_IIC_ERROR_BUS;
 80124f8:	687b      	ldr	r3, [r7, #4]
 80124fa:	f06f 0205 	mvn.w	r2, #5
 80124fe:	619a      	str	r2, [r3, #24]
  }

  // arbitration lost
  if( event & I2C_FLAG_ARLO ) {
 8012500:	68fa      	ldr	r2, [r7, #12]
 8012502:	4b1d      	ldr	r3, [pc, #116]	; (8012578 <ER_IRQHandler+0xac>)
 8012504:	4013      	ands	r3, r2
 8012506:	2b00      	cmp	r3, #0
 8012508:	d009      	beq.n	801251e <ER_IRQHandler+0x52>
    I2C_ClearITPendingBit(iicx->base, I2C_IT_ARLO);
 801250a:	687b      	ldr	r3, [r7, #4]
 801250c:	681b      	ldr	r3, [r3, #0]
 801250e:	491b      	ldr	r1, [pc, #108]	; (801257c <ER_IRQHandler+0xb0>)
 8012510:	4618      	mov	r0, r3
 8012512:	4b18      	ldr	r3, [pc, #96]	; (8012574 <ER_IRQHandler+0xa8>)
 8012514:	4798      	blx	r3
    iicx->transfer_error = MIOS32_IIC_ERROR_ARBITRATION_LOST;
 8012516:	687b      	ldr	r3, [r7, #4]
 8012518:	f06f 0204 	mvn.w	r2, #4
 801251c:	619a      	str	r2, [r3, #24]
  }

  // no acknowledge received from slave (e.g. slave not connected)
  if( event & I2C_FLAG_AF ) {
 801251e:	68fa      	ldr	r2, [r7, #12]
 8012520:	4b17      	ldr	r3, [pc, #92]	; (8012580 <ER_IRQHandler+0xb4>)
 8012522:	4013      	ands	r3, r2
 8012524:	2b00      	cmp	r3, #0
 8012526:	d00f      	beq.n	8012548 <ER_IRQHandler+0x7c>
    I2C_ClearITPendingBit(iicx->base, I2C_IT_AF);
 8012528:	687b      	ldr	r3, [r7, #4]
 801252a:	681b      	ldr	r3, [r3, #0]
 801252c:	4915      	ldr	r1, [pc, #84]	; (8012584 <ER_IRQHandler+0xb8>)
 801252e:	4618      	mov	r0, r3
 8012530:	4b10      	ldr	r3, [pc, #64]	; (8012574 <ER_IRQHandler+0xa8>)
 8012532:	4798      	blx	r3
    iicx->transfer_error = MIOS32_IIC_ERROR_SLAVE_NOT_CONNECTED;
 8012534:	687b      	ldr	r3, [r7, #4]
 8012536:	f06f 0206 	mvn.w	r2, #6
 801253a:	619a      	str	r2, [r3, #24]
    // send stop condition to release bus
    I2C_GenerateSTOP(iicx->base, ENABLE);
 801253c:	687b      	ldr	r3, [r7, #4]
 801253e:	681b      	ldr	r3, [r3, #0]
 8012540:	2101      	movs	r1, #1
 8012542:	4618      	mov	r0, r3
 8012544:	4b10      	ldr	r3, [pc, #64]	; (8012588 <ER_IRQHandler+0xbc>)
 8012546:	4798      	blx	r3
  }

  // disable interrupts
  I2C_ITConfig(iicx->base, I2C_IT_EVT | I2C_IT_BUF | I2C_IT_ERR, DISABLE);
 8012548:	687b      	ldr	r3, [r7, #4]
 801254a:	681b      	ldr	r3, [r3, #0]
 801254c:	2200      	movs	r2, #0
 801254e:	f44f 61e0 	mov.w	r1, #1792	; 0x700
 8012552:	4618      	mov	r0, r3
 8012554:	4b0d      	ldr	r3, [pc, #52]	; (801258c <ER_IRQHandler+0xc0>)
 8012556:	4798      	blx	r3

  // notify that transfer has finished (due to the error)
  iicx->transfer_state.BUSY = 0;
 8012558:	687a      	ldr	r2, [r7, #4]
 801255a:	7d13      	ldrb	r3, [r2, #20]
 801255c:	f36f 0300 	bfc	r3, #0, #1
 8012560:	7513      	strb	r3, [r2, #20]
}
 8012562:	bf00      	nop
 8012564:	3710      	adds	r7, #16
 8012566:	46bd      	mov	sp, r7
 8012568:	bd80      	pop	{r7, pc}
 801256a:	bf00      	nop
 801256c:	08003f81 	.word	0x08003f81
 8012570:	10000100 	.word	0x10000100
 8012574:	080040ad 	.word	0x080040ad
 8012578:	10000200 	.word	0x10000200
 801257c:	01000200 	.word	0x01000200
 8012580:	10000400 	.word	0x10000400
 8012584:	01000400 	.word	0x01000400
 8012588:	08003e21 	.word	0x08003e21
 801258c:	08003e9d 	.word	0x08003e9d

08012590 <I2C1_EV_IRQHandler>:
/////////////////////////////////////////////////////////////////////////////
// interrupt vectors
/////////////////////////////////////////////////////////////////////////////

void I2C1_EV_IRQHandler(void)
{
 8012590:	b580      	push	{r7, lr}
 8012592:	af00      	add	r7, sp, #0
  EV_IRQHandler((iic_rec_t *)&iic_rec[0]);
 8012594:	4802      	ldr	r0, [pc, #8]	; (80125a0 <I2C1_EV_IRQHandler+0x10>)
 8012596:	4b03      	ldr	r3, [pc, #12]	; (80125a4 <I2C1_EV_IRQHandler+0x14>)
 8012598:	4798      	blx	r3
}
 801259a:	bf00      	nop
 801259c:	bd80      	pop	{r7, pc}
 801259e:	bf00      	nop
 80125a0:	20009594 	.word	0x20009594
 80125a4:	080121dd 	.word	0x080121dd

080125a8 <I2C1_ER_IRQHandler>:

void I2C1_ER_IRQHandler(void)
{
 80125a8:	b580      	push	{r7, lr}
 80125aa:	af00      	add	r7, sp, #0
  ER_IRQHandler((iic_rec_t *)&iic_rec[0]);
 80125ac:	4802      	ldr	r0, [pc, #8]	; (80125b8 <I2C1_ER_IRQHandler+0x10>)
 80125ae:	4b03      	ldr	r3, [pc, #12]	; (80125bc <I2C1_ER_IRQHandler+0x14>)
 80125b0:	4798      	blx	r3
}
 80125b2:	bf00      	nop
 80125b4:	bd80      	pop	{r7, pc}
 80125b6:	bf00      	nop
 80125b8:	20009594 	.word	0x20009594
 80125bc:	080124cd 	.word	0x080124cd

080125c0 <EP1_IN_Callback>:
	return i;
}


void EP1_IN_Callback(void)
{
 80125c0:	b580      	push	{r7, lr}
 80125c2:	af00      	add	r7, sp, #0
	if (USB_Tx_Cnt > 0)
 80125c4:	4b1c      	ldr	r3, [pc, #112]	; (8012638 <EP1_IN_Callback+0x78>)
 80125c6:	781b      	ldrb	r3, [r3, #0]
 80125c8:	2b00      	cmp	r3, #0
 80125ca:	d033      	beq.n	8012634 <EP1_IN_Callback+0x74>
	{
		if (USB_Tx_Cnt > VIRTUAL_COM_PORT_DATA_SIZE)
 80125cc:	4b1a      	ldr	r3, [pc, #104]	; (8012638 <EP1_IN_Callback+0x78>)
 80125ce:	781b      	ldrb	r3, [r3, #0]
 80125d0:	2b40      	cmp	r3, #64	; 0x40
 80125d2:	d919      	bls.n	8012608 <EP1_IN_Callback+0x48>
		{
			UserToPMABufferCopy(USB_Tx_Buffer, ENDP1_TXADDR,
 80125d4:	4b19      	ldr	r3, [pc, #100]	; (801263c <EP1_IN_Callback+0x7c>)
 80125d6:	681b      	ldr	r3, [r3, #0]
 80125d8:	2240      	movs	r2, #64	; 0x40
 80125da:	21c0      	movs	r1, #192	; 0xc0
 80125dc:	4618      	mov	r0, r3
 80125de:	4b18      	ldr	r3, [pc, #96]	; (8012640 <EP1_IN_Callback+0x80>)
 80125e0:	4798      	blx	r3
					VIRTUAL_COM_PORT_DATA_SIZE);
			SetEPTxCount(ENDP1, VIRTUAL_COM_PORT_DATA_SIZE);
 80125e2:	2140      	movs	r1, #64	; 0x40
 80125e4:	2001      	movs	r0, #1
 80125e6:	4b17      	ldr	r3, [pc, #92]	; (8012644 <EP1_IN_Callback+0x84>)
 80125e8:	4798      	blx	r3
			SetEPTxValid(ENDP1);
 80125ea:	2001      	movs	r0, #1
 80125ec:	4b16      	ldr	r3, [pc, #88]	; (8012648 <EP1_IN_Callback+0x88>)
 80125ee:	4798      	blx	r3
			USB_Tx_Cnt -= VIRTUAL_COM_PORT_DATA_SIZE;
 80125f0:	4b11      	ldr	r3, [pc, #68]	; (8012638 <EP1_IN_Callback+0x78>)
 80125f2:	781b      	ldrb	r3, [r3, #0]
 80125f4:	3b40      	subs	r3, #64	; 0x40
 80125f6:	b2da      	uxtb	r2, r3
 80125f8:	4b0f      	ldr	r3, [pc, #60]	; (8012638 <EP1_IN_Callback+0x78>)
 80125fa:	701a      	strb	r2, [r3, #0]
			USB_Tx_Buffer += VIRTUAL_COM_PORT_DATA_SIZE;
 80125fc:	4b0f      	ldr	r3, [pc, #60]	; (801263c <EP1_IN_Callback+0x7c>)
 80125fe:	681b      	ldr	r3, [r3, #0]
 8012600:	3340      	adds	r3, #64	; 0x40
 8012602:	4a0e      	ldr	r2, [pc, #56]	; (801263c <EP1_IN_Callback+0x7c>)
 8012604:	6013      	str	r3, [r2, #0]
			SetEPTxCount(ENDP1, USB_Tx_Cnt);
			SetEPTxValid(ENDP1);
			USB_Tx_Cnt = 0;
		}
	}
}
 8012606:	e015      	b.n	8012634 <EP1_IN_Callback+0x74>
			UserToPMABufferCopy(USB_Tx_Buffer, ENDP1_TXADDR, USB_Tx_Cnt);
 8012608:	4b0c      	ldr	r3, [pc, #48]	; (801263c <EP1_IN_Callback+0x7c>)
 801260a:	681b      	ldr	r3, [r3, #0]
 801260c:	4a0a      	ldr	r2, [pc, #40]	; (8012638 <EP1_IN_Callback+0x78>)
 801260e:	7812      	ldrb	r2, [r2, #0]
 8012610:	b292      	uxth	r2, r2
 8012612:	21c0      	movs	r1, #192	; 0xc0
 8012614:	4618      	mov	r0, r3
 8012616:	4b0a      	ldr	r3, [pc, #40]	; (8012640 <EP1_IN_Callback+0x80>)
 8012618:	4798      	blx	r3
			SetEPTxCount(ENDP1, USB_Tx_Cnt);
 801261a:	4b07      	ldr	r3, [pc, #28]	; (8012638 <EP1_IN_Callback+0x78>)
 801261c:	781b      	ldrb	r3, [r3, #0]
 801261e:	b29b      	uxth	r3, r3
 8012620:	4619      	mov	r1, r3
 8012622:	2001      	movs	r0, #1
 8012624:	4b07      	ldr	r3, [pc, #28]	; (8012644 <EP1_IN_Callback+0x84>)
 8012626:	4798      	blx	r3
			SetEPTxValid(ENDP1);
 8012628:	2001      	movs	r0, #1
 801262a:	4b07      	ldr	r3, [pc, #28]	; (8012648 <EP1_IN_Callback+0x88>)
 801262c:	4798      	blx	r3
			USB_Tx_Cnt = 0;
 801262e:	4b02      	ldr	r3, [pc, #8]	; (8012638 <EP1_IN_Callback+0x78>)
 8012630:	2200      	movs	r2, #0
 8012632:	701a      	strb	r2, [r3, #0]
}
 8012634:	bf00      	nop
 8012636:	bd80      	pop	{r7, pc}
 8012638:	200096bd 	.word	0x200096bd
 801263c:	200096b8 	.word	0x200096b8
 8012640:	08013f15 	.word	0x08013f15
 8012644:	080143c9 	.word	0x080143c9
 8012648:	08014139 	.word	0x08014139

0801264c <EP3_OUT_Callback>:
 * Input          : None.
 * Output         : None.
 * Return         : None.
 *******************************************************************************/
void EP3_OUT_Callback(void)
{
 801264c:	b580      	push	{r7, lr}
 801264e:	af00      	add	r7, sp, #0
	if(USB_Rx_Cnt%VIRTUAL_COM_PORT_DATA_SIZE==0)
 8012650:	4b0e      	ldr	r3, [pc, #56]	; (801268c <EP3_OUT_Callback+0x40>)
 8012652:	781b      	ldrb	r3, [r3, #0]
 8012654:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8012658:	b2db      	uxtb	r3, r3
 801265a:	2b00      	cmp	r3, #0
 801265c:	d110      	bne.n	8012680 <EP3_OUT_Callback+0x34>
	{
		USB_Rx_Cnt += USB_SIL_Read(EP3_OUT, &USB_Rx_Buffer[USB_Rx_Cnt]);
 801265e:	4b0b      	ldr	r3, [pc, #44]	; (801268c <EP3_OUT_Callback+0x40>)
 8012660:	781b      	ldrb	r3, [r3, #0]
 8012662:	461a      	mov	r2, r3
 8012664:	4b0a      	ldr	r3, [pc, #40]	; (8012690 <EP3_OUT_Callback+0x44>)
 8012666:	4413      	add	r3, r2
 8012668:	4619      	mov	r1, r3
 801266a:	2003      	movs	r0, #3
 801266c:	4b09      	ldr	r3, [pc, #36]	; (8012694 <EP3_OUT_Callback+0x48>)
 801266e:	4798      	blx	r3
 8012670:	4603      	mov	r3, r0
 8012672:	b2da      	uxtb	r2, r3
 8012674:	4b05      	ldr	r3, [pc, #20]	; (801268c <EP3_OUT_Callback+0x40>)
 8012676:	781b      	ldrb	r3, [r3, #0]
 8012678:	4413      	add	r3, r2
 801267a:	b2da      	uxtb	r2, r3
 801267c:	4b03      	ldr	r3, [pc, #12]	; (801268c <EP3_OUT_Callback+0x40>)
 801267e:	701a      	strb	r2, [r3, #0]
	}
	// Get the received data buffer and update the counter

#ifndef STM32F10X_CL
	// Enable the receive of data on EP3
	SetEPRxValid(ENDP3);
 8012680:	2003      	movs	r0, #3
 8012682:	4b05      	ldr	r3, [pc, #20]	; (8012698 <EP3_OUT_Callback+0x4c>)
 8012684:	4798      	blx	r3
#endif // STM32F10X_CL
}
 8012686:	bf00      	nop
 8012688:	bd80      	pop	{r7, pc}
 801268a:	bf00      	nop
 801268c:	200096bc 	.word	0x200096bc
 8012690:	200095b8 	.word	0x200095b8
 8012694:	08014525 	.word	0x08014525
 8012698:	0801418d 	.word	0x0801418d

0801269c <SOF_Callback>:
#ifdef STM32F10X_CL
void INTR_SOFINTR_Callback(void)
#else
void SOF_Callback(void)
#endif /* STM32F10X_CL */
{
 801269c:	b580      	push	{r7, lr}
 801269e:	af00      	add	r7, sp, #0
	static uint32_t FrameCount = 0;

	if (bDeviceState == CONFIGURED)
 80126a0:	4b08      	ldr	r3, [pc, #32]	; (80126c4 <SOF_Callback+0x28>)
 80126a2:	681b      	ldr	r3, [r3, #0]
 80126a4:	2b05      	cmp	r3, #5
 80126a6:	d10b      	bne.n	80126c0 <SOF_Callback+0x24>
	{
		if (FrameCount++ == VCOMPORT_IN_FRAME_INTERVAL)
 80126a8:	4b07      	ldr	r3, [pc, #28]	; (80126c8 <SOF_Callback+0x2c>)
 80126aa:	681b      	ldr	r3, [r3, #0]
 80126ac:	1c5a      	adds	r2, r3, #1
 80126ae:	4906      	ldr	r1, [pc, #24]	; (80126c8 <SOF_Callback+0x2c>)
 80126b0:	600a      	str	r2, [r1, #0]
 80126b2:	2b05      	cmp	r3, #5
 80126b4:	d104      	bne.n	80126c0 <SOF_Callback+0x24>
		{
			/* Reset the frame counter */
			FrameCount = 0;
 80126b6:	4b04      	ldr	r3, [pc, #16]	; (80126c8 <SOF_Callback+0x2c>)
 80126b8:	2200      	movs	r2, #0
 80126ba:	601a      	str	r2, [r3, #0]

			/* Check the data to be sent through IN pipe */
			Handle_USBAsynchXfer();
 80126bc:	4b03      	ldr	r3, [pc, #12]	; (80126cc <SOF_Callback+0x30>)
 80126be:	4798      	blx	r3
		}
	}
}
 80126c0:	bf00      	nop
 80126c2:	bd80      	pop	{r7, pc}
 80126c4:	200096c8 	.word	0x200096c8
 80126c8:	200096c0 	.word	0x200096c0
 80126cc:	08012b31 	.word	0x08012b31

080126d0 <USB_Istr>:
* Input          :
* Output         :
* Return         :
*******************************************************************************/
void USB_Istr(void)
{
 80126d0:	b580      	push	{r7, lr}
 80126d2:	af00      	add	r7, sp, #0

  wIstr = _GetISTR();
 80126d4:	4b1d      	ldr	r3, [pc, #116]	; (801274c <USB_Istr+0x7c>)
 80126d6:	681b      	ldr	r3, [r3, #0]
 80126d8:	b29a      	uxth	r2, r3
 80126da:	4b1d      	ldr	r3, [pc, #116]	; (8012750 <USB_Istr+0x80>)
 80126dc:	801a      	strh	r2, [r3, #0]

#if (IMR_MSK & ISTR_SOF)
  if (wIstr & ISTR_SOF & wInterrupt_Mask)
 80126de:	4b1c      	ldr	r3, [pc, #112]	; (8012750 <USB_Istr+0x80>)
 80126e0:	881b      	ldrh	r3, [r3, #0]
 80126e2:	b29b      	uxth	r3, r3
 80126e4:	f403 7300 	and.w	r3, r3, #512	; 0x200
 80126e8:	4a1a      	ldr	r2, [pc, #104]	; (8012754 <USB_Istr+0x84>)
 80126ea:	8812      	ldrh	r2, [r2, #0]
 80126ec:	4013      	ands	r3, r2
 80126ee:	2b00      	cmp	r3, #0
 80126f0:	d00c      	beq.n	801270c <USB_Istr+0x3c>
  {
    _SetISTR((uint16_t)CLR_SOF);
 80126f2:	4b16      	ldr	r3, [pc, #88]	; (801274c <USB_Istr+0x7c>)
 80126f4:	f64f 52ff 	movw	r2, #65023	; 0xfdff
 80126f8:	601a      	str	r2, [r3, #0]
    bIntPackSOF++;
 80126fa:	4b17      	ldr	r3, [pc, #92]	; (8012758 <USB_Istr+0x88>)
 80126fc:	781b      	ldrb	r3, [r3, #0]
 80126fe:	b2db      	uxtb	r3, r3
 8012700:	3301      	adds	r3, #1
 8012702:	b2da      	uxtb	r2, r3
 8012704:	4b14      	ldr	r3, [pc, #80]	; (8012758 <USB_Istr+0x88>)
 8012706:	701a      	strb	r2, [r3, #0]

#ifdef SOF_CALLBACK
    SOF_Callback();
 8012708:	4b14      	ldr	r3, [pc, #80]	; (801275c <USB_Istr+0x8c>)
 801270a:	4798      	blx	r3
  }
#endif
  /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/  
  
#if (IMR_MSK & ISTR_CTR)
  if (wIstr & ISTR_CTR & wInterrupt_Mask)
 801270c:	4b10      	ldr	r3, [pc, #64]	; (8012750 <USB_Istr+0x80>)
 801270e:	881b      	ldrh	r3, [r3, #0]
 8012710:	b29b      	uxth	r3, r3
 8012712:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8012716:	4a0f      	ldr	r2, [pc, #60]	; (8012754 <USB_Istr+0x84>)
 8012718:	8812      	ldrh	r2, [r2, #0]
 801271a:	4013      	ands	r3, r2
 801271c:	2b00      	cmp	r3, #0
 801271e:	d001      	beq.n	8012724 <USB_Istr+0x54>
  {
    /* servicing of the endpoint correct transfer interrupt */
    /* clear of the CTR flag into the sub */
    CTR_LP();
 8012720:	4b0f      	ldr	r3, [pc, #60]	; (8012760 <USB_Istr+0x90>)
 8012722:	4798      	blx	r3
#endif
  }
#endif
  /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/  
#if (IMR_MSK & ISTR_RESET)
  if (wIstr & ISTR_RESET & wInterrupt_Mask)
 8012724:	4b0a      	ldr	r3, [pc, #40]	; (8012750 <USB_Istr+0x80>)
 8012726:	881b      	ldrh	r3, [r3, #0]
 8012728:	b29b      	uxth	r3, r3
 801272a:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 801272e:	4a09      	ldr	r2, [pc, #36]	; (8012754 <USB_Istr+0x84>)
 8012730:	8812      	ldrh	r2, [r2, #0]
 8012732:	4013      	ands	r3, r2
 8012734:	2b00      	cmp	r3, #0
 8012736:	d006      	beq.n	8012746 <USB_Istr+0x76>
  {
    _SetISTR((uint16_t)CLR_RESET);
 8012738:	4b04      	ldr	r3, [pc, #16]	; (801274c <USB_Istr+0x7c>)
 801273a:	f64f 32ff 	movw	r2, #64511	; 0xfbff
 801273e:	601a      	str	r2, [r3, #0]
    Device_Property.Reset();
 8012740:	4b08      	ldr	r3, [pc, #32]	; (8012764 <USB_Istr+0x94>)
 8012742:	685b      	ldr	r3, [r3, #4]
 8012744:	4798      	blx	r3
#ifdef ESOF_CALLBACK
    ESOF_Callback();
#endif
  }
#endif
} /* USB_Istr */
 8012746:	bf00      	nop
 8012748:	bd80      	pop	{r7, pc}
 801274a:	bf00      	nop
 801274c:	40005c44 	.word	0x40005c44
 8012750:	200096c4 	.word	0x200096c4
 8012754:	200096d8 	.word	0x200096d8
 8012758:	200096c6 	.word	0x200096c6
 801275c:	0801269d 	.word	0x0801269d
 8012760:	08013c09 	.word	0x08013c09
 8012764:	200001c8 	.word	0x200001c8

08012768 <Virtual_Com_Port_init>:
* Input          : None.
* Output         : None.
* Return         : None.
*******************************************************************************/
void Virtual_Com_Port_init(void)
{
 8012768:	b580      	push	{r7, lr}
 801276a:	af00      	add	r7, sp, #0

  /* Update the serial number string descriptor with the data from the unique
  ID*/
  Get_SerialNum();
 801276c:	4b07      	ldr	r3, [pc, #28]	; (801278c <Virtual_Com_Port_init+0x24>)
 801276e:	4798      	blx	r3

  pInformation->Current_Configuration = 0;
 8012770:	4b07      	ldr	r3, [pc, #28]	; (8012790 <Virtual_Com_Port_init+0x28>)
 8012772:	681b      	ldr	r3, [r3, #0]
 8012774:	2200      	movs	r2, #0
 8012776:	729a      	strb	r2, [r3, #10]

  /* Connect the device */
  PowerOn();
 8012778:	4b06      	ldr	r3, [pc, #24]	; (8012794 <Virtual_Com_Port_init+0x2c>)
 801277a:	4798      	blx	r3

  /* Perform basic device initialization operations */
  USB_SIL_Init();
 801277c:	4b06      	ldr	r3, [pc, #24]	; (8012798 <Virtual_Com_Port_init+0x30>)
 801277e:	4798      	blx	r3

  /* configure the USART to the default settings */
 // USART_Config_Default();

  bDeviceState = UNCONNECTED;
 8012780:	4b06      	ldr	r3, [pc, #24]	; (801279c <Virtual_Com_Port_init+0x34>)
 8012782:	2200      	movs	r2, #0
 8012784:	601a      	str	r2, [r3, #0]
}
 8012786:	bf00      	nop
 8012788:	bd80      	pop	{r7, pc}
 801278a:	bf00      	nop
 801278c:	08012b51 	.word	0x08012b51
 8012790:	200096d0 	.word	0x200096d0
 8012794:	08012ac9 	.word	0x08012ac9
 8012798:	080144f5 	.word	0x080144f5
 801279c:	200096c8 	.word	0x200096c8

080127a0 <Virtual_Com_Port_Reset>:
* Input          : None.
* Output         : None.
* Return         : None.
*******************************************************************************/
void Virtual_Com_Port_Reset(void)
{
 80127a0:	b580      	push	{r7, lr}
 80127a2:	af00      	add	r7, sp, #0
  /* Set Virtual_Com_Port DEVICE as not configured */
  pInformation->Current_Configuration = 0;
 80127a4:	4b37      	ldr	r3, [pc, #220]	; (8012884 <Virtual_Com_Port_Reset+0xe4>)
 80127a6:	681b      	ldr	r3, [r3, #0]
 80127a8:	2200      	movs	r2, #0
 80127aa:	729a      	strb	r2, [r3, #10]

  /* Current Feature initialization */
  pInformation->Current_Feature = Virtual_Com_Port_ConfigDescriptor[7];
 80127ac:	4b35      	ldr	r3, [pc, #212]	; (8012884 <Virtual_Com_Port_Reset+0xe4>)
 80127ae:	681b      	ldr	r3, [r3, #0]
 80127b0:	4a35      	ldr	r2, [pc, #212]	; (8012888 <Virtual_Com_Port_Reset+0xe8>)
 80127b2:	79d2      	ldrb	r2, [r2, #7]
 80127b4:	725a      	strb	r2, [r3, #9]

  /* Set Virtual_Com_Port DEVICE with the default Interface*/
  pInformation->Current_Interface = 0;
 80127b6:	4b33      	ldr	r3, [pc, #204]	; (8012884 <Virtual_Com_Port_Reset+0xe4>)
 80127b8:	681b      	ldr	r3, [r3, #0]
 80127ba:	2200      	movs	r2, #0
 80127bc:	72da      	strb	r2, [r3, #11]

  /* Init EP3 OUT as Bulk endpoint */
  OTG_DEV_EP_Init(EP3_OUT, OTG_DEV_EP_TYPE_BULK, VIRTUAL_COM_PORT_DATA_SIZE);
#else

  SetBTABLE(BTABLE_ADDRESS);
 80127be:	2000      	movs	r0, #0
 80127c0:	4b32      	ldr	r3, [pc, #200]	; (801288c <Virtual_Com_Port_Reset+0xec>)
 80127c2:	4798      	blx	r3

  /* Initialize Endpoint 0 */
  SetEPType(ENDP0, EP_CONTROL);
 80127c4:	f44f 7100 	mov.w	r1, #512	; 0x200
 80127c8:	2000      	movs	r0, #0
 80127ca:	4b31      	ldr	r3, [pc, #196]	; (8012890 <Virtual_Com_Port_Reset+0xf0>)
 80127cc:	4798      	blx	r3
  SetEPTxStatus(ENDP0, EP_TX_STALL);
 80127ce:	2110      	movs	r1, #16
 80127d0:	2000      	movs	r0, #0
 80127d2:	4b30      	ldr	r3, [pc, #192]	; (8012894 <Virtual_Com_Port_Reset+0xf4>)
 80127d4:	4798      	blx	r3
  SetEPRxAddr(ENDP0, ENDP0_RXADDR);
 80127d6:	2140      	movs	r1, #64	; 0x40
 80127d8:	2000      	movs	r0, #0
 80127da:	4b2f      	ldr	r3, [pc, #188]	; (8012898 <Virtual_Com_Port_Reset+0xf8>)
 80127dc:	4798      	blx	r3
  SetEPTxAddr(ENDP0, ENDP0_TXADDR);
 80127de:	2180      	movs	r1, #128	; 0x80
 80127e0:	2000      	movs	r0, #0
 80127e2:	4b2e      	ldr	r3, [pc, #184]	; (801289c <Virtual_Com_Port_Reset+0xfc>)
 80127e4:	4798      	blx	r3
  Clear_Status_Out(ENDP0);
 80127e6:	2000      	movs	r0, #0
 80127e8:	4b2d      	ldr	r3, [pc, #180]	; (80128a0 <Virtual_Com_Port_Reset+0x100>)
 80127ea:	4798      	blx	r3
  SetEPRxCount(ENDP0, Device_Property.MaxPacketSize);
 80127ec:	4b2d      	ldr	r3, [pc, #180]	; (80128a4 <Virtual_Com_Port_Reset+0x104>)
 80127ee:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 80127f2:	b29b      	uxth	r3, r3
 80127f4:	4619      	mov	r1, r3
 80127f6:	2000      	movs	r0, #0
 80127f8:	4b2b      	ldr	r3, [pc, #172]	; (80128a8 <Virtual_Com_Port_Reset+0x108>)
 80127fa:	4798      	blx	r3
  SetEPRxValid(ENDP0);
 80127fc:	2000      	movs	r0, #0
 80127fe:	4b2b      	ldr	r3, [pc, #172]	; (80128ac <Virtual_Com_Port_Reset+0x10c>)
 8012800:	4798      	blx	r3

  /* Initialize Endpoint 1 */
  SetEPType(ENDP1, EP_BULK);
 8012802:	2100      	movs	r1, #0
 8012804:	2001      	movs	r0, #1
 8012806:	4b22      	ldr	r3, [pc, #136]	; (8012890 <Virtual_Com_Port_Reset+0xf0>)
 8012808:	4798      	blx	r3
  SetEPTxAddr(ENDP1, ENDP1_TXADDR);
 801280a:	21c0      	movs	r1, #192	; 0xc0
 801280c:	2001      	movs	r0, #1
 801280e:	4b23      	ldr	r3, [pc, #140]	; (801289c <Virtual_Com_Port_Reset+0xfc>)
 8012810:	4798      	blx	r3
  SetEPTxStatus(ENDP1, EP_TX_NAK);
 8012812:	2120      	movs	r1, #32
 8012814:	2001      	movs	r0, #1
 8012816:	4b1f      	ldr	r3, [pc, #124]	; (8012894 <Virtual_Com_Port_Reset+0xf4>)
 8012818:	4798      	blx	r3
  SetEPRxStatus(ENDP1, EP_RX_DIS);
 801281a:	2100      	movs	r1, #0
 801281c:	2001      	movs	r0, #1
 801281e:	4b24      	ldr	r3, [pc, #144]	; (80128b0 <Virtual_Com_Port_Reset+0x110>)
 8012820:	4798      	blx	r3

  /* Initialize Endpoint 2 */
  SetEPType(ENDP2, EP_INTERRUPT);
 8012822:	f44f 61c0 	mov.w	r1, #1536	; 0x600
 8012826:	2002      	movs	r0, #2
 8012828:	4b19      	ldr	r3, [pc, #100]	; (8012890 <Virtual_Com_Port_Reset+0xf0>)
 801282a:	4798      	blx	r3
  SetEPTxAddr(ENDP2, ENDP2_TXADDR);
 801282c:	f44f 7180 	mov.w	r1, #256	; 0x100
 8012830:	2002      	movs	r0, #2
 8012832:	4b1a      	ldr	r3, [pc, #104]	; (801289c <Virtual_Com_Port_Reset+0xfc>)
 8012834:	4798      	blx	r3
  SetEPRxStatus(ENDP2, EP_RX_DIS);
 8012836:	2100      	movs	r1, #0
 8012838:	2002      	movs	r0, #2
 801283a:	4b1d      	ldr	r3, [pc, #116]	; (80128b0 <Virtual_Com_Port_Reset+0x110>)
 801283c:	4798      	blx	r3
  SetEPTxStatus(ENDP2, EP_TX_NAK);
 801283e:	2120      	movs	r1, #32
 8012840:	2002      	movs	r0, #2
 8012842:	4b14      	ldr	r3, [pc, #80]	; (8012894 <Virtual_Com_Port_Reset+0xf4>)
 8012844:	4798      	blx	r3

  /* Initialize Endpoint 3 */
  SetEPType(ENDP3, EP_BULK);
 8012846:	2100      	movs	r1, #0
 8012848:	2003      	movs	r0, #3
 801284a:	4b11      	ldr	r3, [pc, #68]	; (8012890 <Virtual_Com_Port_Reset+0xf0>)
 801284c:	4798      	blx	r3
  SetEPRxAddr(ENDP3, ENDP3_RXADDR);
 801284e:	f44f 7188 	mov.w	r1, #272	; 0x110
 8012852:	2003      	movs	r0, #3
 8012854:	4b10      	ldr	r3, [pc, #64]	; (8012898 <Virtual_Com_Port_Reset+0xf8>)
 8012856:	4798      	blx	r3
  SetEPRxCount(ENDP3, VIRTUAL_COM_PORT_DATA_SIZE);
 8012858:	2140      	movs	r1, #64	; 0x40
 801285a:	2003      	movs	r0, #3
 801285c:	4b12      	ldr	r3, [pc, #72]	; (80128a8 <Virtual_Com_Port_Reset+0x108>)
 801285e:	4798      	blx	r3
  SetEPRxStatus(ENDP3, EP_RX_VALID);
 8012860:	f44f 5140 	mov.w	r1, #12288	; 0x3000
 8012864:	2003      	movs	r0, #3
 8012866:	4b12      	ldr	r3, [pc, #72]	; (80128b0 <Virtual_Com_Port_Reset+0x110>)
 8012868:	4798      	blx	r3
  SetEPTxStatus(ENDP3, EP_TX_DIS);
 801286a:	2100      	movs	r1, #0
 801286c:	2003      	movs	r0, #3
 801286e:	4b09      	ldr	r3, [pc, #36]	; (8012894 <Virtual_Com_Port_Reset+0xf4>)
 8012870:	4798      	blx	r3

  /* Set this device to response on default address */
  SetDeviceAddress(0);
 8012872:	2000      	movs	r0, #0
 8012874:	4b0f      	ldr	r3, [pc, #60]	; (80128b4 <Virtual_Com_Port_Reset+0x114>)
 8012876:	4798      	blx	r3
#endif /* STM32F10X_CL */

  bDeviceState = ATTACHED;
 8012878:	4b0f      	ldr	r3, [pc, #60]	; (80128b8 <Virtual_Com_Port_Reset+0x118>)
 801287a:	2201      	movs	r2, #1
 801287c:	601a      	str	r2, [r3, #0]
}
 801287e:	bf00      	nop
 8012880:	bd80      	pop	{r7, pc}
 8012882:	bf00      	nop
 8012884:	200096d0 	.word	0x200096d0
 8012888:	08015788 	.word	0x08015788
 801288c:	08013fe9 	.word	0x08013fe9
 8012890:	0801400d 	.word	0x0801400d
 8012894:	08014059 	.word	0x08014059
 8012898:	0801431d 	.word	0x0801431d
 801289c:	080142dd 	.word	0x080142dd
 80128a0:	080141e1 	.word	0x080141e1
 80128a4:	200001c8 	.word	0x200001c8
 80128a8:	08014405 	.word	0x08014405
 80128ac:	0801418d 	.word	0x0801418d
 80128b0:	080140c9 	.word	0x080140c9
 80128b4:	08013b81 	.word	0x08013b81
 80128b8:	200096c8 	.word	0x200096c8

080128bc <Virtual_Com_Port_Status_In>:
* Input          : None.
* Output         : None.
* Return         : None.
*******************************************************************************/
void Virtual_Com_Port_Status_In(void)
{
 80128bc:	b480      	push	{r7}
 80128be:	af00      	add	r7, sp, #0
  if (Request == SET_LINE_CODING)
 80128c0:	4b05      	ldr	r3, [pc, #20]	; (80128d8 <Virtual_Com_Port_Status_In+0x1c>)
 80128c2:	781b      	ldrb	r3, [r3, #0]
 80128c4:	2b20      	cmp	r3, #32
 80128c6:	d102      	bne.n	80128ce <Virtual_Com_Port_Status_In+0x12>
  {
  //  USART_Config();
    Request = 0;
 80128c8:	4b03      	ldr	r3, [pc, #12]	; (80128d8 <Virtual_Com_Port_Status_In+0x1c>)
 80128ca:	2200      	movs	r2, #0
 80128cc:	701a      	strb	r2, [r3, #0]
  }
}
 80128ce:	bf00      	nop
 80128d0:	46bd      	mov	sp, r7
 80128d2:	bc80      	pop	{r7}
 80128d4:	4770      	bx	lr
 80128d6:	bf00      	nop
 80128d8:	200096c7 	.word	0x200096c7

080128dc <Virtual_Com_Port_Status_Out>:
* Input          : None.
* Output         : None.
* Return         : None.
*******************************************************************************/
void Virtual_Com_Port_Status_Out(void)
{}
 80128dc:	b480      	push	{r7}
 80128de:	af00      	add	r7, sp, #0
 80128e0:	bf00      	nop
 80128e2:	46bd      	mov	sp, r7
 80128e4:	bc80      	pop	{r7}
 80128e6:	4770      	bx	lr

080128e8 <Virtual_Com_Port_Data_Setup>:
* Input          : Request Nb.
* Output         : None.
* Return         : USB_UNSUPPORT or USB_SUCCESS.
*******************************************************************************/
RESULT Virtual_Com_Port_Data_Setup(uint8_t RequestNo)
{
 80128e8:	b580      	push	{r7, lr}
 80128ea:	b084      	sub	sp, #16
 80128ec:	af00      	add	r7, sp, #0
 80128ee:	4603      	mov	r3, r0
 80128f0:	71fb      	strb	r3, [r7, #7]
  uint8_t    *(*CopyRoutine)(uint16_t);

  CopyRoutine = NULL;
 80128f2:	2300      	movs	r3, #0
 80128f4:	60fb      	str	r3, [r7, #12]

  if (RequestNo == GET_LINE_CODING)
 80128f6:	79fb      	ldrb	r3, [r7, #7]
 80128f8:	2b21      	cmp	r3, #33	; 0x21
 80128fa:	d109      	bne.n	8012910 <Virtual_Com_Port_Data_Setup+0x28>
  {
    if (Type_Recipient == (CLASS_REQUEST | INTERFACE_RECIPIENT))
 80128fc:	4b16      	ldr	r3, [pc, #88]	; (8012958 <Virtual_Com_Port_Data_Setup+0x70>)
 80128fe:	681b      	ldr	r3, [r3, #0]
 8012900:	781b      	ldrb	r3, [r3, #0]
 8012902:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8012906:	2b21      	cmp	r3, #33	; 0x21
 8012908:	d111      	bne.n	801292e <Virtual_Com_Port_Data_Setup+0x46>
    {
      CopyRoutine = Virtual_Com_Port_GetLineCoding;
 801290a:	4b14      	ldr	r3, [pc, #80]	; (801295c <Virtual_Com_Port_Data_Setup+0x74>)
 801290c:	60fb      	str	r3, [r7, #12]
 801290e:	e00e      	b.n	801292e <Virtual_Com_Port_Data_Setup+0x46>
    }
  }
  else if (RequestNo == SET_LINE_CODING)
 8012910:	79fb      	ldrb	r3, [r7, #7]
 8012912:	2b20      	cmp	r3, #32
 8012914:	d10b      	bne.n	801292e <Virtual_Com_Port_Data_Setup+0x46>
  {
    if (Type_Recipient == (CLASS_REQUEST | INTERFACE_RECIPIENT))
 8012916:	4b10      	ldr	r3, [pc, #64]	; (8012958 <Virtual_Com_Port_Data_Setup+0x70>)
 8012918:	681b      	ldr	r3, [r3, #0]
 801291a:	781b      	ldrb	r3, [r3, #0]
 801291c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8012920:	2b21      	cmp	r3, #33	; 0x21
 8012922:	d101      	bne.n	8012928 <Virtual_Com_Port_Data_Setup+0x40>
    {
      CopyRoutine = Virtual_Com_Port_SetLineCoding;
 8012924:	4b0e      	ldr	r3, [pc, #56]	; (8012960 <Virtual_Com_Port_Data_Setup+0x78>)
 8012926:	60fb      	str	r3, [r7, #12]
    }
    Request = SET_LINE_CODING;
 8012928:	4b0e      	ldr	r3, [pc, #56]	; (8012964 <Virtual_Com_Port_Data_Setup+0x7c>)
 801292a:	2220      	movs	r2, #32
 801292c:	701a      	strb	r2, [r3, #0]
  }

  if (CopyRoutine == NULL)
 801292e:	68fb      	ldr	r3, [r7, #12]
 8012930:	2b00      	cmp	r3, #0
 8012932:	d101      	bne.n	8012938 <Virtual_Com_Port_Data_Setup+0x50>
  {
    return USB_UNSUPPORT;
 8012934:	2302      	movs	r3, #2
 8012936:	e00b      	b.n	8012950 <Virtual_Com_Port_Data_Setup+0x68>
  }

  pInformation->Ctrl_Info.CopyData = CopyRoutine;
 8012938:	4b07      	ldr	r3, [pc, #28]	; (8012958 <Virtual_Com_Port_Data_Setup+0x70>)
 801293a:	681b      	ldr	r3, [r3, #0]
 801293c:	68fa      	ldr	r2, [r7, #12]
 801293e:	619a      	str	r2, [r3, #24]
  pInformation->Ctrl_Info.Usb_wOffset = 0;
 8012940:	4b05      	ldr	r3, [pc, #20]	; (8012958 <Virtual_Com_Port_Data_Setup+0x70>)
 8012942:	681b      	ldr	r3, [r3, #0]
 8012944:	2200      	movs	r2, #0
 8012946:	825a      	strh	r2, [r3, #18]
  (*CopyRoutine)(0);
 8012948:	68fb      	ldr	r3, [r7, #12]
 801294a:	2000      	movs	r0, #0
 801294c:	4798      	blx	r3
  return USB_SUCCESS;
 801294e:	2300      	movs	r3, #0
}
 8012950:	4618      	mov	r0, r3
 8012952:	3710      	adds	r7, #16
 8012954:	46bd      	mov	sp, r7
 8012956:	bd80      	pop	{r7, pc}
 8012958:	200096d0 	.word	0x200096d0
 801295c:	08012a69 	.word	0x08012a69
 8012960:	08012a99 	.word	0x08012a99
 8012964:	200096c7 	.word	0x200096c7

08012968 <Virtual_Com_Port_NoData_Setup>:
* Input          : Request Nb.
* Output         : None.
* Return         : USB_UNSUPPORT or USB_SUCCESS.
*******************************************************************************/
RESULT Virtual_Com_Port_NoData_Setup(uint8_t RequestNo)
{
 8012968:	b480      	push	{r7}
 801296a:	b083      	sub	sp, #12
 801296c:	af00      	add	r7, sp, #0
 801296e:	4603      	mov	r3, r0
 8012970:	71fb      	strb	r3, [r7, #7]

  if (Type_Recipient == (CLASS_REQUEST | INTERFACE_RECIPIENT))
 8012972:	4b0b      	ldr	r3, [pc, #44]	; (80129a0 <Virtual_Com_Port_NoData_Setup+0x38>)
 8012974:	681b      	ldr	r3, [r3, #0]
 8012976:	781b      	ldrb	r3, [r3, #0]
 8012978:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 801297c:	2b21      	cmp	r3, #33	; 0x21
 801297e:	d109      	bne.n	8012994 <Virtual_Com_Port_NoData_Setup+0x2c>
  {
    if (RequestNo == SET_COMM_FEATURE)
 8012980:	79fb      	ldrb	r3, [r7, #7]
 8012982:	2b02      	cmp	r3, #2
 8012984:	d101      	bne.n	801298a <Virtual_Com_Port_NoData_Setup+0x22>
    {
      return USB_SUCCESS;
 8012986:	2300      	movs	r3, #0
 8012988:	e005      	b.n	8012996 <Virtual_Com_Port_NoData_Setup+0x2e>
    }
    else if (RequestNo == SET_CONTROL_LINE_STATE)
 801298a:	79fb      	ldrb	r3, [r7, #7]
 801298c:	2b22      	cmp	r3, #34	; 0x22
 801298e:	d101      	bne.n	8012994 <Virtual_Com_Port_NoData_Setup+0x2c>
    {
      return USB_SUCCESS;
 8012990:	2300      	movs	r3, #0
 8012992:	e000      	b.n	8012996 <Virtual_Com_Port_NoData_Setup+0x2e>
    }
  }

  return USB_UNSUPPORT;
 8012994:	2302      	movs	r3, #2
}
 8012996:	4618      	mov	r0, r3
 8012998:	370c      	adds	r7, #12
 801299a:	46bd      	mov	sp, r7
 801299c:	bc80      	pop	{r7}
 801299e:	4770      	bx	lr
 80129a0:	200096d0 	.word	0x200096d0

080129a4 <Virtual_Com_Port_GetDeviceDescriptor>:
* Input          : Length.
* Output         : None.
* Return         : The address of the device descriptor.
*******************************************************************************/
uint8_t *Virtual_Com_Port_GetDeviceDescriptor(uint16_t Length)
{
 80129a4:	b580      	push	{r7, lr}
 80129a6:	b082      	sub	sp, #8
 80129a8:	af00      	add	r7, sp, #0
 80129aa:	4603      	mov	r3, r0
 80129ac:	80fb      	strh	r3, [r7, #6]
  return Standard_GetDescriptorData(Length, &Device_Descriptor);
 80129ae:	88fb      	ldrh	r3, [r7, #6]
 80129b0:	4904      	ldr	r1, [pc, #16]	; (80129c4 <Virtual_Com_Port_GetDeviceDescriptor+0x20>)
 80129b2:	4618      	mov	r0, r3
 80129b4:	4b04      	ldr	r3, [pc, #16]	; (80129c8 <Virtual_Com_Port_GetDeviceDescriptor+0x24>)
 80129b6:	4798      	blx	r3
 80129b8:	4603      	mov	r3, r0
}
 80129ba:	4618      	mov	r0, r3
 80129bc:	3708      	adds	r7, #8
 80129be:	46bd      	mov	sp, r7
 80129c0:	bd80      	pop	{r7, pc}
 80129c2:	bf00      	nop
 80129c4:	200001f8 	.word	0x200001f8
 80129c8:	080131d9 	.word	0x080131d9

080129cc <Virtual_Com_Port_GetConfigDescriptor>:
* Input          : Length.
* Output         : None.
* Return         : The address of the configuration descriptor.
*******************************************************************************/
uint8_t *Virtual_Com_Port_GetConfigDescriptor(uint16_t Length)
{
 80129cc:	b580      	push	{r7, lr}
 80129ce:	b082      	sub	sp, #8
 80129d0:	af00      	add	r7, sp, #0
 80129d2:	4603      	mov	r3, r0
 80129d4:	80fb      	strh	r3, [r7, #6]
  return Standard_GetDescriptorData(Length, &Config_Descriptor);
 80129d6:	88fb      	ldrh	r3, [r7, #6]
 80129d8:	4904      	ldr	r1, [pc, #16]	; (80129ec <Virtual_Com_Port_GetConfigDescriptor+0x20>)
 80129da:	4618      	mov	r0, r3
 80129dc:	4b04      	ldr	r3, [pc, #16]	; (80129f0 <Virtual_Com_Port_GetConfigDescriptor+0x24>)
 80129de:	4798      	blx	r3
 80129e0:	4603      	mov	r3, r0
}
 80129e2:	4618      	mov	r0, r3
 80129e4:	3708      	adds	r7, #8
 80129e6:	46bd      	mov	sp, r7
 80129e8:	bd80      	pop	{r7, pc}
 80129ea:	bf00      	nop
 80129ec:	20000200 	.word	0x20000200
 80129f0:	080131d9 	.word	0x080131d9

080129f4 <Virtual_Com_Port_GetStringDescriptor>:
* Input          : Length.
* Output         : None.
* Return         : The address of the string descriptors.
*******************************************************************************/
uint8_t *Virtual_Com_Port_GetStringDescriptor(uint16_t Length)
{
 80129f4:	b580      	push	{r7, lr}
 80129f6:	b084      	sub	sp, #16
 80129f8:	af00      	add	r7, sp, #0
 80129fa:	4603      	mov	r3, r0
 80129fc:	80fb      	strh	r3, [r7, #6]
  uint8_t wValue0 = pInformation->USBwValue0;
 80129fe:	4b0b      	ldr	r3, [pc, #44]	; (8012a2c <Virtual_Com_Port_GetStringDescriptor+0x38>)
 8012a00:	681b      	ldr	r3, [r3, #0]
 8012a02:	78db      	ldrb	r3, [r3, #3]
 8012a04:	73fb      	strb	r3, [r7, #15]
  if (wValue0 > 4)
 8012a06:	7bfb      	ldrb	r3, [r7, #15]
 8012a08:	2b04      	cmp	r3, #4
 8012a0a:	d901      	bls.n	8012a10 <Virtual_Com_Port_GetStringDescriptor+0x1c>
  {
    return NULL;
 8012a0c:	2300      	movs	r3, #0
 8012a0e:	e009      	b.n	8012a24 <Virtual_Com_Port_GetStringDescriptor+0x30>
  }
  else
  {
    return Standard_GetDescriptorData(Length, &String_Descriptor[wValue0]);
 8012a10:	7bfb      	ldrb	r3, [r7, #15]
 8012a12:	00db      	lsls	r3, r3, #3
 8012a14:	4a06      	ldr	r2, [pc, #24]	; (8012a30 <Virtual_Com_Port_GetStringDescriptor+0x3c>)
 8012a16:	441a      	add	r2, r3
 8012a18:	88fb      	ldrh	r3, [r7, #6]
 8012a1a:	4611      	mov	r1, r2
 8012a1c:	4618      	mov	r0, r3
 8012a1e:	4b05      	ldr	r3, [pc, #20]	; (8012a34 <Virtual_Com_Port_GetStringDescriptor+0x40>)
 8012a20:	4798      	blx	r3
 8012a22:	4603      	mov	r3, r0
  }
}
 8012a24:	4618      	mov	r0, r3
 8012a26:	3710      	adds	r7, #16
 8012a28:	46bd      	mov	sp, r7
 8012a2a:	bd80      	pop	{r7, pc}
 8012a2c:	200096d0 	.word	0x200096d0
 8012a30:	20000208 	.word	0x20000208
 8012a34:	080131d9 	.word	0x080131d9

08012a38 <Virtual_Com_Port_Get_Interface_Setting>:
* Input2         : uint8_t: AlternateSetting : Alternate Setting number.
* Output         : None.
* Return         : The address of the string descriptors.
*******************************************************************************/
RESULT Virtual_Com_Port_Get_Interface_Setting(uint8_t Interface, uint8_t AlternateSetting)
{
 8012a38:	b480      	push	{r7}
 8012a3a:	b083      	sub	sp, #12
 8012a3c:	af00      	add	r7, sp, #0
 8012a3e:	4603      	mov	r3, r0
 8012a40:	460a      	mov	r2, r1
 8012a42:	71fb      	strb	r3, [r7, #7]
 8012a44:	4613      	mov	r3, r2
 8012a46:	71bb      	strb	r3, [r7, #6]
  if (AlternateSetting > 0)
 8012a48:	79bb      	ldrb	r3, [r7, #6]
 8012a4a:	2b00      	cmp	r3, #0
 8012a4c:	d001      	beq.n	8012a52 <Virtual_Com_Port_Get_Interface_Setting+0x1a>
  {
    return USB_UNSUPPORT;
 8012a4e:	2302      	movs	r3, #2
 8012a50:	e005      	b.n	8012a5e <Virtual_Com_Port_Get_Interface_Setting+0x26>
  }
  else if (Interface > 1)
 8012a52:	79fb      	ldrb	r3, [r7, #7]
 8012a54:	2b01      	cmp	r3, #1
 8012a56:	d901      	bls.n	8012a5c <Virtual_Com_Port_Get_Interface_Setting+0x24>
  {
    return USB_UNSUPPORT;
 8012a58:	2302      	movs	r3, #2
 8012a5a:	e000      	b.n	8012a5e <Virtual_Com_Port_Get_Interface_Setting+0x26>
  }
  return USB_SUCCESS;
 8012a5c:	2300      	movs	r3, #0
}
 8012a5e:	4618      	mov	r0, r3
 8012a60:	370c      	adds	r7, #12
 8012a62:	46bd      	mov	sp, r7
 8012a64:	bc80      	pop	{r7}
 8012a66:	4770      	bx	lr

08012a68 <Virtual_Com_Port_GetLineCoding>:
* Input          : Length.
* Output         : None.
* Return         : Inecoding structure base address.
*******************************************************************************/
uint8_t *Virtual_Com_Port_GetLineCoding(uint16_t Length)
{
 8012a68:	b480      	push	{r7}
 8012a6a:	b083      	sub	sp, #12
 8012a6c:	af00      	add	r7, sp, #0
 8012a6e:	4603      	mov	r3, r0
 8012a70:	80fb      	strh	r3, [r7, #6]
  if (Length == 0)
 8012a72:	88fb      	ldrh	r3, [r7, #6]
 8012a74:	2b00      	cmp	r3, #0
 8012a76:	d105      	bne.n	8012a84 <Virtual_Com_Port_GetLineCoding+0x1c>
  {
    pInformation->Ctrl_Info.Usb_wLength = sizeof(linecoding);
 8012a78:	4b05      	ldr	r3, [pc, #20]	; (8012a90 <Virtual_Com_Port_GetLineCoding+0x28>)
 8012a7a:	681b      	ldr	r3, [r3, #0]
 8012a7c:	2208      	movs	r2, #8
 8012a7e:	821a      	strh	r2, [r3, #16]
    return NULL;
 8012a80:	2300      	movs	r3, #0
 8012a82:	e000      	b.n	8012a86 <Virtual_Com_Port_GetLineCoding+0x1e>
  }
  return(uint8_t *)&linecoding;
 8012a84:	4b03      	ldr	r3, [pc, #12]	; (8012a94 <Virtual_Com_Port_GetLineCoding+0x2c>)
}
 8012a86:	4618      	mov	r0, r3
 8012a88:	370c      	adds	r7, #12
 8012a8a:	46bd      	mov	sp, r7
 8012a8c:	bc80      	pop	{r7}
 8012a8e:	4770      	bx	lr
 8012a90:	200096d0 	.word	0x200096d0
 8012a94:	200001bc 	.word	0x200001bc

08012a98 <Virtual_Com_Port_SetLineCoding>:
* Input          : Length.
* Output         : None.
* Return         : Linecoding structure base address.
*******************************************************************************/
uint8_t *Virtual_Com_Port_SetLineCoding(uint16_t Length)
{
 8012a98:	b480      	push	{r7}
 8012a9a:	b083      	sub	sp, #12
 8012a9c:	af00      	add	r7, sp, #0
 8012a9e:	4603      	mov	r3, r0
 8012aa0:	80fb      	strh	r3, [r7, #6]
  if (Length == 0)
 8012aa2:	88fb      	ldrh	r3, [r7, #6]
 8012aa4:	2b00      	cmp	r3, #0
 8012aa6:	d105      	bne.n	8012ab4 <Virtual_Com_Port_SetLineCoding+0x1c>
  {
    pInformation->Ctrl_Info.Usb_wLength = sizeof(linecoding);
 8012aa8:	4b05      	ldr	r3, [pc, #20]	; (8012ac0 <Virtual_Com_Port_SetLineCoding+0x28>)
 8012aaa:	681b      	ldr	r3, [r3, #0]
 8012aac:	2208      	movs	r2, #8
 8012aae:	821a      	strh	r2, [r3, #16]
    return NULL;
 8012ab0:	2300      	movs	r3, #0
 8012ab2:	e000      	b.n	8012ab6 <Virtual_Com_Port_SetLineCoding+0x1e>
  }
  return(uint8_t *)&linecoding;
 8012ab4:	4b03      	ldr	r3, [pc, #12]	; (8012ac4 <Virtual_Com_Port_SetLineCoding+0x2c>)
}
 8012ab6:	4618      	mov	r0, r3
 8012ab8:	370c      	adds	r7, #12
 8012aba:	46bd      	mov	sp, r7
 8012abc:	bc80      	pop	{r7}
 8012abe:	4770      	bx	lr
 8012ac0:	200096d0 	.word	0x200096d0
 8012ac4:	200001bc 	.word	0x200001bc

08012ac8 <PowerOn>:
* Input          : None.
* Output         : None.
* Return         : USB_SUCCESS.
*******************************************************************************/
RESULT PowerOn(void)
{
 8012ac8:	b580      	push	{r7, lr}
 8012aca:	b082      	sub	sp, #8
 8012acc:	af00      	add	r7, sp, #0
#ifndef STM32F10X_CL
  uint16_t wRegVal;

  /*** cable plugged-in ? ***/
  USB_Cable_Config(ENABLE);
 8012ace:	2001      	movs	r0, #1
 8012ad0:	4b0e      	ldr	r3, [pc, #56]	; (8012b0c <PowerOn+0x44>)
 8012ad2:	4798      	blx	r3

  /*** CNTR_PWDN = 0 ***/
  wRegVal = CNTR_FRES;
 8012ad4:	2301      	movs	r3, #1
 8012ad6:	80fb      	strh	r3, [r7, #6]
  _SetCNTR(wRegVal);
 8012ad8:	4a0d      	ldr	r2, [pc, #52]	; (8012b10 <PowerOn+0x48>)
 8012ada:	88fb      	ldrh	r3, [r7, #6]
 8012adc:	6013      	str	r3, [r2, #0]

  /*** CNTR_FRES = 0 ***/
  wInterrupt_Mask = 0;
 8012ade:	4b0d      	ldr	r3, [pc, #52]	; (8012b14 <PowerOn+0x4c>)
 8012ae0:	2200      	movs	r2, #0
 8012ae2:	801a      	strh	r2, [r3, #0]
  _SetCNTR(wInterrupt_Mask);
 8012ae4:	4b0b      	ldr	r3, [pc, #44]	; (8012b14 <PowerOn+0x4c>)
 8012ae6:	881a      	ldrh	r2, [r3, #0]
 8012ae8:	4b09      	ldr	r3, [pc, #36]	; (8012b10 <PowerOn+0x48>)
 8012aea:	601a      	str	r2, [r3, #0]
  /*** Clear pending interrupts ***/
  _SetISTR(0);
 8012aec:	4b0a      	ldr	r3, [pc, #40]	; (8012b18 <PowerOn+0x50>)
 8012aee:	2200      	movs	r2, #0
 8012af0:	601a      	str	r2, [r3, #0]
  /*** Set interrupt mask ***/
  wInterrupt_Mask = CNTR_RESETM | CNTR_SUSPM | CNTR_WKUPM;
 8012af2:	4b08      	ldr	r3, [pc, #32]	; (8012b14 <PowerOn+0x4c>)
 8012af4:	f44f 52e0 	mov.w	r2, #7168	; 0x1c00
 8012af8:	801a      	strh	r2, [r3, #0]
  _SetCNTR(wInterrupt_Mask);
 8012afa:	4b06      	ldr	r3, [pc, #24]	; (8012b14 <PowerOn+0x4c>)
 8012afc:	881a      	ldrh	r2, [r3, #0]
 8012afe:	4b04      	ldr	r3, [pc, #16]	; (8012b10 <PowerOn+0x48>)
 8012b00:	601a      	str	r2, [r3, #0]
#endif /* STM32F10X_CL */

  return USB_SUCCESS;
 8012b02:	2300      	movs	r3, #0
}
 8012b04:	4618      	mov	r0, r3
 8012b06:	3708      	adds	r7, #8
 8012b08:	46bd      	mov	sp, r7
 8012b0a:	bd80      	pop	{r7, pc}
 8012b0c:	08012b1d 	.word	0x08012b1d
 8012b10:	40005c40 	.word	0x40005c40
 8012b14:	200096d8 	.word	0x200096d8
 8012b18:	40005c44 	.word	0x40005c44

08012b1c <USB_Cable_Config>:
 * Description    : Software Connection/Disconnection of USB Cable
 * Input          : None.
 * Return         : Status
 *******************************************************************************/
void USB_Cable_Config(FunctionalState NewState)
{
 8012b1c:	b480      	push	{r7}
 8012b1e:	b083      	sub	sp, #12
 8012b20:	af00      	add	r7, sp, #0
 8012b22:	4603      	mov	r3, r0
 8012b24:	71fb      	strb	r3, [r7, #7]
	}
	else
	{
		// GPIO_SetBits(USB_DISCONNECT, USB_DISCONNECT_PIN);
	}
}
 8012b26:	bf00      	nop
 8012b28:	370c      	adds	r7, #12
 8012b2a:	46bd      	mov	sp, r7
 8012b2c:	bc80      	pop	{r7}
 8012b2e:	4770      	bx	lr

08012b30 <Handle_USBAsynchXfer>:
 * Description    : send data to USB.
 * Input          : None.
 * Return         : none.
 *******************************************************************************/
void Handle_USBAsynchXfer(void)
{
 8012b30:	b580      	push	{r7, lr}
 8012b32:	af00      	add	r7, sp, #0

	 //UserToPMABufferCopy("Handle_USBAsynchXfer\n\r", ENDP1_TXADDR, 15);
	  SetEPTxCount(ENDP1, 0);
 8012b34:	2100      	movs	r1, #0
 8012b36:	2001      	movs	r0, #1
 8012b38:	4b03      	ldr	r3, [pc, #12]	; (8012b48 <Handle_USBAsynchXfer+0x18>)
 8012b3a:	4798      	blx	r3
	  SetEPTxValid(ENDP1);
 8012b3c:	2001      	movs	r0, #1
 8012b3e:	4b03      	ldr	r3, [pc, #12]	; (8012b4c <Handle_USBAsynchXfer+0x1c>)
 8012b40:	4798      	blx	r3
}
 8012b42:	bf00      	nop
 8012b44:	bd80      	pop	{r7, pc}
 8012b46:	bf00      	nop
 8012b48:	080143c9 	.word	0x080143c9
 8012b4c:	08014139 	.word	0x08014139

08012b50 <Get_SerialNum>:
 * Input          : None.
 * Output         : None.
 * Return         : None.
 *******************************************************************************/
void Get_SerialNum(void)
{
 8012b50:	b580      	push	{r7, lr}
 8012b52:	b084      	sub	sp, #16
 8012b54:	af00      	add	r7, sp, #0
	uint32_t Device_Serial0, Device_Serial1, Device_Serial2;

	Device_Serial0 = *(__IO uint32_t*) (0x1FFFF7E8);
 8012b56:	4b0f      	ldr	r3, [pc, #60]	; (8012b94 <Get_SerialNum+0x44>)
 8012b58:	681b      	ldr	r3, [r3, #0]
 8012b5a:	60fb      	str	r3, [r7, #12]
	Device_Serial1 = *(__IO uint32_t*) (0x1FFFF7EC);
 8012b5c:	4b0e      	ldr	r3, [pc, #56]	; (8012b98 <Get_SerialNum+0x48>)
 8012b5e:	681b      	ldr	r3, [r3, #0]
 8012b60:	60bb      	str	r3, [r7, #8]
	Device_Serial2 = *(__IO uint32_t*) (0x1FFFF7F0);
 8012b62:	4b0e      	ldr	r3, [pc, #56]	; (8012b9c <Get_SerialNum+0x4c>)
 8012b64:	681b      	ldr	r3, [r3, #0]
 8012b66:	607b      	str	r3, [r7, #4]

	Device_Serial0 += Device_Serial2;
 8012b68:	68fa      	ldr	r2, [r7, #12]
 8012b6a:	687b      	ldr	r3, [r7, #4]
 8012b6c:	4413      	add	r3, r2
 8012b6e:	60fb      	str	r3, [r7, #12]

	if (Device_Serial0 != 0)
 8012b70:	68fb      	ldr	r3, [r7, #12]
 8012b72:	2b00      	cmp	r3, #0
 8012b74:	d009      	beq.n	8012b8a <Get_SerialNum+0x3a>
	{
		IntToUnicode(Device_Serial0, &Virtual_Com_Port_StringSerial[2], 8);
 8012b76:	2208      	movs	r2, #8
 8012b78:	4909      	ldr	r1, [pc, #36]	; (8012ba0 <Get_SerialNum+0x50>)
 8012b7a:	68f8      	ldr	r0, [r7, #12]
 8012b7c:	4b09      	ldr	r3, [pc, #36]	; (8012ba4 <Get_SerialNum+0x54>)
 8012b7e:	4798      	blx	r3
		IntToUnicode(Device_Serial1, &Virtual_Com_Port_StringSerial[18], 4);
 8012b80:	2204      	movs	r2, #4
 8012b82:	4909      	ldr	r1, [pc, #36]	; (8012ba8 <Get_SerialNum+0x58>)
 8012b84:	68b8      	ldr	r0, [r7, #8]
 8012b86:	4b07      	ldr	r3, [pc, #28]	; (8012ba4 <Get_SerialNum+0x54>)
 8012b88:	4798      	blx	r3
	}
}
 8012b8a:	bf00      	nop
 8012b8c:	3710      	adds	r7, #16
 8012b8e:	46bd      	mov	sp, r7
 8012b90:	bd80      	pop	{r7, pc}
 8012b92:	bf00      	nop
 8012b94:	1ffff7e8 	.word	0x1ffff7e8
 8012b98:	1ffff7ec 	.word	0x1ffff7ec
 8012b9c:	1ffff7f0 	.word	0x1ffff7f0
 8012ba0:	2000016a 	.word	0x2000016a
 8012ba4:	08012bad 	.word	0x08012bad
 8012ba8:	2000017a 	.word	0x2000017a

08012bac <IntToUnicode>:
 * Input          : None.
 * Output         : None.
 * Return         : None.
 *******************************************************************************/
static void IntToUnicode(uint32_t value, uint8_t *pbuf, uint8_t len)
{
 8012bac:	b480      	push	{r7}
 8012bae:	b087      	sub	sp, #28
 8012bb0:	af00      	add	r7, sp, #0
 8012bb2:	60f8      	str	r0, [r7, #12]
 8012bb4:	60b9      	str	r1, [r7, #8]
 8012bb6:	4613      	mov	r3, r2
 8012bb8:	71fb      	strb	r3, [r7, #7]
	uint8_t idx = 0;
 8012bba:	2300      	movs	r3, #0
 8012bbc:	75fb      	strb	r3, [r7, #23]

	for (idx = 0; idx < len; idx++)
 8012bbe:	2300      	movs	r3, #0
 8012bc0:	75fb      	strb	r3, [r7, #23]
 8012bc2:	e027      	b.n	8012c14 <IntToUnicode+0x68>
	{
		if (((value >> 28)) < 0xA)
 8012bc4:	68fb      	ldr	r3, [r7, #12]
 8012bc6:	0f1b      	lsrs	r3, r3, #28
 8012bc8:	2b09      	cmp	r3, #9
 8012bca:	d80b      	bhi.n	8012be4 <IntToUnicode+0x38>
		{
			pbuf[2* idx ] = (value >> 28) + '0';
 8012bcc:	68fb      	ldr	r3, [r7, #12]
 8012bce:	0f1b      	lsrs	r3, r3, #28
 8012bd0:	b2da      	uxtb	r2, r3
 8012bd2:	7dfb      	ldrb	r3, [r7, #23]
 8012bd4:	005b      	lsls	r3, r3, #1
 8012bd6:	4619      	mov	r1, r3
 8012bd8:	68bb      	ldr	r3, [r7, #8]
 8012bda:	440b      	add	r3, r1
 8012bdc:	3230      	adds	r2, #48	; 0x30
 8012bde:	b2d2      	uxtb	r2, r2
 8012be0:	701a      	strb	r2, [r3, #0]
 8012be2:	e00a      	b.n	8012bfa <IntToUnicode+0x4e>
		}
		else
		{
			pbuf[2* idx ] = (value >> 28) + 'A' - 10;
 8012be4:	68fb      	ldr	r3, [r7, #12]
 8012be6:	0f1b      	lsrs	r3, r3, #28
 8012be8:	b2da      	uxtb	r2, r3
 8012bea:	7dfb      	ldrb	r3, [r7, #23]
 8012bec:	005b      	lsls	r3, r3, #1
 8012bee:	4619      	mov	r1, r3
 8012bf0:	68bb      	ldr	r3, [r7, #8]
 8012bf2:	440b      	add	r3, r1
 8012bf4:	3237      	adds	r2, #55	; 0x37
 8012bf6:	b2d2      	uxtb	r2, r2
 8012bf8:	701a      	strb	r2, [r3, #0]
		}

		value = value << 4;
 8012bfa:	68fb      	ldr	r3, [r7, #12]
 8012bfc:	011b      	lsls	r3, r3, #4
 8012bfe:	60fb      	str	r3, [r7, #12]

		pbuf[2* idx + 1] = 0;
 8012c00:	7dfb      	ldrb	r3, [r7, #23]
 8012c02:	005b      	lsls	r3, r3, #1
 8012c04:	3301      	adds	r3, #1
 8012c06:	68ba      	ldr	r2, [r7, #8]
 8012c08:	4413      	add	r3, r2
 8012c0a:	2200      	movs	r2, #0
 8012c0c:	701a      	strb	r2, [r3, #0]
	for (idx = 0; idx < len; idx++)
 8012c0e:	7dfb      	ldrb	r3, [r7, #23]
 8012c10:	3301      	adds	r3, #1
 8012c12:	75fb      	strb	r3, [r7, #23]
 8012c14:	7dfa      	ldrb	r2, [r7, #23]
 8012c16:	79fb      	ldrb	r3, [r7, #7]
 8012c18:	429a      	cmp	r2, r3
 8012c1a:	d3d3      	bcc.n	8012bc4 <IntToUnicode+0x18>
	}
}
 8012c1c:	bf00      	nop
 8012c1e:	bf00      	nop
 8012c20:	371c      	adds	r7, #28
 8012c22:	46bd      	mov	sp, r7
 8012c24:	bc80      	pop	{r7}
 8012c26:	4770      	bx	lr

08012c28 <Standard_GetConfiguration>:
* Output         : None.
* Return         : Return 1 , if the request is invalid when "Length" is 0.
*                  Return "Buffer" if the "Length" is not 0.
*******************************************************************************/
uint8_t *Standard_GetConfiguration(uint16_t Length)
{
 8012c28:	b580      	push	{r7, lr}
 8012c2a:	b082      	sub	sp, #8
 8012c2c:	af00      	add	r7, sp, #0
 8012c2e:	4603      	mov	r3, r0
 8012c30:	80fb      	strh	r3, [r7, #6]
  if (Length == 0)
 8012c32:	88fb      	ldrh	r3, [r7, #6]
 8012c34:	2b00      	cmp	r3, #0
 8012c36:	d105      	bne.n	8012c44 <Standard_GetConfiguration+0x1c>
  {
    pInformation->Ctrl_Info.Usb_wLength =
 8012c38:	4b08      	ldr	r3, [pc, #32]	; (8012c5c <Standard_GetConfiguration+0x34>)
 8012c3a:	681b      	ldr	r3, [r3, #0]
 8012c3c:	2201      	movs	r2, #1
 8012c3e:	821a      	strh	r2, [r3, #16]
      sizeof(pInformation->Current_Configuration);
    return 0;
 8012c40:	2300      	movs	r3, #0
 8012c42:	e006      	b.n	8012c52 <Standard_GetConfiguration+0x2a>
  }
  pUser_Standard_Requests->User_GetConfiguration();
 8012c44:	4b06      	ldr	r3, [pc, #24]	; (8012c60 <Standard_GetConfiguration+0x38>)
 8012c46:	681b      	ldr	r3, [r3, #0]
 8012c48:	681b      	ldr	r3, [r3, #0]
 8012c4a:	4798      	blx	r3
  return (uint8_t *)&pInformation->Current_Configuration;
 8012c4c:	4b03      	ldr	r3, [pc, #12]	; (8012c5c <Standard_GetConfiguration+0x34>)
 8012c4e:	681b      	ldr	r3, [r3, #0]
 8012c50:	330a      	adds	r3, #10
}
 8012c52:	4618      	mov	r0, r3
 8012c54:	3708      	adds	r7, #8
 8012c56:	46bd      	mov	sp, r7
 8012c58:	bd80      	pop	{r7, pc}
 8012c5a:	bf00      	nop
 8012c5c:	200096d0 	.word	0x200096d0
 8012c60:	200096dc 	.word	0x200096dc

08012c64 <Standard_SetConfiguration>:
* Output         : None.
* Return         : Return USB_SUCCESS, if the request is performed.
*                  Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_SetConfiguration(void)
{
 8012c64:	b580      	push	{r7, lr}
 8012c66:	af00      	add	r7, sp, #0

  if ((pInformation->USBwValue0 <=
 8012c68:	4b0f      	ldr	r3, [pc, #60]	; (8012ca8 <Standard_SetConfiguration+0x44>)
 8012c6a:	681b      	ldr	r3, [r3, #0]
 8012c6c:	78da      	ldrb	r2, [r3, #3]
      Device_Table.Total_Configuration) && (pInformation->USBwValue1 == 0)
 8012c6e:	4b0f      	ldr	r3, [pc, #60]	; (8012cac <Standard_SetConfiguration+0x48>)
 8012c70:	785b      	ldrb	r3, [r3, #1]
  if ((pInformation->USBwValue0 <=
 8012c72:	429a      	cmp	r2, r3
 8012c74:	d815      	bhi.n	8012ca2 <Standard_SetConfiguration+0x3e>
      Device_Table.Total_Configuration) && (pInformation->USBwValue1 == 0)
 8012c76:	4b0c      	ldr	r3, [pc, #48]	; (8012ca8 <Standard_SetConfiguration+0x44>)
 8012c78:	681b      	ldr	r3, [r3, #0]
 8012c7a:	789b      	ldrb	r3, [r3, #2]
 8012c7c:	2b00      	cmp	r3, #0
 8012c7e:	d110      	bne.n	8012ca2 <Standard_SetConfiguration+0x3e>
      && (pInformation->USBwIndex == 0)) /*call Back usb spec 2.0*/
 8012c80:	4b09      	ldr	r3, [pc, #36]	; (8012ca8 <Standard_SetConfiguration+0x44>)
 8012c82:	681b      	ldr	r3, [r3, #0]
 8012c84:	889b      	ldrh	r3, [r3, #4]
 8012c86:	2b00      	cmp	r3, #0
 8012c88:	d10b      	bne.n	8012ca2 <Standard_SetConfiguration+0x3e>
  {
    pInformation->Current_Configuration = pInformation->USBwValue0;
 8012c8a:	4b07      	ldr	r3, [pc, #28]	; (8012ca8 <Standard_SetConfiguration+0x44>)
 8012c8c:	681a      	ldr	r2, [r3, #0]
 8012c8e:	4b06      	ldr	r3, [pc, #24]	; (8012ca8 <Standard_SetConfiguration+0x44>)
 8012c90:	681b      	ldr	r3, [r3, #0]
 8012c92:	78d2      	ldrb	r2, [r2, #3]
 8012c94:	729a      	strb	r2, [r3, #10]
    pUser_Standard_Requests->User_SetConfiguration();
 8012c96:	4b06      	ldr	r3, [pc, #24]	; (8012cb0 <Standard_SetConfiguration+0x4c>)
 8012c98:	681b      	ldr	r3, [r3, #0]
 8012c9a:	685b      	ldr	r3, [r3, #4]
 8012c9c:	4798      	blx	r3
    return USB_SUCCESS;
 8012c9e:	2300      	movs	r3, #0
 8012ca0:	e000      	b.n	8012ca4 <Standard_SetConfiguration+0x40>
  }
  else
  {
    return USB_UNSUPPORT;
 8012ca2:	2302      	movs	r3, #2
  }
}
 8012ca4:	4618      	mov	r0, r3
 8012ca6:	bd80      	pop	{r7, pc}
 8012ca8:	200096d0 	.word	0x200096d0
 8012cac:	200001c4 	.word	0x200001c4
 8012cb0:	200096dc 	.word	0x200096dc

08012cb4 <Standard_GetInterface>:
* Output         : None.
* Return         : Return 0, if the request is invalid when "Length" is 0.
*                  Return "Buffer" if the "Length" is not 0.
*******************************************************************************/
uint8_t *Standard_GetInterface(uint16_t Length)
{
 8012cb4:	b580      	push	{r7, lr}
 8012cb6:	b082      	sub	sp, #8
 8012cb8:	af00      	add	r7, sp, #0
 8012cba:	4603      	mov	r3, r0
 8012cbc:	80fb      	strh	r3, [r7, #6]
  if (Length == 0)
 8012cbe:	88fb      	ldrh	r3, [r7, #6]
 8012cc0:	2b00      	cmp	r3, #0
 8012cc2:	d105      	bne.n	8012cd0 <Standard_GetInterface+0x1c>
  {
    pInformation->Ctrl_Info.Usb_wLength =
 8012cc4:	4b08      	ldr	r3, [pc, #32]	; (8012ce8 <Standard_GetInterface+0x34>)
 8012cc6:	681b      	ldr	r3, [r3, #0]
 8012cc8:	2201      	movs	r2, #1
 8012cca:	821a      	strh	r2, [r3, #16]
      sizeof(pInformation->Current_AlternateSetting);
    return 0;
 8012ccc:	2300      	movs	r3, #0
 8012cce:	e006      	b.n	8012cde <Standard_GetInterface+0x2a>
  }
  pUser_Standard_Requests->User_GetInterface();
 8012cd0:	4b06      	ldr	r3, [pc, #24]	; (8012cec <Standard_GetInterface+0x38>)
 8012cd2:	681b      	ldr	r3, [r3, #0]
 8012cd4:	689b      	ldr	r3, [r3, #8]
 8012cd6:	4798      	blx	r3
  return (uint8_t *)&pInformation->Current_AlternateSetting;
 8012cd8:	4b03      	ldr	r3, [pc, #12]	; (8012ce8 <Standard_GetInterface+0x34>)
 8012cda:	681b      	ldr	r3, [r3, #0]
 8012cdc:	330c      	adds	r3, #12
}
 8012cde:	4618      	mov	r0, r3
 8012ce0:	3708      	adds	r7, #8
 8012ce2:	46bd      	mov	sp, r7
 8012ce4:	bd80      	pop	{r7, pc}
 8012ce6:	bf00      	nop
 8012ce8:	200096d0 	.word	0x200096d0
 8012cec:	200096dc 	.word	0x200096dc

08012cf0 <Standard_SetInterface>:
* Output         : None.
* Return         : - Return USB_SUCCESS, if the request is performed.
*                  - Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_SetInterface(void)
{
 8012cf0:	b580      	push	{r7, lr}
 8012cf2:	b082      	sub	sp, #8
 8012cf4:	af00      	add	r7, sp, #0
  RESULT Re;
  /*Test if the specified Interface and Alternate Setting are supported by
    the application Firmware*/
  Re = (*pProperty->Class_Get_Interface_Setting)(pInformation->USBwIndex0, pInformation->USBwValue0);
 8012cf6:	4b1d      	ldr	r3, [pc, #116]	; (8012d6c <Standard_SetInterface+0x7c>)
 8012cf8:	681b      	ldr	r3, [r3, #0]
 8012cfa:	699b      	ldr	r3, [r3, #24]
 8012cfc:	4a1c      	ldr	r2, [pc, #112]	; (8012d70 <Standard_SetInterface+0x80>)
 8012cfe:	6812      	ldr	r2, [r2, #0]
 8012d00:	7950      	ldrb	r0, [r2, #5]
 8012d02:	4a1b      	ldr	r2, [pc, #108]	; (8012d70 <Standard_SetInterface+0x80>)
 8012d04:	6812      	ldr	r2, [r2, #0]
 8012d06:	78d2      	ldrb	r2, [r2, #3]
 8012d08:	4611      	mov	r1, r2
 8012d0a:	4798      	blx	r3
 8012d0c:	4603      	mov	r3, r0
 8012d0e:	71fb      	strb	r3, [r7, #7]

  if (pInformation->Current_Configuration != 0)
 8012d10:	4b17      	ldr	r3, [pc, #92]	; (8012d70 <Standard_SetInterface+0x80>)
 8012d12:	681b      	ldr	r3, [r3, #0]
 8012d14:	7a9b      	ldrb	r3, [r3, #10]
 8012d16:	2b00      	cmp	r3, #0
 8012d18:	d023      	beq.n	8012d62 <Standard_SetInterface+0x72>
  {
    if ((Re != USB_SUCCESS) || (pInformation->USBwIndex1 != 0)
 8012d1a:	79fb      	ldrb	r3, [r7, #7]
 8012d1c:	2b00      	cmp	r3, #0
 8012d1e:	d109      	bne.n	8012d34 <Standard_SetInterface+0x44>
 8012d20:	4b13      	ldr	r3, [pc, #76]	; (8012d70 <Standard_SetInterface+0x80>)
 8012d22:	681b      	ldr	r3, [r3, #0]
 8012d24:	791b      	ldrb	r3, [r3, #4]
 8012d26:	2b00      	cmp	r3, #0
 8012d28:	d104      	bne.n	8012d34 <Standard_SetInterface+0x44>
        || (pInformation->USBwValue1 != 0))
 8012d2a:	4b11      	ldr	r3, [pc, #68]	; (8012d70 <Standard_SetInterface+0x80>)
 8012d2c:	681b      	ldr	r3, [r3, #0]
 8012d2e:	789b      	ldrb	r3, [r3, #2]
 8012d30:	2b00      	cmp	r3, #0
 8012d32:	d001      	beq.n	8012d38 <Standard_SetInterface+0x48>
    {
      return  USB_UNSUPPORT;
 8012d34:	2302      	movs	r3, #2
 8012d36:	e015      	b.n	8012d64 <Standard_SetInterface+0x74>
    }
    else if (Re == USB_SUCCESS)
 8012d38:	79fb      	ldrb	r3, [r7, #7]
 8012d3a:	2b00      	cmp	r3, #0
 8012d3c:	d111      	bne.n	8012d62 <Standard_SetInterface+0x72>
    {
      pUser_Standard_Requests->User_SetInterface();
 8012d3e:	4b0d      	ldr	r3, [pc, #52]	; (8012d74 <Standard_SetInterface+0x84>)
 8012d40:	681b      	ldr	r3, [r3, #0]
 8012d42:	68db      	ldr	r3, [r3, #12]
 8012d44:	4798      	blx	r3
      pInformation->Current_Interface = pInformation->USBwIndex0;
 8012d46:	4b0a      	ldr	r3, [pc, #40]	; (8012d70 <Standard_SetInterface+0x80>)
 8012d48:	681a      	ldr	r2, [r3, #0]
 8012d4a:	4b09      	ldr	r3, [pc, #36]	; (8012d70 <Standard_SetInterface+0x80>)
 8012d4c:	681b      	ldr	r3, [r3, #0]
 8012d4e:	7952      	ldrb	r2, [r2, #5]
 8012d50:	72da      	strb	r2, [r3, #11]
      pInformation->Current_AlternateSetting = pInformation->USBwValue0;
 8012d52:	4b07      	ldr	r3, [pc, #28]	; (8012d70 <Standard_SetInterface+0x80>)
 8012d54:	681a      	ldr	r2, [r3, #0]
 8012d56:	4b06      	ldr	r3, [pc, #24]	; (8012d70 <Standard_SetInterface+0x80>)
 8012d58:	681b      	ldr	r3, [r3, #0]
 8012d5a:	78d2      	ldrb	r2, [r2, #3]
 8012d5c:	731a      	strb	r2, [r3, #12]
      return USB_SUCCESS;
 8012d5e:	2300      	movs	r3, #0
 8012d60:	e000      	b.n	8012d64 <Standard_SetInterface+0x74>
    }

  }

  return USB_UNSUPPORT;
 8012d62:	2302      	movs	r3, #2
}
 8012d64:	4618      	mov	r0, r3
 8012d66:	3708      	adds	r7, #8
 8012d68:	46bd      	mov	sp, r7
 8012d6a:	bd80      	pop	{r7, pc}
 8012d6c:	200096d4 	.word	0x200096d4
 8012d70:	200096d0 	.word	0x200096d0
 8012d74:	200096dc 	.word	0x200096dc

08012d78 <Standard_GetStatus>:
* Output         : None.
* Return         : Return 0, if the request is at end of data block,
*                  or is invalid when "Length" is 0.
*******************************************************************************/
uint8_t *Standard_GetStatus(uint16_t Length)
{
 8012d78:	b580      	push	{r7, lr}
 8012d7a:	b084      	sub	sp, #16
 8012d7c:	af00      	add	r7, sp, #0
 8012d7e:	4603      	mov	r3, r0
 8012d80:	80fb      	strh	r3, [r7, #6]
  if (Length == 0)
 8012d82:	88fb      	ldrh	r3, [r7, #6]
 8012d84:	2b00      	cmp	r3, #0
 8012d86:	d105      	bne.n	8012d94 <Standard_GetStatus+0x1c>
  {
    pInformation->Ctrl_Info.Usb_wLength = 2;
 8012d88:	4b46      	ldr	r3, [pc, #280]	; (8012ea4 <Standard_GetStatus+0x12c>)
 8012d8a:	681b      	ldr	r3, [r3, #0]
 8012d8c:	2202      	movs	r2, #2
 8012d8e:	821a      	strh	r2, [r3, #16]
    return 0;
 8012d90:	2300      	movs	r3, #0
 8012d92:	e082      	b.n	8012e9a <Standard_GetStatus+0x122>
  }

  /* Reset Status Information */
  StatusInfo.w = 0;
 8012d94:	4b44      	ldr	r3, [pc, #272]	; (8012ea8 <Standard_GetStatus+0x130>)
 8012d96:	2200      	movs	r2, #0
 8012d98:	801a      	strh	r2, [r3, #0]

  if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
 8012d9a:	4b42      	ldr	r3, [pc, #264]	; (8012ea4 <Standard_GetStatus+0x12c>)
 8012d9c:	681b      	ldr	r3, [r3, #0]
 8012d9e:	781b      	ldrb	r3, [r3, #0]
 8012da0:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8012da4:	2b00      	cmp	r3, #0
 8012da6:	d12c      	bne.n	8012e02 <Standard_GetStatus+0x8a>
  {
    /*Get Device Status */
    uint8_t Feature = pInformation->Current_Feature;
 8012da8:	4b3e      	ldr	r3, [pc, #248]	; (8012ea4 <Standard_GetStatus+0x12c>)
 8012daa:	681b      	ldr	r3, [r3, #0]
 8012dac:	7a5b      	ldrb	r3, [r3, #9]
 8012dae:	737b      	strb	r3, [r7, #13]

    /* Remote Wakeup enabled */
    if (ValBit(Feature, 5))
 8012db0:	7b7b      	ldrb	r3, [r7, #13]
 8012db2:	f003 0320 	and.w	r3, r3, #32
 8012db6:	2b00      	cmp	r3, #0
 8012db8:	d007      	beq.n	8012dca <Standard_GetStatus+0x52>
    {
      SetBit(StatusInfo0, 1);
 8012dba:	4b3b      	ldr	r3, [pc, #236]	; (8012ea8 <Standard_GetStatus+0x130>)
 8012dbc:	781b      	ldrb	r3, [r3, #0]
 8012dbe:	f043 0302 	orr.w	r3, r3, #2
 8012dc2:	b2da      	uxtb	r2, r3
 8012dc4:	4b38      	ldr	r3, [pc, #224]	; (8012ea8 <Standard_GetStatus+0x130>)
 8012dc6:	701a      	strb	r2, [r3, #0]
 8012dc8:	e006      	b.n	8012dd8 <Standard_GetStatus+0x60>
    }
    else
    {
      ClrBit(StatusInfo0, 1);
 8012dca:	4b37      	ldr	r3, [pc, #220]	; (8012ea8 <Standard_GetStatus+0x130>)
 8012dcc:	781b      	ldrb	r3, [r3, #0]
 8012dce:	f023 0302 	bic.w	r3, r3, #2
 8012dd2:	b2da      	uxtb	r2, r3
 8012dd4:	4b34      	ldr	r3, [pc, #208]	; (8012ea8 <Standard_GetStatus+0x130>)
 8012dd6:	701a      	strb	r2, [r3, #0]
    }      

    /* Bus-powered */
    if (ValBit(Feature, 6))
 8012dd8:	7b7b      	ldrb	r3, [r7, #13]
 8012dda:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8012dde:	2b00      	cmp	r3, #0
 8012de0:	d007      	beq.n	8012df2 <Standard_GetStatus+0x7a>
    {
      SetBit(StatusInfo0, 0);
 8012de2:	4b31      	ldr	r3, [pc, #196]	; (8012ea8 <Standard_GetStatus+0x130>)
 8012de4:	781b      	ldrb	r3, [r3, #0]
 8012de6:	f043 0301 	orr.w	r3, r3, #1
 8012dea:	b2da      	uxtb	r2, r3
 8012dec:	4b2e      	ldr	r3, [pc, #184]	; (8012ea8 <Standard_GetStatus+0x130>)
 8012dee:	701a      	strb	r2, [r3, #0]
 8012df0:	e04e      	b.n	8012e90 <Standard_GetStatus+0x118>
    }
    else /* Self-powered */
    {
      ClrBit(StatusInfo0, 0);
 8012df2:	4b2d      	ldr	r3, [pc, #180]	; (8012ea8 <Standard_GetStatus+0x130>)
 8012df4:	781b      	ldrb	r3, [r3, #0]
 8012df6:	f023 0301 	bic.w	r3, r3, #1
 8012dfa:	b2da      	uxtb	r2, r3
 8012dfc:	4b2a      	ldr	r3, [pc, #168]	; (8012ea8 <Standard_GetStatus+0x130>)
 8012dfe:	701a      	strb	r2, [r3, #0]
 8012e00:	e046      	b.n	8012e90 <Standard_GetStatus+0x118>
    }
  }
  /*Interface Status*/
  else if (Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
 8012e02:	4b28      	ldr	r3, [pc, #160]	; (8012ea4 <Standard_GetStatus+0x12c>)
 8012e04:	681b      	ldr	r3, [r3, #0]
 8012e06:	781b      	ldrb	r3, [r3, #0]
 8012e08:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8012e0c:	2b01      	cmp	r3, #1
 8012e0e:	d101      	bne.n	8012e14 <Standard_GetStatus+0x9c>
  {
    return (uint8_t *)&StatusInfo;
 8012e10:	4b25      	ldr	r3, [pc, #148]	; (8012ea8 <Standard_GetStatus+0x130>)
 8012e12:	e042      	b.n	8012e9a <Standard_GetStatus+0x122>
  }
  /*Get EndPoint Status*/
  else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
 8012e14:	4b23      	ldr	r3, [pc, #140]	; (8012ea4 <Standard_GetStatus+0x12c>)
 8012e16:	681b      	ldr	r3, [r3, #0]
 8012e18:	781b      	ldrb	r3, [r3, #0]
 8012e1a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8012e1e:	2b02      	cmp	r3, #2
 8012e20:	d134      	bne.n	8012e8c <Standard_GetStatus+0x114>
  {
    uint8_t Related_Endpoint;
    uint8_t wIndex0 = pInformation->USBwIndex0;
 8012e22:	4b20      	ldr	r3, [pc, #128]	; (8012ea4 <Standard_GetStatus+0x12c>)
 8012e24:	681b      	ldr	r3, [r3, #0]
 8012e26:	795b      	ldrb	r3, [r3, #5]
 8012e28:	73fb      	strb	r3, [r7, #15]

    Related_Endpoint = (wIndex0 & 0x0f);
 8012e2a:	7bfb      	ldrb	r3, [r7, #15]
 8012e2c:	f003 030f 	and.w	r3, r3, #15
 8012e30:	73bb      	strb	r3, [r7, #14]
    if (ValBit(wIndex0, 7))
 8012e32:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8012e36:	2b00      	cmp	r3, #0
 8012e38:	da13      	bge.n	8012e62 <Standard_GetStatus+0xea>
    {
      /* IN endpoint */
      if (_GetTxStallStatus(Related_Endpoint))
 8012e3a:	7bbb      	ldrb	r3, [r7, #14]
 8012e3c:	009b      	lsls	r3, r3, #2
 8012e3e:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8012e42:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
 8012e46:	681b      	ldr	r3, [r3, #0]
 8012e48:	b29b      	uxth	r3, r3
 8012e4a:	f003 0330 	and.w	r3, r3, #48	; 0x30
 8012e4e:	2b10      	cmp	r3, #16
 8012e50:	d11e      	bne.n	8012e90 <Standard_GetStatus+0x118>
      {
        SetBit(StatusInfo0, 0); /* IN Endpoint stalled */
 8012e52:	4b15      	ldr	r3, [pc, #84]	; (8012ea8 <Standard_GetStatus+0x130>)
 8012e54:	781b      	ldrb	r3, [r3, #0]
 8012e56:	f043 0301 	orr.w	r3, r3, #1
 8012e5a:	b2da      	uxtb	r2, r3
 8012e5c:	4b12      	ldr	r3, [pc, #72]	; (8012ea8 <Standard_GetStatus+0x130>)
 8012e5e:	701a      	strb	r2, [r3, #0]
 8012e60:	e016      	b.n	8012e90 <Standard_GetStatus+0x118>
      }
    }
    else
    {
      /* OUT endpoint */
      if (_GetRxStallStatus(Related_Endpoint))
 8012e62:	7bbb      	ldrb	r3, [r7, #14]
 8012e64:	009b      	lsls	r3, r3, #2
 8012e66:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8012e6a:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
 8012e6e:	681b      	ldr	r3, [r3, #0]
 8012e70:	b29b      	uxth	r3, r3
 8012e72:	f403 5340 	and.w	r3, r3, #12288	; 0x3000
 8012e76:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8012e7a:	d109      	bne.n	8012e90 <Standard_GetStatus+0x118>
      {
        SetBit(StatusInfo0, 0); /* OUT Endpoint stalled */
 8012e7c:	4b0a      	ldr	r3, [pc, #40]	; (8012ea8 <Standard_GetStatus+0x130>)
 8012e7e:	781b      	ldrb	r3, [r3, #0]
 8012e80:	f043 0301 	orr.w	r3, r3, #1
 8012e84:	b2da      	uxtb	r2, r3
 8012e86:	4b08      	ldr	r3, [pc, #32]	; (8012ea8 <Standard_GetStatus+0x130>)
 8012e88:	701a      	strb	r2, [r3, #0]
 8012e8a:	e001      	b.n	8012e90 <Standard_GetStatus+0x118>
    }

  }
  else
  {
    return NULL;
 8012e8c:	2300      	movs	r3, #0
 8012e8e:	e004      	b.n	8012e9a <Standard_GetStatus+0x122>
  }
  pUser_Standard_Requests->User_GetStatus();
 8012e90:	4b06      	ldr	r3, [pc, #24]	; (8012eac <Standard_GetStatus+0x134>)
 8012e92:	681b      	ldr	r3, [r3, #0]
 8012e94:	691b      	ldr	r3, [r3, #16]
 8012e96:	4798      	blx	r3
  return (uint8_t *)&StatusInfo;
 8012e98:	4b03      	ldr	r3, [pc, #12]	; (8012ea8 <Standard_GetStatus+0x130>)
}
 8012e9a:	4618      	mov	r0, r3
 8012e9c:	3710      	adds	r7, #16
 8012e9e:	46bd      	mov	sp, r7
 8012ea0:	bd80      	pop	{r7, pc}
 8012ea2:	bf00      	nop
 8012ea4:	200096d0 	.word	0x200096d0
 8012ea8:	200096cc 	.word	0x200096cc
 8012eac:	200096dc 	.word	0x200096dc

08012eb0 <Standard_ClearFeature>:
* Output         : None.
* Return         : - Return USB_SUCCESS, if the request is performed.
*                  - Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_ClearFeature(void)
{
 8012eb0:	b590      	push	{r4, r7, lr}
 8012eb2:	b087      	sub	sp, #28
 8012eb4:	af00      	add	r7, sp, #0
  uint32_t     Type_Rec = Type_Recipient;
 8012eb6:	4b6f      	ldr	r3, [pc, #444]	; (8013074 <Standard_ClearFeature+0x1c4>)
 8012eb8:	681b      	ldr	r3, [r3, #0]
 8012eba:	781b      	ldrb	r3, [r3, #0]
 8012ebc:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8012ec0:	613b      	str	r3, [r7, #16]
  uint32_t     Status;


  if (Type_Rec == (STANDARD_REQUEST | DEVICE_RECIPIENT))
 8012ec2:	693b      	ldr	r3, [r7, #16]
 8012ec4:	2b00      	cmp	r3, #0
 8012ec6:	d10a      	bne.n	8012ede <Standard_ClearFeature+0x2e>
  {/*Device Clear Feature*/
    ClrBit(pInformation->Current_Feature, 5);
 8012ec8:	4b6a      	ldr	r3, [pc, #424]	; (8013074 <Standard_ClearFeature+0x1c4>)
 8012eca:	681b      	ldr	r3, [r3, #0]
 8012ecc:	7a5a      	ldrb	r2, [r3, #9]
 8012ece:	4b69      	ldr	r3, [pc, #420]	; (8013074 <Standard_ClearFeature+0x1c4>)
 8012ed0:	681b      	ldr	r3, [r3, #0]
 8012ed2:	f022 0220 	bic.w	r2, r2, #32
 8012ed6:	b2d2      	uxtb	r2, r2
 8012ed8:	725a      	strb	r2, [r3, #9]
    return USB_SUCCESS;
 8012eda:	2300      	movs	r3, #0
 8012edc:	e0c6      	b.n	801306c <Standard_ClearFeature+0x1bc>
  }
  else if (Type_Rec == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
 8012ede:	693b      	ldr	r3, [r7, #16]
 8012ee0:	2b02      	cmp	r3, #2
 8012ee2:	f040 80c2 	bne.w	801306a <Standard_ClearFeature+0x1ba>
    DEVICE* pDev;
    uint32_t Related_Endpoint;
    uint32_t wIndex0;
    uint32_t rEP;

    if ((pInformation->USBwValue != ENDPOINT_STALL)
 8012ee6:	4b63      	ldr	r3, [pc, #396]	; (8013074 <Standard_ClearFeature+0x1c4>)
 8012ee8:	681b      	ldr	r3, [r3, #0]
 8012eea:	885b      	ldrh	r3, [r3, #2]
 8012eec:	2b00      	cmp	r3, #0
 8012eee:	d104      	bne.n	8012efa <Standard_ClearFeature+0x4a>
        || (pInformation->USBwIndex1 != 0))
 8012ef0:	4b60      	ldr	r3, [pc, #384]	; (8013074 <Standard_ClearFeature+0x1c4>)
 8012ef2:	681b      	ldr	r3, [r3, #0]
 8012ef4:	791b      	ldrb	r3, [r3, #4]
 8012ef6:	2b00      	cmp	r3, #0
 8012ef8:	d001      	beq.n	8012efe <Standard_ClearFeature+0x4e>
    {
      return USB_UNSUPPORT;
 8012efa:	2302      	movs	r3, #2
 8012efc:	e0b6      	b.n	801306c <Standard_ClearFeature+0x1bc>
    }

    pDev = &Device_Table;
 8012efe:	4b5e      	ldr	r3, [pc, #376]	; (8013078 <Standard_ClearFeature+0x1c8>)
 8012f00:	60fb      	str	r3, [r7, #12]
    wIndex0 = pInformation->USBwIndex0;
 8012f02:	4b5c      	ldr	r3, [pc, #368]	; (8013074 <Standard_ClearFeature+0x1c4>)
 8012f04:	681b      	ldr	r3, [r3, #0]
 8012f06:	795b      	ldrb	r3, [r3, #5]
 8012f08:	60bb      	str	r3, [r7, #8]
    rEP = wIndex0 & ~0x80;
 8012f0a:	68bb      	ldr	r3, [r7, #8]
 8012f0c:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8012f10:	607b      	str	r3, [r7, #4]
    Related_Endpoint = ENDP0 + rEP;
 8012f12:	687b      	ldr	r3, [r7, #4]
 8012f14:	603b      	str	r3, [r7, #0]

    if (ValBit(pInformation->USBwIndex0, 7))
 8012f16:	4b57      	ldr	r3, [pc, #348]	; (8013074 <Standard_ClearFeature+0x1c4>)
 8012f18:	681b      	ldr	r3, [r3, #0]
 8012f1a:	795b      	ldrb	r3, [r3, #5]
 8012f1c:	b25b      	sxtb	r3, r3
 8012f1e:	2b00      	cmp	r3, #0
 8012f20:	da0b      	bge.n	8012f3a <Standard_ClearFeature+0x8a>
    {
      /*Get Status of endpoint & stall the request if the related_ENdpoint
      is Disabled*/
      Status = _GetEPTxStatus(Related_Endpoint);
 8012f22:	683b      	ldr	r3, [r7, #0]
 8012f24:	009b      	lsls	r3, r3, #2
 8012f26:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8012f2a:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
 8012f2e:	681b      	ldr	r3, [r3, #0]
 8012f30:	b29b      	uxth	r3, r3
 8012f32:	f003 0330 	and.w	r3, r3, #48	; 0x30
 8012f36:	617b      	str	r3, [r7, #20]
 8012f38:	e00a      	b.n	8012f50 <Standard_ClearFeature+0xa0>
    }
    else
    {
      Status = _GetEPRxStatus(Related_Endpoint);
 8012f3a:	683b      	ldr	r3, [r7, #0]
 8012f3c:	009b      	lsls	r3, r3, #2
 8012f3e:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8012f42:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
 8012f46:	681b      	ldr	r3, [r3, #0]
 8012f48:	b29b      	uxth	r3, r3
 8012f4a:	f403 5340 	and.w	r3, r3, #12288	; 0x3000
 8012f4e:	617b      	str	r3, [r7, #20]
    }

    if ((rEP >= pDev->Total_Endpoint) || (Status == 0)
 8012f50:	68fb      	ldr	r3, [r7, #12]
 8012f52:	781b      	ldrb	r3, [r3, #0]
 8012f54:	461a      	mov	r2, r3
 8012f56:	687b      	ldr	r3, [r7, #4]
 8012f58:	4293      	cmp	r3, r2
 8012f5a:	d207      	bcs.n	8012f6c <Standard_ClearFeature+0xbc>
 8012f5c:	697b      	ldr	r3, [r7, #20]
 8012f5e:	2b00      	cmp	r3, #0
 8012f60:	d004      	beq.n	8012f6c <Standard_ClearFeature+0xbc>
        || (pInformation->Current_Configuration == 0))
 8012f62:	4b44      	ldr	r3, [pc, #272]	; (8013074 <Standard_ClearFeature+0x1c4>)
 8012f64:	681b      	ldr	r3, [r3, #0]
 8012f66:	7a9b      	ldrb	r3, [r3, #10]
 8012f68:	2b00      	cmp	r3, #0
 8012f6a:	d101      	bne.n	8012f70 <Standard_ClearFeature+0xc0>
    {
      return USB_UNSUPPORT;
 8012f6c:	2302      	movs	r3, #2
 8012f6e:	e07d      	b.n	801306c <Standard_ClearFeature+0x1bc>
    }


    if (wIndex0 & 0x80)
 8012f70:	68bb      	ldr	r3, [r7, #8]
 8012f72:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8012f76:	2b00      	cmp	r3, #0
 8012f78:	d017      	beq.n	8012faa <Standard_ClearFeature+0xfa>
    {
      /* IN endpoint */
      if (_GetTxStallStatus(Related_Endpoint ))
 8012f7a:	683b      	ldr	r3, [r7, #0]
 8012f7c:	009b      	lsls	r3, r3, #2
 8012f7e:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8012f82:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
 8012f86:	681b      	ldr	r3, [r3, #0]
 8012f88:	b29b      	uxth	r3, r3
 8012f8a:	f003 0330 	and.w	r3, r3, #48	; 0x30
 8012f8e:	2b10      	cmp	r3, #16
 8012f90:	d165      	bne.n	801305e <Standard_ClearFeature+0x1ae>
      {
      #ifndef STM32F10X_CL
        ClearDTOG_TX(Related_Endpoint);
 8012f92:	683b      	ldr	r3, [r7, #0]
 8012f94:	b2db      	uxtb	r3, r3
 8012f96:	4618      	mov	r0, r3
 8012f98:	4b38      	ldr	r3, [pc, #224]	; (801307c <Standard_ClearFeature+0x1cc>)
 8012f9a:	4798      	blx	r3
      #endif /* STM32F10X_CL */
        SetEPTxStatus(Related_Endpoint, EP_TX_VALID);
 8012f9c:	683b      	ldr	r3, [r7, #0]
 8012f9e:	b2db      	uxtb	r3, r3
 8012fa0:	2130      	movs	r1, #48	; 0x30
 8012fa2:	4618      	mov	r0, r3
 8012fa4:	4b36      	ldr	r3, [pc, #216]	; (8013080 <Standard_ClearFeature+0x1d0>)
 8012fa6:	4798      	blx	r3
 8012fa8:	e059      	b.n	801305e <Standard_ClearFeature+0x1ae>
      }
    }
    else
    {
      /* OUT endpoint */
      if (_GetRxStallStatus(Related_Endpoint))
 8012faa:	683b      	ldr	r3, [r7, #0]
 8012fac:	009b      	lsls	r3, r3, #2
 8012fae:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8012fb2:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
 8012fb6:	681b      	ldr	r3, [r3, #0]
 8012fb8:	b29b      	uxth	r3, r3
 8012fba:	f403 5340 	and.w	r3, r3, #12288	; 0x3000
 8012fbe:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8012fc2:	d14c      	bne.n	801305e <Standard_ClearFeature+0x1ae>
      {
        if (Related_Endpoint == ENDP0)
 8012fc4:	683b      	ldr	r3, [r7, #0]
 8012fc6:	2b00      	cmp	r3, #0
 8012fc8:	d127      	bne.n	801301a <Standard_ClearFeature+0x16a>
        {
          /* After clear the STALL, enable the default endpoint receiver */
          SetEPRxCount(Related_Endpoint, Device_Property.MaxPacketSize);
 8012fca:	683b      	ldr	r3, [r7, #0]
 8012fcc:	b2db      	uxtb	r3, r3
 8012fce:	4a2d      	ldr	r2, [pc, #180]	; (8013084 <Standard_ClearFeature+0x1d4>)
 8012fd0:	f892 202c 	ldrb.w	r2, [r2, #44]	; 0x2c
 8012fd4:	b292      	uxth	r2, r2
 8012fd6:	4611      	mov	r1, r2
 8012fd8:	4618      	mov	r0, r3
 8012fda:	4b2b      	ldr	r3, [pc, #172]	; (8013088 <Standard_ClearFeature+0x1d8>)
 8012fdc:	4798      	blx	r3
          _SetEPRxStatus(Related_Endpoint, EP_RX_VALID);
 8012fde:	683b      	ldr	r3, [r7, #0]
 8012fe0:	009b      	lsls	r3, r3, #2
 8012fe2:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8012fe6:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
 8012fea:	681b      	ldr	r3, [r3, #0]
 8012fec:	b29b      	uxth	r3, r3
 8012fee:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8012ff2:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8012ff6:	b29c      	uxth	r4, r3
 8012ff8:	f484 5380 	eor.w	r3, r4, #4096	; 0x1000
 8012ffc:	b29c      	uxth	r4, r3
 8012ffe:	f484 5300 	eor.w	r3, r4, #8192	; 0x2000
 8013002:	b29c      	uxth	r4, r3
 8013004:	4b21      	ldr	r3, [pc, #132]	; (801308c <Standard_ClearFeature+0x1dc>)
 8013006:	4323      	orrs	r3, r4
 8013008:	b29a      	uxth	r2, r3
 801300a:	683b      	ldr	r3, [r7, #0]
 801300c:	009b      	lsls	r3, r3, #2
 801300e:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8013012:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
 8013016:	601a      	str	r2, [r3, #0]
 8013018:	e021      	b.n	801305e <Standard_ClearFeature+0x1ae>
        }
        else
        {
        #ifndef STM32F10X_CL
          ClearDTOG_RX(Related_Endpoint);
 801301a:	683b      	ldr	r3, [r7, #0]
 801301c:	b2db      	uxtb	r3, r3
 801301e:	4618      	mov	r0, r3
 8013020:	4b1b      	ldr	r3, [pc, #108]	; (8013090 <Standard_ClearFeature+0x1e0>)
 8013022:	4798      	blx	r3
        #endif /* STM32F10X_CL */
          _SetEPRxStatus(Related_Endpoint, EP_RX_VALID);
 8013024:	683b      	ldr	r3, [r7, #0]
 8013026:	009b      	lsls	r3, r3, #2
 8013028:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 801302c:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
 8013030:	681b      	ldr	r3, [r3, #0]
 8013032:	b29b      	uxth	r3, r3
 8013034:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8013038:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 801303c:	b29c      	uxth	r4, r3
 801303e:	f484 5380 	eor.w	r3, r4, #4096	; 0x1000
 8013042:	b29c      	uxth	r4, r3
 8013044:	f484 5300 	eor.w	r3, r4, #8192	; 0x2000
 8013048:	b29c      	uxth	r4, r3
 801304a:	4b10      	ldr	r3, [pc, #64]	; (801308c <Standard_ClearFeature+0x1dc>)
 801304c:	4323      	orrs	r3, r4
 801304e:	b29a      	uxth	r2, r3
 8013050:	683b      	ldr	r3, [r7, #0]
 8013052:	009b      	lsls	r3, r3, #2
 8013054:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8013058:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
 801305c:	601a      	str	r2, [r3, #0]
        }
      }
    }
    pUser_Standard_Requests->User_ClearFeature();
 801305e:	4b0d      	ldr	r3, [pc, #52]	; (8013094 <Standard_ClearFeature+0x1e4>)
 8013060:	681b      	ldr	r3, [r3, #0]
 8013062:	695b      	ldr	r3, [r3, #20]
 8013064:	4798      	blx	r3
    return USB_SUCCESS;
 8013066:	2300      	movs	r3, #0
 8013068:	e000      	b.n	801306c <Standard_ClearFeature+0x1bc>
  }

  return USB_UNSUPPORT;
 801306a:	2302      	movs	r3, #2
}
 801306c:	4618      	mov	r0, r3
 801306e:	371c      	adds	r7, #28
 8013070:	46bd      	mov	sp, r7
 8013072:	bd90      	pop	{r4, r7, pc}
 8013074:	200096d0 	.word	0x200096d0
 8013078:	200001c4 	.word	0x200001c4
 801307c:	08014283 	.word	0x08014283
 8013080:	08014059 	.word	0x08014059
 8013084:	200001c8 	.word	0x200001c8
 8013088:	08014405 	.word	0x08014405
 801308c:	ffff8080 	.word	0xffff8080
 8013090:	08014229 	.word	0x08014229
 8013094:	200096dc 	.word	0x200096dc

08013098 <Standard_SetEndPointFeature>:
* Output         : None.
* Return         : - Return USB_SUCCESS, if the request is performed.
*                  - Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_SetEndPointFeature(void)
{
 8013098:	b590      	push	{r4, r7, lr}
 801309a:	b085      	sub	sp, #20
 801309c:	af00      	add	r7, sp, #0
  uint32_t    wIndex0;
  uint32_t    Related_Endpoint;
  uint32_t    rEP;
  uint32_t    Status;

  wIndex0 = pInformation->USBwIndex0;
 801309e:	4b3f      	ldr	r3, [pc, #252]	; (801319c <Standard_SetEndPointFeature+0x104>)
 80130a0:	681b      	ldr	r3, [r3, #0]
 80130a2:	795b      	ldrb	r3, [r3, #5]
 80130a4:	60bb      	str	r3, [r7, #8]
  rEP = wIndex0 & ~0x80;
 80130a6:	68bb      	ldr	r3, [r7, #8]
 80130a8:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 80130ac:	607b      	str	r3, [r7, #4]
  Related_Endpoint = ENDP0 + rEP;
 80130ae:	687b      	ldr	r3, [r7, #4]
 80130b0:	603b      	str	r3, [r7, #0]

  if (ValBit(pInformation->USBwIndex0, 7))
 80130b2:	4b3a      	ldr	r3, [pc, #232]	; (801319c <Standard_SetEndPointFeature+0x104>)
 80130b4:	681b      	ldr	r3, [r3, #0]
 80130b6:	795b      	ldrb	r3, [r3, #5]
 80130b8:	b25b      	sxtb	r3, r3
 80130ba:	2b00      	cmp	r3, #0
 80130bc:	da0b      	bge.n	80130d6 <Standard_SetEndPointFeature+0x3e>
  {
    /* get Status of endpoint & stall the request if the related_ENdpoint
    is Disabled*/
    Status = _GetEPTxStatus(Related_Endpoint);
 80130be:	683b      	ldr	r3, [r7, #0]
 80130c0:	009b      	lsls	r3, r3, #2
 80130c2:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 80130c6:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
 80130ca:	681b      	ldr	r3, [r3, #0]
 80130cc:	b29b      	uxth	r3, r3
 80130ce:	f003 0330 	and.w	r3, r3, #48	; 0x30
 80130d2:	60fb      	str	r3, [r7, #12]
 80130d4:	e00a      	b.n	80130ec <Standard_SetEndPointFeature+0x54>
  }
  else
  {
    Status = _GetEPRxStatus(Related_Endpoint);
 80130d6:	683b      	ldr	r3, [r7, #0]
 80130d8:	009b      	lsls	r3, r3, #2
 80130da:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 80130de:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
 80130e2:	681b      	ldr	r3, [r3, #0]
 80130e4:	b29b      	uxth	r3, r3
 80130e6:	f403 5340 	and.w	r3, r3, #12288	; 0x3000
 80130ea:	60fb      	str	r3, [r7, #12]
  }

  if (Related_Endpoint >= Device_Table.Total_Endpoint
 80130ec:	4b2c      	ldr	r3, [pc, #176]	; (80131a0 <Standard_SetEndPointFeature+0x108>)
 80130ee:	781b      	ldrb	r3, [r3, #0]
 80130f0:	461a      	mov	r2, r3
 80130f2:	683b      	ldr	r3, [r7, #0]
 80130f4:	4293      	cmp	r3, r2
 80130f6:	d20c      	bcs.n	8013112 <Standard_SetEndPointFeature+0x7a>
      || pInformation->USBwValue != 0 || Status == 0
 80130f8:	4b28      	ldr	r3, [pc, #160]	; (801319c <Standard_SetEndPointFeature+0x104>)
 80130fa:	681b      	ldr	r3, [r3, #0]
 80130fc:	885b      	ldrh	r3, [r3, #2]
 80130fe:	2b00      	cmp	r3, #0
 8013100:	d107      	bne.n	8013112 <Standard_SetEndPointFeature+0x7a>
 8013102:	68fb      	ldr	r3, [r7, #12]
 8013104:	2b00      	cmp	r3, #0
 8013106:	d004      	beq.n	8013112 <Standard_SetEndPointFeature+0x7a>
      || pInformation->Current_Configuration == 0)
 8013108:	4b24      	ldr	r3, [pc, #144]	; (801319c <Standard_SetEndPointFeature+0x104>)
 801310a:	681b      	ldr	r3, [r3, #0]
 801310c:	7a9b      	ldrb	r3, [r3, #10]
 801310e:	2b00      	cmp	r3, #0
 8013110:	d101      	bne.n	8013116 <Standard_SetEndPointFeature+0x7e>
  {
    return USB_UNSUPPORT;
 8013112:	2302      	movs	r3, #2
 8013114:	e03e      	b.n	8013194 <Standard_SetEndPointFeature+0xfc>
  }
  else
  {
    if (wIndex0 & 0x80)
 8013116:	68bb      	ldr	r3, [r7, #8]
 8013118:	f003 0380 	and.w	r3, r3, #128	; 0x80
 801311c:	2b00      	cmp	r3, #0
 801311e:	d01a      	beq.n	8013156 <Standard_SetEndPointFeature+0xbe>
    {
      /* IN endpoint */
      _SetEPTxStatus(Related_Endpoint, EP_TX_STALL);
 8013120:	683b      	ldr	r3, [r7, #0]
 8013122:	009b      	lsls	r3, r3, #2
 8013124:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8013128:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
 801312c:	681b      	ldr	r3, [r3, #0]
 801312e:	b29b      	uxth	r3, r3
 8013130:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8013134:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8013138:	b29c      	uxth	r4, r3
 801313a:	f084 0310 	eor.w	r3, r4, #16
 801313e:	b29c      	uxth	r4, r3
 8013140:	4b18      	ldr	r3, [pc, #96]	; (80131a4 <Standard_SetEndPointFeature+0x10c>)
 8013142:	4323      	orrs	r3, r4
 8013144:	b29a      	uxth	r2, r3
 8013146:	683b      	ldr	r3, [r7, #0]
 8013148:	009b      	lsls	r3, r3, #2
 801314a:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 801314e:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
 8013152:	601a      	str	r2, [r3, #0]
 8013154:	e019      	b.n	801318a <Standard_SetEndPointFeature+0xf2>
    }

    else
    {
      /* OUT endpoint */
      _SetEPRxStatus(Related_Endpoint, EP_RX_STALL);
 8013156:	683b      	ldr	r3, [r7, #0]
 8013158:	009b      	lsls	r3, r3, #2
 801315a:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 801315e:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
 8013162:	681b      	ldr	r3, [r3, #0]
 8013164:	b29b      	uxth	r3, r3
 8013166:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 801316a:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 801316e:	b29c      	uxth	r4, r3
 8013170:	f484 5380 	eor.w	r3, r4, #4096	; 0x1000
 8013174:	b29c      	uxth	r4, r3
 8013176:	4b0b      	ldr	r3, [pc, #44]	; (80131a4 <Standard_SetEndPointFeature+0x10c>)
 8013178:	4323      	orrs	r3, r4
 801317a:	b29a      	uxth	r2, r3
 801317c:	683b      	ldr	r3, [r7, #0]
 801317e:	009b      	lsls	r3, r3, #2
 8013180:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8013184:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
 8013188:	601a      	str	r2, [r3, #0]
    }
  }
  pUser_Standard_Requests->User_SetEndPointFeature();
 801318a:	4b07      	ldr	r3, [pc, #28]	; (80131a8 <Standard_SetEndPointFeature+0x110>)
 801318c:	681b      	ldr	r3, [r3, #0]
 801318e:	699b      	ldr	r3, [r3, #24]
 8013190:	4798      	blx	r3
  return USB_SUCCESS;
 8013192:	2300      	movs	r3, #0
}
 8013194:	4618      	mov	r0, r3
 8013196:	3714      	adds	r7, #20
 8013198:	46bd      	mov	sp, r7
 801319a:	bd90      	pop	{r4, r7, pc}
 801319c:	200096d0 	.word	0x200096d0
 80131a0:	200001c4 	.word	0x200001c4
 80131a4:	ffff8080 	.word	0xffff8080
 80131a8:	200096dc 	.word	0x200096dc

080131ac <Standard_SetDeviceFeature>:
* Output         : None.
* Return         : - Return USB_SUCCESS, if the request is performed.
*                  - Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_SetDeviceFeature(void)
{
 80131ac:	b580      	push	{r7, lr}
 80131ae:	af00      	add	r7, sp, #0
  SetBit(pInformation->Current_Feature, 5);
 80131b0:	4b07      	ldr	r3, [pc, #28]	; (80131d0 <Standard_SetDeviceFeature+0x24>)
 80131b2:	681b      	ldr	r3, [r3, #0]
 80131b4:	7a5a      	ldrb	r2, [r3, #9]
 80131b6:	4b06      	ldr	r3, [pc, #24]	; (80131d0 <Standard_SetDeviceFeature+0x24>)
 80131b8:	681b      	ldr	r3, [r3, #0]
 80131ba:	f042 0220 	orr.w	r2, r2, #32
 80131be:	b2d2      	uxtb	r2, r2
 80131c0:	725a      	strb	r2, [r3, #9]
  pUser_Standard_Requests->User_SetDeviceFeature();
 80131c2:	4b04      	ldr	r3, [pc, #16]	; (80131d4 <Standard_SetDeviceFeature+0x28>)
 80131c4:	681b      	ldr	r3, [r3, #0]
 80131c6:	69db      	ldr	r3, [r3, #28]
 80131c8:	4798      	blx	r3
  return USB_SUCCESS;
 80131ca:	2300      	movs	r3, #0
}
 80131cc:	4618      	mov	r0, r3
 80131ce:	bd80      	pop	{r7, pc}
 80131d0:	200096d0 	.word	0x200096d0
 80131d4:	200096dc 	.word	0x200096dc

080131d8 <Standard_GetDescriptorData>:
* Return         : Address of a part of the descriptor pointed by the Usb_
*                  wOffset The buffer pointed by this address contains at least
*                  Length bytes.
*******************************************************************************/
uint8_t *Standard_GetDescriptorData(uint16_t Length, ONE_DESCRIPTOR *pDesc)
{
 80131d8:	b480      	push	{r7}
 80131da:	b085      	sub	sp, #20
 80131dc:	af00      	add	r7, sp, #0
 80131de:	4603      	mov	r3, r0
 80131e0:	6039      	str	r1, [r7, #0]
 80131e2:	80fb      	strh	r3, [r7, #6]
  uint32_t  wOffset;

  wOffset = pInformation->Ctrl_Info.Usb_wOffset;
 80131e4:	4b0d      	ldr	r3, [pc, #52]	; (801321c <Standard_GetDescriptorData+0x44>)
 80131e6:	681b      	ldr	r3, [r3, #0]
 80131e8:	8a5b      	ldrh	r3, [r3, #18]
 80131ea:	60fb      	str	r3, [r7, #12]
  if (Length == 0)
 80131ec:	88fb      	ldrh	r3, [r7, #6]
 80131ee:	2b00      	cmp	r3, #0
 80131f0:	d10a      	bne.n	8013208 <Standard_GetDescriptorData+0x30>
  {
    pInformation->Ctrl_Info.Usb_wLength = pDesc->Descriptor_Size - wOffset;
 80131f2:	683b      	ldr	r3, [r7, #0]
 80131f4:	8899      	ldrh	r1, [r3, #4]
 80131f6:	68fb      	ldr	r3, [r7, #12]
 80131f8:	b29a      	uxth	r2, r3
 80131fa:	4b08      	ldr	r3, [pc, #32]	; (801321c <Standard_GetDescriptorData+0x44>)
 80131fc:	681b      	ldr	r3, [r3, #0]
 80131fe:	1a8a      	subs	r2, r1, r2
 8013200:	b292      	uxth	r2, r2
 8013202:	821a      	strh	r2, [r3, #16]
    return 0;
 8013204:	2300      	movs	r3, #0
 8013206:	e003      	b.n	8013210 <Standard_GetDescriptorData+0x38>
  }

  return pDesc->Descriptor + wOffset;
 8013208:	683b      	ldr	r3, [r7, #0]
 801320a:	681a      	ldr	r2, [r3, #0]
 801320c:	68fb      	ldr	r3, [r7, #12]
 801320e:	4413      	add	r3, r2
}
 8013210:	4618      	mov	r0, r3
 8013212:	3714      	adds	r7, #20
 8013214:	46bd      	mov	sp, r7
 8013216:	bc80      	pop	{r7}
 8013218:	4770      	bx	lr
 801321a:	bf00      	nop
 801321c:	200096d0 	.word	0x200096d0

08013220 <DataStageOut>:
* Input          : None.
* Output         : None.
* Return         : None.
*******************************************************************************/
void DataStageOut(void)
{
 8013220:	b580      	push	{r7, lr}
 8013222:	b084      	sub	sp, #16
 8013224:	af00      	add	r7, sp, #0
  ENDPOINT_INFO *pEPinfo = &pInformation->Ctrl_Info;
 8013226:	4b3a      	ldr	r3, [pc, #232]	; (8013310 <DataStageOut+0xf0>)
 8013228:	681b      	ldr	r3, [r3, #0]
 801322a:	3310      	adds	r3, #16
 801322c:	60bb      	str	r3, [r7, #8]
  uint32_t save_rLength;

  save_rLength = pEPinfo->Usb_rLength;
 801322e:	68bb      	ldr	r3, [r7, #8]
 8013230:	881b      	ldrh	r3, [r3, #0]
 8013232:	607b      	str	r3, [r7, #4]

  if (pEPinfo->CopyData && save_rLength)
 8013234:	68bb      	ldr	r3, [r7, #8]
 8013236:	689b      	ldr	r3, [r3, #8]
 8013238:	2b00      	cmp	r3, #0
 801323a:	d02d      	beq.n	8013298 <DataStageOut+0x78>
 801323c:	687b      	ldr	r3, [r7, #4]
 801323e:	2b00      	cmp	r3, #0
 8013240:	d02a      	beq.n	8013298 <DataStageOut+0x78>
  {
    uint8_t *Buffer;
    uint32_t Length;

    Length = pEPinfo->PacketSize;
 8013242:	68bb      	ldr	r3, [r7, #8]
 8013244:	889b      	ldrh	r3, [r3, #4]
 8013246:	60fb      	str	r3, [r7, #12]
    if (Length > save_rLength)
 8013248:	68fa      	ldr	r2, [r7, #12]
 801324a:	687b      	ldr	r3, [r7, #4]
 801324c:	429a      	cmp	r2, r3
 801324e:	d901      	bls.n	8013254 <DataStageOut+0x34>
    {
      Length = save_rLength;
 8013250:	687b      	ldr	r3, [r7, #4]
 8013252:	60fb      	str	r3, [r7, #12]
    }

    Buffer = (*pEPinfo->CopyData)(Length);
 8013254:	68bb      	ldr	r3, [r7, #8]
 8013256:	689b      	ldr	r3, [r3, #8]
 8013258:	68fa      	ldr	r2, [r7, #12]
 801325a:	b292      	uxth	r2, r2
 801325c:	4610      	mov	r0, r2
 801325e:	4798      	blx	r3
 8013260:	6038      	str	r0, [r7, #0]
    pEPinfo->Usb_rLength -= Length;
 8013262:	68bb      	ldr	r3, [r7, #8]
 8013264:	881a      	ldrh	r2, [r3, #0]
 8013266:	68fb      	ldr	r3, [r7, #12]
 8013268:	b29b      	uxth	r3, r3
 801326a:	1ad3      	subs	r3, r2, r3
 801326c:	b29a      	uxth	r2, r3
 801326e:	68bb      	ldr	r3, [r7, #8]
 8013270:	801a      	strh	r2, [r3, #0]
    pEPinfo->Usb_rOffset += Length;
 8013272:	68bb      	ldr	r3, [r7, #8]
 8013274:	885a      	ldrh	r2, [r3, #2]
 8013276:	68fb      	ldr	r3, [r7, #12]
 8013278:	b29b      	uxth	r3, r3
 801327a:	4413      	add	r3, r2
 801327c:	b29a      	uxth	r2, r3
 801327e:	68bb      	ldr	r3, [r7, #8]
 8013280:	805a      	strh	r2, [r3, #2]

  #ifdef STM32F10X_CL  
    PCD_EP_Read(ENDP0, Buffer, Length); 
  #else  
    PMAToUserBufferCopy(Buffer, GetEPRxAddr(ENDP0), Length);
 8013282:	2000      	movs	r0, #0
 8013284:	4b23      	ldr	r3, [pc, #140]	; (8013314 <DataStageOut+0xf4>)
 8013286:	4798      	blx	r3
 8013288:	4603      	mov	r3, r0
 801328a:	4619      	mov	r1, r3
 801328c:	68fb      	ldr	r3, [r7, #12]
 801328e:	b29b      	uxth	r3, r3
 8013290:	461a      	mov	r2, r3
 8013292:	6838      	ldr	r0, [r7, #0]
 8013294:	4b20      	ldr	r3, [pc, #128]	; (8013318 <DataStageOut+0xf8>)
 8013296:	4798      	blx	r3
  #endif  /* STM32F10X_CL */
  }

  if (pEPinfo->Usb_rLength != 0)
 8013298:	68bb      	ldr	r3, [r7, #8]
 801329a:	881b      	ldrh	r3, [r3, #0]
 801329c:	2b00      	cmp	r3, #0
 801329e:	d00a      	beq.n	80132b6 <DataStageOut+0x96>
  {
    vSetEPRxStatus(EP_RX_VALID);/* re-enable for next data reception */
 80132a0:	4b1e      	ldr	r3, [pc, #120]	; (801331c <DataStageOut+0xfc>)
 80132a2:	f44f 5240 	mov.w	r2, #12288	; 0x3000
 80132a6:	801a      	strh	r2, [r3, #0]
    SetEPTxCount(ENDP0, 0);
 80132a8:	2100      	movs	r1, #0
 80132aa:	2000      	movs	r0, #0
 80132ac:	4b1c      	ldr	r3, [pc, #112]	; (8013320 <DataStageOut+0x100>)
 80132ae:	4798      	blx	r3
    vSetEPTxStatus(EP_TX_VALID);/* Expect the host to abort the data OUT stage */
 80132b0:	4b1c      	ldr	r3, [pc, #112]	; (8013324 <DataStageOut+0x104>)
 80132b2:	2230      	movs	r2, #48	; 0x30
 80132b4:	801a      	strh	r2, [r3, #0]
  }
  /* Set the next State*/
  if (pEPinfo->Usb_rLength >= pEPinfo->PacketSize)
 80132b6:	68bb      	ldr	r3, [r7, #8]
 80132b8:	881a      	ldrh	r2, [r3, #0]
 80132ba:	68bb      	ldr	r3, [r7, #8]
 80132bc:	889b      	ldrh	r3, [r3, #4]
 80132be:	429a      	cmp	r2, r3
 80132c0:	d304      	bcc.n	80132cc <DataStageOut+0xac>
  {
    pInformation->ControlState = OUT_DATA;
 80132c2:	4b13      	ldr	r3, [pc, #76]	; (8013310 <DataStageOut+0xf0>)
 80132c4:	681b      	ldr	r3, [r3, #0]
 80132c6:	2203      	movs	r2, #3
 80132c8:	721a      	strb	r2, [r3, #8]
    {
      pInformation->ControlState = WAIT_STATUS_IN;
      USB_StatusIn();
    }
  }
}
 80132ca:	e01d      	b.n	8013308 <DataStageOut+0xe8>
    if (pEPinfo->Usb_rLength > 0)
 80132cc:	68bb      	ldr	r3, [r7, #8]
 80132ce:	881b      	ldrh	r3, [r3, #0]
 80132d0:	2b00      	cmp	r3, #0
 80132d2:	d004      	beq.n	80132de <DataStageOut+0xbe>
      pInformation->ControlState = LAST_OUT_DATA;
 80132d4:	4b0e      	ldr	r3, [pc, #56]	; (8013310 <DataStageOut+0xf0>)
 80132d6:	681b      	ldr	r3, [r3, #0]
 80132d8:	2205      	movs	r2, #5
 80132da:	721a      	strb	r2, [r3, #8]
}
 80132dc:	e014      	b.n	8013308 <DataStageOut+0xe8>
    else if (pEPinfo->Usb_rLength == 0)
 80132de:	68bb      	ldr	r3, [r7, #8]
 80132e0:	881b      	ldrh	r3, [r3, #0]
 80132e2:	2b00      	cmp	r3, #0
 80132e4:	d110      	bne.n	8013308 <DataStageOut+0xe8>
      pInformation->ControlState = WAIT_STATUS_IN;
 80132e6:	4b0a      	ldr	r3, [pc, #40]	; (8013310 <DataStageOut+0xf0>)
 80132e8:	681b      	ldr	r3, [r3, #0]
 80132ea:	2206      	movs	r2, #6
 80132ec:	721a      	strb	r2, [r3, #8]
      USB_StatusIn();
 80132ee:	4b0e      	ldr	r3, [pc, #56]	; (8013328 <DataStageOut+0x108>)
 80132f0:	681b      	ldr	r3, [r3, #0]
 80132f2:	b29b      	uxth	r3, r3
 80132f4:	461a      	mov	r2, r3
 80132f6:	4b0d      	ldr	r3, [pc, #52]	; (801332c <DataStageOut+0x10c>)
 80132f8:	4413      	add	r3, r2
 80132fa:	005b      	lsls	r3, r3, #1
 80132fc:	461a      	mov	r2, r3
 80132fe:	2300      	movs	r3, #0
 8013300:	6013      	str	r3, [r2, #0]
 8013302:	4b08      	ldr	r3, [pc, #32]	; (8013324 <DataStageOut+0x104>)
 8013304:	2230      	movs	r2, #48	; 0x30
 8013306:	801a      	strh	r2, [r3, #0]
}
 8013308:	bf00      	nop
 801330a:	3710      	adds	r7, #16
 801330c:	46bd      	mov	sp, r7
 801330e:	bd80      	pop	{r7, pc}
 8013310:	200096d0 	.word	0x200096d0
 8013314:	08014395 	.word	0x08014395
 8013318:	08013f8b 	.word	0x08013f8b
 801331c:	200096e0 	.word	0x200096e0
 8013320:	080143c9 	.word	0x080143c9
 8013324:	200096e2 	.word	0x200096e2
 8013328:	40005c50 	.word	0x40005c50
 801332c:	20003002 	.word	0x20003002

08013330 <DataStageIn>:
* Input          : None.
* Output         : None.
* Return         : None.
*******************************************************************************/
void DataStageIn(void)
{
 8013330:	b580      	push	{r7, lr}
 8013332:	b086      	sub	sp, #24
 8013334:	af00      	add	r7, sp, #0
  ENDPOINT_INFO *pEPinfo = &pInformation->Ctrl_Info;
 8013336:	4b3b      	ldr	r3, [pc, #236]	; (8013424 <DataStageIn+0xf4>)
 8013338:	681b      	ldr	r3, [r3, #0]
 801333a:	3310      	adds	r3, #16
 801333c:	60fb      	str	r3, [r7, #12]
  uint32_t save_wLength = pEPinfo->Usb_wLength;
 801333e:	68fb      	ldr	r3, [r7, #12]
 8013340:	881b      	ldrh	r3, [r3, #0]
 8013342:	60bb      	str	r3, [r7, #8]
  uint32_t ControlState = pInformation->ControlState;
 8013344:	4b37      	ldr	r3, [pc, #220]	; (8013424 <DataStageIn+0xf4>)
 8013346:	681b      	ldr	r3, [r3, #0]
 8013348:	7a1b      	ldrb	r3, [r3, #8]
 801334a:	617b      	str	r3, [r7, #20]

  uint8_t *DataBuffer;
  uint32_t Length;

  if ((save_wLength == 0) && (ControlState == LAST_IN_DATA))
 801334c:	68bb      	ldr	r3, [r7, #8]
 801334e:	2b00      	cmp	r3, #0
 8013350:	d11f      	bne.n	8013392 <DataStageIn+0x62>
 8013352:	697b      	ldr	r3, [r7, #20]
 8013354:	2b04      	cmp	r3, #4
 8013356:	d11c      	bne.n	8013392 <DataStageIn+0x62>
  {
    if(Data_Mul_MaxPacketSize == TRUE)
 8013358:	4b33      	ldr	r3, [pc, #204]	; (8013428 <DataStageIn+0xf8>)
 801335a:	781b      	ldrb	r3, [r3, #0]
 801335c:	2b00      	cmp	r3, #0
 801335e:	d012      	beq.n	8013386 <DataStageIn+0x56>
    {
      /* No more data to send and empty packet */
      Send0LengthData();
 8013360:	4b32      	ldr	r3, [pc, #200]	; (801342c <DataStageIn+0xfc>)
 8013362:	681b      	ldr	r3, [r3, #0]
 8013364:	b29b      	uxth	r3, r3
 8013366:	461a      	mov	r2, r3
 8013368:	4b31      	ldr	r3, [pc, #196]	; (8013430 <DataStageIn+0x100>)
 801336a:	4413      	add	r3, r2
 801336c:	005b      	lsls	r3, r3, #1
 801336e:	461a      	mov	r2, r3
 8013370:	2300      	movs	r3, #0
 8013372:	6013      	str	r3, [r2, #0]
 8013374:	4b2f      	ldr	r3, [pc, #188]	; (8013434 <DataStageIn+0x104>)
 8013376:	2230      	movs	r2, #48	; 0x30
 8013378:	801a      	strh	r2, [r3, #0]
      ControlState = LAST_IN_DATA;
 801337a:	2304      	movs	r3, #4
 801337c:	617b      	str	r3, [r7, #20]
      Data_Mul_MaxPacketSize = FALSE;
 801337e:	4b2a      	ldr	r3, [pc, #168]	; (8013428 <DataStageIn+0xf8>)
 8013380:	2200      	movs	r2, #0
 8013382:	701a      	strb	r2, [r3, #0]
    #ifndef STM32F10X_CL 
      vSetEPTxStatus(EP_TX_STALL);
    #endif  /* STM32F10X_CL */ 
    }
    
    goto Expect_Status_Out;
 8013384:	e045      	b.n	8013412 <DataStageIn+0xe2>
      ControlState = WAIT_STATUS_OUT;
 8013386:	2307      	movs	r3, #7
 8013388:	617b      	str	r3, [r7, #20]
      vSetEPTxStatus(EP_TX_STALL);
 801338a:	4b2a      	ldr	r3, [pc, #168]	; (8013434 <DataStageIn+0x104>)
 801338c:	2210      	movs	r2, #16
 801338e:	801a      	strh	r2, [r3, #0]
    goto Expect_Status_Out;
 8013390:	e03f      	b.n	8013412 <DataStageIn+0xe2>
  }

  Length = pEPinfo->PacketSize;
 8013392:	68fb      	ldr	r3, [r7, #12]
 8013394:	889b      	ldrh	r3, [r3, #4]
 8013396:	613b      	str	r3, [r7, #16]
  ControlState = (save_wLength <= Length) ? LAST_IN_DATA : IN_DATA;
 8013398:	68ba      	ldr	r2, [r7, #8]
 801339a:	693b      	ldr	r3, [r7, #16]
 801339c:	429a      	cmp	r2, r3
 801339e:	d801      	bhi.n	80133a4 <DataStageIn+0x74>
 80133a0:	2304      	movs	r3, #4
 80133a2:	e000      	b.n	80133a6 <DataStageIn+0x76>
 80133a4:	2302      	movs	r3, #2
 80133a6:	617b      	str	r3, [r7, #20]

  if (Length > save_wLength)
 80133a8:	693a      	ldr	r2, [r7, #16]
 80133aa:	68bb      	ldr	r3, [r7, #8]
 80133ac:	429a      	cmp	r2, r3
 80133ae:	d901      	bls.n	80133b4 <DataStageIn+0x84>
  {
    Length = save_wLength;
 80133b0:	68bb      	ldr	r3, [r7, #8]
 80133b2:	613b      	str	r3, [r7, #16]
  }

  DataBuffer = (*pEPinfo->CopyData)(Length);
 80133b4:	68fb      	ldr	r3, [r7, #12]
 80133b6:	689b      	ldr	r3, [r3, #8]
 80133b8:	693a      	ldr	r2, [r7, #16]
 80133ba:	b292      	uxth	r2, r2
 80133bc:	4610      	mov	r0, r2
 80133be:	4798      	blx	r3
 80133c0:	6078      	str	r0, [r7, #4]

#ifdef STM32F10X_CL
  PCD_EP_Write (ENDP0, DataBuffer, Length);
#else   
  UserToPMABufferCopy(DataBuffer, GetEPTxAddr(ENDP0), Length);
 80133c2:	2000      	movs	r0, #0
 80133c4:	4b1c      	ldr	r3, [pc, #112]	; (8013438 <DataStageIn+0x108>)
 80133c6:	4798      	blx	r3
 80133c8:	4603      	mov	r3, r0
 80133ca:	4619      	mov	r1, r3
 80133cc:	693b      	ldr	r3, [r7, #16]
 80133ce:	b29b      	uxth	r3, r3
 80133d0:	461a      	mov	r2, r3
 80133d2:	6878      	ldr	r0, [r7, #4]
 80133d4:	4b19      	ldr	r3, [pc, #100]	; (801343c <DataStageIn+0x10c>)
 80133d6:	4798      	blx	r3
#endif /* STM32F10X_CL */ 

  SetEPTxCount(ENDP0, Length);
 80133d8:	693b      	ldr	r3, [r7, #16]
 80133da:	b29b      	uxth	r3, r3
 80133dc:	4619      	mov	r1, r3
 80133de:	2000      	movs	r0, #0
 80133e0:	4b17      	ldr	r3, [pc, #92]	; (8013440 <DataStageIn+0x110>)
 80133e2:	4798      	blx	r3

  pEPinfo->Usb_wLength -= Length;
 80133e4:	68fb      	ldr	r3, [r7, #12]
 80133e6:	881a      	ldrh	r2, [r3, #0]
 80133e8:	693b      	ldr	r3, [r7, #16]
 80133ea:	b29b      	uxth	r3, r3
 80133ec:	1ad3      	subs	r3, r2, r3
 80133ee:	b29a      	uxth	r2, r3
 80133f0:	68fb      	ldr	r3, [r7, #12]
 80133f2:	801a      	strh	r2, [r3, #0]
  pEPinfo->Usb_wOffset += Length;
 80133f4:	68fb      	ldr	r3, [r7, #12]
 80133f6:	885a      	ldrh	r2, [r3, #2]
 80133f8:	693b      	ldr	r3, [r7, #16]
 80133fa:	b29b      	uxth	r3, r3
 80133fc:	4413      	add	r3, r2
 80133fe:	b29a      	uxth	r2, r3
 8013400:	68fb      	ldr	r3, [r7, #12]
 8013402:	805a      	strh	r2, [r3, #2]
  vSetEPTxStatus(EP_TX_VALID);
 8013404:	4b0b      	ldr	r3, [pc, #44]	; (8013434 <DataStageIn+0x104>)
 8013406:	2230      	movs	r2, #48	; 0x30
 8013408:	801a      	strh	r2, [r3, #0]

  USB_StatusOut();/* Expect the host to abort the data IN stage */
 801340a:	4b0e      	ldr	r3, [pc, #56]	; (8013444 <DataStageIn+0x114>)
 801340c:	f44f 5240 	mov.w	r2, #12288	; 0x3000
 8013410:	801a      	strh	r2, [r3, #0]

Expect_Status_Out:
  pInformation->ControlState = ControlState;
 8013412:	4b04      	ldr	r3, [pc, #16]	; (8013424 <DataStageIn+0xf4>)
 8013414:	681b      	ldr	r3, [r3, #0]
 8013416:	697a      	ldr	r2, [r7, #20]
 8013418:	b2d2      	uxtb	r2, r2
 801341a:	721a      	strb	r2, [r3, #8]
}
 801341c:	bf00      	nop
 801341e:	3718      	adds	r7, #24
 8013420:	46bd      	mov	sp, r7
 8013422:	bd80      	pop	{r7, pc}
 8013424:	200096d0 	.word	0x200096d0
 8013428:	200096ce 	.word	0x200096ce
 801342c:	40005c50 	.word	0x40005c50
 8013430:	20003002 	.word	0x20003002
 8013434:	200096e2 	.word	0x200096e2
 8013438:	08014361 	.word	0x08014361
 801343c:	08013f15 	.word	0x08013f15
 8013440:	080143c9 	.word	0x080143c9
 8013444:	200096e0 	.word	0x200096e0

08013448 <NoData_Setup0>:
* Input          : None.
* Output         : None.
* Return         : None.
*******************************************************************************/
void NoData_Setup0(void)
{
 8013448:	b580      	push	{r7, lr}
 801344a:	b084      	sub	sp, #16
 801344c:	af00      	add	r7, sp, #0
  RESULT Result = USB_UNSUPPORT;
 801344e:	2302      	movs	r3, #2
 8013450:	73fb      	strb	r3, [r7, #15]
  uint32_t RequestNo = pInformation->USBbRequest;
 8013452:	4b60      	ldr	r3, [pc, #384]	; (80135d4 <NoData_Setup0+0x18c>)
 8013454:	681b      	ldr	r3, [r3, #0]
 8013456:	785b      	ldrb	r3, [r3, #1]
 8013458:	607b      	str	r3, [r7, #4]
  uint32_t ControlState;

  if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
 801345a:	4b5e      	ldr	r3, [pc, #376]	; (80135d4 <NoData_Setup0+0x18c>)
 801345c:	681b      	ldr	r3, [r3, #0]
 801345e:	781b      	ldrb	r3, [r3, #0]
 8013460:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8013464:	2b00      	cmp	r3, #0
 8013466:	d15d      	bne.n	8013524 <NoData_Setup0+0xdc>
  {
    /* Device Request*/
    /* SET_CONFIGURATION*/
    if (RequestNo == SET_CONFIGURATION)
 8013468:	687b      	ldr	r3, [r7, #4]
 801346a:	2b09      	cmp	r3, #9
 801346c:	d104      	bne.n	8013478 <NoData_Setup0+0x30>
    {
      Result = Standard_SetConfiguration();
 801346e:	4b5a      	ldr	r3, [pc, #360]	; (80135d8 <NoData_Setup0+0x190>)
 8013470:	4798      	blx	r3
 8013472:	4603      	mov	r3, r0
 8013474:	73fb      	strb	r3, [r7, #15]
 8013476:	e07d      	b.n	8013574 <NoData_Setup0+0x12c>
    }

    /*SET ADDRESS*/
    else if (RequestNo == SET_ADDRESS)
 8013478:	687b      	ldr	r3, [r7, #4]
 801347a:	2b05      	cmp	r3, #5
 801347c:	d11a      	bne.n	80134b4 <NoData_Setup0+0x6c>
    {
      if ((pInformation->USBwValue0 > 127) || (pInformation->USBwValue1 != 0)
 801347e:	4b55      	ldr	r3, [pc, #340]	; (80135d4 <NoData_Setup0+0x18c>)
 8013480:	681b      	ldr	r3, [r3, #0]
 8013482:	78db      	ldrb	r3, [r3, #3]
 8013484:	b25b      	sxtb	r3, r3
 8013486:	2b00      	cmp	r3, #0
 8013488:	db0e      	blt.n	80134a8 <NoData_Setup0+0x60>
 801348a:	4b52      	ldr	r3, [pc, #328]	; (80135d4 <NoData_Setup0+0x18c>)
 801348c:	681b      	ldr	r3, [r3, #0]
 801348e:	789b      	ldrb	r3, [r3, #2]
 8013490:	2b00      	cmp	r3, #0
 8013492:	d109      	bne.n	80134a8 <NoData_Setup0+0x60>
          || (pInformation->USBwIndex != 0)
 8013494:	4b4f      	ldr	r3, [pc, #316]	; (80135d4 <NoData_Setup0+0x18c>)
 8013496:	681b      	ldr	r3, [r3, #0]
 8013498:	889b      	ldrh	r3, [r3, #4]
 801349a:	2b00      	cmp	r3, #0
 801349c:	d104      	bne.n	80134a8 <NoData_Setup0+0x60>
          || (pInformation->Current_Configuration != 0))
 801349e:	4b4d      	ldr	r3, [pc, #308]	; (80135d4 <NoData_Setup0+0x18c>)
 80134a0:	681b      	ldr	r3, [r3, #0]
 80134a2:	7a9b      	ldrb	r3, [r3, #10]
 80134a4:	2b00      	cmp	r3, #0
 80134a6:	d002      	beq.n	80134ae <NoData_Setup0+0x66>
        /* Device Address should be 127 or less*/
      {
        ControlState = STALLED;
 80134a8:	2308      	movs	r3, #8
 80134aa:	60bb      	str	r3, [r7, #8]
        goto exit_NoData_Setup0;
 80134ac:	e089      	b.n	80135c2 <NoData_Setup0+0x17a>
      }
      else
      {
        Result = USB_SUCCESS;
 80134ae:	2300      	movs	r3, #0
 80134b0:	73fb      	strb	r3, [r7, #15]
 80134b2:	e05f      	b.n	8013574 <NoData_Setup0+0x12c>
         SetDeviceAddress(pInformation->USBwValue0);
      #endif  /* STM32F10X_CL */
      }
    }
    /*SET FEATURE for Device*/
    else if (RequestNo == SET_FEATURE)
 80134b4:	687b      	ldr	r3, [r7, #4]
 80134b6:	2b03      	cmp	r3, #3
 80134b8:	d118      	bne.n	80134ec <NoData_Setup0+0xa4>
    {
      if ((pInformation->USBwValue0 == DEVICE_REMOTE_WAKEUP)
 80134ba:	4b46      	ldr	r3, [pc, #280]	; (80135d4 <NoData_Setup0+0x18c>)
 80134bc:	681b      	ldr	r3, [r3, #0]
 80134be:	78db      	ldrb	r3, [r3, #3]
 80134c0:	2b01      	cmp	r3, #1
 80134c2:	d110      	bne.n	80134e6 <NoData_Setup0+0x9e>
          && (pInformation->USBwIndex == 0)
 80134c4:	4b43      	ldr	r3, [pc, #268]	; (80135d4 <NoData_Setup0+0x18c>)
 80134c6:	681b      	ldr	r3, [r3, #0]
 80134c8:	889b      	ldrh	r3, [r3, #4]
 80134ca:	2b00      	cmp	r3, #0
 80134cc:	d10b      	bne.n	80134e6 <NoData_Setup0+0x9e>
          && (ValBit(pInformation->Current_Feature, 5)))
 80134ce:	4b41      	ldr	r3, [pc, #260]	; (80135d4 <NoData_Setup0+0x18c>)
 80134d0:	681b      	ldr	r3, [r3, #0]
 80134d2:	7a5b      	ldrb	r3, [r3, #9]
 80134d4:	f003 0320 	and.w	r3, r3, #32
 80134d8:	2b00      	cmp	r3, #0
 80134da:	d004      	beq.n	80134e6 <NoData_Setup0+0x9e>
      {
        Result = Standard_SetDeviceFeature();
 80134dc:	4b3f      	ldr	r3, [pc, #252]	; (80135dc <NoData_Setup0+0x194>)
 80134de:	4798      	blx	r3
 80134e0:	4603      	mov	r3, r0
 80134e2:	73fb      	strb	r3, [r7, #15]
 80134e4:	e046      	b.n	8013574 <NoData_Setup0+0x12c>
      }
      else
      {
        Result = USB_UNSUPPORT;
 80134e6:	2302      	movs	r3, #2
 80134e8:	73fb      	strb	r3, [r7, #15]
 80134ea:	e043      	b.n	8013574 <NoData_Setup0+0x12c>
      }
    }
    /*Clear FEATURE for Device */
    else if (RequestNo == CLEAR_FEATURE)
 80134ec:	687b      	ldr	r3, [r7, #4]
 80134ee:	2b01      	cmp	r3, #1
 80134f0:	d140      	bne.n	8013574 <NoData_Setup0+0x12c>
    {
      if (pInformation->USBwValue0 == DEVICE_REMOTE_WAKEUP
 80134f2:	4b38      	ldr	r3, [pc, #224]	; (80135d4 <NoData_Setup0+0x18c>)
 80134f4:	681b      	ldr	r3, [r3, #0]
 80134f6:	78db      	ldrb	r3, [r3, #3]
 80134f8:	2b01      	cmp	r3, #1
 80134fa:	d110      	bne.n	801351e <NoData_Setup0+0xd6>
          && pInformation->USBwIndex == 0
 80134fc:	4b35      	ldr	r3, [pc, #212]	; (80135d4 <NoData_Setup0+0x18c>)
 80134fe:	681b      	ldr	r3, [r3, #0]
 8013500:	889b      	ldrh	r3, [r3, #4]
 8013502:	2b00      	cmp	r3, #0
 8013504:	d10b      	bne.n	801351e <NoData_Setup0+0xd6>
          && ValBit(pInformation->Current_Feature, 5))
 8013506:	4b33      	ldr	r3, [pc, #204]	; (80135d4 <NoData_Setup0+0x18c>)
 8013508:	681b      	ldr	r3, [r3, #0]
 801350a:	7a5b      	ldrb	r3, [r3, #9]
 801350c:	f003 0320 	and.w	r3, r3, #32
 8013510:	2b00      	cmp	r3, #0
 8013512:	d004      	beq.n	801351e <NoData_Setup0+0xd6>
      {
        Result = Standard_ClearFeature();
 8013514:	4b32      	ldr	r3, [pc, #200]	; (80135e0 <NoData_Setup0+0x198>)
 8013516:	4798      	blx	r3
 8013518:	4603      	mov	r3, r0
 801351a:	73fb      	strb	r3, [r7, #15]
 801351c:	e02a      	b.n	8013574 <NoData_Setup0+0x12c>
      }
      else
      {
        Result = USB_UNSUPPORT;
 801351e:	2302      	movs	r3, #2
 8013520:	73fb      	strb	r3, [r7, #15]
 8013522:	e027      	b.n	8013574 <NoData_Setup0+0x12c>
    }

  }

  /* Interface Request*/
  else if (Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
 8013524:	4b2b      	ldr	r3, [pc, #172]	; (80135d4 <NoData_Setup0+0x18c>)
 8013526:	681b      	ldr	r3, [r3, #0]
 8013528:	781b      	ldrb	r3, [r3, #0]
 801352a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 801352e:	2b01      	cmp	r3, #1
 8013530:	d107      	bne.n	8013542 <NoData_Setup0+0xfa>
  {
    /*SET INTERFACE*/
    if (RequestNo == SET_INTERFACE)
 8013532:	687b      	ldr	r3, [r7, #4]
 8013534:	2b0b      	cmp	r3, #11
 8013536:	d11d      	bne.n	8013574 <NoData_Setup0+0x12c>
    {
      Result = Standard_SetInterface();
 8013538:	4b2a      	ldr	r3, [pc, #168]	; (80135e4 <NoData_Setup0+0x19c>)
 801353a:	4798      	blx	r3
 801353c:	4603      	mov	r3, r0
 801353e:	73fb      	strb	r3, [r7, #15]
 8013540:	e018      	b.n	8013574 <NoData_Setup0+0x12c>
    }
  }

  /* EndPoint Request*/
  else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
 8013542:	4b24      	ldr	r3, [pc, #144]	; (80135d4 <NoData_Setup0+0x18c>)
 8013544:	681b      	ldr	r3, [r3, #0]
 8013546:	781b      	ldrb	r3, [r3, #0]
 8013548:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 801354c:	2b02      	cmp	r3, #2
 801354e:	d10f      	bne.n	8013570 <NoData_Setup0+0x128>
  {
    /*CLEAR FEATURE for EndPoint*/
    if (RequestNo == CLEAR_FEATURE)
 8013550:	687b      	ldr	r3, [r7, #4]
 8013552:	2b01      	cmp	r3, #1
 8013554:	d104      	bne.n	8013560 <NoData_Setup0+0x118>
    {
      Result = Standard_ClearFeature();
 8013556:	4b22      	ldr	r3, [pc, #136]	; (80135e0 <NoData_Setup0+0x198>)
 8013558:	4798      	blx	r3
 801355a:	4603      	mov	r3, r0
 801355c:	73fb      	strb	r3, [r7, #15]
 801355e:	e009      	b.n	8013574 <NoData_Setup0+0x12c>
    }
    /* SET FEATURE for EndPoint*/
    else if (RequestNo == SET_FEATURE)
 8013560:	687b      	ldr	r3, [r7, #4]
 8013562:	2b03      	cmp	r3, #3
 8013564:	d106      	bne.n	8013574 <NoData_Setup0+0x12c>
    {
      Result = Standard_SetEndPointFeature();
 8013566:	4b20      	ldr	r3, [pc, #128]	; (80135e8 <NoData_Setup0+0x1a0>)
 8013568:	4798      	blx	r3
 801356a:	4603      	mov	r3, r0
 801356c:	73fb      	strb	r3, [r7, #15]
 801356e:	e001      	b.n	8013574 <NoData_Setup0+0x12c>
    }
  }
  else
  {
    Result = USB_UNSUPPORT;
 8013570:	2302      	movs	r3, #2
 8013572:	73fb      	strb	r3, [r7, #15]
  }


  if (Result != USB_SUCCESS)
 8013574:	7bfb      	ldrb	r3, [r7, #15]
 8013576:	2b00      	cmp	r3, #0
 8013578:	d00e      	beq.n	8013598 <NoData_Setup0+0x150>
  {
    Result = (*pProperty->Class_NoData_Setup)(RequestNo);
 801357a:	4b1c      	ldr	r3, [pc, #112]	; (80135ec <NoData_Setup0+0x1a4>)
 801357c:	681b      	ldr	r3, [r3, #0]
 801357e:	695b      	ldr	r3, [r3, #20]
 8013580:	687a      	ldr	r2, [r7, #4]
 8013582:	b2d2      	uxtb	r2, r2
 8013584:	4610      	mov	r0, r2
 8013586:	4798      	blx	r3
 8013588:	4603      	mov	r3, r0
 801358a:	73fb      	strb	r3, [r7, #15]
    if (Result == USB_NOT_READY)
 801358c:	7bfb      	ldrb	r3, [r7, #15]
 801358e:	2b03      	cmp	r3, #3
 8013590:	d102      	bne.n	8013598 <NoData_Setup0+0x150>
    {
      ControlState = PAUSE;
 8013592:	2309      	movs	r3, #9
 8013594:	60bb      	str	r3, [r7, #8]
      goto exit_NoData_Setup0;
 8013596:	e014      	b.n	80135c2 <NoData_Setup0+0x17a>
    }
  }

  if (Result != USB_SUCCESS)
 8013598:	7bfb      	ldrb	r3, [r7, #15]
 801359a:	2b00      	cmp	r3, #0
 801359c:	d002      	beq.n	80135a4 <NoData_Setup0+0x15c>
  {
    ControlState = STALLED;
 801359e:	2308      	movs	r3, #8
 80135a0:	60bb      	str	r3, [r7, #8]
    goto exit_NoData_Setup0;
 80135a2:	e00e      	b.n	80135c2 <NoData_Setup0+0x17a>
  }

  ControlState = WAIT_STATUS_IN;/* After no data stage SETUP */
 80135a4:	2306      	movs	r3, #6
 80135a6:	60bb      	str	r3, [r7, #8]

  USB_StatusIn();
 80135a8:	4b11      	ldr	r3, [pc, #68]	; (80135f0 <NoData_Setup0+0x1a8>)
 80135aa:	681b      	ldr	r3, [r3, #0]
 80135ac:	b29b      	uxth	r3, r3
 80135ae:	461a      	mov	r2, r3
 80135b0:	4b10      	ldr	r3, [pc, #64]	; (80135f4 <NoData_Setup0+0x1ac>)
 80135b2:	4413      	add	r3, r2
 80135b4:	005b      	lsls	r3, r3, #1
 80135b6:	461a      	mov	r2, r3
 80135b8:	2300      	movs	r3, #0
 80135ba:	6013      	str	r3, [r2, #0]
 80135bc:	4b0e      	ldr	r3, [pc, #56]	; (80135f8 <NoData_Setup0+0x1b0>)
 80135be:	2230      	movs	r2, #48	; 0x30
 80135c0:	801a      	strh	r2, [r3, #0]

exit_NoData_Setup0:
  pInformation->ControlState = ControlState;
 80135c2:	4b04      	ldr	r3, [pc, #16]	; (80135d4 <NoData_Setup0+0x18c>)
 80135c4:	681b      	ldr	r3, [r3, #0]
 80135c6:	68ba      	ldr	r2, [r7, #8]
 80135c8:	b2d2      	uxtb	r2, r2
 80135ca:	721a      	strb	r2, [r3, #8]
  return;
 80135cc:	bf00      	nop
}
 80135ce:	3710      	adds	r7, #16
 80135d0:	46bd      	mov	sp, r7
 80135d2:	bd80      	pop	{r7, pc}
 80135d4:	200096d0 	.word	0x200096d0
 80135d8:	08012c65 	.word	0x08012c65
 80135dc:	080131ad 	.word	0x080131ad
 80135e0:	08012eb1 	.word	0x08012eb1
 80135e4:	08012cf1 	.word	0x08012cf1
 80135e8:	08013099 	.word	0x08013099
 80135ec:	200096d4 	.word	0x200096d4
 80135f0:	40005c50 	.word	0x40005c50
 80135f4:	20003002 	.word	0x20003002
 80135f8:	200096e2 	.word	0x200096e2

080135fc <Data_Setup0>:
* Input          : None.
* Output         : None.
* Return         : None.
*******************************************************************************/
void Data_Setup0(void)
{
 80135fc:	b580      	push	{r7, lr}
 80135fe:	b08a      	sub	sp, #40	; 0x28
 8013600:	af00      	add	r7, sp, #0
  uint8_t *(*CopyRoutine)(uint16_t);
  RESULT Result;
  uint32_t Request_No = pInformation->USBbRequest;
 8013602:	4b8d      	ldr	r3, [pc, #564]	; (8013838 <Data_Setup0+0x23c>)
 8013604:	681b      	ldr	r3, [r3, #0]
 8013606:	785b      	ldrb	r3, [r3, #1]
 8013608:	61bb      	str	r3, [r7, #24]
  uint32_t Related_Endpoint, Reserved;
  uint32_t wOffset, Status;



  CopyRoutine = NULL;
 801360a:	2300      	movs	r3, #0
 801360c:	627b      	str	r3, [r7, #36]	; 0x24
  wOffset = 0;
 801360e:	2300      	movs	r3, #0
 8013610:	617b      	str	r3, [r7, #20]

  /*GET DESCRIPTOR*/
  if (Request_No == GET_DESCRIPTOR)
 8013612:	69bb      	ldr	r3, [r7, #24]
 8013614:	2b06      	cmp	r3, #6
 8013616:	d124      	bne.n	8013662 <Data_Setup0+0x66>
  {
    if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
 8013618:	4b87      	ldr	r3, [pc, #540]	; (8013838 <Data_Setup0+0x23c>)
 801361a:	681b      	ldr	r3, [r3, #0]
 801361c:	781b      	ldrb	r3, [r3, #0]
 801361e:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8013622:	2b00      	cmp	r3, #0
 8013624:	f040 80d4 	bne.w	80137d0 <Data_Setup0+0x1d4>
    {
      uint8_t wValue1 = pInformation->USBwValue1;
 8013628:	4b83      	ldr	r3, [pc, #524]	; (8013838 <Data_Setup0+0x23c>)
 801362a:	681b      	ldr	r3, [r3, #0]
 801362c:	789b      	ldrb	r3, [r3, #2]
 801362e:	72fb      	strb	r3, [r7, #11]
      if (wValue1 == DEVICE_DESCRIPTOR)
 8013630:	7afb      	ldrb	r3, [r7, #11]
 8013632:	2b01      	cmp	r3, #1
 8013634:	d104      	bne.n	8013640 <Data_Setup0+0x44>
      {
        CopyRoutine = pProperty->GetDeviceDescriptor;
 8013636:	4b81      	ldr	r3, [pc, #516]	; (801383c <Data_Setup0+0x240>)
 8013638:	681b      	ldr	r3, [r3, #0]
 801363a:	69db      	ldr	r3, [r3, #28]
 801363c:	627b      	str	r3, [r7, #36]	; 0x24
 801363e:	e0c7      	b.n	80137d0 <Data_Setup0+0x1d4>
      }
      else if (wValue1 == CONFIG_DESCRIPTOR)
 8013640:	7afb      	ldrb	r3, [r7, #11]
 8013642:	2b02      	cmp	r3, #2
 8013644:	d104      	bne.n	8013650 <Data_Setup0+0x54>
      {
        CopyRoutine = pProperty->GetConfigDescriptor;
 8013646:	4b7d      	ldr	r3, [pc, #500]	; (801383c <Data_Setup0+0x240>)
 8013648:	681b      	ldr	r3, [r3, #0]
 801364a:	6a1b      	ldr	r3, [r3, #32]
 801364c:	627b      	str	r3, [r7, #36]	; 0x24
 801364e:	e0bf      	b.n	80137d0 <Data_Setup0+0x1d4>
      }
      else if (wValue1 == STRING_DESCRIPTOR)
 8013650:	7afb      	ldrb	r3, [r7, #11]
 8013652:	2b03      	cmp	r3, #3
 8013654:	f040 80bc 	bne.w	80137d0 <Data_Setup0+0x1d4>
      {
        CopyRoutine = pProperty->GetStringDescriptor;
 8013658:	4b78      	ldr	r3, [pc, #480]	; (801383c <Data_Setup0+0x240>)
 801365a:	681b      	ldr	r3, [r3, #0]
 801365c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 801365e:	627b      	str	r3, [r7, #36]	; 0x24
 8013660:	e0b6      	b.n	80137d0 <Data_Setup0+0x1d4>
      }  /* End of GET_DESCRIPTOR */
    }
  }

  /*GET STATUS*/
  else if ((Request_No == GET_STATUS) && (pInformation->USBwValue == 0)
 8013662:	69bb      	ldr	r3, [r7, #24]
 8013664:	2b00      	cmp	r3, #0
 8013666:	d178      	bne.n	801375a <Data_Setup0+0x15e>
 8013668:	4b73      	ldr	r3, [pc, #460]	; (8013838 <Data_Setup0+0x23c>)
 801366a:	681b      	ldr	r3, [r3, #0]
 801366c:	885b      	ldrh	r3, [r3, #2]
 801366e:	2b00      	cmp	r3, #0
 8013670:	d173      	bne.n	801375a <Data_Setup0+0x15e>
           && (pInformation->USBwLength == 0x0002)
 8013672:	4b71      	ldr	r3, [pc, #452]	; (8013838 <Data_Setup0+0x23c>)
 8013674:	681b      	ldr	r3, [r3, #0]
 8013676:	88db      	ldrh	r3, [r3, #6]
 8013678:	2b02      	cmp	r3, #2
 801367a:	d16e      	bne.n	801375a <Data_Setup0+0x15e>
           && (pInformation->USBwIndex1 == 0))
 801367c:	4b6e      	ldr	r3, [pc, #440]	; (8013838 <Data_Setup0+0x23c>)
 801367e:	681b      	ldr	r3, [r3, #0]
 8013680:	791b      	ldrb	r3, [r3, #4]
 8013682:	2b00      	cmp	r3, #0
 8013684:	d169      	bne.n	801375a <Data_Setup0+0x15e>
  {
    /* GET STATUS for Device*/
    if ((Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
 8013686:	4b6c      	ldr	r3, [pc, #432]	; (8013838 <Data_Setup0+0x23c>)
 8013688:	681b      	ldr	r3, [r3, #0]
 801368a:	781b      	ldrb	r3, [r3, #0]
 801368c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8013690:	2b00      	cmp	r3, #0
 8013692:	d107      	bne.n	80136a4 <Data_Setup0+0xa8>
        && (pInformation->USBwIndex == 0))
 8013694:	4b68      	ldr	r3, [pc, #416]	; (8013838 <Data_Setup0+0x23c>)
 8013696:	681b      	ldr	r3, [r3, #0]
 8013698:	889b      	ldrh	r3, [r3, #4]
 801369a:	2b00      	cmp	r3, #0
 801369c:	d102      	bne.n	80136a4 <Data_Setup0+0xa8>
    {
      CopyRoutine = Standard_GetStatus;
 801369e:	4b68      	ldr	r3, [pc, #416]	; (8013840 <Data_Setup0+0x244>)
 80136a0:	627b      	str	r3, [r7, #36]	; 0x24
    if ((Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
 80136a2:	e094      	b.n	80137ce <Data_Setup0+0x1d2>
    }

    /* GET STATUS for Interface*/
    else if (Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
 80136a4:	4b64      	ldr	r3, [pc, #400]	; (8013838 <Data_Setup0+0x23c>)
 80136a6:	681b      	ldr	r3, [r3, #0]
 80136a8:	781b      	ldrb	r3, [r3, #0]
 80136aa:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80136ae:	2b01      	cmp	r3, #1
 80136b0:	d114      	bne.n	80136dc <Data_Setup0+0xe0>
    {
      if (((*pProperty->Class_Get_Interface_Setting)(pInformation->USBwIndex0, 0) == USB_SUCCESS)
 80136b2:	4b62      	ldr	r3, [pc, #392]	; (801383c <Data_Setup0+0x240>)
 80136b4:	681b      	ldr	r3, [r3, #0]
 80136b6:	699b      	ldr	r3, [r3, #24]
 80136b8:	4a5f      	ldr	r2, [pc, #380]	; (8013838 <Data_Setup0+0x23c>)
 80136ba:	6812      	ldr	r2, [r2, #0]
 80136bc:	7952      	ldrb	r2, [r2, #5]
 80136be:	2100      	movs	r1, #0
 80136c0:	4610      	mov	r0, r2
 80136c2:	4798      	blx	r3
 80136c4:	4603      	mov	r3, r0
 80136c6:	2b00      	cmp	r3, #0
 80136c8:	f040 8081 	bne.w	80137ce <Data_Setup0+0x1d2>
          && (pInformation->Current_Configuration != 0))
 80136cc:	4b5a      	ldr	r3, [pc, #360]	; (8013838 <Data_Setup0+0x23c>)
 80136ce:	681b      	ldr	r3, [r3, #0]
 80136d0:	7a9b      	ldrb	r3, [r3, #10]
 80136d2:	2b00      	cmp	r3, #0
 80136d4:	d07b      	beq.n	80137ce <Data_Setup0+0x1d2>
      {
        CopyRoutine = Standard_GetStatus;
 80136d6:	4b5a      	ldr	r3, [pc, #360]	; (8013840 <Data_Setup0+0x244>)
 80136d8:	627b      	str	r3, [r7, #36]	; 0x24
    if ((Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
 80136da:	e078      	b.n	80137ce <Data_Setup0+0x1d2>
      }
    }

    /* GET STATUS for EndPoint*/
    else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
 80136dc:	4b56      	ldr	r3, [pc, #344]	; (8013838 <Data_Setup0+0x23c>)
 80136de:	681b      	ldr	r3, [r3, #0]
 80136e0:	781b      	ldrb	r3, [r3, #0]
 80136e2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80136e6:	2b02      	cmp	r3, #2
 80136e8:	d171      	bne.n	80137ce <Data_Setup0+0x1d2>
    {
      Related_Endpoint = (pInformation->USBwIndex0 & 0x0f);
 80136ea:	4b53      	ldr	r3, [pc, #332]	; (8013838 <Data_Setup0+0x23c>)
 80136ec:	681b      	ldr	r3, [r3, #0]
 80136ee:	795b      	ldrb	r3, [r3, #5]
 80136f0:	f003 030f 	and.w	r3, r3, #15
 80136f4:	613b      	str	r3, [r7, #16]
      Reserved = pInformation->USBwIndex0 & 0x70;
 80136f6:	4b50      	ldr	r3, [pc, #320]	; (8013838 <Data_Setup0+0x23c>)
 80136f8:	681b      	ldr	r3, [r3, #0]
 80136fa:	795b      	ldrb	r3, [r3, #5]
 80136fc:	f003 0370 	and.w	r3, r3, #112	; 0x70
 8013700:	60fb      	str	r3, [r7, #12]

      if (ValBit(pInformation->USBwIndex0, 7))
 8013702:	4b4d      	ldr	r3, [pc, #308]	; (8013838 <Data_Setup0+0x23c>)
 8013704:	681b      	ldr	r3, [r3, #0]
 8013706:	795b      	ldrb	r3, [r3, #5]
 8013708:	b25b      	sxtb	r3, r3
 801370a:	2b00      	cmp	r3, #0
 801370c:	da0b      	bge.n	8013726 <Data_Setup0+0x12a>
      {
        /*Get Status of endpoint & stall the request if the related_ENdpoint
        is Disabled*/
        Status = _GetEPTxStatus(Related_Endpoint);
 801370e:	693b      	ldr	r3, [r7, #16]
 8013710:	009b      	lsls	r3, r3, #2
 8013712:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8013716:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
 801371a:	681b      	ldr	r3, [r3, #0]
 801371c:	b29b      	uxth	r3, r3
 801371e:	f003 0330 	and.w	r3, r3, #48	; 0x30
 8013722:	61fb      	str	r3, [r7, #28]
 8013724:	e00a      	b.n	801373c <Data_Setup0+0x140>
      }
      else
      {
        Status = _GetEPRxStatus(Related_Endpoint);
 8013726:	693b      	ldr	r3, [r7, #16]
 8013728:	009b      	lsls	r3, r3, #2
 801372a:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 801372e:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
 8013732:	681b      	ldr	r3, [r3, #0]
 8013734:	b29b      	uxth	r3, r3
 8013736:	f403 5340 	and.w	r3, r3, #12288	; 0x3000
 801373a:	61fb      	str	r3, [r7, #28]
      }

      if ((Related_Endpoint < Device_Table.Total_Endpoint) && (Reserved == 0)
 801373c:	4b41      	ldr	r3, [pc, #260]	; (8013844 <Data_Setup0+0x248>)
 801373e:	781b      	ldrb	r3, [r3, #0]
 8013740:	461a      	mov	r2, r3
 8013742:	693b      	ldr	r3, [r7, #16]
 8013744:	4293      	cmp	r3, r2
 8013746:	d242      	bcs.n	80137ce <Data_Setup0+0x1d2>
 8013748:	68fb      	ldr	r3, [r7, #12]
 801374a:	2b00      	cmp	r3, #0
 801374c:	d13f      	bne.n	80137ce <Data_Setup0+0x1d2>
          && (Status != 0))
 801374e:	69fb      	ldr	r3, [r7, #28]
 8013750:	2b00      	cmp	r3, #0
 8013752:	d03c      	beq.n	80137ce <Data_Setup0+0x1d2>
      {
        CopyRoutine = Standard_GetStatus;
 8013754:	4b3a      	ldr	r3, [pc, #232]	; (8013840 <Data_Setup0+0x244>)
 8013756:	627b      	str	r3, [r7, #36]	; 0x24
    if ((Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
 8013758:	e039      	b.n	80137ce <Data_Setup0+0x1d2>
    }

  }

  /*GET CONFIGURATION*/
  else if (Request_No == GET_CONFIGURATION)
 801375a:	69bb      	ldr	r3, [r7, #24]
 801375c:	2b08      	cmp	r3, #8
 801375e:	d109      	bne.n	8013774 <Data_Setup0+0x178>
  {
    if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
 8013760:	4b35      	ldr	r3, [pc, #212]	; (8013838 <Data_Setup0+0x23c>)
 8013762:	681b      	ldr	r3, [r3, #0]
 8013764:	781b      	ldrb	r3, [r3, #0]
 8013766:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 801376a:	2b00      	cmp	r3, #0
 801376c:	d130      	bne.n	80137d0 <Data_Setup0+0x1d4>
    {
      CopyRoutine = Standard_GetConfiguration;
 801376e:	4b36      	ldr	r3, [pc, #216]	; (8013848 <Data_Setup0+0x24c>)
 8013770:	627b      	str	r3, [r7, #36]	; 0x24
 8013772:	e02d      	b.n	80137d0 <Data_Setup0+0x1d4>
    }
  }
  /*GET INTERFACE*/
  else if (Request_No == GET_INTERFACE)
 8013774:	69bb      	ldr	r3, [r7, #24]
 8013776:	2b0a      	cmp	r3, #10
 8013778:	d12a      	bne.n	80137d0 <Data_Setup0+0x1d4>
  {
    if ((Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
 801377a:	4b2f      	ldr	r3, [pc, #188]	; (8013838 <Data_Setup0+0x23c>)
 801377c:	681b      	ldr	r3, [r3, #0]
 801377e:	781b      	ldrb	r3, [r3, #0]
 8013780:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8013784:	2b01      	cmp	r3, #1
 8013786:	d123      	bne.n	80137d0 <Data_Setup0+0x1d4>
        && (pInformation->Current_Configuration != 0) && (pInformation->USBwValue == 0)
 8013788:	4b2b      	ldr	r3, [pc, #172]	; (8013838 <Data_Setup0+0x23c>)
 801378a:	681b      	ldr	r3, [r3, #0]
 801378c:	7a9b      	ldrb	r3, [r3, #10]
 801378e:	2b00      	cmp	r3, #0
 8013790:	d01e      	beq.n	80137d0 <Data_Setup0+0x1d4>
 8013792:	4b29      	ldr	r3, [pc, #164]	; (8013838 <Data_Setup0+0x23c>)
 8013794:	681b      	ldr	r3, [r3, #0]
 8013796:	885b      	ldrh	r3, [r3, #2]
 8013798:	2b00      	cmp	r3, #0
 801379a:	d119      	bne.n	80137d0 <Data_Setup0+0x1d4>
        && (pInformation->USBwIndex1 == 0) && (pInformation->USBwLength == 0x0001)
 801379c:	4b26      	ldr	r3, [pc, #152]	; (8013838 <Data_Setup0+0x23c>)
 801379e:	681b      	ldr	r3, [r3, #0]
 80137a0:	791b      	ldrb	r3, [r3, #4]
 80137a2:	2b00      	cmp	r3, #0
 80137a4:	d114      	bne.n	80137d0 <Data_Setup0+0x1d4>
 80137a6:	4b24      	ldr	r3, [pc, #144]	; (8013838 <Data_Setup0+0x23c>)
 80137a8:	681b      	ldr	r3, [r3, #0]
 80137aa:	88db      	ldrh	r3, [r3, #6]
 80137ac:	2b01      	cmp	r3, #1
 80137ae:	d10f      	bne.n	80137d0 <Data_Setup0+0x1d4>
        && ((*pProperty->Class_Get_Interface_Setting)(pInformation->USBwIndex0, 0) == USB_SUCCESS))
 80137b0:	4b22      	ldr	r3, [pc, #136]	; (801383c <Data_Setup0+0x240>)
 80137b2:	681b      	ldr	r3, [r3, #0]
 80137b4:	699b      	ldr	r3, [r3, #24]
 80137b6:	4a20      	ldr	r2, [pc, #128]	; (8013838 <Data_Setup0+0x23c>)
 80137b8:	6812      	ldr	r2, [r2, #0]
 80137ba:	7952      	ldrb	r2, [r2, #5]
 80137bc:	2100      	movs	r1, #0
 80137be:	4610      	mov	r0, r2
 80137c0:	4798      	blx	r3
 80137c2:	4603      	mov	r3, r0
 80137c4:	2b00      	cmp	r3, #0
 80137c6:	d103      	bne.n	80137d0 <Data_Setup0+0x1d4>
    {
      CopyRoutine = Standard_GetInterface;
 80137c8:	4b20      	ldr	r3, [pc, #128]	; (801384c <Data_Setup0+0x250>)
 80137ca:	627b      	str	r3, [r7, #36]	; 0x24
 80137cc:	e000      	b.n	80137d0 <Data_Setup0+0x1d4>
    if ((Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
 80137ce:	bf00      	nop
    }

  }
  
  if (CopyRoutine)
 80137d0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80137d2:	2b00      	cmp	r3, #0
 80137d4:	d00f      	beq.n	80137f6 <Data_Setup0+0x1fa>
  {
    pInformation->Ctrl_Info.Usb_wOffset = wOffset;
 80137d6:	4b18      	ldr	r3, [pc, #96]	; (8013838 <Data_Setup0+0x23c>)
 80137d8:	681b      	ldr	r3, [r3, #0]
 80137da:	697a      	ldr	r2, [r7, #20]
 80137dc:	b292      	uxth	r2, r2
 80137de:	825a      	strh	r2, [r3, #18]
    pInformation->Ctrl_Info.CopyData = CopyRoutine;
 80137e0:	4b15      	ldr	r3, [pc, #84]	; (8013838 <Data_Setup0+0x23c>)
 80137e2:	681b      	ldr	r3, [r3, #0]
 80137e4:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 80137e6:	619a      	str	r2, [r3, #24]
    /* sb in the original the cast to word was directly */
    /* now the cast is made step by step */
    (*CopyRoutine)(0);
 80137e8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80137ea:	2000      	movs	r0, #0
 80137ec:	4798      	blx	r3
    Result = USB_SUCCESS;
 80137ee:	2300      	movs	r3, #0
 80137f0:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
 80137f4:	e013      	b.n	801381e <Data_Setup0+0x222>
  }
  else
  {
    Result = (*pProperty->Class_Data_Setup)(pInformation->USBbRequest);
 80137f6:	4b11      	ldr	r3, [pc, #68]	; (801383c <Data_Setup0+0x240>)
 80137f8:	681b      	ldr	r3, [r3, #0]
 80137fa:	691b      	ldr	r3, [r3, #16]
 80137fc:	4a0e      	ldr	r2, [pc, #56]	; (8013838 <Data_Setup0+0x23c>)
 80137fe:	6812      	ldr	r2, [r2, #0]
 8013800:	7852      	ldrb	r2, [r2, #1]
 8013802:	4610      	mov	r0, r2
 8013804:	4798      	blx	r3
 8013806:	4603      	mov	r3, r0
 8013808:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
    if (Result == USB_NOT_READY)
 801380c:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 8013810:	2b03      	cmp	r3, #3
 8013812:	d104      	bne.n	801381e <Data_Setup0+0x222>
    {
      pInformation->ControlState = PAUSE;
 8013814:	4b08      	ldr	r3, [pc, #32]	; (8013838 <Data_Setup0+0x23c>)
 8013816:	681b      	ldr	r3, [r3, #0]
 8013818:	2209      	movs	r2, #9
 801381a:	721a      	strb	r2, [r3, #8]
      return;
 801381c:	e078      	b.n	8013910 <Data_Setup0+0x314>
    }
  }

  if (pInformation->Ctrl_Info.Usb_wLength == 0xFFFF)
 801381e:	4b06      	ldr	r3, [pc, #24]	; (8013838 <Data_Setup0+0x23c>)
 8013820:	681b      	ldr	r3, [r3, #0]
 8013822:	8a1b      	ldrh	r3, [r3, #16]
 8013824:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8013828:	4293      	cmp	r3, r2
 801382a:	d111      	bne.n	8013850 <Data_Setup0+0x254>
  {
    /* Data is not ready, wait it */
    pInformation->ControlState = PAUSE;
 801382c:	4b02      	ldr	r3, [pc, #8]	; (8013838 <Data_Setup0+0x23c>)
 801382e:	681b      	ldr	r3, [r3, #0]
 8013830:	2209      	movs	r2, #9
 8013832:	721a      	strb	r2, [r3, #8]
    return;
 8013834:	e06c      	b.n	8013910 <Data_Setup0+0x314>
 8013836:	bf00      	nop
 8013838:	200096d0 	.word	0x200096d0
 801383c:	200096d4 	.word	0x200096d4
 8013840:	08012d79 	.word	0x08012d79
 8013844:	200001c4 	.word	0x200001c4
 8013848:	08012c29 	.word	0x08012c29
 801384c:	08012cb5 	.word	0x08012cb5
  }
  if ((Result == USB_UNSUPPORT) || (pInformation->Ctrl_Info.Usb_wLength == 0))
 8013850:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
 8013854:	2b02      	cmp	r3, #2
 8013856:	d004      	beq.n	8013862 <Data_Setup0+0x266>
 8013858:	4b2f      	ldr	r3, [pc, #188]	; (8013918 <Data_Setup0+0x31c>)
 801385a:	681b      	ldr	r3, [r3, #0]
 801385c:	8a1b      	ldrh	r3, [r3, #16]
 801385e:	2b00      	cmp	r3, #0
 8013860:	d104      	bne.n	801386c <Data_Setup0+0x270>
  {
    /* Unsupported request */
    pInformation->ControlState = STALLED;
 8013862:	4b2d      	ldr	r3, [pc, #180]	; (8013918 <Data_Setup0+0x31c>)
 8013864:	681b      	ldr	r3, [r3, #0]
 8013866:	2208      	movs	r2, #8
 8013868:	721a      	strb	r2, [r3, #8]
    return;
 801386a:	e051      	b.n	8013910 <Data_Setup0+0x314>
  }


  if (ValBit(pInformation->USBbmRequestType, 7))
 801386c:	4b2a      	ldr	r3, [pc, #168]	; (8013918 <Data_Setup0+0x31c>)
 801386e:	681b      	ldr	r3, [r3, #0]
 8013870:	781b      	ldrb	r3, [r3, #0]
 8013872:	b25b      	sxtb	r3, r3
 8013874:	2b00      	cmp	r3, #0
 8013876:	da42      	bge.n	80138fe <Data_Setup0+0x302>
  {
    /* Device ==> Host */
    __IO uint32_t wLength = pInformation->USBwLength;
 8013878:	4b27      	ldr	r3, [pc, #156]	; (8013918 <Data_Setup0+0x31c>)
 801387a:	681b      	ldr	r3, [r3, #0]
 801387c:	88db      	ldrh	r3, [r3, #6]
 801387e:	607b      	str	r3, [r7, #4]
     
    /* Restrict the data length to be the one host asks for */
    if (pInformation->Ctrl_Info.Usb_wLength > wLength)
 8013880:	4b25      	ldr	r3, [pc, #148]	; (8013918 <Data_Setup0+0x31c>)
 8013882:	681b      	ldr	r3, [r3, #0]
 8013884:	8a1b      	ldrh	r3, [r3, #16]
 8013886:	461a      	mov	r2, r3
 8013888:	687b      	ldr	r3, [r7, #4]
 801388a:	429a      	cmp	r2, r3
 801388c:	d905      	bls.n	801389a <Data_Setup0+0x29e>
    {
      pInformation->Ctrl_Info.Usb_wLength = wLength;
 801388e:	687a      	ldr	r2, [r7, #4]
 8013890:	4b21      	ldr	r3, [pc, #132]	; (8013918 <Data_Setup0+0x31c>)
 8013892:	681b      	ldr	r3, [r3, #0]
 8013894:	b292      	uxth	r2, r2
 8013896:	821a      	strh	r2, [r3, #16]
 8013898:	e026      	b.n	80138e8 <Data_Setup0+0x2ec>
    }
    
    else if (pInformation->Ctrl_Info.Usb_wLength < pInformation->USBwLength)
 801389a:	4b1f      	ldr	r3, [pc, #124]	; (8013918 <Data_Setup0+0x31c>)
 801389c:	681b      	ldr	r3, [r3, #0]
 801389e:	8a1a      	ldrh	r2, [r3, #16]
 80138a0:	4b1d      	ldr	r3, [pc, #116]	; (8013918 <Data_Setup0+0x31c>)
 80138a2:	681b      	ldr	r3, [r3, #0]
 80138a4:	88db      	ldrh	r3, [r3, #6]
 80138a6:	429a      	cmp	r2, r3
 80138a8:	d21e      	bcs.n	80138e8 <Data_Setup0+0x2ec>
    {
      if (pInformation->Ctrl_Info.Usb_wLength < pProperty->MaxPacketSize)
 80138aa:	4b1b      	ldr	r3, [pc, #108]	; (8013918 <Data_Setup0+0x31c>)
 80138ac:	681b      	ldr	r3, [r3, #0]
 80138ae:	8a1a      	ldrh	r2, [r3, #16]
 80138b0:	4b1a      	ldr	r3, [pc, #104]	; (801391c <Data_Setup0+0x320>)
 80138b2:	681b      	ldr	r3, [r3, #0]
 80138b4:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 80138b8:	b29b      	uxth	r3, r3
 80138ba:	429a      	cmp	r2, r3
 80138bc:	d203      	bcs.n	80138c6 <Data_Setup0+0x2ca>
      {
        Data_Mul_MaxPacketSize = FALSE;
 80138be:	4b18      	ldr	r3, [pc, #96]	; (8013920 <Data_Setup0+0x324>)
 80138c0:	2200      	movs	r2, #0
 80138c2:	701a      	strb	r2, [r3, #0]
 80138c4:	e010      	b.n	80138e8 <Data_Setup0+0x2ec>
      }
      else if ((pInformation->Ctrl_Info.Usb_wLength % pProperty->MaxPacketSize) == 0)
 80138c6:	4b14      	ldr	r3, [pc, #80]	; (8013918 <Data_Setup0+0x31c>)
 80138c8:	681b      	ldr	r3, [r3, #0]
 80138ca:	8a1b      	ldrh	r3, [r3, #16]
 80138cc:	4a13      	ldr	r2, [pc, #76]	; (801391c <Data_Setup0+0x320>)
 80138ce:	6812      	ldr	r2, [r2, #0]
 80138d0:	f892 202c 	ldrb.w	r2, [r2, #44]	; 0x2c
 80138d4:	fb93 f1f2 	sdiv	r1, r3, r2
 80138d8:	fb01 f202 	mul.w	r2, r1, r2
 80138dc:	1a9b      	subs	r3, r3, r2
 80138de:	2b00      	cmp	r3, #0
 80138e0:	d102      	bne.n	80138e8 <Data_Setup0+0x2ec>
      {
        Data_Mul_MaxPacketSize = TRUE;
 80138e2:	4b0f      	ldr	r3, [pc, #60]	; (8013920 <Data_Setup0+0x324>)
 80138e4:	2201      	movs	r2, #1
 80138e6:	701a      	strb	r2, [r3, #0]
      }
    }   

    pInformation->Ctrl_Info.PacketSize = pProperty->MaxPacketSize;
 80138e8:	4b0c      	ldr	r3, [pc, #48]	; (801391c <Data_Setup0+0x320>)
 80138ea:	681b      	ldr	r3, [r3, #0]
 80138ec:	f893 202c 	ldrb.w	r2, [r3, #44]	; 0x2c
 80138f0:	4b09      	ldr	r3, [pc, #36]	; (8013918 <Data_Setup0+0x31c>)
 80138f2:	681b      	ldr	r3, [r3, #0]
 80138f4:	b292      	uxth	r2, r2
 80138f6:	829a      	strh	r2, [r3, #20]
    DataStageIn();
 80138f8:	4b0a      	ldr	r3, [pc, #40]	; (8013924 <Data_Setup0+0x328>)
 80138fa:	4798      	blx	r3
  {
    pInformation->ControlState = OUT_DATA;
    vSetEPRxStatus(EP_RX_VALID); /* enable for next data reception */
  }

  return;
 80138fc:	e007      	b.n	801390e <Data_Setup0+0x312>
    pInformation->ControlState = OUT_DATA;
 80138fe:	4b06      	ldr	r3, [pc, #24]	; (8013918 <Data_Setup0+0x31c>)
 8013900:	681b      	ldr	r3, [r3, #0]
 8013902:	2203      	movs	r2, #3
 8013904:	721a      	strb	r2, [r3, #8]
    vSetEPRxStatus(EP_RX_VALID); /* enable for next data reception */
 8013906:	4b08      	ldr	r3, [pc, #32]	; (8013928 <Data_Setup0+0x32c>)
 8013908:	f44f 5240 	mov.w	r2, #12288	; 0x3000
 801390c:	801a      	strh	r2, [r3, #0]
  return;
 801390e:	bf00      	nop
}
 8013910:	3728      	adds	r7, #40	; 0x28
 8013912:	46bd      	mov	sp, r7
 8013914:	bd80      	pop	{r7, pc}
 8013916:	bf00      	nop
 8013918:	200096d0 	.word	0x200096d0
 801391c:	200096d4 	.word	0x200096d4
 8013920:	200096ce 	.word	0x200096ce
 8013924:	08013331 	.word	0x08013331
 8013928:	200096e0 	.word	0x200096e0

0801392c <Setup0_Process>:
* Input          : None.
* Output         : None.
* Return         : Post0_Process.
*******************************************************************************/
uint8_t Setup0_Process(void)
{
 801392c:	b590      	push	{r4, r7, lr}
 801392e:	b083      	sub	sp, #12
 8013930:	af00      	add	r7, sp, #0
  uint16_t offset = 0;
 
  ep = PCD_GetOutEP(ENDP0);
  pBuf.b = ep->xfer_buff;
#else  
  uint16_t offset = 1;
 8013932:	2301      	movs	r3, #1
 8013934:	80fb      	strh	r3, [r7, #6]
  
  pBuf.b = PMAAddr + (uint8_t *)(_GetEPRxAddr(ENDP0) * 2); /* *2 for 32 bits addr */
 8013936:	4b30      	ldr	r3, [pc, #192]	; (80139f8 <Setup0_Process+0xcc>)
 8013938:	681b      	ldr	r3, [r3, #0]
 801393a:	b29b      	uxth	r3, r3
 801393c:	461a      	mov	r2, r3
 801393e:	4b2f      	ldr	r3, [pc, #188]	; (80139fc <Setup0_Process+0xd0>)
 8013940:	4413      	add	r3, r2
 8013942:	005b      	lsls	r3, r3, #1
 8013944:	681b      	ldr	r3, [r3, #0]
 8013946:	b29b      	uxth	r3, r3
 8013948:	005b      	lsls	r3, r3, #1
 801394a:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 801394e:	f503 43c0 	add.w	r3, r3, #24576	; 0x6000
 8013952:	603b      	str	r3, [r7, #0]
#endif /* STM32F10X_CL */

  if (pInformation->ControlState != PAUSE)
 8013954:	4b2a      	ldr	r3, [pc, #168]	; (8013a00 <Setup0_Process+0xd4>)
 8013956:	681b      	ldr	r3, [r3, #0]
 8013958:	7a1b      	ldrb	r3, [r3, #8]
 801395a:	2b09      	cmp	r3, #9
 801395c:	d037      	beq.n	80139ce <Setup0_Process+0xa2>
  {
    pInformation->USBbmRequestType = *pBuf.b++; /* bmRequestType */
 801395e:	683b      	ldr	r3, [r7, #0]
 8013960:	1c5a      	adds	r2, r3, #1
 8013962:	603a      	str	r2, [r7, #0]
 8013964:	4a26      	ldr	r2, [pc, #152]	; (8013a00 <Setup0_Process+0xd4>)
 8013966:	6812      	ldr	r2, [r2, #0]
 8013968:	781b      	ldrb	r3, [r3, #0]
 801396a:	7013      	strb	r3, [r2, #0]
    pInformation->USBbRequest = *pBuf.b++; /* bRequest */
 801396c:	683b      	ldr	r3, [r7, #0]
 801396e:	1c5a      	adds	r2, r3, #1
 8013970:	603a      	str	r2, [r7, #0]
 8013972:	4a23      	ldr	r2, [pc, #140]	; (8013a00 <Setup0_Process+0xd4>)
 8013974:	6812      	ldr	r2, [r2, #0]
 8013976:	781b      	ldrb	r3, [r3, #0]
 8013978:	7053      	strb	r3, [r2, #1]
    pBuf.w += offset;  /* word not accessed because of 32 bits addressing */
 801397a:	683a      	ldr	r2, [r7, #0]
 801397c:	88fb      	ldrh	r3, [r7, #6]
 801397e:	005b      	lsls	r3, r3, #1
 8013980:	4413      	add	r3, r2
 8013982:	603b      	str	r3, [r7, #0]
    pInformation->USBwValue = ByteSwap(*pBuf.w++); /* wValue */
 8013984:	683b      	ldr	r3, [r7, #0]
 8013986:	1c9a      	adds	r2, r3, #2
 8013988:	603a      	str	r2, [r7, #0]
 801398a:	881b      	ldrh	r3, [r3, #0]
 801398c:	4a1c      	ldr	r2, [pc, #112]	; (8013a00 <Setup0_Process+0xd4>)
 801398e:	6814      	ldr	r4, [r2, #0]
 8013990:	4618      	mov	r0, r3
 8013992:	4b1c      	ldr	r3, [pc, #112]	; (8013a04 <Setup0_Process+0xd8>)
 8013994:	4798      	blx	r3
 8013996:	4603      	mov	r3, r0
 8013998:	8063      	strh	r3, [r4, #2]
    pBuf.w += offset;  /* word not accessed because of 32 bits addressing */
 801399a:	683a      	ldr	r2, [r7, #0]
 801399c:	88fb      	ldrh	r3, [r7, #6]
 801399e:	005b      	lsls	r3, r3, #1
 80139a0:	4413      	add	r3, r2
 80139a2:	603b      	str	r3, [r7, #0]
    pInformation->USBwIndex  = ByteSwap(*pBuf.w++); /* wIndex */
 80139a4:	683b      	ldr	r3, [r7, #0]
 80139a6:	1c9a      	adds	r2, r3, #2
 80139a8:	603a      	str	r2, [r7, #0]
 80139aa:	881b      	ldrh	r3, [r3, #0]
 80139ac:	4a14      	ldr	r2, [pc, #80]	; (8013a00 <Setup0_Process+0xd4>)
 80139ae:	6814      	ldr	r4, [r2, #0]
 80139b0:	4618      	mov	r0, r3
 80139b2:	4b14      	ldr	r3, [pc, #80]	; (8013a04 <Setup0_Process+0xd8>)
 80139b4:	4798      	blx	r3
 80139b6:	4603      	mov	r3, r0
 80139b8:	80a3      	strh	r3, [r4, #4]
    pBuf.w += offset;  /* word not accessed because of 32 bits addressing */
 80139ba:	683a      	ldr	r2, [r7, #0]
 80139bc:	88fb      	ldrh	r3, [r7, #6]
 80139be:	005b      	lsls	r3, r3, #1
 80139c0:	4413      	add	r3, r2
 80139c2:	603b      	str	r3, [r7, #0]
    pInformation->USBwLength = *pBuf.w; /* wLength */
 80139c4:	683a      	ldr	r2, [r7, #0]
 80139c6:	4b0e      	ldr	r3, [pc, #56]	; (8013a00 <Setup0_Process+0xd4>)
 80139c8:	681b      	ldr	r3, [r3, #0]
 80139ca:	8812      	ldrh	r2, [r2, #0]
 80139cc:	80da      	strh	r2, [r3, #6]
  }

  pInformation->ControlState = SETTING_UP;
 80139ce:	4b0c      	ldr	r3, [pc, #48]	; (8013a00 <Setup0_Process+0xd4>)
 80139d0:	681b      	ldr	r3, [r3, #0]
 80139d2:	2201      	movs	r2, #1
 80139d4:	721a      	strb	r2, [r3, #8]
  if (pInformation->USBwLength == 0)
 80139d6:	4b0a      	ldr	r3, [pc, #40]	; (8013a00 <Setup0_Process+0xd4>)
 80139d8:	681b      	ldr	r3, [r3, #0]
 80139da:	88db      	ldrh	r3, [r3, #6]
 80139dc:	2b00      	cmp	r3, #0
 80139de:	d102      	bne.n	80139e6 <Setup0_Process+0xba>
  {
    /* Setup with no data stage */
    NoData_Setup0();
 80139e0:	4b09      	ldr	r3, [pc, #36]	; (8013a08 <Setup0_Process+0xdc>)
 80139e2:	4798      	blx	r3
 80139e4:	e001      	b.n	80139ea <Setup0_Process+0xbe>
  }
  else
  {
    /* Setup with data stage */
    Data_Setup0();
 80139e6:	4b09      	ldr	r3, [pc, #36]	; (8013a0c <Setup0_Process+0xe0>)
 80139e8:	4798      	blx	r3
  }
  return Post0_Process();
 80139ea:	4b09      	ldr	r3, [pc, #36]	; (8013a10 <Setup0_Process+0xe4>)
 80139ec:	4798      	blx	r3
 80139ee:	4603      	mov	r3, r0
}
 80139f0:	4618      	mov	r0, r3
 80139f2:	370c      	adds	r7, #12
 80139f4:	46bd      	mov	sp, r7
 80139f6:	bd90      	pop	{r4, r7, pc}
 80139f8:	40005c50 	.word	0x40005c50
 80139fc:	20003004 	.word	0x20003004
 8013a00:	200096d0 	.word	0x200096d0
 8013a04:	080144c5 	.word	0x080144c5
 8013a08:	08013449 	.word	0x08013449
 8013a0c:	080135fd 	.word	0x080135fd
 8013a10:	08013b2d 	.word	0x08013b2d

08013a14 <In0_Process>:
* Input          : None.
* Output         : None.
* Return         : Post0_Process.
*******************************************************************************/
uint8_t In0_Process(void)
{
 8013a14:	b580      	push	{r7, lr}
 8013a16:	b082      	sub	sp, #8
 8013a18:	af00      	add	r7, sp, #0
  uint32_t ControlState = pInformation->ControlState;
 8013a1a:	4b1f      	ldr	r3, [pc, #124]	; (8013a98 <In0_Process+0x84>)
 8013a1c:	681b      	ldr	r3, [r3, #0]
 8013a1e:	7a1b      	ldrb	r3, [r3, #8]
 8013a20:	607b      	str	r3, [r7, #4]

  if ((ControlState == IN_DATA) || (ControlState == LAST_IN_DATA))
 8013a22:	687b      	ldr	r3, [r7, #4]
 8013a24:	2b02      	cmp	r3, #2
 8013a26:	d002      	beq.n	8013a2e <In0_Process+0x1a>
 8013a28:	687b      	ldr	r3, [r7, #4]
 8013a2a:	2b04      	cmp	r3, #4
 8013a2c:	d106      	bne.n	8013a3c <In0_Process+0x28>
  {
    DataStageIn();
 8013a2e:	4b1b      	ldr	r3, [pc, #108]	; (8013a9c <In0_Process+0x88>)
 8013a30:	4798      	blx	r3
    /* ControlState may be changed outside the function */
    ControlState = pInformation->ControlState;
 8013a32:	4b19      	ldr	r3, [pc, #100]	; (8013a98 <In0_Process+0x84>)
 8013a34:	681b      	ldr	r3, [r3, #0]
 8013a36:	7a1b      	ldrb	r3, [r3, #8]
 8013a38:	607b      	str	r3, [r7, #4]
 8013a3a:	e021      	b.n	8013a80 <In0_Process+0x6c>
  }

  else if (ControlState == WAIT_STATUS_IN)
 8013a3c:	687b      	ldr	r3, [r7, #4]
 8013a3e:	2b06      	cmp	r3, #6
 8013a40:	d11c      	bne.n	8013a7c <In0_Process+0x68>
  {
    if ((pInformation->USBbRequest == SET_ADDRESS) &&
 8013a42:	4b15      	ldr	r3, [pc, #84]	; (8013a98 <In0_Process+0x84>)
 8013a44:	681b      	ldr	r3, [r3, #0]
 8013a46:	785b      	ldrb	r3, [r3, #1]
 8013a48:	2b05      	cmp	r3, #5
 8013a4a:	d110      	bne.n	8013a6e <In0_Process+0x5a>
        (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT)))
 8013a4c:	4b12      	ldr	r3, [pc, #72]	; (8013a98 <In0_Process+0x84>)
 8013a4e:	681b      	ldr	r3, [r3, #0]
 8013a50:	781b      	ldrb	r3, [r3, #0]
 8013a52:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    if ((pInformation->USBbRequest == SET_ADDRESS) &&
 8013a56:	2b00      	cmp	r3, #0
 8013a58:	d109      	bne.n	8013a6e <In0_Process+0x5a>
    {
      SetDeviceAddress(pInformation->USBwValue0);
 8013a5a:	4b0f      	ldr	r3, [pc, #60]	; (8013a98 <In0_Process+0x84>)
 8013a5c:	681b      	ldr	r3, [r3, #0]
 8013a5e:	78db      	ldrb	r3, [r3, #3]
 8013a60:	4618      	mov	r0, r3
 8013a62:	4b0f      	ldr	r3, [pc, #60]	; (8013aa0 <In0_Process+0x8c>)
 8013a64:	4798      	blx	r3
      pUser_Standard_Requests->User_SetDeviceAddress();
 8013a66:	4b0f      	ldr	r3, [pc, #60]	; (8013aa4 <In0_Process+0x90>)
 8013a68:	681b      	ldr	r3, [r3, #0]
 8013a6a:	6a1b      	ldr	r3, [r3, #32]
 8013a6c:	4798      	blx	r3
    }
    (*pProperty->Process_Status_IN)();
 8013a6e:	4b0e      	ldr	r3, [pc, #56]	; (8013aa8 <In0_Process+0x94>)
 8013a70:	681b      	ldr	r3, [r3, #0]
 8013a72:	689b      	ldr	r3, [r3, #8]
 8013a74:	4798      	blx	r3
    ControlState = STALLED;
 8013a76:	2308      	movs	r3, #8
 8013a78:	607b      	str	r3, [r7, #4]
 8013a7a:	e001      	b.n	8013a80 <In0_Process+0x6c>
  }

  else
  {
    ControlState = STALLED;
 8013a7c:	2308      	movs	r3, #8
 8013a7e:	607b      	str	r3, [r7, #4]
  }

  pInformation->ControlState = ControlState;
 8013a80:	4b05      	ldr	r3, [pc, #20]	; (8013a98 <In0_Process+0x84>)
 8013a82:	681b      	ldr	r3, [r3, #0]
 8013a84:	687a      	ldr	r2, [r7, #4]
 8013a86:	b2d2      	uxtb	r2, r2
 8013a88:	721a      	strb	r2, [r3, #8]

  return Post0_Process();
 8013a8a:	4b08      	ldr	r3, [pc, #32]	; (8013aac <In0_Process+0x98>)
 8013a8c:	4798      	blx	r3
 8013a8e:	4603      	mov	r3, r0
}
 8013a90:	4618      	mov	r0, r3
 8013a92:	3708      	adds	r7, #8
 8013a94:	46bd      	mov	sp, r7
 8013a96:	bd80      	pop	{r7, pc}
 8013a98:	200096d0 	.word	0x200096d0
 8013a9c:	08013331 	.word	0x08013331
 8013aa0:	08013b81 	.word	0x08013b81
 8013aa4:	200096dc 	.word	0x200096dc
 8013aa8:	200096d4 	.word	0x200096d4
 8013aac:	08013b2d 	.word	0x08013b2d

08013ab0 <Out0_Process>:
* Input          : None.
* Output         : None.
* Return         : Post0_Process.
*******************************************************************************/
uint8_t Out0_Process(void)
{
 8013ab0:	b580      	push	{r7, lr}
 8013ab2:	b082      	sub	sp, #8
 8013ab4:	af00      	add	r7, sp, #0
  uint32_t ControlState = pInformation->ControlState;
 8013ab6:	4b19      	ldr	r3, [pc, #100]	; (8013b1c <Out0_Process+0x6c>)
 8013ab8:	681b      	ldr	r3, [r3, #0]
 8013aba:	7a1b      	ldrb	r3, [r3, #8]
 8013abc:	607b      	str	r3, [r7, #4]

  if ((ControlState == IN_DATA) || (ControlState == LAST_IN_DATA))
 8013abe:	687b      	ldr	r3, [r7, #4]
 8013ac0:	2b02      	cmp	r3, #2
 8013ac2:	d002      	beq.n	8013aca <Out0_Process+0x1a>
 8013ac4:	687b      	ldr	r3, [r7, #4]
 8013ac6:	2b04      	cmp	r3, #4
 8013ac8:	d102      	bne.n	8013ad0 <Out0_Process+0x20>
  {
    /* host aborts the transfer before finish */
    ControlState = STALLED;
 8013aca:	2308      	movs	r3, #8
 8013acc:	607b      	str	r3, [r7, #4]
 8013ace:	e018      	b.n	8013b02 <Out0_Process+0x52>
  }
  else if ((ControlState == OUT_DATA) || (ControlState == LAST_OUT_DATA))
 8013ad0:	687b      	ldr	r3, [r7, #4]
 8013ad2:	2b03      	cmp	r3, #3
 8013ad4:	d002      	beq.n	8013adc <Out0_Process+0x2c>
 8013ad6:	687b      	ldr	r3, [r7, #4]
 8013ad8:	2b05      	cmp	r3, #5
 8013ada:	d106      	bne.n	8013aea <Out0_Process+0x3a>
  {
    DataStageOut();
 8013adc:	4b10      	ldr	r3, [pc, #64]	; (8013b20 <Out0_Process+0x70>)
 8013ade:	4798      	blx	r3
    ControlState = pInformation->ControlState; /* may be changed outside the function */
 8013ae0:	4b0e      	ldr	r3, [pc, #56]	; (8013b1c <Out0_Process+0x6c>)
 8013ae2:	681b      	ldr	r3, [r3, #0]
 8013ae4:	7a1b      	ldrb	r3, [r3, #8]
 8013ae6:	607b      	str	r3, [r7, #4]
 8013ae8:	e00b      	b.n	8013b02 <Out0_Process+0x52>
  }

  else if (ControlState == WAIT_STATUS_OUT)
 8013aea:	687b      	ldr	r3, [r7, #4]
 8013aec:	2b07      	cmp	r3, #7
 8013aee:	d106      	bne.n	8013afe <Out0_Process+0x4e>
  {
    (*pProperty->Process_Status_OUT)();
 8013af0:	4b0c      	ldr	r3, [pc, #48]	; (8013b24 <Out0_Process+0x74>)
 8013af2:	681b      	ldr	r3, [r3, #0]
 8013af4:	68db      	ldr	r3, [r3, #12]
 8013af6:	4798      	blx	r3
  #ifndef STM32F10X_CL
    ControlState = STALLED;
 8013af8:	2308      	movs	r3, #8
 8013afa:	607b      	str	r3, [r7, #4]
 8013afc:	e001      	b.n	8013b02 <Out0_Process+0x52>


  /* Unexpect state, STALL the endpoint */
  else
  {
    ControlState = STALLED;
 8013afe:	2308      	movs	r3, #8
 8013b00:	607b      	str	r3, [r7, #4]
  }

  pInformation->ControlState = ControlState;
 8013b02:	4b06      	ldr	r3, [pc, #24]	; (8013b1c <Out0_Process+0x6c>)
 8013b04:	681b      	ldr	r3, [r3, #0]
 8013b06:	687a      	ldr	r2, [r7, #4]
 8013b08:	b2d2      	uxtb	r2, r2
 8013b0a:	721a      	strb	r2, [r3, #8]

  return Post0_Process();
 8013b0c:	4b06      	ldr	r3, [pc, #24]	; (8013b28 <Out0_Process+0x78>)
 8013b0e:	4798      	blx	r3
 8013b10:	4603      	mov	r3, r0
}
 8013b12:	4618      	mov	r0, r3
 8013b14:	3708      	adds	r7, #8
 8013b16:	46bd      	mov	sp, r7
 8013b18:	bd80      	pop	{r7, pc}
 8013b1a:	bf00      	nop
 8013b1c:	200096d0 	.word	0x200096d0
 8013b20:	08013221 	.word	0x08013221
 8013b24:	200096d4 	.word	0x200096d4
 8013b28:	08013b2d 	.word	0x08013b2d

08013b2c <Post0_Process>:
* Output         : None.
* Return         : - 0 if the control State is in PAUSE
*                  - 1 if not.
*******************************************************************************/
uint8_t Post0_Process(void)
{
 8013b2c:	b580      	push	{r7, lr}
 8013b2e:	af00      	add	r7, sp, #0
#ifdef STM32F10X_CL  
  USB_OTG_EP *ep;
#endif /* STM32F10X_CL */
      
  SetEPRxCount(ENDP0, Device_Property.MaxPacketSize);
 8013b30:	4b0e      	ldr	r3, [pc, #56]	; (8013b6c <Post0_Process+0x40>)
 8013b32:	f893 302c 	ldrb.w	r3, [r3, #44]	; 0x2c
 8013b36:	b29b      	uxth	r3, r3
 8013b38:	4619      	mov	r1, r3
 8013b3a:	2000      	movs	r0, #0
 8013b3c:	4b0c      	ldr	r3, [pc, #48]	; (8013b70 <Post0_Process+0x44>)
 8013b3e:	4798      	blx	r3

  if (pInformation->ControlState == STALLED)
 8013b40:	4b0c      	ldr	r3, [pc, #48]	; (8013b74 <Post0_Process+0x48>)
 8013b42:	681b      	ldr	r3, [r3, #0]
 8013b44:	7a1b      	ldrb	r3, [r3, #8]
 8013b46:	2b08      	cmp	r3, #8
 8013b48:	d106      	bne.n	8013b58 <Post0_Process+0x2c>
  {
    vSetEPRxStatus(EP_RX_STALL);
 8013b4a:	4b0b      	ldr	r3, [pc, #44]	; (8013b78 <Post0_Process+0x4c>)
 8013b4c:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8013b50:	801a      	strh	r2, [r3, #0]
    vSetEPTxStatus(EP_TX_STALL);
 8013b52:	4b0a      	ldr	r3, [pc, #40]	; (8013b7c <Post0_Process+0x50>)
 8013b54:	2210      	movs	r2, #16
 8013b56:	801a      	strh	r2, [r3, #0]
    ep->is_in = 1;
    OTGD_FS_EP0StartXfer(ep);    
  }  
#endif /* STM32F10X_CL */

  return (pInformation->ControlState == PAUSE);
 8013b58:	4b06      	ldr	r3, [pc, #24]	; (8013b74 <Post0_Process+0x48>)
 8013b5a:	681b      	ldr	r3, [r3, #0]
 8013b5c:	7a1b      	ldrb	r3, [r3, #8]
 8013b5e:	2b09      	cmp	r3, #9
 8013b60:	bf0c      	ite	eq
 8013b62:	2301      	moveq	r3, #1
 8013b64:	2300      	movne	r3, #0
 8013b66:	b2db      	uxtb	r3, r3
}
 8013b68:	4618      	mov	r0, r3
 8013b6a:	bd80      	pop	{r7, pc}
 8013b6c:	200001c8 	.word	0x200001c8
 8013b70:	08014405 	.word	0x08014405
 8013b74:	200096d0 	.word	0x200096d0
 8013b78:	200096e0 	.word	0x200096e0
 8013b7c:	200096e2 	.word	0x200096e2

08013b80 <SetDeviceAddress>:
* Input          : - Val: device adress.
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetDeviceAddress(uint8_t Val)
{
 8013b80:	b480      	push	{r7}
 8013b82:	b085      	sub	sp, #20
 8013b84:	af00      	add	r7, sp, #0
 8013b86:	4603      	mov	r3, r0
 8013b88:	71fb      	strb	r3, [r7, #7]
#ifdef STM32F10X_CL 
  PCD_EP_SetAddress ((uint8_t)Val);
#else 
  uint32_t i;
  uint32_t nEP = Device_Table.Total_Endpoint;
 8013b8a:	4b1a      	ldr	r3, [pc, #104]	; (8013bf4 <SetDeviceAddress+0x74>)
 8013b8c:	781b      	ldrb	r3, [r3, #0]
 8013b8e:	60bb      	str	r3, [r7, #8]

  /* set address in every used endpoint */
  for (i = 0; i < nEP; i++)
 8013b90:	2300      	movs	r3, #0
 8013b92:	60fb      	str	r3, [r7, #12]
 8013b94:	e01e      	b.n	8013bd4 <SetDeviceAddress+0x54>
  {
    _SetEPAddress((uint8_t)i, (uint8_t)i);
 8013b96:	68fb      	ldr	r3, [r7, #12]
 8013b98:	b2db      	uxtb	r3, r3
 8013b9a:	009b      	lsls	r3, r3, #2
 8013b9c:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8013ba0:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
 8013ba4:	681b      	ldr	r3, [r3, #0]
 8013ba6:	b29b      	uxth	r3, r3
 8013ba8:	461a      	mov	r2, r3
 8013baa:	f640 730f 	movw	r3, #3855	; 0xf0f
 8013bae:	4013      	ands	r3, r2
 8013bb0:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8013bb4:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8013bb8:	68fa      	ldr	r2, [r7, #12]
 8013bba:	b2d2      	uxtb	r2, r2
 8013bbc:	431a      	orrs	r2, r3
 8013bbe:	68fb      	ldr	r3, [r7, #12]
 8013bc0:	b2db      	uxtb	r3, r3
 8013bc2:	009b      	lsls	r3, r3, #2
 8013bc4:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8013bc8:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
 8013bcc:	601a      	str	r2, [r3, #0]
  for (i = 0; i < nEP; i++)
 8013bce:	68fb      	ldr	r3, [r7, #12]
 8013bd0:	3301      	adds	r3, #1
 8013bd2:	60fb      	str	r3, [r7, #12]
 8013bd4:	68fa      	ldr	r2, [r7, #12]
 8013bd6:	68bb      	ldr	r3, [r7, #8]
 8013bd8:	429a      	cmp	r2, r3
 8013bda:	d3dc      	bcc.n	8013b96 <SetDeviceAddress+0x16>
  } /* for */
  _SetDADDR(Val | DADDR_EF); /* set device address and enable function */
 8013bdc:	79fb      	ldrb	r3, [r7, #7]
 8013bde:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8013be2:	b2da      	uxtb	r2, r3
 8013be4:	4b04      	ldr	r3, [pc, #16]	; (8013bf8 <SetDeviceAddress+0x78>)
 8013be6:	601a      	str	r2, [r3, #0]
#endif  /* STM32F10X_CL */  
}
 8013be8:	bf00      	nop
 8013bea:	3714      	adds	r7, #20
 8013bec:	46bd      	mov	sp, r7
 8013bee:	bc80      	pop	{r7}
 8013bf0:	4770      	bx	lr
 8013bf2:	bf00      	nop
 8013bf4:	200001c4 	.word	0x200001c4
 8013bf8:	40005c4c 	.word	0x40005c4c

08013bfc <NOP_Process>:
* Input          : None.
* Output         : None.
* Return         : None.
*******************************************************************************/
void NOP_Process(void)
{
 8013bfc:	b480      	push	{r7}
 8013bfe:	af00      	add	r7, sp, #0
}
 8013c00:	bf00      	nop
 8013c02:	46bd      	mov	sp, r7
 8013c04:	bc80      	pop	{r7}
 8013c06:	4770      	bx	lr

08013c08 <CTR_LP>:
* Input          : None.
* Output         : None.
* Return         : None.
*******************************************************************************/
void CTR_LP(void)
{
 8013c08:	b590      	push	{r4, r7, lr}
 8013c0a:	b083      	sub	sp, #12
 8013c0c:	af00      	add	r7, sp, #0
  __IO uint16_t wEPVal = 0;
 8013c0e:	2300      	movs	r3, #0
 8013c10:	80fb      	strh	r3, [r7, #6]
  /* stay in loop while pending ints */
  while (((wIstr = _GetISTR()) & ISTR_CTR) != 0)
 8013c12:	e168      	b.n	8013ee6 <CTR_LP+0x2de>
  {
    /* extract highest priority endpoint number */
    EPindex = (uint8_t)(wIstr & ISTR_EP_ID);
 8013c14:	4b84      	ldr	r3, [pc, #528]	; (8013e28 <CTR_LP+0x220>)
 8013c16:	881b      	ldrh	r3, [r3, #0]
 8013c18:	b29b      	uxth	r3, r3
 8013c1a:	b2db      	uxtb	r3, r3
 8013c1c:	f003 030f 	and.w	r3, r3, #15
 8013c20:	b2da      	uxtb	r2, r3
 8013c22:	4b82      	ldr	r3, [pc, #520]	; (8013e2c <CTR_LP+0x224>)
 8013c24:	701a      	strb	r2, [r3, #0]
    if (EPindex == 0)
 8013c26:	4b81      	ldr	r3, [pc, #516]	; (8013e2c <CTR_LP+0x224>)
 8013c28:	781b      	ldrb	r3, [r3, #0]
 8013c2a:	2b00      	cmp	r3, #0
 8013c2c:	f040 810e 	bne.w	8013e4c <CTR_LP+0x244>

      /* save RX & TX status */
      /* and set both to NAK */


	    SaveRState = _GetENDPOINT(ENDP0);
 8013c30:	4b7f      	ldr	r3, [pc, #508]	; (8013e30 <CTR_LP+0x228>)
 8013c32:	681b      	ldr	r3, [r3, #0]
 8013c34:	b29a      	uxth	r2, r3
 8013c36:	4b7f      	ldr	r3, [pc, #508]	; (8013e34 <CTR_LP+0x22c>)
 8013c38:	801a      	strh	r2, [r3, #0]
	    SaveTState = SaveRState & EPTX_STAT;
 8013c3a:	4b7e      	ldr	r3, [pc, #504]	; (8013e34 <CTR_LP+0x22c>)
 8013c3c:	881b      	ldrh	r3, [r3, #0]
 8013c3e:	b29b      	uxth	r3, r3
 8013c40:	f003 0330 	and.w	r3, r3, #48	; 0x30
 8013c44:	b29a      	uxth	r2, r3
 8013c46:	4b7c      	ldr	r3, [pc, #496]	; (8013e38 <CTR_LP+0x230>)
 8013c48:	801a      	strh	r2, [r3, #0]
	    SaveRState &=  EPRX_STAT;	
 8013c4a:	4b7a      	ldr	r3, [pc, #488]	; (8013e34 <CTR_LP+0x22c>)
 8013c4c:	881b      	ldrh	r3, [r3, #0]
 8013c4e:	b29b      	uxth	r3, r3
 8013c50:	f403 5340 	and.w	r3, r3, #12288	; 0x3000
 8013c54:	b29a      	uxth	r2, r3
 8013c56:	4b77      	ldr	r3, [pc, #476]	; (8013e34 <CTR_LP+0x22c>)
 8013c58:	801a      	strh	r2, [r3, #0]

	    _SetEPRxTxStatus(ENDP0,EP_RX_NAK,EP_TX_NAK);
 8013c5a:	4b75      	ldr	r3, [pc, #468]	; (8013e30 <CTR_LP+0x228>)
 8013c5c:	681b      	ldr	r3, [r3, #0]
 8013c5e:	b29b      	uxth	r3, r3
 8013c60:	f64b 74bf 	movw	r4, #49087	; 0xbfbf
 8013c64:	401c      	ands	r4, r3
 8013c66:	f484 5400 	eor.w	r4, r4, #8192	; 0x2000
 8013c6a:	f084 0420 	eor.w	r4, r4, #32
 8013c6e:	b2a2      	uxth	r2, r4
 8013c70:	4b72      	ldr	r3, [pc, #456]	; (8013e3c <CTR_LP+0x234>)
 8013c72:	4313      	orrs	r3, r2
 8013c74:	b29a      	uxth	r2, r3
 8013c76:	4b6e      	ldr	r3, [pc, #440]	; (8013e30 <CTR_LP+0x228>)
 8013c78:	601a      	str	r2, [r3, #0]

      /* DIR bit = origin of the interrupt */

      if ((wIstr & ISTR_DIR) == 0)
 8013c7a:	4b6b      	ldr	r3, [pc, #428]	; (8013e28 <CTR_LP+0x220>)
 8013c7c:	881b      	ldrh	r3, [r3, #0]
 8013c7e:	b29b      	uxth	r3, r3
 8013c80:	f003 0310 	and.w	r3, r3, #16
 8013c84:	2b00      	cmp	r3, #0
 8013c86:	d13f      	bne.n	8013d08 <CTR_LP+0x100>

        /* DIR = 0      => IN  int */
        /* DIR = 0 implies that (EP_CTR_TX = 1) always  */


        _ClearEP_CTR_TX(ENDP0);
 8013c88:	4b69      	ldr	r3, [pc, #420]	; (8013e30 <CTR_LP+0x228>)
 8013c8a:	681b      	ldr	r3, [r3, #0]
 8013c8c:	b29b      	uxth	r3, r3
 8013c8e:	4619      	mov	r1, r3
 8013c90:	4a67      	ldr	r2, [pc, #412]	; (8013e30 <CTR_LP+0x228>)
 8013c92:	f648 730f 	movw	r3, #36623	; 0x8f0f
 8013c96:	400b      	ands	r3, r1
 8013c98:	6013      	str	r3, [r2, #0]
        In0_Process();
 8013c9a:	4b69      	ldr	r3, [pc, #420]	; (8013e40 <CTR_LP+0x238>)
 8013c9c:	4798      	blx	r3

           /* before terminate set Tx & Rx status */

            _SetEPRxTxStatus(ENDP0,SaveRState,SaveTState);
 8013c9e:	4b64      	ldr	r3, [pc, #400]	; (8013e30 <CTR_LP+0x228>)
 8013ca0:	681b      	ldr	r3, [r3, #0]
 8013ca2:	b29b      	uxth	r3, r3
 8013ca4:	f64b 74bf 	movw	r4, #49087	; 0xbfbf
 8013ca8:	401c      	ands	r4, r3
 8013caa:	4b62      	ldr	r3, [pc, #392]	; (8013e34 <CTR_LP+0x22c>)
 8013cac:	881b      	ldrh	r3, [r3, #0]
 8013cae:	b29b      	uxth	r3, r3
 8013cb0:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8013cb4:	b29b      	uxth	r3, r3
 8013cb6:	2b00      	cmp	r3, #0
 8013cb8:	d001      	beq.n	8013cbe <CTR_LP+0xb6>
 8013cba:	f484 5480 	eor.w	r4, r4, #4096	; 0x1000
 8013cbe:	4b5d      	ldr	r3, [pc, #372]	; (8013e34 <CTR_LP+0x22c>)
 8013cc0:	881b      	ldrh	r3, [r3, #0]
 8013cc2:	b29b      	uxth	r3, r3
 8013cc4:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8013cc8:	b29b      	uxth	r3, r3
 8013cca:	2b00      	cmp	r3, #0
 8013ccc:	d001      	beq.n	8013cd2 <CTR_LP+0xca>
 8013cce:	f484 5400 	eor.w	r4, r4, #8192	; 0x2000
 8013cd2:	4b59      	ldr	r3, [pc, #356]	; (8013e38 <CTR_LP+0x230>)
 8013cd4:	881b      	ldrh	r3, [r3, #0]
 8013cd6:	b29b      	uxth	r3, r3
 8013cd8:	f003 0310 	and.w	r3, r3, #16
 8013cdc:	b29b      	uxth	r3, r3
 8013cde:	2b00      	cmp	r3, #0
 8013ce0:	d001      	beq.n	8013ce6 <CTR_LP+0xde>
 8013ce2:	f084 0410 	eor.w	r4, r4, #16
 8013ce6:	4b54      	ldr	r3, [pc, #336]	; (8013e38 <CTR_LP+0x230>)
 8013ce8:	881b      	ldrh	r3, [r3, #0]
 8013cea:	b29b      	uxth	r3, r3
 8013cec:	f003 0320 	and.w	r3, r3, #32
 8013cf0:	b29b      	uxth	r3, r3
 8013cf2:	2b00      	cmp	r3, #0
 8013cf4:	d001      	beq.n	8013cfa <CTR_LP+0xf2>
 8013cf6:	f084 0420 	eor.w	r4, r4, #32
 8013cfa:	b2a2      	uxth	r2, r4
 8013cfc:	4b4f      	ldr	r3, [pc, #316]	; (8013e3c <CTR_LP+0x234>)
 8013cfe:	4313      	orrs	r3, r2
 8013d00:	b29a      	uxth	r2, r3
 8013d02:	4b4b      	ldr	r3, [pc, #300]	; (8013e30 <CTR_LP+0x228>)
 8013d04:	601a      	str	r2, [r3, #0]
		  return;
 8013d06:	e0f8      	b.n	8013efa <CTR_LP+0x2f2>
        /* DIR = 1 */

        /* DIR = 1 & CTR_RX       => SETUP or OUT int */
        /* DIR = 1 & (CTR_TX | CTR_RX) => 2 int pending */

        wEPVal = _GetENDPOINT(ENDP0);
 8013d08:	4b49      	ldr	r3, [pc, #292]	; (8013e30 <CTR_LP+0x228>)
 8013d0a:	681b      	ldr	r3, [r3, #0]
 8013d0c:	b29b      	uxth	r3, r3
 8013d0e:	80fb      	strh	r3, [r7, #6]
        
        if ((wEPVal &EP_SETUP) != 0)
 8013d10:	88fb      	ldrh	r3, [r7, #6]
 8013d12:	b29b      	uxth	r3, r3
 8013d14:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8013d18:	2b00      	cmp	r3, #0
 8013d1a:	d03f      	beq.n	8013d9c <CTR_LP+0x194>
        {
          _ClearEP_CTR_RX(ENDP0); /* SETUP bit kept frozen while CTR_RX = 1 */
 8013d1c:	4b44      	ldr	r3, [pc, #272]	; (8013e30 <CTR_LP+0x228>)
 8013d1e:	681b      	ldr	r3, [r3, #0]
 8013d20:	b29b      	uxth	r3, r3
 8013d22:	4619      	mov	r1, r3
 8013d24:	4a42      	ldr	r2, [pc, #264]	; (8013e30 <CTR_LP+0x228>)
 8013d26:	f640 738f 	movw	r3, #3983	; 0xf8f
 8013d2a:	400b      	ands	r3, r1
 8013d2c:	6013      	str	r3, [r2, #0]
          Setup0_Process();
 8013d2e:	4b45      	ldr	r3, [pc, #276]	; (8013e44 <CTR_LP+0x23c>)
 8013d30:	4798      	blx	r3
          /* before terminate set Tx & Rx status */

		      _SetEPRxTxStatus(ENDP0,SaveRState,SaveTState);
 8013d32:	4b3f      	ldr	r3, [pc, #252]	; (8013e30 <CTR_LP+0x228>)
 8013d34:	681b      	ldr	r3, [r3, #0]
 8013d36:	b29b      	uxth	r3, r3
 8013d38:	f64b 74bf 	movw	r4, #49087	; 0xbfbf
 8013d3c:	401c      	ands	r4, r3
 8013d3e:	4b3d      	ldr	r3, [pc, #244]	; (8013e34 <CTR_LP+0x22c>)
 8013d40:	881b      	ldrh	r3, [r3, #0]
 8013d42:	b29b      	uxth	r3, r3
 8013d44:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8013d48:	b29b      	uxth	r3, r3
 8013d4a:	2b00      	cmp	r3, #0
 8013d4c:	d001      	beq.n	8013d52 <CTR_LP+0x14a>
 8013d4e:	f484 5480 	eor.w	r4, r4, #4096	; 0x1000
 8013d52:	4b38      	ldr	r3, [pc, #224]	; (8013e34 <CTR_LP+0x22c>)
 8013d54:	881b      	ldrh	r3, [r3, #0]
 8013d56:	b29b      	uxth	r3, r3
 8013d58:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8013d5c:	b29b      	uxth	r3, r3
 8013d5e:	2b00      	cmp	r3, #0
 8013d60:	d001      	beq.n	8013d66 <CTR_LP+0x15e>
 8013d62:	f484 5400 	eor.w	r4, r4, #8192	; 0x2000
 8013d66:	4b34      	ldr	r3, [pc, #208]	; (8013e38 <CTR_LP+0x230>)
 8013d68:	881b      	ldrh	r3, [r3, #0]
 8013d6a:	b29b      	uxth	r3, r3
 8013d6c:	f003 0310 	and.w	r3, r3, #16
 8013d70:	b29b      	uxth	r3, r3
 8013d72:	2b00      	cmp	r3, #0
 8013d74:	d001      	beq.n	8013d7a <CTR_LP+0x172>
 8013d76:	f084 0410 	eor.w	r4, r4, #16
 8013d7a:	4b2f      	ldr	r3, [pc, #188]	; (8013e38 <CTR_LP+0x230>)
 8013d7c:	881b      	ldrh	r3, [r3, #0]
 8013d7e:	b29b      	uxth	r3, r3
 8013d80:	f003 0320 	and.w	r3, r3, #32
 8013d84:	b29b      	uxth	r3, r3
 8013d86:	2b00      	cmp	r3, #0
 8013d88:	d001      	beq.n	8013d8e <CTR_LP+0x186>
 8013d8a:	f084 0420 	eor.w	r4, r4, #32
 8013d8e:	b2a2      	uxth	r2, r4
 8013d90:	4b2a      	ldr	r3, [pc, #168]	; (8013e3c <CTR_LP+0x234>)
 8013d92:	4313      	orrs	r3, r2
 8013d94:	b29a      	uxth	r2, r3
 8013d96:	4b26      	ldr	r3, [pc, #152]	; (8013e30 <CTR_LP+0x228>)
 8013d98:	601a      	str	r2, [r3, #0]
          return;
 8013d9a:	e0ae      	b.n	8013efa <CTR_LP+0x2f2>
        }

        else if ((wEPVal & EP_CTR_RX) != 0)
 8013d9c:	88fb      	ldrh	r3, [r7, #6]
 8013d9e:	b29b      	uxth	r3, r3
 8013da0:	b21b      	sxth	r3, r3
 8013da2:	2b00      	cmp	r3, #0
 8013da4:	f280 809f 	bge.w	8013ee6 <CTR_LP+0x2de>
        {
          _ClearEP_CTR_RX(ENDP0);
 8013da8:	4b21      	ldr	r3, [pc, #132]	; (8013e30 <CTR_LP+0x228>)
 8013daa:	681b      	ldr	r3, [r3, #0]
 8013dac:	b29b      	uxth	r3, r3
 8013dae:	4619      	mov	r1, r3
 8013db0:	4a1f      	ldr	r2, [pc, #124]	; (8013e30 <CTR_LP+0x228>)
 8013db2:	f640 738f 	movw	r3, #3983	; 0xf8f
 8013db6:	400b      	ands	r3, r1
 8013db8:	6013      	str	r3, [r2, #0]
          Out0_Process();
 8013dba:	4b23      	ldr	r3, [pc, #140]	; (8013e48 <CTR_LP+0x240>)
 8013dbc:	4798      	blx	r3
          /* before terminate set Tx & Rx status */
     
		     _SetEPRxTxStatus(ENDP0,SaveRState,SaveTState);
 8013dbe:	4b1c      	ldr	r3, [pc, #112]	; (8013e30 <CTR_LP+0x228>)
 8013dc0:	681b      	ldr	r3, [r3, #0]
 8013dc2:	b29b      	uxth	r3, r3
 8013dc4:	f64b 74bf 	movw	r4, #49087	; 0xbfbf
 8013dc8:	401c      	ands	r4, r3
 8013dca:	4b1a      	ldr	r3, [pc, #104]	; (8013e34 <CTR_LP+0x22c>)
 8013dcc:	881b      	ldrh	r3, [r3, #0]
 8013dce:	b29b      	uxth	r3, r3
 8013dd0:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8013dd4:	b29b      	uxth	r3, r3
 8013dd6:	2b00      	cmp	r3, #0
 8013dd8:	d001      	beq.n	8013dde <CTR_LP+0x1d6>
 8013dda:	f484 5480 	eor.w	r4, r4, #4096	; 0x1000
 8013dde:	4b15      	ldr	r3, [pc, #84]	; (8013e34 <CTR_LP+0x22c>)
 8013de0:	881b      	ldrh	r3, [r3, #0]
 8013de2:	b29b      	uxth	r3, r3
 8013de4:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8013de8:	b29b      	uxth	r3, r3
 8013dea:	2b00      	cmp	r3, #0
 8013dec:	d001      	beq.n	8013df2 <CTR_LP+0x1ea>
 8013dee:	f484 5400 	eor.w	r4, r4, #8192	; 0x2000
 8013df2:	4b11      	ldr	r3, [pc, #68]	; (8013e38 <CTR_LP+0x230>)
 8013df4:	881b      	ldrh	r3, [r3, #0]
 8013df6:	b29b      	uxth	r3, r3
 8013df8:	f003 0310 	and.w	r3, r3, #16
 8013dfc:	b29b      	uxth	r3, r3
 8013dfe:	2b00      	cmp	r3, #0
 8013e00:	d001      	beq.n	8013e06 <CTR_LP+0x1fe>
 8013e02:	f084 0410 	eor.w	r4, r4, #16
 8013e06:	4b0c      	ldr	r3, [pc, #48]	; (8013e38 <CTR_LP+0x230>)
 8013e08:	881b      	ldrh	r3, [r3, #0]
 8013e0a:	b29b      	uxth	r3, r3
 8013e0c:	f003 0320 	and.w	r3, r3, #32
 8013e10:	b29b      	uxth	r3, r3
 8013e12:	2b00      	cmp	r3, #0
 8013e14:	d001      	beq.n	8013e1a <CTR_LP+0x212>
 8013e16:	f084 0420 	eor.w	r4, r4, #32
 8013e1a:	b2a2      	uxth	r2, r4
 8013e1c:	4b07      	ldr	r3, [pc, #28]	; (8013e3c <CTR_LP+0x234>)
 8013e1e:	4313      	orrs	r3, r2
 8013e20:	b29a      	uxth	r2, r3
 8013e22:	4b03      	ldr	r3, [pc, #12]	; (8013e30 <CTR_LP+0x228>)
 8013e24:	601a      	str	r2, [r3, #0]
          return;
 8013e26:	e068      	b.n	8013efa <CTR_LP+0x2f2>
 8013e28:	200096c4 	.word	0x200096c4
 8013e2c:	200096cf 	.word	0x200096cf
 8013e30:	40005c00 	.word	0x40005c00
 8013e34:	200096e0 	.word	0x200096e0
 8013e38:	200096e2 	.word	0x200096e2
 8013e3c:	ffff8080 	.word	0xffff8080
 8013e40:	08013a15 	.word	0x08013a15
 8013e44:	0801392d 	.word	0x0801392d
 8013e48:	08013ab1 	.word	0x08013ab1
    else
    {
      /* Decode and service non control endpoints interrupt  */

      /* process related endpoint register */
      wEPVal = _GetENDPOINT(EPindex);
 8013e4c:	4b2c      	ldr	r3, [pc, #176]	; (8013f00 <CTR_LP+0x2f8>)
 8013e4e:	781b      	ldrb	r3, [r3, #0]
 8013e50:	009b      	lsls	r3, r3, #2
 8013e52:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8013e56:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
 8013e5a:	681b      	ldr	r3, [r3, #0]
 8013e5c:	b29b      	uxth	r3, r3
 8013e5e:	80fb      	strh	r3, [r7, #6]
      if ((wEPVal & EP_CTR_RX) != 0)
 8013e60:	88fb      	ldrh	r3, [r7, #6]
 8013e62:	b29b      	uxth	r3, r3
 8013e64:	b21b      	sxth	r3, r3
 8013e66:	2b00      	cmp	r3, #0
 8013e68:	da1b      	bge.n	8013ea2 <CTR_LP+0x29a>
      {
        /* clear int flag */
        _ClearEP_CTR_RX(EPindex);
 8013e6a:	4b25      	ldr	r3, [pc, #148]	; (8013f00 <CTR_LP+0x2f8>)
 8013e6c:	781b      	ldrb	r3, [r3, #0]
 8013e6e:	009b      	lsls	r3, r3, #2
 8013e70:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8013e74:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
 8013e78:	681b      	ldr	r3, [r3, #0]
 8013e7a:	b29b      	uxth	r3, r3
 8013e7c:	4619      	mov	r1, r3
 8013e7e:	4b20      	ldr	r3, [pc, #128]	; (8013f00 <CTR_LP+0x2f8>)
 8013e80:	781b      	ldrb	r3, [r3, #0]
 8013e82:	009b      	lsls	r3, r3, #2
 8013e84:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8013e88:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
 8013e8c:	f640 728f 	movw	r2, #3983	; 0xf8f
 8013e90:	400a      	ands	r2, r1
 8013e92:	601a      	str	r2, [r3, #0]

        /* call OUT service function */
        (*pEpInt_OUT[EPindex-1])();
 8013e94:	4b1a      	ldr	r3, [pc, #104]	; (8013f00 <CTR_LP+0x2f8>)
 8013e96:	781b      	ldrb	r3, [r3, #0]
 8013e98:	3b01      	subs	r3, #1
 8013e9a:	4a1a      	ldr	r2, [pc, #104]	; (8013f04 <CTR_LP+0x2fc>)
 8013e9c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8013ea0:	4798      	blx	r3

      } /* if((wEPVal & EP_CTR_RX) */

      if ((wEPVal & EP_CTR_TX) != 0)
 8013ea2:	88fb      	ldrh	r3, [r7, #6]
 8013ea4:	b29b      	uxth	r3, r3
 8013ea6:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8013eaa:	2b00      	cmp	r3, #0
 8013eac:	d01b      	beq.n	8013ee6 <CTR_LP+0x2de>
      {
        /* clear int flag */
        _ClearEP_CTR_TX(EPindex);
 8013eae:	4b14      	ldr	r3, [pc, #80]	; (8013f00 <CTR_LP+0x2f8>)
 8013eb0:	781b      	ldrb	r3, [r3, #0]
 8013eb2:	009b      	lsls	r3, r3, #2
 8013eb4:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8013eb8:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
 8013ebc:	681b      	ldr	r3, [r3, #0]
 8013ebe:	b29b      	uxth	r3, r3
 8013ec0:	4619      	mov	r1, r3
 8013ec2:	4b0f      	ldr	r3, [pc, #60]	; (8013f00 <CTR_LP+0x2f8>)
 8013ec4:	781b      	ldrb	r3, [r3, #0]
 8013ec6:	009b      	lsls	r3, r3, #2
 8013ec8:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8013ecc:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
 8013ed0:	f648 720f 	movw	r2, #36623	; 0x8f0f
 8013ed4:	400a      	ands	r2, r1
 8013ed6:	601a      	str	r2, [r3, #0]

        /* call IN service function */
        (*pEpInt_IN[EPindex-1])();
 8013ed8:	4b09      	ldr	r3, [pc, #36]	; (8013f00 <CTR_LP+0x2f8>)
 8013eda:	781b      	ldrb	r3, [r3, #0]
 8013edc:	3b01      	subs	r3, #1
 8013ede:	4a0a      	ldr	r2, [pc, #40]	; (8013f08 <CTR_LP+0x300>)
 8013ee0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8013ee4:	4798      	blx	r3
  while (((wIstr = _GetISTR()) & ISTR_CTR) != 0)
 8013ee6:	4b09      	ldr	r3, [pc, #36]	; (8013f0c <CTR_LP+0x304>)
 8013ee8:	681b      	ldr	r3, [r3, #0]
 8013eea:	b29a      	uxth	r2, r3
 8013eec:	4b08      	ldr	r3, [pc, #32]	; (8013f10 <CTR_LP+0x308>)
 8013eee:	4611      	mov	r1, r2
 8013ef0:	8019      	strh	r1, [r3, #0]
 8013ef2:	b213      	sxth	r3, r2
 8013ef4:	2b00      	cmp	r3, #0
 8013ef6:	f6ff ae8d 	blt.w	8013c14 <CTR_LP+0xc>
      } /* if((wEPVal & EP_CTR_TX) != 0) */

    }/* if(EPindex == 0) else */

  }/* while(...) */
}
 8013efa:	370c      	adds	r7, #12
 8013efc:	46bd      	mov	sp, r7
 8013efe:	bd90      	pop	{r4, r7, pc}
 8013f00:	200096cf 	.word	0x200096cf
 8013f04:	200001a0 	.word	0x200001a0
 8013f08:	20000184 	.word	0x20000184
 8013f0c:	40005c44 	.word	0x40005c44
 8013f10:	200096c4 	.word	0x200096c4

08013f14 <UserToPMABufferCopy>:
*                  - wNBytes: no. of bytes to be copied.
* Output         : None.
* Return         : None	.
*******************************************************************************/
void UserToPMABufferCopy(uint8_t *pbUsrBuf, uint16_t wPMABufAddr, uint16_t wNBytes)
{
 8013f14:	b480      	push	{r7}
 8013f16:	b089      	sub	sp, #36	; 0x24
 8013f18:	af00      	add	r7, sp, #0
 8013f1a:	6078      	str	r0, [r7, #4]
 8013f1c:	460b      	mov	r3, r1
 8013f1e:	807b      	strh	r3, [r7, #2]
 8013f20:	4613      	mov	r3, r2
 8013f22:	803b      	strh	r3, [r7, #0]
  uint32_t n = (wNBytes + 1) >> 1;   /* n = (wNBytes + 1) / 2 */
 8013f24:	883b      	ldrh	r3, [r7, #0]
 8013f26:	3301      	adds	r3, #1
 8013f28:	105b      	asrs	r3, r3, #1
 8013f2a:	617b      	str	r3, [r7, #20]
  uint32_t i, temp1, temp2;
  uint16_t *pdwVal;
  pdwVal = (uint16_t *)(wPMABufAddr * 2 + PMAAddr);
 8013f2c:	887b      	ldrh	r3, [r7, #2]
 8013f2e:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
 8013f32:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8013f36:	005b      	lsls	r3, r3, #1
 8013f38:	61bb      	str	r3, [r7, #24]
  for (i = n; i != 0; i--)
 8013f3a:	697b      	ldr	r3, [r7, #20]
 8013f3c:	61fb      	str	r3, [r7, #28]
 8013f3e:	e01b      	b.n	8013f78 <UserToPMABufferCopy+0x64>
  {
    temp1 = (uint16_t) * pbUsrBuf;
 8013f40:	687b      	ldr	r3, [r7, #4]
 8013f42:	781b      	ldrb	r3, [r3, #0]
 8013f44:	613b      	str	r3, [r7, #16]
    pbUsrBuf++;
 8013f46:	687b      	ldr	r3, [r7, #4]
 8013f48:	3301      	adds	r3, #1
 8013f4a:	607b      	str	r3, [r7, #4]
    temp2 = temp1 | (uint16_t) * pbUsrBuf << 8;
 8013f4c:	687b      	ldr	r3, [r7, #4]
 8013f4e:	781b      	ldrb	r3, [r3, #0]
 8013f50:	021b      	lsls	r3, r3, #8
 8013f52:	461a      	mov	r2, r3
 8013f54:	693b      	ldr	r3, [r7, #16]
 8013f56:	4313      	orrs	r3, r2
 8013f58:	60fb      	str	r3, [r7, #12]
    *pdwVal++ = temp2;
 8013f5a:	69bb      	ldr	r3, [r7, #24]
 8013f5c:	1c9a      	adds	r2, r3, #2
 8013f5e:	61ba      	str	r2, [r7, #24]
 8013f60:	68fa      	ldr	r2, [r7, #12]
 8013f62:	b292      	uxth	r2, r2
 8013f64:	801a      	strh	r2, [r3, #0]
    pdwVal++;
 8013f66:	69bb      	ldr	r3, [r7, #24]
 8013f68:	3302      	adds	r3, #2
 8013f6a:	61bb      	str	r3, [r7, #24]
    pbUsrBuf++;
 8013f6c:	687b      	ldr	r3, [r7, #4]
 8013f6e:	3301      	adds	r3, #1
 8013f70:	607b      	str	r3, [r7, #4]
  for (i = n; i != 0; i--)
 8013f72:	69fb      	ldr	r3, [r7, #28]
 8013f74:	3b01      	subs	r3, #1
 8013f76:	61fb      	str	r3, [r7, #28]
 8013f78:	69fb      	ldr	r3, [r7, #28]
 8013f7a:	2b00      	cmp	r3, #0
 8013f7c:	d1e0      	bne.n	8013f40 <UserToPMABufferCopy+0x2c>
  }
}
 8013f7e:	bf00      	nop
 8013f80:	bf00      	nop
 8013f82:	3724      	adds	r7, #36	; 0x24
 8013f84:	46bd      	mov	sp, r7
 8013f86:	bc80      	pop	{r7}
 8013f88:	4770      	bx	lr

08013f8a <PMAToUserBufferCopy>:
*                  - wNBytes     = no. of bytes to be copied.
* Output         : None.
* Return         : None.
*******************************************************************************/
void PMAToUserBufferCopy(uint8_t *pbUsrBuf, uint16_t wPMABufAddr, uint16_t wNBytes)
{
 8013f8a:	b480      	push	{r7}
 8013f8c:	b087      	sub	sp, #28
 8013f8e:	af00      	add	r7, sp, #0
 8013f90:	6078      	str	r0, [r7, #4]
 8013f92:	460b      	mov	r3, r1
 8013f94:	807b      	strh	r3, [r7, #2]
 8013f96:	4613      	mov	r3, r2
 8013f98:	803b      	strh	r3, [r7, #0]
  uint32_t n = (wNBytes + 1) >> 1;/* /2*/
 8013f9a:	883b      	ldrh	r3, [r7, #0]
 8013f9c:	3301      	adds	r3, #1
 8013f9e:	105b      	asrs	r3, r3, #1
 8013fa0:	60fb      	str	r3, [r7, #12]
  uint32_t i;
  uint32_t *pdwVal;
  pdwVal = (uint32_t *)(wPMABufAddr * 2 + PMAAddr);
 8013fa2:	887b      	ldrh	r3, [r7, #2]
 8013fa4:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
 8013fa8:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8013fac:	005b      	lsls	r3, r3, #1
 8013fae:	613b      	str	r3, [r7, #16]
  for (i = n; i != 0; i--)
 8013fb0:	68fb      	ldr	r3, [r7, #12]
 8013fb2:	617b      	str	r3, [r7, #20]
 8013fb4:	e00e      	b.n	8013fd4 <PMAToUserBufferCopy+0x4a>
  {
    *(uint16_t*)pbUsrBuf++ = *pdwVal++;
 8013fb6:	693b      	ldr	r3, [r7, #16]
 8013fb8:	1d1a      	adds	r2, r3, #4
 8013fba:	613a      	str	r2, [r7, #16]
 8013fbc:	6819      	ldr	r1, [r3, #0]
 8013fbe:	687b      	ldr	r3, [r7, #4]
 8013fc0:	1c5a      	adds	r2, r3, #1
 8013fc2:	607a      	str	r2, [r7, #4]
 8013fc4:	b28a      	uxth	r2, r1
 8013fc6:	801a      	strh	r2, [r3, #0]
    pbUsrBuf++;
 8013fc8:	687b      	ldr	r3, [r7, #4]
 8013fca:	3301      	adds	r3, #1
 8013fcc:	607b      	str	r3, [r7, #4]
  for (i = n; i != 0; i--)
 8013fce:	697b      	ldr	r3, [r7, #20]
 8013fd0:	3b01      	subs	r3, #1
 8013fd2:	617b      	str	r3, [r7, #20]
 8013fd4:	697b      	ldr	r3, [r7, #20]
 8013fd6:	2b00      	cmp	r3, #0
 8013fd8:	d1ed      	bne.n	8013fb6 <PMAToUserBufferCopy+0x2c>
  }
}
 8013fda:	bf00      	nop
 8013fdc:	bf00      	nop
 8013fde:	371c      	adds	r7, #28
 8013fe0:	46bd      	mov	sp, r7
 8013fe2:	bc80      	pop	{r7}
 8013fe4:	4770      	bx	lr
	...

08013fe8 <SetBTABLE>:
* Input          : wRegValue: New register value.
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetBTABLE(uint16_t wRegValue)
{
 8013fe8:	b480      	push	{r7}
 8013fea:	b083      	sub	sp, #12
 8013fec:	af00      	add	r7, sp, #0
 8013fee:	4603      	mov	r3, r0
 8013ff0:	80fb      	strh	r3, [r7, #6]
  _SetBTABLE(wRegValue);
 8013ff2:	88fa      	ldrh	r2, [r7, #6]
 8013ff4:	4904      	ldr	r1, [pc, #16]	; (8014008 <SetBTABLE+0x20>)
 8013ff6:	f64f 73f8 	movw	r3, #65528	; 0xfff8
 8013ffa:	4013      	ands	r3, r2
 8013ffc:	600b      	str	r3, [r1, #0]
}
 8013ffe:	bf00      	nop
 8014000:	370c      	adds	r7, #12
 8014002:	46bd      	mov	sp, r7
 8014004:	bc80      	pop	{r7}
 8014006:	4770      	bx	lr
 8014008:	40005c50 	.word	0x40005c50

0801400c <SetEPType>:
*                  wType: type definition.
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPType(uint8_t bEpNum, uint16_t wType)
{
 801400c:	b480      	push	{r7}
 801400e:	b083      	sub	sp, #12
 8014010:	af00      	add	r7, sp, #0
 8014012:	4603      	mov	r3, r0
 8014014:	460a      	mov	r2, r1
 8014016:	71fb      	strb	r3, [r7, #7]
 8014018:	4613      	mov	r3, r2
 801401a:	80bb      	strh	r3, [r7, #4]
  _SetEPType(bEpNum, wType);
 801401c:	79fb      	ldrb	r3, [r7, #7]
 801401e:	009b      	lsls	r3, r3, #2
 8014020:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8014024:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
 8014028:	681b      	ldr	r3, [r3, #0]
 801402a:	b21b      	sxth	r3, r3
 801402c:	f423 43ec 	bic.w	r3, r3, #30208	; 0x7600
 8014030:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8014034:	b21a      	sxth	r2, r3
 8014036:	f9b7 3004 	ldrsh.w	r3, [r7, #4]
 801403a:	4313      	orrs	r3, r2
 801403c:	b21b      	sxth	r3, r3
 801403e:	b29a      	uxth	r2, r3
 8014040:	79fb      	ldrb	r3, [r7, #7]
 8014042:	009b      	lsls	r3, r3, #2
 8014044:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8014048:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
 801404c:	601a      	str	r2, [r3, #0]
}
 801404e:	bf00      	nop
 8014050:	370c      	adds	r7, #12
 8014052:	46bd      	mov	sp, r7
 8014054:	bc80      	pop	{r7}
 8014056:	4770      	bx	lr

08014058 <SetEPTxStatus>:
*                  wState: new state.
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPTxStatus(uint8_t bEpNum, uint16_t wState)
{
 8014058:	b490      	push	{r4, r7}
 801405a:	b082      	sub	sp, #8
 801405c:	af00      	add	r7, sp, #0
 801405e:	4603      	mov	r3, r0
 8014060:	460a      	mov	r2, r1
 8014062:	71fb      	strb	r3, [r7, #7]
 8014064:	4613      	mov	r3, r2
 8014066:	80bb      	strh	r3, [r7, #4]
  _SetEPTxStatus(bEpNum, wState);
 8014068:	79fb      	ldrb	r3, [r7, #7]
 801406a:	009b      	lsls	r3, r3, #2
 801406c:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8014070:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
 8014074:	681b      	ldr	r3, [r3, #0]
 8014076:	b29b      	uxth	r3, r3
 8014078:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 801407c:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8014080:	b29c      	uxth	r4, r3
 8014082:	88bb      	ldrh	r3, [r7, #4]
 8014084:	f003 0310 	and.w	r3, r3, #16
 8014088:	b29b      	uxth	r3, r3
 801408a:	2b00      	cmp	r3, #0
 801408c:	d002      	beq.n	8014094 <SetEPTxStatus+0x3c>
 801408e:	f084 0310 	eor.w	r3, r4, #16
 8014092:	b29c      	uxth	r4, r3
 8014094:	88bb      	ldrh	r3, [r7, #4]
 8014096:	f003 0320 	and.w	r3, r3, #32
 801409a:	b29b      	uxth	r3, r3
 801409c:	2b00      	cmp	r3, #0
 801409e:	d002      	beq.n	80140a6 <SetEPTxStatus+0x4e>
 80140a0:	f084 0320 	eor.w	r3, r4, #32
 80140a4:	b29c      	uxth	r4, r3
 80140a6:	4b07      	ldr	r3, [pc, #28]	; (80140c4 <SetEPTxStatus+0x6c>)
 80140a8:	4323      	orrs	r3, r4
 80140aa:	b29a      	uxth	r2, r3
 80140ac:	79fb      	ldrb	r3, [r7, #7]
 80140ae:	009b      	lsls	r3, r3, #2
 80140b0:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 80140b4:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
 80140b8:	601a      	str	r2, [r3, #0]
}
 80140ba:	bf00      	nop
 80140bc:	3708      	adds	r7, #8
 80140be:	46bd      	mov	sp, r7
 80140c0:	bc90      	pop	{r4, r7}
 80140c2:	4770      	bx	lr
 80140c4:	ffff8080 	.word	0xffff8080

080140c8 <SetEPRxStatus>:
*                  wState: new state.
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPRxStatus(uint8_t bEpNum, uint16_t wState)
{
 80140c8:	b490      	push	{r4, r7}
 80140ca:	b082      	sub	sp, #8
 80140cc:	af00      	add	r7, sp, #0
 80140ce:	4603      	mov	r3, r0
 80140d0:	460a      	mov	r2, r1
 80140d2:	71fb      	strb	r3, [r7, #7]
 80140d4:	4613      	mov	r3, r2
 80140d6:	80bb      	strh	r3, [r7, #4]
  _SetEPRxStatus(bEpNum, wState);
 80140d8:	79fb      	ldrb	r3, [r7, #7]
 80140da:	009b      	lsls	r3, r3, #2
 80140dc:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 80140e0:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
 80140e4:	681b      	ldr	r3, [r3, #0]
 80140e6:	b29b      	uxth	r3, r3
 80140e8:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 80140ec:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80140f0:	b29c      	uxth	r4, r3
 80140f2:	88bb      	ldrh	r3, [r7, #4]
 80140f4:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 80140f8:	b29b      	uxth	r3, r3
 80140fa:	2b00      	cmp	r3, #0
 80140fc:	d002      	beq.n	8014104 <SetEPRxStatus+0x3c>
 80140fe:	f484 5380 	eor.w	r3, r4, #4096	; 0x1000
 8014102:	b29c      	uxth	r4, r3
 8014104:	88bb      	ldrh	r3, [r7, #4]
 8014106:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 801410a:	b29b      	uxth	r3, r3
 801410c:	2b00      	cmp	r3, #0
 801410e:	d002      	beq.n	8014116 <SetEPRxStatus+0x4e>
 8014110:	f484 5300 	eor.w	r3, r4, #8192	; 0x2000
 8014114:	b29c      	uxth	r4, r3
 8014116:	4b07      	ldr	r3, [pc, #28]	; (8014134 <SetEPRxStatus+0x6c>)
 8014118:	4323      	orrs	r3, r4
 801411a:	b29a      	uxth	r2, r3
 801411c:	79fb      	ldrb	r3, [r7, #7]
 801411e:	009b      	lsls	r3, r3, #2
 8014120:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8014124:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
 8014128:	601a      	str	r2, [r3, #0]
}
 801412a:	bf00      	nop
 801412c:	3708      	adds	r7, #8
 801412e:	46bd      	mov	sp, r7
 8014130:	bc90      	pop	{r4, r7}
 8014132:	4770      	bx	lr
 8014134:	ffff8080 	.word	0xffff8080

08014138 <SetEPTxValid>:
* Input          : bEpNum: Endpoint Number.  
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPTxValid(uint8_t bEpNum)
{
 8014138:	b490      	push	{r4, r7}
 801413a:	b082      	sub	sp, #8
 801413c:	af00      	add	r7, sp, #0
 801413e:	4603      	mov	r3, r0
 8014140:	71fb      	strb	r3, [r7, #7]
  _SetEPTxStatus(bEpNum, EP_TX_VALID);
 8014142:	79fb      	ldrb	r3, [r7, #7]
 8014144:	009b      	lsls	r3, r3, #2
 8014146:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 801414a:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
 801414e:	681b      	ldr	r3, [r3, #0]
 8014150:	b29b      	uxth	r3, r3
 8014152:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8014156:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 801415a:	b29c      	uxth	r4, r3
 801415c:	f084 0310 	eor.w	r3, r4, #16
 8014160:	b29c      	uxth	r4, r3
 8014162:	f084 0320 	eor.w	r3, r4, #32
 8014166:	b29c      	uxth	r4, r3
 8014168:	4b07      	ldr	r3, [pc, #28]	; (8014188 <SetEPTxValid+0x50>)
 801416a:	4323      	orrs	r3, r4
 801416c:	b29a      	uxth	r2, r3
 801416e:	79fb      	ldrb	r3, [r7, #7]
 8014170:	009b      	lsls	r3, r3, #2
 8014172:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8014176:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
 801417a:	601a      	str	r2, [r3, #0]
}
 801417c:	bf00      	nop
 801417e:	3708      	adds	r7, #8
 8014180:	46bd      	mov	sp, r7
 8014182:	bc90      	pop	{r4, r7}
 8014184:	4770      	bx	lr
 8014186:	bf00      	nop
 8014188:	ffff8080 	.word	0xffff8080

0801418c <SetEPRxValid>:
* Input          : bEpNum: Endpoint Number. 
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPRxValid(uint8_t bEpNum)
{
 801418c:	b490      	push	{r4, r7}
 801418e:	b082      	sub	sp, #8
 8014190:	af00      	add	r7, sp, #0
 8014192:	4603      	mov	r3, r0
 8014194:	71fb      	strb	r3, [r7, #7]
  _SetEPRxStatus(bEpNum, EP_RX_VALID);
 8014196:	79fb      	ldrb	r3, [r7, #7]
 8014198:	009b      	lsls	r3, r3, #2
 801419a:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 801419e:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
 80141a2:	681b      	ldr	r3, [r3, #0]
 80141a4:	b29b      	uxth	r3, r3
 80141a6:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 80141aa:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 80141ae:	b29c      	uxth	r4, r3
 80141b0:	f484 5380 	eor.w	r3, r4, #4096	; 0x1000
 80141b4:	b29c      	uxth	r4, r3
 80141b6:	f484 5300 	eor.w	r3, r4, #8192	; 0x2000
 80141ba:	b29c      	uxth	r4, r3
 80141bc:	4b07      	ldr	r3, [pc, #28]	; (80141dc <SetEPRxValid+0x50>)
 80141be:	4323      	orrs	r3, r4
 80141c0:	b29a      	uxth	r2, r3
 80141c2:	79fb      	ldrb	r3, [r7, #7]
 80141c4:	009b      	lsls	r3, r3, #2
 80141c6:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 80141ca:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
 80141ce:	601a      	str	r2, [r3, #0]
}
 80141d0:	bf00      	nop
 80141d2:	3708      	adds	r7, #8
 80141d4:	46bd      	mov	sp, r7
 80141d6:	bc90      	pop	{r4, r7}
 80141d8:	4770      	bx	lr
 80141da:	bf00      	nop
 80141dc:	ffff8080 	.word	0xffff8080

080141e0 <Clear_Status_Out>:
* Input          : bEpNum: Endpoint Number. 
* Output         : None.
* Return         : None.
*******************************************************************************/
void Clear_Status_Out(uint8_t bEpNum)
{
 80141e0:	b480      	push	{r7}
 80141e2:	b083      	sub	sp, #12
 80141e4:	af00      	add	r7, sp, #0
 80141e6:	4603      	mov	r3, r0
 80141e8:	71fb      	strb	r3, [r7, #7]
  _ClearEP_KIND(bEpNum);
 80141ea:	79fb      	ldrb	r3, [r7, #7]
 80141ec:	009b      	lsls	r3, r3, #2
 80141ee:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 80141f2:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
 80141f6:	681b      	ldr	r3, [r3, #0]
 80141f8:	b21a      	sxth	r2, r3
 80141fa:	f640 630f 	movw	r3, #3599	; 0xe0f
 80141fe:	4013      	ands	r3, r2
 8014200:	b21a      	sxth	r2, r3
 8014202:	4b08      	ldr	r3, [pc, #32]	; (8014224 <Clear_Status_Out+0x44>)
 8014204:	4313      	orrs	r3, r2
 8014206:	b21b      	sxth	r3, r3
 8014208:	b29a      	uxth	r2, r3
 801420a:	79fb      	ldrb	r3, [r7, #7]
 801420c:	009b      	lsls	r3, r3, #2
 801420e:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8014212:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
 8014216:	601a      	str	r2, [r3, #0]
}
 8014218:	bf00      	nop
 801421a:	370c      	adds	r7, #12
 801421c:	46bd      	mov	sp, r7
 801421e:	bc80      	pop	{r7}
 8014220:	4770      	bx	lr
 8014222:	bf00      	nop
 8014224:	ffff8080 	.word	0xffff8080

08014228 <ClearDTOG_RX>:
* Input          : bEpNum: Endpoint Number. 
* Output         : None.
* Return         : None.
*******************************************************************************/
void ClearDTOG_RX(uint8_t bEpNum)
{
 8014228:	b480      	push	{r7}
 801422a:	b083      	sub	sp, #12
 801422c:	af00      	add	r7, sp, #0
 801422e:	4603      	mov	r3, r0
 8014230:	71fb      	strb	r3, [r7, #7]
  _ClearDTOG_RX(bEpNum);
 8014232:	79fb      	ldrb	r3, [r7, #7]
 8014234:	009b      	lsls	r3, r3, #2
 8014236:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 801423a:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
 801423e:	681b      	ldr	r3, [r3, #0]
 8014240:	b29b      	uxth	r3, r3
 8014242:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 8014246:	2b00      	cmp	r3, #0
 8014248:	d016      	beq.n	8014278 <ClearDTOG_RX+0x50>
 801424a:	79fb      	ldrb	r3, [r7, #7]
 801424c:	009b      	lsls	r3, r3, #2
 801424e:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8014252:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
 8014256:	681b      	ldr	r3, [r3, #0]
 8014258:	b29b      	uxth	r3, r3
 801425a:	461a      	mov	r2, r3
 801425c:	f640 730f 	movw	r3, #3855	; 0xf0f
 8014260:	4013      	ands	r3, r2
 8014262:	f443 4240 	orr.w	r2, r3, #49152	; 0xc000
 8014266:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 801426a:	79fb      	ldrb	r3, [r7, #7]
 801426c:	009b      	lsls	r3, r3, #2
 801426e:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8014272:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
 8014276:	601a      	str	r2, [r3, #0]
}
 8014278:	bf00      	nop
 801427a:	370c      	adds	r7, #12
 801427c:	46bd      	mov	sp, r7
 801427e:	bc80      	pop	{r7}
 8014280:	4770      	bx	lr

08014282 <ClearDTOG_TX>:
* Input          : bEpNum: Endpoint Number. 
* Output         : None.
* Return         : None.
*******************************************************************************/
void ClearDTOG_TX(uint8_t bEpNum)
{
 8014282:	b480      	push	{r7}
 8014284:	b083      	sub	sp, #12
 8014286:	af00      	add	r7, sp, #0
 8014288:	4603      	mov	r3, r0
 801428a:	71fb      	strb	r3, [r7, #7]
  _ClearDTOG_TX(bEpNum);
 801428c:	79fb      	ldrb	r3, [r7, #7]
 801428e:	009b      	lsls	r3, r3, #2
 8014290:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8014294:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
 8014298:	681b      	ldr	r3, [r3, #0]
 801429a:	b29b      	uxth	r3, r3
 801429c:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80142a0:	2b00      	cmp	r3, #0
 80142a2:	d016      	beq.n	80142d2 <ClearDTOG_TX+0x50>
 80142a4:	79fb      	ldrb	r3, [r7, #7]
 80142a6:	009b      	lsls	r3, r3, #2
 80142a8:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 80142ac:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
 80142b0:	681b      	ldr	r3, [r3, #0]
 80142b2:	b29b      	uxth	r3, r3
 80142b4:	461a      	mov	r2, r3
 80142b6:	f640 730f 	movw	r3, #3855	; 0xf0f
 80142ba:	4013      	ands	r3, r2
 80142bc:	f443 4200 	orr.w	r2, r3, #32768	; 0x8000
 80142c0:	f042 02c0 	orr.w	r2, r2, #192	; 0xc0
 80142c4:	79fb      	ldrb	r3, [r7, #7]
 80142c6:	009b      	lsls	r3, r3, #2
 80142c8:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 80142cc:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
 80142d0:	601a      	str	r2, [r3, #0]
}
 80142d2:	bf00      	nop
 80142d4:	370c      	adds	r7, #12
 80142d6:	46bd      	mov	sp, r7
 80142d8:	bc80      	pop	{r7}
 80142da:	4770      	bx	lr

080142dc <SetEPTxAddr>:
*                  wAddr: new address. 
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPTxAddr(uint8_t bEpNum, uint16_t wAddr)
{
 80142dc:	b480      	push	{r7}
 80142de:	b083      	sub	sp, #12
 80142e0:	af00      	add	r7, sp, #0
 80142e2:	4603      	mov	r3, r0
 80142e4:	460a      	mov	r2, r1
 80142e6:	71fb      	strb	r3, [r7, #7]
 80142e8:	4613      	mov	r3, r2
 80142ea:	80bb      	strh	r3, [r7, #4]
  _SetEPTxAddr(bEpNum, wAddr);
 80142ec:	88bb      	ldrh	r3, [r7, #4]
 80142ee:	085b      	lsrs	r3, r3, #1
 80142f0:	b29b      	uxth	r3, r3
 80142f2:	005a      	lsls	r2, r3, #1
 80142f4:	4b08      	ldr	r3, [pc, #32]	; (8014318 <SetEPTxAddr+0x3c>)
 80142f6:	681b      	ldr	r3, [r3, #0]
 80142f8:	b29b      	uxth	r3, r3
 80142fa:	4619      	mov	r1, r3
 80142fc:	79fb      	ldrb	r3, [r7, #7]
 80142fe:	00db      	lsls	r3, r3, #3
 8014300:	440b      	add	r3, r1
 8014302:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
 8014306:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 801430a:	005b      	lsls	r3, r3, #1
 801430c:	601a      	str	r2, [r3, #0]
}
 801430e:	bf00      	nop
 8014310:	370c      	adds	r7, #12
 8014312:	46bd      	mov	sp, r7
 8014314:	bc80      	pop	{r7}
 8014316:	4770      	bx	lr
 8014318:	40005c50 	.word	0x40005c50

0801431c <SetEPRxAddr>:
*                  wAddr: new address.
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPRxAddr(uint8_t bEpNum, uint16_t wAddr)
{
 801431c:	b480      	push	{r7}
 801431e:	b083      	sub	sp, #12
 8014320:	af00      	add	r7, sp, #0
 8014322:	4603      	mov	r3, r0
 8014324:	460a      	mov	r2, r1
 8014326:	71fb      	strb	r3, [r7, #7]
 8014328:	4613      	mov	r3, r2
 801432a:	80bb      	strh	r3, [r7, #4]
  _SetEPRxAddr(bEpNum, wAddr);
 801432c:	88bb      	ldrh	r3, [r7, #4]
 801432e:	085b      	lsrs	r3, r3, #1
 8014330:	b29b      	uxth	r3, r3
 8014332:	0059      	lsls	r1, r3, #1
 8014334:	4b08      	ldr	r3, [pc, #32]	; (8014358 <SetEPRxAddr+0x3c>)
 8014336:	681b      	ldr	r3, [r3, #0]
 8014338:	b29b      	uxth	r3, r3
 801433a:	461a      	mov	r2, r3
 801433c:	79fb      	ldrb	r3, [r7, #7]
 801433e:	00db      	lsls	r3, r3, #3
 8014340:	441a      	add	r2, r3
 8014342:	4b06      	ldr	r3, [pc, #24]	; (801435c <SetEPRxAddr+0x40>)
 8014344:	4413      	add	r3, r2
 8014346:	005b      	lsls	r3, r3, #1
 8014348:	460a      	mov	r2, r1
 801434a:	601a      	str	r2, [r3, #0]
}
 801434c:	bf00      	nop
 801434e:	370c      	adds	r7, #12
 8014350:	46bd      	mov	sp, r7
 8014352:	bc80      	pop	{r7}
 8014354:	4770      	bx	lr
 8014356:	bf00      	nop
 8014358:	40005c50 	.word	0x40005c50
 801435c:	20003004 	.word	0x20003004

08014360 <GetEPTxAddr>:
* Input          : bEpNum: Endpoint Number. 
* Output         : None.
* Return         : Rx buffer address. 
*******************************************************************************/
uint16_t GetEPTxAddr(uint8_t bEpNum)
{
 8014360:	b480      	push	{r7}
 8014362:	b083      	sub	sp, #12
 8014364:	af00      	add	r7, sp, #0
 8014366:	4603      	mov	r3, r0
 8014368:	71fb      	strb	r3, [r7, #7]
  return(_GetEPTxAddr(bEpNum));
 801436a:	4b09      	ldr	r3, [pc, #36]	; (8014390 <GetEPTxAddr+0x30>)
 801436c:	681b      	ldr	r3, [r3, #0]
 801436e:	b29b      	uxth	r3, r3
 8014370:	461a      	mov	r2, r3
 8014372:	79fb      	ldrb	r3, [r7, #7]
 8014374:	00db      	lsls	r3, r3, #3
 8014376:	4413      	add	r3, r2
 8014378:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
 801437c:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
 8014380:	005b      	lsls	r3, r3, #1
 8014382:	681b      	ldr	r3, [r3, #0]
 8014384:	b29b      	uxth	r3, r3
}
 8014386:	4618      	mov	r0, r3
 8014388:	370c      	adds	r7, #12
 801438a:	46bd      	mov	sp, r7
 801438c:	bc80      	pop	{r7}
 801438e:	4770      	bx	lr
 8014390:	40005c50 	.word	0x40005c50

08014394 <GetEPRxAddr>:
* Input          : bEpNum: Endpoint Number. 
* Output         : None.
* Return         : Rx buffer address.
*******************************************************************************/
uint16_t GetEPRxAddr(uint8_t bEpNum)
{
 8014394:	b480      	push	{r7}
 8014396:	b083      	sub	sp, #12
 8014398:	af00      	add	r7, sp, #0
 801439a:	4603      	mov	r3, r0
 801439c:	71fb      	strb	r3, [r7, #7]
  return(_GetEPRxAddr(bEpNum));
 801439e:	4b08      	ldr	r3, [pc, #32]	; (80143c0 <GetEPRxAddr+0x2c>)
 80143a0:	681b      	ldr	r3, [r3, #0]
 80143a2:	b29b      	uxth	r3, r3
 80143a4:	461a      	mov	r2, r3
 80143a6:	79fb      	ldrb	r3, [r7, #7]
 80143a8:	00db      	lsls	r3, r3, #3
 80143aa:	441a      	add	r2, r3
 80143ac:	4b05      	ldr	r3, [pc, #20]	; (80143c4 <GetEPRxAddr+0x30>)
 80143ae:	4413      	add	r3, r2
 80143b0:	005b      	lsls	r3, r3, #1
 80143b2:	681b      	ldr	r3, [r3, #0]
 80143b4:	b29b      	uxth	r3, r3
}
 80143b6:	4618      	mov	r0, r3
 80143b8:	370c      	adds	r7, #12
 80143ba:	46bd      	mov	sp, r7
 80143bc:	bc80      	pop	{r7}
 80143be:	4770      	bx	lr
 80143c0:	40005c50 	.word	0x40005c50
 80143c4:	20003004 	.word	0x20003004

080143c8 <SetEPTxCount>:
*                  wCount: new count value.
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPTxCount(uint8_t bEpNum, uint16_t wCount)
{
 80143c8:	b480      	push	{r7}
 80143ca:	b083      	sub	sp, #12
 80143cc:	af00      	add	r7, sp, #0
 80143ce:	4603      	mov	r3, r0
 80143d0:	460a      	mov	r2, r1
 80143d2:	71fb      	strb	r3, [r7, #7]
 80143d4:	4613      	mov	r3, r2
 80143d6:	80bb      	strh	r3, [r7, #4]
  _SetEPTxCount(bEpNum, wCount);
 80143d8:	4b08      	ldr	r3, [pc, #32]	; (80143fc <SetEPTxCount+0x34>)
 80143da:	681b      	ldr	r3, [r3, #0]
 80143dc:	b29b      	uxth	r3, r3
 80143de:	461a      	mov	r2, r3
 80143e0:	79fb      	ldrb	r3, [r7, #7]
 80143e2:	00db      	lsls	r3, r3, #3
 80143e4:	441a      	add	r2, r3
 80143e6:	4b06      	ldr	r3, [pc, #24]	; (8014400 <SetEPTxCount+0x38>)
 80143e8:	4413      	add	r3, r2
 80143ea:	005b      	lsls	r3, r3, #1
 80143ec:	461a      	mov	r2, r3
 80143ee:	88bb      	ldrh	r3, [r7, #4]
 80143f0:	6013      	str	r3, [r2, #0]
}
 80143f2:	bf00      	nop
 80143f4:	370c      	adds	r7, #12
 80143f6:	46bd      	mov	sp, r7
 80143f8:	bc80      	pop	{r7}
 80143fa:	4770      	bx	lr
 80143fc:	40005c50 	.word	0x40005c50
 8014400:	20003002 	.word	0x20003002

08014404 <SetEPRxCount>:
*                  wCount: the new count value.
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPRxCount(uint8_t bEpNum, uint16_t wCount)
{
 8014404:	b480      	push	{r7}
 8014406:	b085      	sub	sp, #20
 8014408:	af00      	add	r7, sp, #0
 801440a:	4603      	mov	r3, r0
 801440c:	460a      	mov	r2, r1
 801440e:	71fb      	strb	r3, [r7, #7]
 8014410:	4613      	mov	r3, r2
 8014412:	80bb      	strh	r3, [r7, #4]
  _SetEPRxCount(bEpNum, wCount);
 8014414:	4b1a      	ldr	r3, [pc, #104]	; (8014480 <SetEPRxCount+0x7c>)
 8014416:	681b      	ldr	r3, [r3, #0]
 8014418:	b29b      	uxth	r3, r3
 801441a:	461a      	mov	r2, r3
 801441c:	79fb      	ldrb	r3, [r7, #7]
 801441e:	00db      	lsls	r3, r3, #3
 8014420:	441a      	add	r2, r3
 8014422:	4b18      	ldr	r3, [pc, #96]	; (8014484 <SetEPRxCount+0x80>)
 8014424:	4413      	add	r3, r2
 8014426:	005b      	lsls	r3, r3, #1
 8014428:	60bb      	str	r3, [r7, #8]
 801442a:	88bb      	ldrh	r3, [r7, #4]
 801442c:	2b3e      	cmp	r3, #62	; 0x3e
 801442e:	d912      	bls.n	8014456 <SetEPRxCount+0x52>
 8014430:	88bb      	ldrh	r3, [r7, #4]
 8014432:	095b      	lsrs	r3, r3, #5
 8014434:	81fb      	strh	r3, [r7, #14]
 8014436:	88bb      	ldrh	r3, [r7, #4]
 8014438:	f003 031f 	and.w	r3, r3, #31
 801443c:	2b00      	cmp	r3, #0
 801443e:	d102      	bne.n	8014446 <SetEPRxCount+0x42>
 8014440:	89fb      	ldrh	r3, [r7, #14]
 8014442:	3b01      	subs	r3, #1
 8014444:	81fb      	strh	r3, [r7, #14]
 8014446:	89fb      	ldrh	r3, [r7, #14]
 8014448:	029b      	lsls	r3, r3, #10
 801444a:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 801444e:	461a      	mov	r2, r3
 8014450:	68bb      	ldr	r3, [r7, #8]
 8014452:	601a      	str	r2, [r3, #0]
}
 8014454:	e00f      	b.n	8014476 <SetEPRxCount+0x72>
  _SetEPRxCount(bEpNum, wCount);
 8014456:	88bb      	ldrh	r3, [r7, #4]
 8014458:	085b      	lsrs	r3, r3, #1
 801445a:	81fb      	strh	r3, [r7, #14]
 801445c:	88bb      	ldrh	r3, [r7, #4]
 801445e:	f003 0301 	and.w	r3, r3, #1
 8014462:	2b00      	cmp	r3, #0
 8014464:	d002      	beq.n	801446c <SetEPRxCount+0x68>
 8014466:	89fb      	ldrh	r3, [r7, #14]
 8014468:	3301      	adds	r3, #1
 801446a:	81fb      	strh	r3, [r7, #14]
 801446c:	89fb      	ldrh	r3, [r7, #14]
 801446e:	029b      	lsls	r3, r3, #10
 8014470:	461a      	mov	r2, r3
 8014472:	68bb      	ldr	r3, [r7, #8]
 8014474:	601a      	str	r2, [r3, #0]
}
 8014476:	bf00      	nop
 8014478:	3714      	adds	r7, #20
 801447a:	46bd      	mov	sp, r7
 801447c:	bc80      	pop	{r7}
 801447e:	4770      	bx	lr
 8014480:	40005c50 	.word	0x40005c50
 8014484:	20003006 	.word	0x20003006

08014488 <GetEPRxCount>:
* Input          : bEpNum: Endpoint Number. 
* Output         : None.
* Return         : Rx count value.
*******************************************************************************/
uint16_t GetEPRxCount(uint8_t bEpNum)
{
 8014488:	b480      	push	{r7}
 801448a:	b083      	sub	sp, #12
 801448c:	af00      	add	r7, sp, #0
 801448e:	4603      	mov	r3, r0
 8014490:	71fb      	strb	r3, [r7, #7]
  return(_GetEPRxCount(bEpNum));
 8014492:	4b0a      	ldr	r3, [pc, #40]	; (80144bc <GetEPRxCount+0x34>)
 8014494:	681b      	ldr	r3, [r3, #0]
 8014496:	b29b      	uxth	r3, r3
 8014498:	461a      	mov	r2, r3
 801449a:	79fb      	ldrb	r3, [r7, #7]
 801449c:	00db      	lsls	r3, r3, #3
 801449e:	441a      	add	r2, r3
 80144a0:	4b07      	ldr	r3, [pc, #28]	; (80144c0 <GetEPRxCount+0x38>)
 80144a2:	4413      	add	r3, r2
 80144a4:	005b      	lsls	r3, r3, #1
 80144a6:	681b      	ldr	r3, [r3, #0]
 80144a8:	b29b      	uxth	r3, r3
 80144aa:	f3c3 0309 	ubfx	r3, r3, #0, #10
 80144ae:	b29b      	uxth	r3, r3
}
 80144b0:	4618      	mov	r0, r3
 80144b2:	370c      	adds	r7, #12
 80144b4:	46bd      	mov	sp, r7
 80144b6:	bc80      	pop	{r7}
 80144b8:	4770      	bx	lr
 80144ba:	bf00      	nop
 80144bc:	40005c50 	.word	0x40005c50
 80144c0:	20003006 	.word	0x20003006

080144c4 <ByteSwap>:
* Input          : wSwW: word to Swap.
* Output         : None.
* Return         : resulted word.
*******************************************************************************/
uint16_t ByteSwap(uint16_t wSwW)
{
 80144c4:	b480      	push	{r7}
 80144c6:	b085      	sub	sp, #20
 80144c8:	af00      	add	r7, sp, #0
 80144ca:	4603      	mov	r3, r0
 80144cc:	80fb      	strh	r3, [r7, #6]
  uint8_t bTemp;
  uint16_t wRet;
  bTemp = (uint8_t)(wSwW & 0xff);
 80144ce:	88fb      	ldrh	r3, [r7, #6]
 80144d0:	73fb      	strb	r3, [r7, #15]
  wRet =  (wSwW >> 8) | ((uint16_t)bTemp << 8);
 80144d2:	88fb      	ldrh	r3, [r7, #6]
 80144d4:	0a1b      	lsrs	r3, r3, #8
 80144d6:	b29b      	uxth	r3, r3
 80144d8:	b21a      	sxth	r2, r3
 80144da:	7bfb      	ldrb	r3, [r7, #15]
 80144dc:	021b      	lsls	r3, r3, #8
 80144de:	b21b      	sxth	r3, r3
 80144e0:	4313      	orrs	r3, r2
 80144e2:	b21b      	sxth	r3, r3
 80144e4:	81bb      	strh	r3, [r7, #12]
  return(wRet);
 80144e6:	89bb      	ldrh	r3, [r7, #12]
}
 80144e8:	4618      	mov	r0, r3
 80144ea:	3714      	adds	r7, #20
 80144ec:	46bd      	mov	sp, r7
 80144ee:	bc80      	pop	{r7}
 80144f0:	4770      	bx	lr
	...

080144f4 <USB_SIL_Init>:
* Input          : None.
* Output         : None.
* Return         : Status.
*******************************************************************************/
uint32_t USB_SIL_Init(void)
{
 80144f4:	b480      	push	{r7}
 80144f6:	af00      	add	r7, sp, #0
#ifndef STM32F10X_CL
  
  /* USB interrupts initialization */
  /* clear pending interrupts */
  _SetISTR(0);
 80144f8:	4b07      	ldr	r3, [pc, #28]	; (8014518 <USB_SIL_Init+0x24>)
 80144fa:	2200      	movs	r2, #0
 80144fc:	601a      	str	r2, [r3, #0]
  wInterrupt_Mask = IMR_MSK;
 80144fe:	4b07      	ldr	r3, [pc, #28]	; (801451c <USB_SIL_Init+0x28>)
 8014500:	f44f 4206 	mov.w	r2, #34304	; 0x8600
 8014504:	801a      	strh	r2, [r3, #0]
  /* set interrupts mask */
  _SetCNTR(wInterrupt_Mask);
 8014506:	4b05      	ldr	r3, [pc, #20]	; (801451c <USB_SIL_Init+0x28>)
 8014508:	881a      	ldrh	r2, [r3, #0]
 801450a:	4b05      	ldr	r3, [pc, #20]	; (8014520 <USB_SIL_Init+0x2c>)
 801450c:	601a      	str	r2, [r3, #0]
  /* Perform OTG Device initialization procedure (including EP0 init) */
  OTG_DEV_Init();
  
#endif /* STM32F10X_CL */

  return 0;
 801450e:	2300      	movs	r3, #0
}
 8014510:	4618      	mov	r0, r3
 8014512:	46bd      	mov	sp, r7
 8014514:	bc80      	pop	{r7}
 8014516:	4770      	bx	lr
 8014518:	40005c44 	.word	0x40005c44
 801451c:	200096d8 	.word	0x200096d8
 8014520:	40005c40 	.word	0x40005c40

08014524 <USB_SIL_Read>:
*                     received data buffer.
* Output         : None.
* Return         : Number of received data (in Bytes).
*******************************************************************************/
uint32_t USB_SIL_Read(uint8_t bEpAddr, uint8_t* pBufferPointer)
{
 8014524:	b580      	push	{r7, lr}
 8014526:	b084      	sub	sp, #16
 8014528:	af00      	add	r7, sp, #0
 801452a:	4603      	mov	r3, r0
 801452c:	6039      	str	r1, [r7, #0]
 801452e:	71fb      	strb	r3, [r7, #7]
  uint32_t DataLength = 0;
 8014530:	2300      	movs	r3, #0
 8014532:	60fb      	str	r3, [r7, #12]

#ifndef STM32F10X_CL

  /* Get the number of received data on the selected Endpoint */
  DataLength = GetEPRxCount(bEpAddr & 0x7F);
 8014534:	79fb      	ldrb	r3, [r7, #7]
 8014536:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 801453a:	b2db      	uxtb	r3, r3
 801453c:	4618      	mov	r0, r3
 801453e:	4b0c      	ldr	r3, [pc, #48]	; (8014570 <USB_SIL_Read+0x4c>)
 8014540:	4798      	blx	r3
 8014542:	4603      	mov	r3, r0
 8014544:	60fb      	str	r3, [r7, #12]
  
  /* Use the memory interface function to write to the selected endpoint */
  PMAToUserBufferCopy(pBufferPointer, GetEPRxAddr(bEpAddr & 0x7F), DataLength);
 8014546:	79fb      	ldrb	r3, [r7, #7]
 8014548:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 801454c:	b2db      	uxtb	r3, r3
 801454e:	4618      	mov	r0, r3
 8014550:	4b08      	ldr	r3, [pc, #32]	; (8014574 <USB_SIL_Read+0x50>)
 8014552:	4798      	blx	r3
 8014554:	4603      	mov	r3, r0
 8014556:	4619      	mov	r1, r3
 8014558:	68fb      	ldr	r3, [r7, #12]
 801455a:	b29b      	uxth	r3, r3
 801455c:	461a      	mov	r2, r3
 801455e:	6838      	ldr	r0, [r7, #0]
 8014560:	4b05      	ldr	r3, [pc, #20]	; (8014578 <USB_SIL_Read+0x54>)
 8014562:	4798      	blx	r3
  PCD_EP_Read (bEpAddr, pBufferPointer, DataLength);
  
#endif /* STM32F10X_CL */

  /* Return the number of received data */
  return DataLength;
 8014564:	68fb      	ldr	r3, [r7, #12]
}
 8014566:	4618      	mov	r0, r3
 8014568:	3710      	adds	r7, #16
 801456a:	46bd      	mov	sp, r7
 801456c:	bd80      	pop	{r7, pc}
 801456e:	bf00      	nop
 8014570:	08014489 	.word	0x08014489
 8014574:	08014395 	.word	0x08014395
 8014578:	08013f8b 	.word	0x08013f8b

0801457c <atoi>:
 801457c:	220a      	movs	r2, #10
 801457e:	2100      	movs	r1, #0
 8014580:	f000 b9c8 	b.w	8014914 <strtol>

08014584 <__errno>:
 8014584:	4b01      	ldr	r3, [pc, #4]	; (801458c <__errno+0x8>)
 8014586:	6818      	ldr	r0, [r3, #0]
 8014588:	4770      	bx	lr
 801458a:	bf00      	nop
 801458c:	20000228 	.word	0x20000228

08014590 <memset>:
 8014590:	0783      	lsls	r3, r0, #30
 8014592:	b530      	push	{r4, r5, lr}
 8014594:	d048      	beq.n	8014628 <memset+0x98>
 8014596:	1e54      	subs	r4, r2, #1
 8014598:	2a00      	cmp	r2, #0
 801459a:	d03f      	beq.n	801461c <memset+0x8c>
 801459c:	4603      	mov	r3, r0
 801459e:	b2ca      	uxtb	r2, r1
 80145a0:	e001      	b.n	80145a6 <memset+0x16>
 80145a2:	3c01      	subs	r4, #1
 80145a4:	d33a      	bcc.n	801461c <memset+0x8c>
 80145a6:	f803 2b01 	strb.w	r2, [r3], #1
 80145aa:	079d      	lsls	r5, r3, #30
 80145ac:	d1f9      	bne.n	80145a2 <memset+0x12>
 80145ae:	2c03      	cmp	r4, #3
 80145b0:	d92d      	bls.n	801460e <memset+0x7e>
 80145b2:	b2cd      	uxtb	r5, r1
 80145b4:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 80145b8:	2c0f      	cmp	r4, #15
 80145ba:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 80145be:	d936      	bls.n	801462e <memset+0x9e>
 80145c0:	f1a4 0210 	sub.w	r2, r4, #16
 80145c4:	f022 0c0f 	bic.w	ip, r2, #15
 80145c8:	f103 0e20 	add.w	lr, r3, #32
 80145cc:	44e6      	add	lr, ip
 80145ce:	ea4f 1c12 	mov.w	ip, r2, lsr #4
 80145d2:	f103 0210 	add.w	r2, r3, #16
 80145d6:	e942 5504 	strd	r5, r5, [r2, #-16]
 80145da:	e942 5502 	strd	r5, r5, [r2, #-8]
 80145de:	3210      	adds	r2, #16
 80145e0:	4572      	cmp	r2, lr
 80145e2:	d1f8      	bne.n	80145d6 <memset+0x46>
 80145e4:	f10c 0201 	add.w	r2, ip, #1
 80145e8:	f014 0f0c 	tst.w	r4, #12
 80145ec:	eb03 1202 	add.w	r2, r3, r2, lsl #4
 80145f0:	f004 0c0f 	and.w	ip, r4, #15
 80145f4:	d013      	beq.n	801461e <memset+0x8e>
 80145f6:	f1ac 0304 	sub.w	r3, ip, #4
 80145fa:	f023 0303 	bic.w	r3, r3, #3
 80145fe:	3304      	adds	r3, #4
 8014600:	4413      	add	r3, r2
 8014602:	f842 5b04 	str.w	r5, [r2], #4
 8014606:	4293      	cmp	r3, r2
 8014608:	d1fb      	bne.n	8014602 <memset+0x72>
 801460a:	f00c 0403 	and.w	r4, ip, #3
 801460e:	b12c      	cbz	r4, 801461c <memset+0x8c>
 8014610:	b2ca      	uxtb	r2, r1
 8014612:	441c      	add	r4, r3
 8014614:	f803 2b01 	strb.w	r2, [r3], #1
 8014618:	429c      	cmp	r4, r3
 801461a:	d1fb      	bne.n	8014614 <memset+0x84>
 801461c:	bd30      	pop	{r4, r5, pc}
 801461e:	4664      	mov	r4, ip
 8014620:	4613      	mov	r3, r2
 8014622:	2c00      	cmp	r4, #0
 8014624:	d1f4      	bne.n	8014610 <memset+0x80>
 8014626:	e7f9      	b.n	801461c <memset+0x8c>
 8014628:	4603      	mov	r3, r0
 801462a:	4614      	mov	r4, r2
 801462c:	e7bf      	b.n	80145ae <memset+0x1e>
 801462e:	461a      	mov	r2, r3
 8014630:	46a4      	mov	ip, r4
 8014632:	e7e0      	b.n	80145f6 <memset+0x66>

08014634 <strcat>:
 8014634:	0783      	lsls	r3, r0, #30
 8014636:	b510      	push	{r4, lr}
 8014638:	4604      	mov	r4, r0
 801463a:	d110      	bne.n	801465e <strcat+0x2a>
 801463c:	6802      	ldr	r2, [r0, #0]
 801463e:	f1a2 3301 	sub.w	r3, r2, #16843009	; 0x1010101
 8014642:	ea23 0302 	bic.w	r3, r3, r2
 8014646:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 801464a:	d108      	bne.n	801465e <strcat+0x2a>
 801464c:	f850 2f04 	ldr.w	r2, [r0, #4]!
 8014650:	f1a2 3301 	sub.w	r3, r2, #16843009	; 0x1010101
 8014654:	ea23 0302 	bic.w	r3, r3, r2
 8014658:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 801465c:	d0f6      	beq.n	801464c <strcat+0x18>
 801465e:	7803      	ldrb	r3, [r0, #0]
 8014660:	b11b      	cbz	r3, 801466a <strcat+0x36>
 8014662:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 8014666:	2b00      	cmp	r3, #0
 8014668:	d1fb      	bne.n	8014662 <strcat+0x2e>
 801466a:	f000 f803 	bl	8014674 <strcpy>
 801466e:	4620      	mov	r0, r4
 8014670:	bd10      	pop	{r4, pc}
 8014672:	bf00      	nop

08014674 <strcpy>:
 8014674:	ea80 0201 	eor.w	r2, r0, r1
 8014678:	4684      	mov	ip, r0
 801467a:	f012 0f03 	tst.w	r2, #3
 801467e:	d14f      	bne.n	8014720 <strcpy+0xac>
 8014680:	f011 0f03 	tst.w	r1, #3
 8014684:	d132      	bne.n	80146ec <strcpy+0x78>
 8014686:	f84d 4d04 	str.w	r4, [sp, #-4]!
 801468a:	f011 0f04 	tst.w	r1, #4
 801468e:	f851 3b04 	ldr.w	r3, [r1], #4
 8014692:	d00b      	beq.n	80146ac <strcpy+0x38>
 8014694:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
 8014698:	439a      	bics	r2, r3
 801469a:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
 801469e:	bf04      	itt	eq
 80146a0:	f84c 3b04 	streq.w	r3, [ip], #4
 80146a4:	f851 3b04 	ldreq.w	r3, [r1], #4
 80146a8:	d116      	bne.n	80146d8 <strcpy+0x64>
 80146aa:	bf00      	nop
 80146ac:	f851 4b04 	ldr.w	r4, [r1], #4
 80146b0:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
 80146b4:	439a      	bics	r2, r3
 80146b6:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
 80146ba:	f1a4 3201 	sub.w	r2, r4, #16843009	; 0x1010101
 80146be:	d10b      	bne.n	80146d8 <strcpy+0x64>
 80146c0:	f84c 3b04 	str.w	r3, [ip], #4
 80146c4:	43a2      	bics	r2, r4
 80146c6:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
 80146ca:	bf04      	itt	eq
 80146cc:	f851 3b04 	ldreq.w	r3, [r1], #4
 80146d0:	f84c 4b04 	streq.w	r4, [ip], #4
 80146d4:	d0ea      	beq.n	80146ac <strcpy+0x38>
 80146d6:	4623      	mov	r3, r4
 80146d8:	f80c 3b01 	strb.w	r3, [ip], #1
 80146dc:	f013 0fff 	tst.w	r3, #255	; 0xff
 80146e0:	ea4f 2333 	mov.w	r3, r3, ror #8
 80146e4:	d1f8      	bne.n	80146d8 <strcpy+0x64>
 80146e6:	f85d 4b04 	ldr.w	r4, [sp], #4
 80146ea:	4770      	bx	lr
 80146ec:	f011 0f01 	tst.w	r1, #1
 80146f0:	d006      	beq.n	8014700 <strcpy+0x8c>
 80146f2:	f811 2b01 	ldrb.w	r2, [r1], #1
 80146f6:	f80c 2b01 	strb.w	r2, [ip], #1
 80146fa:	2a00      	cmp	r2, #0
 80146fc:	bf08      	it	eq
 80146fe:	4770      	bxeq	lr
 8014700:	f011 0f02 	tst.w	r1, #2
 8014704:	d0bf      	beq.n	8014686 <strcpy+0x12>
 8014706:	f831 2b02 	ldrh.w	r2, [r1], #2
 801470a:	f012 0fff 	tst.w	r2, #255	; 0xff
 801470e:	bf16      	itet	ne
 8014710:	f82c 2b02 	strhne.w	r2, [ip], #2
 8014714:	f88c 2000 	strbeq.w	r2, [ip]
 8014718:	f412 4f7f 	tstne.w	r2, #65280	; 0xff00
 801471c:	d1b3      	bne.n	8014686 <strcpy+0x12>
 801471e:	4770      	bx	lr
 8014720:	f811 2b01 	ldrb.w	r2, [r1], #1
 8014724:	f80c 2b01 	strb.w	r2, [ip], #1
 8014728:	2a00      	cmp	r2, #0
 801472a:	d1f9      	bne.n	8014720 <strcpy+0xac>
 801472c:	4770      	bx	lr
 801472e:	bf00      	nop

08014730 <strlen>:
 8014730:	f020 0103 	bic.w	r1, r0, #3
 8014734:	f010 0003 	ands.w	r0, r0, #3
 8014738:	f1c0 0000 	rsb	r0, r0, #0
 801473c:	f851 3b04 	ldr.w	r3, [r1], #4
 8014740:	f100 0c04 	add.w	ip, r0, #4
 8014744:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 8014748:	f06f 0200 	mvn.w	r2, #0
 801474c:	bf1c      	itt	ne
 801474e:	fa22 f20c 	lsrne.w	r2, r2, ip
 8014752:	4313      	orrne	r3, r2
 8014754:	f04f 0c01 	mov.w	ip, #1
 8014758:	ea4c 2c0c 	orr.w	ip, ip, ip, lsl #8
 801475c:	ea4c 4c0c 	orr.w	ip, ip, ip, lsl #16
 8014760:	eba3 020c 	sub.w	r2, r3, ip
 8014764:	ea22 0203 	bic.w	r2, r2, r3
 8014768:	ea12 12cc 	ands.w	r2, r2, ip, lsl #7
 801476c:	bf04      	itt	eq
 801476e:	f851 3b04 	ldreq.w	r3, [r1], #4
 8014772:	3004      	addeq	r0, #4
 8014774:	d0f4      	beq.n	8014760 <strlen+0x30>
 8014776:	f1c2 0100 	rsb	r1, r2, #0
 801477a:	ea02 0201 	and.w	r2, r2, r1
 801477e:	fab2 f282 	clz	r2, r2
 8014782:	f1c2 021f 	rsb	r2, r2, #31
 8014786:	eb00 00d2 	add.w	r0, r0, r2, lsr #3
 801478a:	4770      	bx	lr

0801478c <strncpy>:
 801478c:	b530      	push	{r4, r5, lr}
 801478e:	ea40 0401 	orr.w	r4, r0, r1
 8014792:	07a3      	lsls	r3, r4, #30
 8014794:	d122      	bne.n	80147dc <strncpy+0x50>
 8014796:	2a03      	cmp	r2, #3
 8014798:	d920      	bls.n	80147dc <strncpy+0x50>
 801479a:	460b      	mov	r3, r1
 801479c:	4684      	mov	ip, r0
 801479e:	4619      	mov	r1, r3
 80147a0:	f853 5b04 	ldr.w	r5, [r3], #4
 80147a4:	f1a5 3401 	sub.w	r4, r5, #16843009	; 0x1010101
 80147a8:	ea24 0405 	bic.w	r4, r4, r5
 80147ac:	f014 3f80 	tst.w	r4, #2155905152	; 0x80808080
 80147b0:	d115      	bne.n	80147de <strncpy+0x52>
 80147b2:	3a04      	subs	r2, #4
 80147b4:	2a03      	cmp	r2, #3
 80147b6:	4619      	mov	r1, r3
 80147b8:	f84c 5b04 	str.w	r5, [ip], #4
 80147bc:	d8ef      	bhi.n	801479e <strncpy+0x12>
 80147be:	f101 3eff 	add.w	lr, r1, #4294967295
 80147c2:	b152      	cbz	r2, 80147da <strncpy+0x4e>
 80147c4:	4663      	mov	r3, ip
 80147c6:	f81e 1f01 	ldrb.w	r1, [lr, #1]!
 80147ca:	1e54      	subs	r4, r2, #1
 80147cc:	f803 1b01 	strb.w	r1, [r3], #1
 80147d0:	b141      	cbz	r1, 80147e4 <strncpy+0x58>
 80147d2:	4622      	mov	r2, r4
 80147d4:	469c      	mov	ip, r3
 80147d6:	2a00      	cmp	r2, #0
 80147d8:	d1f4      	bne.n	80147c4 <strncpy+0x38>
 80147da:	bd30      	pop	{r4, r5, pc}
 80147dc:	4684      	mov	ip, r0
 80147de:	f101 3eff 	add.w	lr, r1, #4294967295
 80147e2:	e7ee      	b.n	80147c2 <strncpy+0x36>
 80147e4:	4462      	add	r2, ip
 80147e6:	2c00      	cmp	r4, #0
 80147e8:	d0f7      	beq.n	80147da <strncpy+0x4e>
 80147ea:	f803 1b01 	strb.w	r1, [r3], #1
 80147ee:	4293      	cmp	r3, r2
 80147f0:	d1fb      	bne.n	80147ea <strncpy+0x5e>
 80147f2:	bd30      	pop	{r4, r5, pc}

080147f4 <_strtol_l.part.0>:
 80147f4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80147f8:	4681      	mov	r9, r0
 80147fa:	468e      	mov	lr, r1
 80147fc:	4d44      	ldr	r5, [pc, #272]	; (8014910 <_strtol_l.part.0+0x11c>)
 80147fe:	4670      	mov	r0, lr
 8014800:	f81e cb01 	ldrb.w	ip, [lr], #1
 8014804:	f815 400c 	ldrb.w	r4, [r5, ip]
 8014808:	f014 0408 	ands.w	r4, r4, #8
 801480c:	d1f7      	bne.n	80147fe <_strtol_l.part.0+0xa>
 801480e:	f1bc 0f2d 	cmp.w	ip, #45	; 0x2d
 8014812:	46e3      	mov	fp, ip
 8014814:	d053      	beq.n	80148be <_strtol_l.part.0+0xca>
 8014816:	f06f 4800 	mvn.w	r8, #2147483648	; 0x80000000
 801481a:	f1bc 0f2b 	cmp.w	ip, #43	; 0x2b
 801481e:	bf04      	itt	eq
 8014820:	f89e b000 	ldrbeq.w	fp, [lr]
 8014824:	f100 0e02 	addeq.w	lr, r0, #2
 8014828:	b11b      	cbz	r3, 8014832 <_strtol_l.part.0+0x3e>
 801482a:	2b10      	cmp	r3, #16
 801482c:	d04f      	beq.n	80148ce <_strtol_l.part.0+0xda>
 801482e:	461f      	mov	r7, r3
 8014830:	e004      	b.n	801483c <_strtol_l.part.0+0x48>
 8014832:	f1bb 0f30 	cmp.w	fp, #48	; 0x30
 8014836:	d055      	beq.n	80148e4 <_strtol_l.part.0+0xf0>
 8014838:	230a      	movs	r3, #10
 801483a:	461f      	mov	r7, r3
 801483c:	2500      	movs	r5, #0
 801483e:	fbb8 f6f7 	udiv	r6, r8, r7
 8014842:	4628      	mov	r0, r5
 8014844:	fb07 8a16 	mls	sl, r7, r6, r8
 8014848:	e007      	b.n	801485a <_strtol_l.part.0+0x66>
 801484a:	4286      	cmp	r6, r0
 801484c:	d315      	bcc.n	801487a <_strtol_l.part.0+0x86>
 801484e:	d029      	beq.n	80148a4 <_strtol_l.part.0+0xb0>
 8014850:	2501      	movs	r5, #1
 8014852:	fb07 c000 	mla	r0, r7, r0, ip
 8014856:	f81e bb01 	ldrb.w	fp, [lr], #1
 801485a:	f1ab 0c30 	sub.w	ip, fp, #48	; 0x30
 801485e:	f1bc 0f09 	cmp.w	ip, #9
 8014862:	d906      	bls.n	8014872 <_strtol_l.part.0+0x7e>
 8014864:	f1ab 0c41 	sub.w	ip, fp, #65	; 0x41
 8014868:	f1bc 0f19 	cmp.w	ip, #25
 801486c:	d808      	bhi.n	8014880 <_strtol_l.part.0+0x8c>
 801486e:	f1ab 0c37 	sub.w	ip, fp, #55	; 0x37
 8014872:	4563      	cmp	r3, ip
 8014874:	dd0d      	ble.n	8014892 <_strtol_l.part.0+0x9e>
 8014876:	2d00      	cmp	r5, #0
 8014878:	dae7      	bge.n	801484a <_strtol_l.part.0+0x56>
 801487a:	f04f 35ff 	mov.w	r5, #4294967295
 801487e:	e7ea      	b.n	8014856 <_strtol_l.part.0+0x62>
 8014880:	f1ab 0c61 	sub.w	ip, fp, #97	; 0x61
 8014884:	f1bc 0f19 	cmp.w	ip, #25
 8014888:	d803      	bhi.n	8014892 <_strtol_l.part.0+0x9e>
 801488a:	f1ab 0c57 	sub.w	ip, fp, #87	; 0x57
 801488e:	4563      	cmp	r3, ip
 8014890:	dcf1      	bgt.n	8014876 <_strtol_l.part.0+0x82>
 8014892:	2d00      	cmp	r5, #0
 8014894:	db0b      	blt.n	80148ae <_strtol_l.part.0+0xba>
 8014896:	b104      	cbz	r4, 801489a <_strtol_l.part.0+0xa6>
 8014898:	4240      	negs	r0, r0
 801489a:	b10a      	cbz	r2, 80148a0 <_strtol_l.part.0+0xac>
 801489c:	bb95      	cbnz	r5, 8014904 <_strtol_l.part.0+0x110>
 801489e:	6011      	str	r1, [r2, #0]
 80148a0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80148a4:	45e2      	cmp	sl, ip
 80148a6:	dad3      	bge.n	8014850 <_strtol_l.part.0+0x5c>
 80148a8:	f04f 35ff 	mov.w	r5, #4294967295
 80148ac:	e7d3      	b.n	8014856 <_strtol_l.part.0+0x62>
 80148ae:	2322      	movs	r3, #34	; 0x22
 80148b0:	f8c9 3000 	str.w	r3, [r9]
 80148b4:	b31a      	cbz	r2, 80148fe <_strtol_l.part.0+0x10a>
 80148b6:	4640      	mov	r0, r8
 80148b8:	f10e 31ff 	add.w	r1, lr, #4294967295
 80148bc:	e7ef      	b.n	801489e <_strtol_l.part.0+0xaa>
 80148be:	f89e b000 	ldrb.w	fp, [lr]
 80148c2:	f04f 4800 	mov.w	r8, #2147483648	; 0x80000000
 80148c6:	2401      	movs	r4, #1
 80148c8:	f100 0e02 	add.w	lr, r0, #2
 80148cc:	e7ac      	b.n	8014828 <_strtol_l.part.0+0x34>
 80148ce:	f1bb 0f30 	cmp.w	fp, #48	; 0x30
 80148d2:	d1ac      	bne.n	801482e <_strtol_l.part.0+0x3a>
 80148d4:	f89e 0000 	ldrb.w	r0, [lr]
 80148d8:	f000 00df 	and.w	r0, r0, #223	; 0xdf
 80148dc:	2858      	cmp	r0, #88	; 0x58
 80148de:	d007      	beq.n	80148f0 <_strtol_l.part.0+0xfc>
 80148e0:	461f      	mov	r7, r3
 80148e2:	e7ab      	b.n	801483c <_strtol_l.part.0+0x48>
 80148e4:	f89e 3000 	ldrb.w	r3, [lr]
 80148e8:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 80148ec:	2b58      	cmp	r3, #88	; 0x58
 80148ee:	d10b      	bne.n	8014908 <_strtol_l.part.0+0x114>
 80148f0:	2710      	movs	r7, #16
 80148f2:	f89e b001 	ldrb.w	fp, [lr, #1]
 80148f6:	463b      	mov	r3, r7
 80148f8:	f10e 0e02 	add.w	lr, lr, #2
 80148fc:	e79e      	b.n	801483c <_strtol_l.part.0+0x48>
 80148fe:	4640      	mov	r0, r8
 8014900:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8014904:	4680      	mov	r8, r0
 8014906:	e7d6      	b.n	80148b6 <_strtol_l.part.0+0xc2>
 8014908:	2308      	movs	r3, #8
 801490a:	461f      	mov	r7, r3
 801490c:	e796      	b.n	801483c <_strtol_l.part.0+0x48>
 801490e:	bf00      	nop
 8014910:	0801582d 	.word	0x0801582d

08014914 <strtol>:
 8014914:	2a01      	cmp	r2, #1
 8014916:	b510      	push	{r4, lr}
 8014918:	d00a      	beq.n	8014930 <strtol+0x1c>
 801491a:	2a24      	cmp	r2, #36	; 0x24
 801491c:	d808      	bhi.n	8014930 <strtol+0x1c>
 801491e:	4c07      	ldr	r4, [pc, #28]	; (801493c <strtol+0x28>)
 8014920:	4613      	mov	r3, r2
 8014922:	460a      	mov	r2, r1
 8014924:	4601      	mov	r1, r0
 8014926:	6820      	ldr	r0, [r4, #0]
 8014928:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 801492c:	f7ff bf62 	b.w	80147f4 <_strtol_l.part.0>
 8014930:	f7ff fe28 	bl	8014584 <__errno>
 8014934:	2316      	movs	r3, #22
 8014936:	6003      	str	r3, [r0, #0]
 8014938:	2000      	movs	r0, #0
 801493a:	bd10      	pop	{r4, pc}
 801493c:	20000228 	.word	0x20000228
 8014940:	454c4449 	.word	0x454c4449
 8014944:	00000000 	.word	0x00000000
 8014948:	04010105 	.word	0x04010105
 801494c:	00040206 	.word	0x00040206
 8014950:	03010503 	.word	0x03010503
 8014954:	00000030 	.word	0x00000030
 8014958:	0000002e 	.word	0x0000002e
 801495c:	525f4d4d 	.word	0x525f4d4d
 8014960:	41646165 	.word	0x41646165
 8014964:	73656363 	.word	0x73656363
 8014968:	00000073 	.word	0x00000073
 801496c:	575f4d4d 	.word	0x575f4d4d
 8014970:	65746972 	.word	0x65746972
 8014974:	65636341 	.word	0x65636341
 8014978:	00007373 	.word	0x00007373

0801497c <crc16_table>:
 801497c:	00000000 0000c0c1 0000c181 00000140     ............@...
 801498c:	0000c301 000003c0 00000280 0000c241     ............A...
 801499c:	0000c601 000006c0 00000780 0000c741     ............A...
 80149ac:	00000500 0000c5c1 0000c481 00000440     ............@...
 80149bc:	0000cc01 00000cc0 00000d80 0000cd41     ............A...
 80149cc:	00000f00 0000cfc1 0000ce81 00000e40     ............@...
 80149dc:	00000a00 0000cac1 0000cb81 00000b40     ............@...
 80149ec:	0000c901 000009c0 00000880 0000c841     ............A...
 80149fc:	0000d801 000018c0 00001980 0000d941     ............A...
 8014a0c:	00001b00 0000dbc1 0000da81 00001a40     ............@...
 8014a1c:	00001e00 0000dec1 0000df81 00001f40     ............@...
 8014a2c:	0000dd01 00001dc0 00001c80 0000dc41     ............A...
 8014a3c:	00001400 0000d4c1 0000d581 00001540     ............@...
 8014a4c:	0000d701 000017c0 00001680 0000d641     ............A...
 8014a5c:	0000d201 000012c0 00001380 0000d341     ............A...
 8014a6c:	00001100 0000d1c1 0000d081 00001040     ............@...
 8014a7c:	0000f001 000030c0 00003180 0000f141     .....0...1..A...
 8014a8c:	00003300 0000f3c1 0000f281 00003240     .3..........@2..
 8014a9c:	00003600 0000f6c1 0000f781 00003740     .6..........@7..
 8014aac:	0000f501 000035c0 00003480 0000f441     .....5...4..A...
 8014abc:	00003c00 0000fcc1 0000fd81 00003d40     .<..........@=..
 8014acc:	0000ff01 00003fc0 00003e80 0000fe41     .....?...>..A...
 8014adc:	0000fa01 00003ac0 00003b80 0000fb41     .....:...;..A...
 8014aec:	00003900 0000f9c1 0000f881 00003840     .9..........@8..
 8014afc:	00002800 0000e8c1 0000e981 00002940     .(..........@)..
 8014b0c:	0000eb01 00002bc0 00002a80 0000ea41     .....+...*..A...
 8014b1c:	0000ee01 00002ec0 00002f80 0000ef41     ........./..A...
 8014b2c:	00002d00 0000edc1 0000ec81 00002c40     .-..........@,..
 8014b3c:	0000e401 000024c0 00002580 0000e541     .....$...%..A...
 8014b4c:	00002700 0000e7c1 0000e681 00002640     .'..........@&..
 8014b5c:	00002200 0000e2c1 0000e381 00002340     ."..........@#..
 8014b6c:	0000e101 000021c0 00002080 0000e041     .....!... ..A...
 8014b7c:	0000a001 000060c0 00006180 0000a141     .....`...a..A...
 8014b8c:	00006300 0000a3c1 0000a281 00006240     .c..........@b..
 8014b9c:	00006600 0000a6c1 0000a781 00006740     .f..........@g..
 8014bac:	0000a501 000065c0 00006480 0000a441     .....e...d..A...
 8014bbc:	00006c00 0000acc1 0000ad81 00006d40     .l..........@m..
 8014bcc:	0000af01 00006fc0 00006e80 0000ae41     .....o...n..A...
 8014bdc:	0000aa01 00006ac0 00006b80 0000ab41     .....j...k..A...
 8014bec:	00006900 0000a9c1 0000a881 00006840     .i..........@h..
 8014bfc:	00007800 0000b8c1 0000b981 00007940     .x..........@y..
 8014c0c:	0000bb01 00007bc0 00007a80 0000ba41     .....{...z..A...
 8014c1c:	0000be01 00007ec0 00007f80 0000bf41     .....~......A...
 8014c2c:	00007d00 0000bdc1 0000bc81 00007c40     .}..........@|..
 8014c3c:	0000b401 000074c0 00007580 0000b541     .....t...u..A...
 8014c4c:	00007700 0000b7c1 0000b681 00007640     .w..........@v..
 8014c5c:	00007200 0000b2c1 0000b381 00007340     .r..........@s..
 8014c6c:	0000b101 000071c0 00007080 0000b041     .....q...p..A...
 8014c7c:	00005000 000090c1 00009181 00005140     .P..........@Q..
 8014c8c:	00009301 000053c0 00005280 00009241     .....S...R..A...
 8014c9c:	00009601 000056c0 00005780 00009741     .....V...W..A...
 8014cac:	00005500 000095c1 00009481 00005440     .U..........@T..
 8014cbc:	00009c01 00005cc0 00005d80 00009d41     .....\...]..A...
 8014ccc:	00005f00 00009fc1 00009e81 00005e40     ._..........@^..
 8014cdc:	00005a00 00009ac1 00009b81 00005b40     .Z..........@[..
 8014cec:	00009901 000059c0 00005880 00009841     .....Y...X..A...
 8014cfc:	00008801 000048c0 00004980 00008941     .....H...I..A...
 8014d0c:	00004b00 00008bc1 00008a81 00004a40     .K..........@J..
 8014d1c:	00004e00 00008ec1 00008f81 00004f40     .N..........@O..
 8014d2c:	00008d01 00004dc0 00004c80 00008c41     .....M...L..A...
 8014d3c:	00004400 000084c1 00008581 00004540     .D..........@E..
 8014d4c:	00008701 000047c0 00004680 00008641     .....G...F..A...
 8014d5c:	00008201 000042c0 00004380 00008341     .....B...C..A...
 8014d6c:	00004100 000081c1 00008081 00004040     .A..........@@..
 8014d7c:	69676f4c 00006163 38345352 00000035     Logica..RS485...
 8014d8c:	656c6552 74736574 00000000 00425355     Reletest....USB.
 8014d9c:	53525047 00000000 0044454c 434f4c43     GPRS....LED.CLOC
 8014dac:	0000004b 3a4d5347 e1e8f8ee e020e0ea     K...GSM:...... .
 8014dbc:	f2efe0e4 00e0f0e5 512b5441 44574f50     ........AT+QPOWD
 8014dcc:	00000a0d 512b5441 44574f50 0a0d303d     ....AT+QPOWD=0..
 8014ddc:	00000000 e1e8f8ce e020e0ea f2efe0e4     .......... .....
 8014dec:	00e0f0e5 ece5f0c2 e7e820ff e5ede5ec     ......... ......
 8014dfc:	0000eeed 00000000 45544144 0000005f     ........DATE_...
 8014e0c:	454d4954 0000005f 4d554e53 00000042     TIME_...SNUMB...
 8014e1c:	50305445 00000045 50574f50 00000050     ET0PE...POWPP...
 8014e2c:	544c4f56 00000041 52525543 00000045     VOLTA...CURRE...
 8014e3c:	51455246 00000055                       FREQU...

08014e44 <Crc16Tabl>:
 8014e44:	80050000 000a800f 001e801b 80110014     ................
 8014e54:	00368033 8039003c 802d0028 00228027     3.6.<.9.(.-.'.".
 8014e64:	00668063 8069006c 807d0078 00728077     c.f.l.i.x.}.w.r.
 8014e74:	80550050 005a805f 004e804b 80410044     P.U._.Z.K.N.D.A.
 8014e84:	00c680c3 80c900cc 80dd00d8 00d280d7     ................
 8014e94:	80f500f0 00fa80ff 00ee80eb 80e100e4     ................
 8014ea4:	80a500a0 00aa80af 00be80bb 80b100b4     ................
 8014eb4:	00968093 8099009c 808d0088 00828087     ................
 8014ec4:	01868183 8189018c 819d0198 01928197     ................
 8014ed4:	81b501b0 01ba81bf 01ae81ab 81a101a4     ................
 8014ee4:	81e501e0 01ea81ef 01fe81fb 81f101f4     ................
 8014ef4:	01d681d3 81d901dc 81cd01c8 01c281c7     ................
 8014f04:	81450140 014a814f 015e815b 81510154     @.E.O.J.[.^.T.Q.
 8014f14:	01768173 8179017c 816d0168 01628167     s.v.|.y.h.m.g.b.
 8014f24:	01268123 8129012c 813d0138 01328137     #.&.,.).8.=.7.2.
 8014f34:	81150110 011a811f 010e810b 81010104     ................
 8014f44:	03068303 8309030c 831d0318 03128317     ................
 8014f54:	83350330 033a833f 032e832b 83210324     0.5.?.:.+...$.!.
 8014f64:	83650360 036a836f 037e837b 83710374     `.e.o.j.{.~.t.q.
 8014f74:	03568353 8359035c 834d0348 03428347     S.V.\.Y.H.M.G.B.
 8014f84:	83c503c0 03ca83cf 03de83db 83d103d4     ................
 8014f94:	03f683f3 83f903fc 83ed03e8 03e283e7     ................
 8014fa4:	03a683a3 83a903ac 83bd03b8 03b283b7     ................
 8014fb4:	83950390 039a839f 038e838b 83810384     ................
 8014fc4:	82850280 028a828f 029e829b 82910294     ................
 8014fd4:	02b682b3 82b902bc 82ad02a8 02a282a7     ................
 8014fe4:	02e682e3 82e902ec 82fd02f8 02f282f7     ................
 8014ff4:	82d502d0 02da82df 02ce82cb 82c102c4     ................
 8015004:	02468243 8249024c 825d0258 02528257     C.F.L.I.X.].W.R.
 8015014:	82750270 027a827f 026e826b 82610264     p.u...z.k.n.d.a.
 8015024:	82250220 022a822f 023e823b 82310234      .%./.*.;.>.4.1.
 8015034:	02168213 8219021c 820d0208 02028207     ................
 8015044:	0000003a 0000002e 4f4e5552 32435520     :.......RUNO UC2
 8015054:	20202030 20202020 00000000 4f4e5552     0       ....RUNO
 8015064:	36364d20 20202020 20202020 00000000      M66        ....
 8015074:	4f4e5552 31435520 20202035 20202020     RUNO UC15       
 8015084:	00000000 4f4e5552 31374e20 20202035     ....RUNO N715   
 8015094:	20202020 00000000 4f4e5552 20202020         ....RUNO    
 80150a4:	20202020 00202020 302f3831 30322f39            .18/09/20
 80150b4:	00003432 5242502b 59444145 00000000     24..+PBREADY....
 80150c4:	00004b4f 56524553 4f205245 0000004b     OK..SERVER OK...
 80150d4:	4d524f4e 50204c41 5245574f 574f4420     NORMAL POWER DOW
 80150e4:	0000004e 54415453 49203a45 54532050     N...STATE: IP ST
 80150f4:	53555441 00000000 54415453 49203a45     ATUS....STATE: I
 8015104:	4c432050 0045534f 54415453 49203a45     P CLOSE.STATE: I
 8015114:	4e492050 41495449 0000004c 54415453     P INITIAL...STAT
 8015124:	49203a45 50472050 43415352 00000054     E: IP GPRSACT...
 8015134:	54415453 50203a45 44205044 54434145     STATE: PDP DEACT
 8015144:	00000000 0000203e 4e4e4f43 00544345     ....> ..CONNECT.
 8015154:	43204f4e 49525241 00005245 74696157     NO CARRIER..Wait
 8015164:	20676e69 20726f66 65646f6d 00002e6d     ing for modem...
 8015174:	0a0d5441 00000000 44265441 000a0d30     AT......AT&D0...
 8015184:	532b5441 414e4749 0a0d3f4c 00000000     AT+SIGNAL?......
 8015194:	432b5441 0a0d5153 00000000 432b5441     AT+CSQ......AT+C
 80151a4:	3f4b4c43 00000a0d 712b7461 61747369     CLK?....at+qista
 80151b4:	000a0d74 432b5441 3f4e4950 00000a0d     t...AT+CPIN?....
 80151c4:	3a4d5347 2dece8f1 f2f0e0ea cace20e0     GSM:...-..... ..
 80151d4:	00000000 432b5441 3f474552 00000a0d     ....AT+CREG?....
 80151e4:	512b5441 45504f49 2c313d4e 54222c31     AT+QIOPEN=1,1,"T
 80151f4:	4c205043 45545349 2252454e 3231222c     CP LISTENER","12
 8015204:	2e302e37 22312e30 342c302c 2c343434     7.0.0.1",0,4444,
 8015214:	000a0d30 512b5441 4f4c4349 003d4553     0...AT+QICLOSE=.
 8015224:	00000a0d 512b5441 4f4c4349 313d4553     ....AT+QICLOSE=1
 8015234:	00000a0d 432b5441 3d525a54 000a0d32     ....AT+CTZR=2...
 8015244:	432b5441 3d555a54 000a0d31 432b5441     AT+CTZU=1...AT+C
 8015254:	3d555a54 000a0d33 512b5441 5a54494e     TZU=3...AT+QNITZ
 8015264:	0a0d313d 00000000 512b5441 41454449     =1......AT+QIDEA
 8015274:	313d5443 00000a0d 512b5441 47534349     CT=1....AT+QICSG
 8015284:	2c313d50 00222c31 00222c22 0d312c22     P=1,1,".",".",1.
 8015294:	0000000a 3a4d5347 e1e8f8ee e820e0ea     ....GSM:...... .
 80152a4:	e8f6e8ed 002eebe0 432b5441 3d46474d     ........AT+CMGF=
 80152b4:	000a0d31 432b5441 3d494d4e 2c322c32     1...AT+CNMI=2,2,
 80152c4:	2c302c30 000a0d30 512b5441 54434149     0,0,0...AT+QIACT
 80152d4:	0a0d313d 00000000 512b5441 434f4c49     =1......AT+QILOC
 80152e4:	0a0d5049 00000000 676e696d 7673726f     IP......mingorsv
 80152f4:	762e7465 6f636c65 79622e6d 00000000     et.velcom.by....
 8015304:	00000020 512b5441 41454449 0a0d5443      ...AT+QIDEACT..
 8015314:	00000000 512b5441 444f4d49 0d303d45     ....AT+QIMODE=0.
 8015324:	0000000a 512b5441 47455249 3d505041     ....AT+QIREGAPP=
 8015334:	00000022 000a0d22 512b5441 4f525049     "..."...AT+QIPRO
 8015344:	3d54504d 000a0d32 512b5441 41454849     MPT=2...AT+QIHEA
 8015354:	0d313d44 0000000a 512b5441 54434149     D=1.....AT+QIACT
 8015364:	00000a0d 512b5441 47534349 2c313d50     ....AT+QICSGP=1,
 8015374:	4e4d4322 0d225445 0000000a 512b5441     "CMNET".....AT+Q
 8015384:	4f504c49 223d5452 22504354 3434222c     ILPORT="TCP","44
 8015394:	0d223434 0000000a 512b5441 52455349     44".....AT+QISER
 80153a4:	0d524556 0000000a 512b5441 56525349     VER.....AT+QISRV
 80153b4:	0d323d43 0000000a 582b5441 3d505349     C=2.....AT+XISP=
 80153c4:	000a0d30 432b5441 4f434447 313d544e     0...AT+CGDCONT=1
 80153d4:	5049222c 00222c22 432b5441 4f434447     ,"IP",".AT+CGDCO
 80153e4:	313d544e 5050222c 222c2250 00000000     NT=1,"PPP","....
 80153f4:	582b5441 3d434949 000a0d31 582b5441     AT+XIIC=1...AT+X
 8015404:	3f434949 00000a0d 542b5441 494c5043     IIC?....AT+TCPLI
 8015414:	4e455453 3434343d 000a0d34 492b5441     STEN=4444...AT+I
 8015424:	41545350 3d535554 000a0d30 472b5441     PSTATUS=0...AT+G
 8015434:	0a0d4d4d 00000000 3a4d5347 e1e8f8ee     MM......GSM:....
 8015444:	f120e0ea ea2dece8 fbf2f0e0 00000000     .. ...-.........
 8015454:	512b5441 3d445249 00000000 5249512b     AT+QIRD=....+QIR
 8015464:	00000044 00445049 512b5441 4e455349     D...IPD.AT+QISEN
 8015474:	00003d44 0000002c 003e0a0d 542b5441     D=..,.....>.AT+T
 8015484:	45535043 3d53444e 00000000 0000000d     CPSENDS=........

08015494 <atset>:
 8015494:	080150b8 00000001 080150c4 00000002     .P.......P......
 80154a4:	080150c8 00000003 080150d4 00000004     .P.......P......
 80154b4:	080150e8 00000005 080150fc 00000006     .P.......P......
 80154c4:	0801510c 00000007 08015120 00000008     .Q...... Q......
 80154d4:	08015134 00000009 08015148 0000000a     4Q......HQ......
 80154e4:	0801514c 0000000b 08015154 0000000c     LQ......TQ......
 80154f4:	0000003a 0000002f eef0e1d1 f3e620f1     :.../........ ..
 8015504:	ebe0edf0 000000e0 00003c3e 00000020     ........><.. ...
 8015514:	0000003e f4edeeca f0f3e3e8 ffe8f6e0     >...............
 8015524:	ece7e820 ede5ede5 000000e0 f4e0f0c3      ...............
 8015534:	ee20eae8 202ee2f1 e5ece7e8 00ede5ed     .. .... ........
 8015544:	f4e0f0c3 ef20eae8 e2f1e4ee e7e8202e     ...... ...... ..
 8015554:	e5ede5ec 000000ed f4e0f0c3 e820eae8     .............. .
 8015564:	ecfeebeb e7e8202e e5ede5ec 000000ed     ..... ..........
 8015574:	f4e0f0c3 fd20eae8 e3f0e5ed e7e8202e     ...... ...... ..
 8015584:	e5ede5ec 000000ed f4e0f0c3 ee20eae8     .............. .
 8015594:	f0e3eee1 e7e8202e e5ede5ec 000000ed     ..... ..........
 80155a4:	f4edeeca eeec202e e0ece5e4 ece7e820     ..... ...... ...
 80155b4:	ede5ede5 000000e0 f4edeeca f7f1202e     ............. ..
 80155c4:	e8f7f2e5 e7e820ea e5ede5ec 0000e0ed     ..... ..........
 80155d4:	eef0e1d1 f1f320f1 e9eef0f2 e0e2f2f1     ..... ..........
 80155e4:	00000000 2eebeac2 ede0ea20 3ae0ebe0     ........ ......:
 80155f4:	00000000 ebeafbc2 e0ea202e e0ebe0ed     ......... ......
 8015604:	0000003a 202ef8ce e0f2e8ef 00ffe8ed     :...... ........
 8015614:	202ef8ce 2eefe5f6 f0eff320 0000002e     ... .... .......
 8015624:	f0e5e2c4 f2ee20fc f2fbf0ea 000000e0     ..... ..........
 8015634:	202ef8ce e0f0eff3 0000ebe2 202ef8ce     ... ........... 
 8015644:	e4e5f0ef 2ef0f5ee 00000000 e7e8e5cd     ................
 8015654:	f8ee20e2 e0eae1e8 00000021 ecf0eecd     . ......!.......
 8015664:	e8ef20e0 e8ede0f2 000000e5 ecf0eecd     . ..............
 8015674:	e5f620e0 eff32eef 00002ef0 f0e5e2c4     . ..............
 8015684:	e0e720fc f2fbf0ea 000000e0 ecf0eecd     . ..............
 8015694:	eff320e0 00002ef0 ecf0eecd f0ef20e0     . ........... ..
 80156a4:	f5eee4e5 00002ef0 e7e8e5cd eeed20e2     ............. ..
 80156b4:	00e0ecf0 00003ac4 3a293028 00000000     .....:..(0):....
 80156c4:	3a293128 00000000 eef0e1d1 f2ee20f1     (1):......... ..
 80156d4:	eef2f120 f2202ef0 e5ece9e0 0000e0f0      ..... .........
 80156e4:	20e4eeca e1e8f8ee 003de8ea f2edeeca     ... ......=.....
 80156f4:	ebebeef0 c220f0e5 00ebeafb f2edeeca     ...... .........
 8015704:	ebebeef0 c220f0e5 0000ebea 2ef2e2c0     ...... .........
 8015714:	e8e6e5f0 f1e220ec ca20f5e5 000000d3     ..... .... .....
 8015724:	edf7f3d0 f020e9ee ece8e6e5 3ad3ca2e     ...... ........:
 8015734:	00000000 eef2e2c0 e6e5f020 ca2eece8     ........ .......
 8015744:	00003ad3 2eebeac2 ece5d020 e5f0202e     .:...... .... ..
 8015754:	2eece8e6 003ad3ca ebeaf2ce e5d0202e     ......:...... ..
 8015764:	f0202eec ece8e6e5 3ad3ca2e 00000000     .. ........:....

08015774 <Virtual_Com_Port_DeviceDescriptor>:
 8015774:	02000112 40000002 611903eb 02010200     .......@...a....
 8015784:	00000103                                ....

08015788 <Virtual_Com_Port_ConfigDescriptor>:
 8015788:	00430209 c0000102 00040932 02020100     ..C.....2.......
 8015798:	24050001 05011000 01000124 06022404     ...$....$....$..
 80157a8:	00062405 82050701 ff000803 00010409     .$..............
 80157b8:	00000a02 03050700 00004002 02810507     .........@......
 80157c8:	00000040                                @...

080157cc <Virtual_Com_Port_StringLangID>:
 80157cc:	04090304                                ....

080157d0 <Virtual_Com_Port_StringVendor>:
 80157d0:	00530326 004d0054 00630069 006f0072     &.S.T.M.i.c.r.o.
 80157e0:	006c0065 00630065 00720074 006e006f     e.l.e.c.t.r.o.n.
 80157f0:	00630069 00000073                       i.c.s...

080157f8 <Virtual_Com_Port_StringProduct>:
 80157f8:	00530332 004d0054 00320033 00560020     2.S.T.M.3.2. .V.
 8015808:	00720069 00750074 006c0061 00430020     i.r.t.u.a.l. .C.
 8015818:	004d004f 00500020 0072006f 00200074     O.M. .P.o.r.t. .
 8015828:	00000020                                 ...

0801582c <_ctype_>:
 801582c:	20202000 20202020 28282020 20282828     .         ((((( 
 801583c:	20202020 20202020 20202020 20202020                     
 801584c:	10108820 10101010 10101010 10101010      ...............
 801585c:	04040410 04040404 10040404 10101010     ................
 801586c:	41411010 41414141 01010101 01010101     ..AAAAAA........
 801587c:	01010101 01010101 01010101 10101010     ................
 801588c:	42421010 42424242 02020202 02020202     ..BBBBBB........
 801589c:	02020202 02020202 02020202 10101010     ................
 80158ac:	00000020 00000000 00000000 00000000      ...............
	...
